(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["STK"] = factory();
	else
		root["STK"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/apps/MultiModelView/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/async/dist/async.js":
/*!*******************************************!*\
  !*** ../node_modules/async/dist/async.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process, global, module) {(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, (function (exports) { 'use strict';\n\nfunction slice(arrayLike, start) {\n    start = start|0;\n    var newLen = Math.max(arrayLike.length - start, 0);\n    var newArr = Array(newLen);\n    for(var idx = 0; idx < newLen; idx++)  {\n        newArr[idx] = arrayLike[start + idx];\n    }\n    return newArr;\n}\n\n/**\n * Creates a continuation function with some arguments already applied.\n *\n * Useful as a shorthand when combined with other control flow functions. Any\n * arguments passed to the returned function are added to the arguments\n * originally passed to apply.\n *\n * @name apply\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {Function} fn - The function you want to eventually apply all\n * arguments to. Invokes with (arguments...).\n * @param {...*} arguments... - Any number of arguments to automatically apply\n * when the continuation is called.\n * @returns {Function} the partially-applied function\n * @example\n *\n * // using apply\n * async.parallel([\n *     async.apply(fs.writeFile, 'testfile1', 'test1'),\n *     async.apply(fs.writeFile, 'testfile2', 'test2')\n * ]);\n *\n *\n * // the same process without using apply\n * async.parallel([\n *     function(callback) {\n *         fs.writeFile('testfile1', 'test1', callback);\n *     },\n *     function(callback) {\n *         fs.writeFile('testfile2', 'test2', callback);\n *     }\n * ]);\n *\n * // It's possible to pass any number of additional arguments when calling the\n * // continuation:\n *\n * node> var fn = async.apply(sys.puts, 'one');\n * node> fn('two', 'three');\n * one\n * two\n * three\n */\nvar apply = function(fn/*, ...args*/) {\n    var args = slice(arguments, 1);\n    return function(/*callArgs*/) {\n        var callArgs = slice(arguments);\n        return fn.apply(null, args.concat(callArgs));\n    };\n};\n\nvar initialParams = function (fn) {\n    return function (/*...args, callback*/) {\n        var args = slice(arguments);\n        var callback = args.pop();\n        fn.call(this, args, callback);\n    };\n};\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nvar hasSetImmediate = typeof setImmediate === 'function' && setImmediate;\nvar hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';\n\nfunction fallback(fn) {\n    setTimeout(fn, 0);\n}\n\nfunction wrap(defer) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        defer(function () {\n            fn.apply(null, args);\n        });\n    };\n}\n\nvar _defer;\n\nif (hasSetImmediate) {\n    _defer = setImmediate;\n} else if (hasNextTick) {\n    _defer = process.nextTick;\n} else {\n    _defer = fallback;\n}\n\nvar setImmediate$1 = wrap(_defer);\n\n/**\n * Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);\n */\nfunction asyncify(func) {\n    return initialParams(function (args, callback) {\n        var result;\n        try {\n            result = func.apply(this, args);\n        } catch (e) {\n            return callback(e);\n        }\n        // if result is Promise object\n        if (isObject(result) && typeof result.then === 'function') {\n            result.then(function(value) {\n                invokeCallback(callback, null, value);\n            }, function(err) {\n                invokeCallback(callback, err.message ? err : new Error(err));\n            });\n        } else {\n            callback(null, result);\n        }\n    });\n}\n\nfunction invokeCallback(callback, error, value) {\n    try {\n        callback(error, value);\n    } catch (e) {\n        setImmediate$1(rethrow, e);\n    }\n}\n\nfunction rethrow(error) {\n    throw error;\n}\n\nvar supportsSymbol = typeof Symbol === 'function';\n\nfunction isAsync(fn) {\n    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';\n}\n\nfunction wrapAsync(asyncFn) {\n    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;\n}\n\nfunction applyEach$1(eachfn) {\n    return function(fns/*, ...args*/) {\n        var args = slice(arguments, 1);\n        var go = initialParams(function(args, callback) {\n            var that = this;\n            return eachfn(fns, function (fn, cb) {\n                wrapAsync(fn).apply(that, args.concat(cb));\n            }, callback);\n        });\n        if (args.length) {\n            return go.apply(this, args);\n        }\n        else {\n            return go;\n        }\n    };\n}\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/** `Object#toString` result references. */\nvar asyncTag = '[object AsyncFunction]';\nvar funcTag = '[object Function]';\nvar genTag = '[object GeneratorFunction]';\nvar proxyTag = '[object Proxy]';\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n// A temporary value used to identify if the loop should be broken.\n// See #1064, #1293\nvar breakLoop = {};\n\n/**\n * This method returns `undefined`.\n *\n * @static\n * @memberOf _\n * @since 2.3.0\n * @category Util\n * @example\n *\n * _.times(2, _.noop);\n * // => [undefined, undefined]\n */\nfunction noop() {\n  // No operation performed.\n}\n\nfunction once(fn) {\n    return function () {\n        if (fn === null) return;\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nvar iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;\n\nvar getIterator = function (coll) {\n    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();\n};\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]';\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/** Used for built-in method references. */\nvar objectProto$3 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$2 = objectProto$3.hasOwnProperty;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto$3.propertyIsEnumerable;\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER$1 = 9007199254740991;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER$1 : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/** `Object#toString` result references. */\nvar argsTag$1 = '[object Arguments]';\nvar arrayTag = '[object Array]';\nvar boolTag = '[object Boolean]';\nvar dateTag = '[object Date]';\nvar errorTag = '[object Error]';\nvar funcTag$1 = '[object Function]';\nvar mapTag = '[object Map]';\nvar numberTag = '[object Number]';\nvar objectTag = '[object Object]';\nvar regexpTag = '[object RegExp]';\nvar setTag = '[object Set]';\nvar stringTag = '[object String]';\nvar weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]';\nvar dataViewTag = '[object DataView]';\nvar float32Tag = '[object Float32Array]';\nvar float64Tag = '[object Float64Array]';\nvar int8Tag = '[object Int8Array]';\nvar int16Tag = '[object Int16Array]';\nvar int32Tag = '[object Int32Array]';\nvar uint8Tag = '[object Uint8Array]';\nvar uint8ClampedTag = '[object Uint8ClampedArray]';\nvar uint16Tag = '[object Uint16Array]';\nvar uint32Tag = '[object Uint32Array]';\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag$1] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/** Detect free variable `exports`. */\nvar freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports$1 && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    // Use `util.types` for Node.js 10+.\n    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;\n\n    if (types) {\n      return types;\n    }\n\n    // Legacy `process.binding('util')` for Node.js < 10.\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$2.hasOwnProperty;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty$1.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$5 = Object.prototype;\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$5;\n\n  return value === proto;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeKeys = overArg(Object.keys, Object);\n\n/** Used for built-in method references. */\nvar objectProto$4 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$3 = objectProto$4.hasOwnProperty;\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\nfunction createArrayIterator(coll) {\n    var i = -1;\n    var len = coll.length;\n    return function next() {\n        return ++i < len ? {value: coll[i], key: i} : null;\n    }\n}\n\nfunction createES2015Iterator(iterator) {\n    var i = -1;\n    return function next() {\n        var item = iterator.next();\n        if (item.done)\n            return null;\n        i++;\n        return {value: item.value, key: i};\n    }\n}\n\nfunction createObjectIterator(obj) {\n    var okeys = keys(obj);\n    var i = -1;\n    var len = okeys.length;\n    return function next() {\n        var key = okeys[++i];\n        return i < len ? {value: obj[key], key: key} : null;\n    };\n}\n\nfunction iterator(coll) {\n    if (isArrayLike(coll)) {\n        return createArrayIterator(coll);\n    }\n\n    var iterator = getIterator(coll);\n    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);\n}\n\nfunction onlyOnce(fn) {\n    return function() {\n        if (fn === null) throw new Error(\"Callback was already called.\");\n        var callFn = fn;\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\nfunction _eachOfLimit(limit) {\n    return function (obj, iteratee, callback) {\n        callback = once(callback || noop);\n        if (limit <= 0 || !obj) {\n            return callback(null);\n        }\n        var nextElem = iterator(obj);\n        var done = false;\n        var running = 0;\n        var looping = false;\n\n        function iterateeCallback(err, value) {\n            running -= 1;\n            if (err) {\n                done = true;\n                callback(err);\n            }\n            else if (value === breakLoop || (done && running <= 0)) {\n                done = true;\n                return callback(null);\n            }\n            else if (!looping) {\n                replenish();\n            }\n        }\n\n        function replenish () {\n            looping = true;\n            while (running < limit && !done) {\n                var elem = nextElem();\n                if (elem === null) {\n                    done = true;\n                    if (running <= 0) {\n                        callback(null);\n                    }\n                    return;\n                }\n                running += 1;\n                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));\n            }\n            looping = false;\n        }\n\n        replenish();\n    };\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name eachOfLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`. The `key` is the item's key, or index in the case of an\n * array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachOfLimit(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);\n}\n\nfunction doLimit(fn, limit) {\n    return function (iterable, iteratee, callback) {\n        return fn(iterable, limit, iteratee, callback);\n    };\n}\n\n// eachOf implementation optimized for array-likes\nfunction eachOfArrayLike(coll, iteratee, callback) {\n    callback = once(callback || noop);\n    var index = 0,\n        completed = 0,\n        length = coll.length;\n    if (length === 0) {\n        callback(null);\n    }\n\n    function iteratorCallback(err, value) {\n        if (err) {\n            callback(err);\n        } else if ((++completed === length) || value === breakLoop) {\n            callback(null);\n        }\n    }\n\n    for (; index < length; index++) {\n        iteratee(coll[index], index, onlyOnce(iteratorCallback));\n    }\n}\n\n// a generic version of eachOf which can handle array, object, and iterator cases.\nvar eachOfGeneric = doLimit(eachOfLimit, Infinity);\n\n/**\n * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument\n * to the iteratee.\n *\n * @name eachOf\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEachOf\n * @category Collection\n * @see [async.each]{@link module:Collections.each}\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each\n * item in `coll`.\n * The `key` is the item's key, or index in the case of an array.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * var obj = {dev: \"/dev.json\", test: \"/test.json\", prod: \"/prod.json\"};\n * var configs = {};\n *\n * async.forEachOf(obj, function (value, key, callback) {\n *     fs.readFile(__dirname + value, \"utf8\", function (err, data) {\n *         if (err) return callback(err);\n *         try {\n *             configs[key] = JSON.parse(data);\n *         } catch (e) {\n *             return callback(e);\n *         }\n *         callback();\n *     });\n * }, function (err) {\n *     if (err) console.error(err.message);\n *     // configs is now a map of JSON data\n *     doSomethingWith(configs);\n * });\n */\nvar eachOf = function(coll, iteratee, callback) {\n    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;\n    eachOfImplementation(coll, wrapAsync(iteratee), callback);\n};\n\nfunction doParallel(fn) {\n    return function (obj, iteratee, callback) {\n        return fn(eachOf, obj, wrapAsync(iteratee), callback);\n    };\n}\n\nfunction _asyncMap(eachfn, arr, iteratee, callback) {\n    callback = callback || noop;\n    arr = arr || [];\n    var results = [];\n    var counter = 0;\n    var _iteratee = wrapAsync(iteratee);\n\n    eachfn(arr, function (value, _, callback) {\n        var index = counter++;\n        _iteratee(value, function (err, v) {\n            results[index] = v;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Produces a new collection of values by mapping each value in `coll` through\n * the `iteratee` function. The `iteratee` is called with an item from `coll`\n * and a callback for when it has finished processing. Each of these callback\n * takes 2 arguments: an `error`, and the transformed item from `coll`. If\n * `iteratee` passes an error to its callback, the main `callback` (for the\n * `map` function) is immediately called with the error.\n *\n * Note, that since this function applies the `iteratee` to each item in\n * parallel, there is no guarantee that the `iteratee` functions will complete\n * in order. However, the results array will be in the same order as the\n * original `coll`.\n *\n * If `map` is passed an Object, the results will be an Array.  The results\n * will roughly be in the order of the original Objects' keys (but this can\n * vary across JavaScript engines).\n *\n * @name map\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an Array of the\n * transformed items from the `coll`. Invoked with (err, results).\n * @example\n *\n * async.map(['file1','file2','file3'], fs.stat, function(err, results) {\n *     // results is now an array of stats for each file\n * });\n */\nvar map = doParallel(_asyncMap);\n\n/**\n * Applies the provided arguments to each function in the array, calling\n * `callback` after all functions have completed. If you only provide the first\n * argument, `fns`, then it will return a function which lets you pass in the\n * arguments as if it were a single function call. If more arguments are\n * provided, `callback` is required while `args` is still optional.\n *\n * @name applyEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s\n * to all call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument, `fns`, is provided, it will\n * return a function which lets you pass in the arguments as if it were a single\n * function call. The signature is `(..args, callback)`. If invoked with any\n * arguments, `callback` is required.\n * @example\n *\n * async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n *\n * // partial application example:\n * async.each(\n *     buckets,\n *     async.applyEach([enableSearch, updateSchema]),\n *     callback\n * );\n */\nvar applyEach = applyEach$1(map);\n\nfunction doParallelLimit(fn) {\n    return function (obj, limit, iteratee, callback) {\n        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);\n    };\n}\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.\n *\n * @name mapLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapLimit = doParallelLimit(_asyncMap);\n\n/**\n * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.\n *\n * @name mapSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with the transformed item.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Results is an array of the\n * transformed items from the `coll`. Invoked with (err, results).\n */\nvar mapSeries = doLimit(mapLimit, 1);\n\n/**\n * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.\n *\n * @name applyEachSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.applyEach]{@link module:ControlFlow.applyEach}\n * @category Control Flow\n * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all\n * call with the same arguments\n * @param {...*} [args] - any number of separate arguments to pass to the\n * function.\n * @param {Function} [callback] - the final argument should be the callback,\n * called when all functions have completed processing.\n * @returns {Function} - If only the first argument is provided, it will return\n * a function which lets you pass in the arguments as if it were a single\n * function call.\n */\nvar applyEachSeries = applyEach$1(mapSeries);\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.isNaN` without support for number objects.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n */\nfunction baseIsNaN(value) {\n  return value !== value;\n}\n\n/**\n * A specialized version of `_.indexOf` which performs strict equality\n * comparisons of values, i.e. `===`.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction strictIndexOf(array, value, fromIndex) {\n  var index = fromIndex - 1,\n      length = array.length;\n\n  while (++index < length) {\n    if (array[index] === value) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} value The value to search for.\n * @param {number} fromIndex The index to search from.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseIndexOf(array, value, fromIndex) {\n  return value === value\n    ? strictIndexOf(array, value, fromIndex)\n    : baseFindIndex(array, baseIsNaN, fromIndex);\n}\n\n/**\n * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns undefined\n * @example\n *\n * async.auto({\n *     // this function will just be passed a callback\n *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),\n *     showData: ['readData', function(results, cb) {\n *         // results.readData is the file's contents\n *         // ...\n *     }]\n * }, callback);\n *\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         console.log('in write_file', JSON.stringify(results));\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         console.log('in email_link', JSON.stringify(results));\n *         // once the file is written let's email a link to it...\n *         // results.write_file contains the filename returned by write_file.\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('results = ', results);\n * });\n */\nvar auto = function (tasks, concurrency, callback) {\n    if (typeof concurrency === 'function') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }\n    callback = once(callback || noop);\n    var keys$$1 = keys(tasks);\n    var numTasks = keys$$1.length;\n    if (!numTasks) {\n        return callback(null);\n    }\n    if (!concurrency) {\n        concurrency = numTasks;\n    }\n\n    var results = {};\n    var runningTasks = 0;\n    var hasError = false;\n\n    var listeners = Object.create(null);\n\n    var readyTasks = [];\n\n    // for cycle detection:\n    var readyToCheck = []; // tasks that have been identified as reachable\n    // without the possibility of returning to an ancestor task\n    var uncheckedDependencies = {};\n\n    baseForOwn(tasks, function (task, key) {\n        if (!isArray(task)) {\n            // no dependencies\n            enqueueTask(key, [task]);\n            readyToCheck.push(key);\n            return;\n        }\n\n        var dependencies = task.slice(0, task.length - 1);\n        var remainingDependencies = dependencies.length;\n        if (remainingDependencies === 0) {\n            enqueueTask(key, task);\n            readyToCheck.push(key);\n            return;\n        }\n        uncheckedDependencies[key] = remainingDependencies;\n\n        arrayEach(dependencies, function (dependencyName) {\n            if (!tasks[dependencyName]) {\n                throw new Error('async.auto task `' + key +\n                    '` has a non-existent dependency `' +\n                    dependencyName + '` in ' +\n                    dependencies.join(', '));\n            }\n            addListener(dependencyName, function () {\n                remainingDependencies--;\n                if (remainingDependencies === 0) {\n                    enqueueTask(key, task);\n                }\n            });\n        });\n    });\n\n    checkForDeadlocks();\n    processQueue();\n\n    function enqueueTask(key, task) {\n        readyTasks.push(function () {\n            runTask(key, task);\n        });\n    }\n\n    function processQueue() {\n        if (readyTasks.length === 0 && runningTasks === 0) {\n            return callback(null, results);\n        }\n        while(readyTasks.length && runningTasks < concurrency) {\n            var run = readyTasks.shift();\n            run();\n        }\n\n    }\n\n    function addListener(taskName, fn) {\n        var taskListeners = listeners[taskName];\n        if (!taskListeners) {\n            taskListeners = listeners[taskName] = [];\n        }\n\n        taskListeners.push(fn);\n    }\n\n    function taskComplete(taskName) {\n        var taskListeners = listeners[taskName] || [];\n        arrayEach(taskListeners, function (fn) {\n            fn();\n        });\n        processQueue();\n    }\n\n\n    function runTask(key, task) {\n        if (hasError) return;\n\n        var taskCallback = onlyOnce(function(err, result) {\n            runningTasks--;\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            if (err) {\n                var safeResults = {};\n                baseForOwn(results, function(val, rkey) {\n                    safeResults[rkey] = val;\n                });\n                safeResults[key] = result;\n                hasError = true;\n                listeners = Object.create(null);\n\n                callback(err, safeResults);\n            } else {\n                results[key] = result;\n                taskComplete(key);\n            }\n        });\n\n        runningTasks++;\n        var taskFn = wrapAsync(task[task.length - 1]);\n        if (task.length > 1) {\n            taskFn(results, taskCallback);\n        } else {\n            taskFn(taskCallback);\n        }\n    }\n\n    function checkForDeadlocks() {\n        // Kahn's algorithm\n        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm\n        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html\n        var currentTask;\n        var counter = 0;\n        while (readyToCheck.length) {\n            currentTask = readyToCheck.pop();\n            counter++;\n            arrayEach(getDependents(currentTask), function (dependent) {\n                if (--uncheckedDependencies[dependent] === 0) {\n                    readyToCheck.push(dependent);\n                }\n            });\n        }\n\n        if (counter !== numTasks) {\n            throw new Error(\n                'async.auto cannot execute tasks due to a recursive dependency'\n            );\n        }\n    }\n\n    function getDependents(taskName) {\n        var result = [];\n        baseForOwn(tasks, function (task, key) {\n            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {\n                result.push(key);\n            }\n        });\n        return result;\n    }\n};\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol$1 ? Symbol$1.prototype : undefined;\nvar symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * The base implementation of `_.slice` without an iteratee call guard.\n *\n * @private\n * @param {Array} array The array to slice.\n * @param {number} [start=0] The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the slice of `array`.\n */\nfunction baseSlice(array, start, end) {\n  var index = -1,\n      length = array.length;\n\n  if (start < 0) {\n    start = -start > length ? 0 : (length + start);\n  }\n  end = end > length ? length : end;\n  if (end < 0) {\n    end += length;\n  }\n  length = start > end ? 0 : ((end - start) >>> 0);\n  start >>>= 0;\n\n  var result = Array(length);\n  while (++index < length) {\n    result[index] = array[index + start];\n  }\n  return result;\n}\n\n/**\n * Casts `array` to a slice if it's needed.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {number} start The start position.\n * @param {number} [end=array.length] The end position.\n * @returns {Array} Returns the cast slice.\n */\nfunction castSlice(array, start, end) {\n  var length = array.length;\n  end = end === undefined ? length : end;\n  return (!start && end >= length) ? array : baseSlice(array, start, end);\n}\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the last unmatched string symbol.\n */\nfunction charsEndIndex(strSymbols, chrSymbols) {\n  var index = strSymbols.length;\n\n  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n * that is not found in the character symbols.\n *\n * @private\n * @param {Array} strSymbols The string symbols to inspect.\n * @param {Array} chrSymbols The character symbols to find.\n * @returns {number} Returns the index of the first unmatched string symbol.\n */\nfunction charsStartIndex(strSymbols, chrSymbols) {\n  var index = -1,\n      length = strSymbols.length;\n\n  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n  return index;\n}\n\n/**\n * Converts an ASCII `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction asciiToArray(string) {\n  return string.split('');\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;\nvar rsVarRange = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsZWJ = '\\\\u200d';\n\n/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\nvar reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n/**\n * Checks if `string` contains Unicode symbols.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n */\nfunction hasUnicode(string) {\n  return reHasUnicode.test(string);\n}\n\n/** Used to compose unicode character classes. */\nvar rsAstralRange$1 = '\\\\ud800-\\\\udfff';\nvar rsComboMarksRange$1 = '\\\\u0300-\\\\u036f';\nvar reComboHalfMarksRange$1 = '\\\\ufe20-\\\\ufe2f';\nvar rsComboSymbolsRange$1 = '\\\\u20d0-\\\\u20ff';\nvar rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;\nvar rsVarRange$1 = '\\\\ufe0e\\\\ufe0f';\n\n/** Used to compose unicode capture groups. */\nvar rsAstral = '[' + rsAstralRange$1 + ']';\nvar rsCombo = '[' + rsComboRange$1 + ']';\nvar rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]';\nvar rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')';\nvar rsNonAstral = '[^' + rsAstralRange$1 + ']';\nvar rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}';\nvar rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]';\nvar rsZWJ$1 = '\\\\u200d';\n\n/** Used to compose unicode regexes. */\nvar reOptMod = rsModifier + '?';\nvar rsOptVar = '[' + rsVarRange$1 + ']?';\nvar rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*';\nvar rsSeq = rsOptVar + reOptMod + rsOptJoin;\nvar rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\nvar reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n/**\n * Converts a Unicode `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction unicodeToArray(string) {\n  return string.match(reUnicode) || [];\n}\n\n/**\n * Converts `string` to an array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the converted array.\n */\nfunction stringToArray(string) {\n  return hasUnicode(string)\n    ? unicodeToArray(string)\n    : asciiToArray(string);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/**\n * Removes leading and trailing whitespace or specified characters from `string`.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to trim.\n * @param {string} [chars=whitespace] The characters to trim.\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n * @returns {string} Returns the trimmed string.\n * @example\n *\n * _.trim('  abc  ');\n * // => 'abc'\n *\n * _.trim('-_-abc-_-', '_-');\n * // => 'abc'\n *\n * _.map(['  foo  ', '  bar  '], _.trim);\n * // => ['foo', 'bar']\n */\nfunction trim(string, chars, guard) {\n  string = toString(string);\n  if (string && (guard || chars === undefined)) {\n    return string.replace(reTrim, '');\n  }\n  if (!string || !(chars = baseToString(chars))) {\n    return string;\n  }\n  var strSymbols = stringToArray(string),\n      chrSymbols = stringToArray(chars),\n      start = charsStartIndex(strSymbols, chrSymbols),\n      end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n  return castSlice(strSymbols, start, end).join('');\n}\n\nvar FN_ARGS = /^(?:async\\s+)?(function)?\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /(=.+)?(\\s*)$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\nfunction parseParams(func) {\n    func = func.toString().replace(STRIP_COMMENTS, '');\n    func = func.match(FN_ARGS)[2].replace(' ', '');\n    func = func ? func.split(FN_ARG_SPLIT) : [];\n    func = func.map(function (arg){\n        return trim(arg.replace(FN_ARG, ''));\n    });\n    return func;\n}\n\n/**\n * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n */\nfunction autoInject(tasks, callback) {\n    var newTasks = {};\n\n    baseForOwn(tasks, function (taskFn, key) {\n        var params;\n        var fnIsAsync = isAsync(taskFn);\n        var hasNoDeps =\n            (!fnIsAsync && taskFn.length === 1) ||\n            (fnIsAsync && taskFn.length === 0);\n\n        if (isArray(taskFn)) {\n            params = taskFn.slice(0, -1);\n            taskFn = taskFn[taskFn.length - 1];\n\n            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);\n        } else if (hasNoDeps) {\n            // no dependencies, use the function as-is\n            newTasks[key] = taskFn;\n        } else {\n            params = parseParams(taskFn);\n            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {\n                throw new Error(\"autoInject task functions require explicit parameters.\");\n            }\n\n            // remove callback param\n            if (!fnIsAsync) params.pop();\n\n            newTasks[key] = params.concat(newTask);\n        }\n\n        function newTask(results, taskCb) {\n            var newArgs = arrayMap(params, function (name) {\n                return results[name];\n            });\n            newArgs.push(taskCb);\n            wrapAsync(taskFn).apply(null, newArgs);\n        }\n    });\n\n    auto(newTasks, callback);\n}\n\n// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation\n// used for queues. This implementation assumes that the node provided by the user can be modified\n// to adjust the next and last properties. We implement only the minimal functionality\n// for queue support.\nfunction DLL() {\n    this.head = this.tail = null;\n    this.length = 0;\n}\n\nfunction setInitial(dll, node) {\n    dll.length = 1;\n    dll.head = dll.tail = node;\n}\n\nDLL.prototype.removeLink = function(node) {\n    if (node.prev) node.prev.next = node.next;\n    else this.head = node.next;\n    if (node.next) node.next.prev = node.prev;\n    else this.tail = node.prev;\n\n    node.prev = node.next = null;\n    this.length -= 1;\n    return node;\n};\n\nDLL.prototype.empty = function () {\n    while(this.head) this.shift();\n    return this;\n};\n\nDLL.prototype.insertAfter = function(node, newNode) {\n    newNode.prev = node;\n    newNode.next = node.next;\n    if (node.next) node.next.prev = newNode;\n    else this.tail = newNode;\n    node.next = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.insertBefore = function(node, newNode) {\n    newNode.prev = node.prev;\n    newNode.next = node;\n    if (node.prev) node.prev.next = newNode;\n    else this.head = newNode;\n    node.prev = newNode;\n    this.length += 1;\n};\n\nDLL.prototype.unshift = function(node) {\n    if (this.head) this.insertBefore(this.head, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.push = function(node) {\n    if (this.tail) this.insertAfter(this.tail, node);\n    else setInitial(this, node);\n};\n\nDLL.prototype.shift = function() {\n    return this.head && this.removeLink(this.head);\n};\n\nDLL.prototype.pop = function() {\n    return this.tail && this.removeLink(this.tail);\n};\n\nDLL.prototype.toArray = function () {\n    var arr = Array(this.length);\n    var curr = this.head;\n    for(var idx = 0; idx < this.length; idx++) {\n        arr[idx] = curr.data;\n        curr = curr.next;\n    }\n    return arr;\n};\n\nDLL.prototype.remove = function (testFn) {\n    var curr = this.head;\n    while(!!curr) {\n        var next = curr.next;\n        if (testFn(curr)) {\n            this.removeLink(curr);\n        }\n        curr = next;\n    }\n    return this;\n};\n\nfunction queue(worker, concurrency, payload) {\n    if (concurrency == null) {\n        concurrency = 1;\n    }\n    else if(concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var _worker = wrapAsync(worker);\n    var numRunning = 0;\n    var workersList = [];\n\n    var processingScheduled = false;\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0 && q.idle()) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                callback: callback || noop\n            };\n\n            if (insertAtFront) {\n                q._tasks.unshift(item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n\n        if (!processingScheduled) {\n            processingScheduled = true;\n            setImmediate$1(function() {\n                processingScheduled = false;\n                q.process();\n            });\n        }\n    }\n\n    function _next(tasks) {\n        return function(err){\n            numRunning -= 1;\n\n            for (var i = 0, l = tasks.length; i < l; i++) {\n                var task = tasks[i];\n\n                var index = baseIndexOf(workersList, task, 0);\n                if (index === 0) {\n                    workersList.shift();\n                } else if (index > 0) {\n                    workersList.splice(index, 1);\n                }\n\n                task.callback.apply(task, arguments);\n\n                if (err != null) {\n                    q.error(err, task.data);\n                }\n            }\n\n            if (numRunning <= (q.concurrency - q.buffer) ) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n            q.process();\n        };\n    }\n\n    var isProcessing = false;\n    var q = {\n        _tasks: new DLL(),\n        concurrency: concurrency,\n        payload: payload,\n        saturated: noop,\n        unsaturated:noop,\n        buffer: concurrency / 4,\n        empty: noop,\n        drain: noop,\n        error: noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = noop;\n            q._tasks.empty();\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        remove: function (testFn) {\n            q._tasks.remove(testFn);\n        },\n        process: function () {\n            // Avoid trying to start too many processing operations. This can occur\n            // when callbacks resolve synchronously (#1267).\n            if (isProcessing) {\n                return;\n            }\n            isProcessing = true;\n            while(!q.paused && numRunning < q.concurrency && q._tasks.length){\n                var tasks = [], data = [];\n                var l = q._tasks.length;\n                if (q.payload) l = Math.min(l, q.payload);\n                for (var i = 0; i < l; i++) {\n                    var node = q._tasks.shift();\n                    tasks.push(node);\n                    workersList.push(node);\n                    data.push(node.data);\n                }\n\n                numRunning += 1;\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                if (numRunning === q.concurrency) {\n                    q.saturated();\n                }\n\n                var cb = onlyOnce(_next(tasks));\n                _worker(data, cb);\n            }\n            isProcessing = false;\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return numRunning;\n        },\n        workersList: function () {\n            return workersList;\n        },\n        idle: function() {\n            return q._tasks.length + numRunning === 0;\n        },\n        pause: function () {\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) { return; }\n            q.paused = false;\n            setImmediate$1(q.process);\n        }\n    };\n    return q;\n}\n\n/**\n * A cargo of tasks for the worker function to complete. Cargo inherits all of\n * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.\n * @typedef {Object} CargoObject\n * @memberOf module:ControlFlow\n * @property {Function} length - A function returning the number of items\n * waiting to be processed. Invoke like `cargo.length()`.\n * @property {number} payload - An `integer` for determining how many tasks\n * should be process per round. This property can be changed after a `cargo` is\n * created to alter the payload on-the-fly.\n * @property {Function} push - Adds `task` to the `queue`. The callback is\n * called once the `worker` has finished processing the task. Instead of a\n * single task, an array of `tasks` can be submitted. The respective callback is\n * used for every task in the list. Invoke like `cargo.push(task, [callback])`.\n * @property {Function} saturated - A callback that is called when the\n * `queue.length()` hits the concurrency and further tasks will be queued.\n * @property {Function} empty - A callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - A callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke like `cargo.idle()`.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke like `cargo.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke like `cargo.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.\n */\n\n/**\n * Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargo.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n */\nfunction cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}\n\n/**\n * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.\n *\n * @name eachOfSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.eachOf]{@link module:Collections.eachOf}\n * @alias forEachOfSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * Invoked with (item, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachOfSeries = doLimit(eachOfLimit, 1);\n\n/**\n * Reduces `coll` into a single value using an async `iteratee` to return each\n * successive step. `memo` is the initial state of the reduction. This function\n * only operates in series.\n *\n * For performance reasons, it may make sense to split a call to this function\n * into a parallel map, and then use the normal `Array.prototype.reduce` on the\n * results. This function is for situations where each step in the reduction\n * needs to be async; if you can get the data before reducing it, then it's\n * probably a good idea to do so.\n *\n * @name reduce\n * @static\n * @memberOf module:Collections\n * @method\n * @alias inject\n * @alias foldl\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n * @example\n *\n * async.reduce([1,2,3], 0, function(memo, item, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         callback(null, memo + item)\n *     });\n * }, function(err, result) {\n *     // result is now equal to the last value of memo, which is 6\n * });\n */\nfunction reduce(coll, memo, iteratee, callback) {\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    eachOfSeries(coll, function(x, i, callback) {\n        _iteratee(memo, x, function(err, v) {\n            memo = v;\n            callback(err);\n        });\n    }, function(err) {\n        callback(err, memo);\n    });\n}\n\n/**\n * Version of the compose function that is more natural to read. Each function\n * consumes the return value of the previous function. It is the equivalent of\n * [compose]{@link module:ControlFlow.compose} with the arguments reversed.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name seq\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.compose]{@link module:ControlFlow.compose}\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} a function that composes the `functions` in order\n * @example\n *\n * // Requires lodash (or underscore), express3 and dresende's orm2.\n * // Part of an app, that fetches cats of the logged user.\n * // This example uses `seq` function to avoid overnesting and error\n * // handling clutter.\n * app.get('/cats', function(request, response) {\n *     var User = request.models.User;\n *     async.seq(\n *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n *         function(user, fn) {\n *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n *         }\n *     )(req.session.user_id, function (err, cats) {\n *         if (err) {\n *             console.error(err);\n *             response.json({ status: 'error', message: err.message });\n *         } else {\n *             response.json({ status: 'ok', message: 'Cats found', data: cats });\n *         }\n *     });\n * });\n */\nfunction seq(/*...functions*/) {\n    var _functions = arrayMap(arguments, wrapAsync);\n    return function(/*...args*/) {\n        var args = slice(arguments);\n        var that = this;\n\n        var cb = args[args.length - 1];\n        if (typeof cb == 'function') {\n            args.pop();\n        } else {\n            cb = noop;\n        }\n\n        reduce(_functions, args, function(newargs, fn, cb) {\n            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {\n                var nextargs = slice(arguments, 1);\n                cb(err, nextargs);\n            }));\n        },\n        function(err, results) {\n            cb.apply(that, [err].concat(results));\n        });\n    };\n}\n\n/**\n * Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });\n */\nvar compose = function(/*...args*/) {\n    return seq.apply(null, slice(arguments).reverse());\n};\n\nvar _concat = Array.prototype.concat;\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err /*, ...args*/) {\n            if (err) return callback(err);\n            return callback(null, slice(arguments, 1));\n        });\n    }, function(err, mapResults) {\n        var result = [];\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                result = _concat.apply(result, mapResults[i]);\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. There is no guarantee that the\n * results array will be returned in the original order of `coll` passed to the\n * `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @example\n *\n * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {\n *     // files is now a list of filenames that exist in the 3 directories\n * });\n */\nvar concat = doLimit(concatLimit, Infinity);\n\n/**\n * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback(err)] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n */\nvar concatSeries = doLimit(concatLimit, 1);\n\n/**\n * Returns a function that when called, calls-back with the values provided.\n * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to\n * [`auto`]{@link module:ControlFlow.auto}.\n *\n * @name constant\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {...*} arguments... - Any number of arguments to automatically invoke\n * callback with.\n * @returns {AsyncFunction} Returns a function that when invoked, automatically\n * invokes the callback with the previous given arguments.\n * @example\n *\n * async.waterfall([\n *     async.constant(42),\n *     function (value, next) {\n *         // value === 42\n *     },\n *     //...\n * ], callback);\n *\n * async.waterfall([\n *     async.constant(filename, \"utf8\"),\n *     fs.readFile,\n *     function (fileData, next) {\n *         //...\n *     }\n *     //...\n * ], callback);\n *\n * async.auto({\n *     hostname: async.constant(\"https://server.net/\"),\n *     port: findFreePort,\n *     launchServer: [\"hostname\", \"port\", function (options, cb) {\n *         startServer(options, cb);\n *     }],\n *     //...\n * }, callback);\n */\nvar constant = function(/*...values*/) {\n    var values = slice(arguments);\n    var args = [null].concat(values);\n    return function (/*...ignoredArgs, callback*/) {\n        var callback = arguments[arguments.length - 1];\n        return callback.apply(this, args);\n    };\n};\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\nfunction _createTester(check, getResult) {\n    return function(eachfn, arr, iteratee, cb) {\n        cb = cb || noop;\n        var testPassed = false;\n        var testResult;\n        eachfn(arr, function(value, _, callback) {\n            iteratee(value, function(err, result) {\n                if (err) {\n                    callback(err);\n                } else if (check(result) && !testResult) {\n                    testPassed = true;\n                    testResult = getResult(true, value);\n                    callback(null, breakLoop);\n                } else {\n                    callback();\n                }\n            });\n        }, function(err) {\n            if (err) {\n                cb(err);\n            } else {\n                cb(null, testPassed ? testResult : getResult(false));\n            }\n        });\n    };\n}\n\nfunction _findGetResult(v, x) {\n    return x;\n}\n\n/**\n * Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @example\n *\n * async.detect(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // result now equals the first file in the list that exists\n * });\n */\nvar detect = doParallel(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name detectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findLimit\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectLimit = doParallelLimit(_createTester(identity, _findGetResult));\n\n/**\n * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.\n *\n * @name detectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.detect]{@link module:Collections.detect}\n * @alias findSeries\n * @category Collections\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n */\nvar detectSeries = doLimit(detectLimit, 1);\n\nfunction consoleFunc(name) {\n    return function (fn/*, ...args*/) {\n        var args = slice(arguments, 1);\n        args.push(function (err/*, ...args*/) {\n            var args = slice(arguments, 1);\n            if (typeof console === 'object') {\n                if (err) {\n                    if (console.error) {\n                        console.error(err);\n                    }\n                } else if (console[name]) {\n                    arrayEach(args, function (x) {\n                        console[name](x);\n                    });\n                }\n            }\n        });\n        wrapAsync(fn).apply(null, args);\n    };\n}\n\n/**\n * Logs the result of an [`async` function]{@link AsyncFunction} to the\n * `console` using `console.dir` to display the properties of the resulting object.\n * Only works in Node.js or in browsers that support `console.dir` and\n * `console.error` (such as FF and Chrome).\n * If multiple arguments are returned from the async function,\n * `console.dir` is called on each argument in order.\n *\n * @name dir\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, {hello: name});\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.dir(hello, 'world');\n * {hello: 'world'}\n */\nvar dir = consoleFunc('dir');\n\n/**\n * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in\n * the order of operations, the arguments `test` and `fn` are switched.\n *\n * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.\n * @name doDuring\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.during]{@link module:ControlFlow.during}\n * @category Control Flow\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (...args, callback), where `...args` are the\n * non-error args from the previous callback of `fn`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error if one occurred, otherwise `null`.\n */\nfunction doDuring(fn, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        args.push(check);\n        _test.apply(this, args);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    check(null, true);\n\n}\n\n/**\n * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in\n * the order of operations, the arguments `test` and `iteratee` are switched.\n *\n * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n *\n * @name doWhilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - A function which is called each time `test`\n * passes. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped.\n * `callback` will be passed an error and any arguments passed to the final\n * `iteratee`'s callback. Invoked with (err, [results]);\n */\nfunction doWhilst(iteratee, test, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        var args = slice(arguments, 1);\n        if (test.apply(this, args)) return _iteratee(next);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the\n * argument ordering differs from `until`.\n *\n * @name doUntil\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}\n * @category Control Flow\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} test - synchronous truth test to perform after each\n * execution of `iteratee`. Invoked with any non-error callback results of\n * `iteratee`.\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction doUntil(iteratee, test, callback) {\n    doWhilst(iteratee, function() {\n        return !test.apply(this, arguments);\n    }, callback);\n}\n\n/**\n * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that\n * is passed a callback in the form of `function (err, truth)`. If error is\n * passed to `test` or `fn`, the main callback is immediately called with the\n * value of the error.\n *\n * @name during\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {AsyncFunction} test - asynchronous truth test to perform before each\n * execution of `fn`. Invoked with (callback).\n * @param {AsyncFunction} fn - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `fn` has stopped. `callback`\n * will be passed an error, if one occurred, otherwise `null`.\n * @example\n *\n * var count = 0;\n *\n * async.during(\n *     function (callback) {\n *         return callback(null, count < 5);\n *     },\n *     function (callback) {\n *         count++;\n *         setTimeout(callback, 1000);\n *     },\n *     function (err) {\n *         // 5 seconds have passed\n *     }\n * );\n */\nfunction during(test, fn, callback) {\n    callback = onlyOnce(callback || noop);\n    var _fn = wrapAsync(fn);\n    var _test = wrapAsync(test);\n\n    function next(err) {\n        if (err) return callback(err);\n        _test(check);\n    }\n\n    function check(err, truth) {\n        if (err) return callback(err);\n        if (!truth) return callback(null);\n        _fn(next);\n    }\n\n    _test(check);\n}\n\nfunction _withoutIndex(iteratee) {\n    return function (value, index, callback) {\n        return iteratee(value, callback);\n    };\n}\n\n/**\n * Applies the function `iteratee` to each item in `coll`, in parallel.\n * The `iteratee` is called with an item from the list, and a callback for when\n * it has finished. If the `iteratee` passes an error to its `callback`, the\n * main `callback` (for the `each` function) is immediately called with the\n * error.\n *\n * Note, that since this function applies `iteratee` to each item in parallel,\n * there is no guarantee that the iteratee functions will complete in order.\n *\n * @name each\n * @static\n * @memberOf module:Collections\n * @method\n * @alias forEach\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to\n * each item in `coll`. Invoked with (item, callback).\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOf`.\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n * @example\n *\n * // assuming openFiles is an array of file names and saveFile is a function\n * // to save the modified contents of that file:\n *\n * async.each(openFiles, saveFile, function(err){\n *   // if any of the saves produced an error, err would equal that error\n * });\n *\n * // assuming openFiles is an array of file names\n * async.each(openFiles, function(file, callback) {\n *\n *     // Perform operation on file here.\n *     console.log('Processing file ' + file);\n *\n *     if( file.length > 32 ) {\n *       console.log('This file name is too long');\n *       callback('File name too long');\n *     } else {\n *       // Do work to process file here\n *       console.log('File processed');\n *       callback();\n *     }\n * }, function(err) {\n *     // if any of the file processing produced an error, err would equal that error\n *     if( err ) {\n *       // One of the iterations produced an error.\n *       // All processing will now stop.\n *       console.log('A file failed to process');\n *     } else {\n *       console.log('All files have been processed successfully');\n *     }\n * });\n */\nfunction eachLimit(coll, iteratee, callback) {\n    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.\n *\n * @name eachLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfLimit`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nfunction eachLimit$1(coll, limit, iteratee, callback) {\n    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);\n}\n\n/**\n * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.\n *\n * @name eachSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.each]{@link module:Collections.each}\n * @alias forEachSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each\n * item in `coll`.\n * The array index is not passed to the iteratee.\n * If you need the index, use `eachOfSeries`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called when all\n * `iteratee` functions have finished, or an error occurs. Invoked with (err).\n */\nvar eachSeries = doLimit(eachLimit$1, 1);\n\n/**\n * Wrap an async function and ensure it calls its callback on a later tick of\n * the event loop.  If the function already calls its callback on a next tick,\n * no extra deferral is added. This is useful for preventing stack overflows\n * (`RangeError: Maximum call stack size exceeded`) and generally keeping\n * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)\n * contained. ES2017 `async` functions are returned as-is -- they are immune\n * to Zalgo's corrupting influences, as they always resolve on a later tick.\n *\n * @name ensureAsync\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - an async function, one that expects a node-style\n * callback as its last argument.\n * @returns {AsyncFunction} Returns a wrapped function with the exact same call\n * signature as the function passed in.\n * @example\n *\n * function sometimesAsync(arg, callback) {\n *     if (cache[arg]) {\n *         return callback(null, cache[arg]); // this would be synchronous!!\n *     } else {\n *         doSomeIO(arg, callback); // this IO would be asynchronous\n *     }\n * }\n *\n * // this has a risk of stack overflows if many results are cached in a row\n * async.mapSeries(args, sometimesAsync, done);\n *\n * // this will defer sometimesAsync's callback if necessary,\n * // preventing stack overflows\n * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);\n */\nfunction ensureAsync(fn) {\n    if (isAsync(fn)) return fn;\n    return initialParams(function (args, callback) {\n        var sync = true;\n        args.push(function () {\n            var innerArgs = arguments;\n            if (sync) {\n                setImmediate$1(function () {\n                    callback.apply(null, innerArgs);\n                });\n            } else {\n                callback.apply(null, innerArgs);\n            }\n        });\n        fn.apply(this, args);\n        sync = false;\n    });\n}\n\nfunction notId(v) {\n    return !v;\n}\n\n/**\n * Returns `true` if every element in `coll` satisfies an async test. If any\n * iteratee call returns `false`, the main `callback` is immediately called.\n *\n * @name every\n * @static\n * @memberOf module:Collections\n * @method\n * @alias all\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n * @example\n *\n * async.every(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then every file exists\n * });\n */\nvar every = doParallel(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.\n *\n * @name everyLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in parallel.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everyLimit = doParallelLimit(_createTester(notId, notId));\n\n/**\n * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.\n *\n * @name everySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.every]{@link module:Collections.every}\n * @alias allSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collection in series.\n * The iteratee must complete with a boolean result value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result will be either `true` or `false`\n * depending on the values of the async tests. Invoked with (err, result).\n */\nvar everySeries = doLimit(everyLimit, 1);\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nfunction filterArray(eachfn, arr, iteratee, callback) {\n    var truthValues = new Array(arr.length);\n    eachfn(arr, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            truthValues[index] = !!v;\n            callback(err);\n        });\n    }, function (err) {\n        if (err) return callback(err);\n        var results = [];\n        for (var i = 0; i < arr.length; i++) {\n            if (truthValues[i]) results.push(arr[i]);\n        }\n        callback(null, results);\n    });\n}\n\nfunction filterGeneric(eachfn, coll, iteratee, callback) {\n    var results = [];\n    eachfn(coll, function (x, index, callback) {\n        iteratee(x, function (err, v) {\n            if (err) {\n                callback(err);\n            } else {\n                if (v) {\n                    results.push({index: index, value: x});\n                }\n                callback();\n            }\n        });\n    }, function (err) {\n        if (err) {\n            callback(err);\n        } else {\n            callback(null, arrayMap(results.sort(function (a, b) {\n                return a.index - b.index;\n            }), baseProperty('value')));\n        }\n    });\n}\n\nfunction _filter(eachfn, coll, iteratee, callback) {\n    var filter = isArrayLike(coll) ? filterArray : filterGeneric;\n    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);\n}\n\n/**\n * Returns a new array of all the values in `coll` which pass an async truth\n * test. This operation is performed in parallel, but the results array will be\n * in the same order as the original.\n *\n * @name filter\n * @static\n * @memberOf module:Collections\n * @method\n * @alias select\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.filter(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of the existing files\n * });\n */\nvar filter = doParallel(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name filterLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar filterLimit = doParallelLimit(_filter);\n\n/**\n * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.\n *\n * @name filterSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @alias selectSeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - A truth test to apply to each item in `coll`.\n * The `iteratee` is passed a `callback(err, truthValue)`, which must be called\n * with a boolean argument once it has completed. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results)\n */\nvar filterSeries = doLimit(filterLimit, 1);\n\n/**\n * Calls the asynchronous function `fn` with a callback parameter that allows it\n * to call itself again, in series, indefinitely.\n\n * If an error is passed to the callback then `errback` is called with the\n * error, and execution stops, otherwise it will never be called.\n *\n * @name forever\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} fn - an async function to call repeatedly.\n * Invoked with (next).\n * @param {Function} [errback] - when `fn` passes an error to it's callback,\n * this function will be called, and execution stops. Invoked with (err).\n * @example\n *\n * async.forever(\n *     function(next) {\n *         // next is suitable for passing to things that need a callback(err [, whatever]);\n *         // it will result in this function being called again.\n *     },\n *     function(err) {\n *         // if next is called with a value in its first parameter, it will appear\n *         // in here as 'err', and execution will stop.\n *     }\n * );\n */\nfunction forever(fn, errback) {\n    var done = onlyOnce(errback || noop);\n    var task = wrapAsync(ensureAsync(fn));\n\n    function next(err) {\n        if (err) return done(err);\n        task(next);\n    }\n    next();\n}\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.\n *\n * @name groupByLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupByLimit = function(coll, limit, iteratee, callback) {\n    callback = callback || noop;\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(coll, limit, function(val, callback) {\n        _iteratee(val, function(err, key) {\n            if (err) return callback(err);\n            return callback(null, {key: key, val: val});\n        });\n    }, function(err, mapResults) {\n        var result = {};\n        // from MDN, handle object having an `hasOwnProperty` prop\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n        for (var i = 0; i < mapResults.length; i++) {\n            if (mapResults[i]) {\n                var key = mapResults[i].key;\n                var val = mapResults[i].val;\n\n                if (hasOwnProperty.call(result, key)) {\n                    result[key].push(val);\n                } else {\n                    result[key] = [val];\n                }\n            }\n        }\n\n        return callback(err, result);\n    });\n};\n\n/**\n * Returns a new object, where each value corresponds to an array of items, from\n * `coll`, that returned the corresponding key. That is, the keys of the object\n * correspond to the values passed to the `iteratee` callback.\n *\n * Note: Since this function applies the `iteratee` to each item in parallel,\n * there is no guarantee that the `iteratee` functions will complete in order.\n * However, the values for each key in the `result` will be in the same order as\n * the original `coll`. For Objects, the values will roughly be in the order of\n * the original Objects' keys (but this can vary across JavaScript engines).\n *\n * @name groupBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n * @example\n *\n * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {\n *     db.findById(userId, function(err, user) {\n *         if (err) return callback(err);\n *         return callback(null, user.age);\n *     });\n * }, function(err, result) {\n *     // result is object containing the userIds grouped by age\n *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};\n * });\n */\nvar groupBy = doLimit(groupByLimit, Infinity);\n\n/**\n * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.\n *\n * @name groupBySeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.groupBy]{@link module:Collections.groupBy}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a `key` to group the value under.\n * Invoked with (value, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. Result is an `Object` whoses\n * properties are arrays of values which returned the corresponding key.\n */\nvar groupBySeries = doLimit(groupByLimit, 1);\n\n/**\n * Logs the result of an `async` function to the `console`. Only works in\n * Node.js or in browsers that support `console.log` and `console.error` (such\n * as FF and Chrome). If multiple arguments are returned from the async\n * function, `console.log` is called on each argument in order.\n *\n * @name log\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} function - The function you want to eventually apply\n * all arguments to.\n * @param {...*} arguments... - Any number of arguments to apply to the function.\n * @example\n *\n * // in a module\n * var hello = function(name, callback) {\n *     setTimeout(function() {\n *         callback(null, 'hello ' + name);\n *     }, 1000);\n * };\n *\n * // in the node repl\n * node> async.log(hello, 'world');\n * 'hello world'\n */\nvar log = consoleFunc('log');\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name mapValuesLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nfunction mapValuesLimit(obj, limit, iteratee, callback) {\n    callback = once(callback || noop);\n    var newObj = {};\n    var _iteratee = wrapAsync(iteratee);\n    eachOfLimit(obj, limit, function(val, key, next) {\n        _iteratee(val, key, function (err, result) {\n            if (err) return next(err);\n            newObj[key] = result;\n            next();\n        });\n    }, function (err) {\n        callback(err, newObj);\n    });\n}\n\n/**\n * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.\n *\n * Produces a new Object by mapping each value of `obj` through the `iteratee`\n * function. The `iteratee` is called each `value` and `key` from `obj` and a\n * callback for when it has finished processing. Each of these callbacks takes\n * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`\n * passes an error to its callback, the main `callback` (for the `mapValues`\n * function) is immediately called with the error.\n *\n * Note, the order of the keys in the result is not guaranteed.  The keys will\n * be roughly in the order they complete, (but this is very engine-specific)\n *\n * @name mapValues\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n * @example\n *\n * async.mapValues({\n *     f1: 'file1',\n *     f2: 'file2',\n *     f3: 'file3'\n * }, function (file, key, callback) {\n *   fs.stat(file, callback);\n * }, function(err, result) {\n *     // result is now a map of stats for each file, e.g.\n *     // {\n *     //     f1: [stats for file1],\n *     //     f2: [stats for file2],\n *     //     f3: [stats for file3]\n *     // }\n * });\n */\n\nvar mapValues = doLimit(mapValuesLimit, Infinity);\n\n/**\n * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.\n *\n * @name mapValuesSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.mapValues]{@link module:Collections.mapValues}\n * @category Collection\n * @param {Object} obj - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each value and key\n * in `coll`.\n * The iteratee should complete with the transformed value as its result.\n * Invoked with (value, key, callback).\n * @param {Function} [callback] - A callback which is called when all `iteratee`\n * functions have finished, or an error occurs. `result` is a new object consisting\n * of each key from `obj`, with each transformed value on the right-hand side.\n * Invoked with (err, result).\n */\nvar mapValuesSeries = doLimit(mapValuesLimit, 1);\n\nfunction has(obj, key) {\n    return key in obj;\n}\n\n/**\n * Caches the results of an async function. When creating a hash to store\n * function results against, the callback is omitted from the hash and an\n * optional hash function can be used.\n *\n * If no hash function is specified, the first argument is used as a hash key,\n * which may work reasonably if it is a string or a data type that converts to a\n * distinct string. Note that objects and arrays will not behave reasonably.\n * Neither will cases where the other arguments are significant. In such cases,\n * specify your own hash function.\n *\n * The cache of results is exposed as the `memo` property of the function\n * returned by `memoize`.\n *\n * @name memoize\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function to proxy and cache results from.\n * @param {Function} hasher - An optional function for generating a custom hash\n * for storing results. It has all the arguments applied to it apart from the\n * callback, and must be synchronous.\n * @returns {AsyncFunction} a memoized version of `fn`\n * @example\n *\n * var slow_fn = function(name, callback) {\n *     // do something\n *     callback(null, result);\n * };\n * var fn = async.memoize(slow_fn);\n *\n * // fn can now be used as if it were slow_fn\n * fn('some name', function() {\n *     // callback\n * });\n */\nfunction memoize(fn, hasher) {\n    var memo = Object.create(null);\n    var queues = Object.create(null);\n    hasher = hasher || identity;\n    var _fn = wrapAsync(fn);\n    var memoized = initialParams(function memoized(args, callback) {\n        var key = hasher.apply(null, args);\n        if (has(memo, key)) {\n            setImmediate$1(function() {\n                callback.apply(null, memo[key]);\n            });\n        } else if (has(queues, key)) {\n            queues[key].push(callback);\n        } else {\n            queues[key] = [callback];\n            _fn.apply(null, args.concat(function(/*args*/) {\n                var args = slice(arguments);\n                memo[key] = args;\n                var q = queues[key];\n                delete queues[key];\n                for (var i = 0, l = q.length; i < l; i++) {\n                    q[i].apply(null, args);\n                }\n            }));\n        }\n    });\n    memoized.memo = memo;\n    memoized.unmemoized = fn;\n    return memoized;\n}\n\n/**\n * Calls `callback` on a later loop around the event loop. In Node.js this just\n * calls `process.nextTick`.  In the browser it will use `setImmediate` if\n * available, otherwise `setTimeout(callback, 0)`, which means other higher\n * priority events may precede the execution of `callback`.\n *\n * This is used internally for browser-compatibility purposes.\n *\n * @name nextTick\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.setImmediate]{@link module:Utils.setImmediate}\n * @category Util\n * @param {Function} callback - The function to call on a later loop around\n * the event loop. Invoked with (args...).\n * @param {...*} args... - any number of additional arguments to pass to the\n * callback on the next tick.\n * @example\n *\n * var call_order = [];\n * async.nextTick(function() {\n *     call_order.push('two');\n *     // call_order now equals ['one','two']\n * });\n * call_order.push('one');\n *\n * async.setImmediate(function (a, b, c) {\n *     // a, b, and c equal 1, 2, and 3\n * }, 1, 2, 3);\n */\nvar _defer$1;\n\nif (hasNextTick) {\n    _defer$1 = process.nextTick;\n} else if (hasSetImmediate) {\n    _defer$1 = setImmediate;\n} else {\n    _defer$1 = fallback;\n}\n\nvar nextTick = wrap(_defer$1);\n\nfunction _parallel(eachfn, tasks, callback) {\n    callback = callback || noop;\n    var results = isArrayLike(tasks) ? [] : {};\n\n    eachfn(tasks, function (task, key, callback) {\n        wrapAsync(task)(function (err, result) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            }\n            results[key] = result;\n            callback(err);\n        });\n    }, function (err) {\n        callback(err, results);\n    });\n}\n\n/**\n * Run the `tasks` collection of functions in parallel, without waiting until\n * the previous function has completed. If any of the functions pass an error to\n * its callback, the main `callback` is immediately called with the value of the\n * error. Once the `tasks` have completed, the results are passed to the final\n * `callback` as an array.\n *\n * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about\n * parallel execution of code.  If your tasks do not use any timers or perform\n * any I/O, they will actually be executed in series.  Any synchronous setup\n * sections for each task will happen one after the other.  JavaScript remains\n * single-threaded.\n *\n * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the\n * execution of other tasks when a task fails.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n * results from {@link async.parallel}.\n *\n * @name parallel\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n *\n * @example\n * async.parallel([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // the results array will equal ['one','two'] even though\n *     // the second function had a shorter timeout.\n * });\n *\n * // an example using an object instead of an array\n * async.parallel({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equals to: {one: 1, two: 2}\n * });\n */\nfunction parallelLimit(tasks, callback) {\n    _parallel(eachOf, tasks, callback);\n}\n\n/**\n * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name parallelLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.parallel]{@link module:ControlFlow.parallel}\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection of\n * [async functions]{@link AsyncFunction} to run.\n * Each async function can complete with any number of optional `result` values.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed successfully. This function gets a results array\n * (or object) containing all the result arguments passed to the task callbacks.\n * Invoked with (err, results).\n */\nfunction parallelLimit$1(tasks, limit, callback) {\n    _parallel(_eachOfLimit(limit), tasks, callback);\n}\n\n/**\n * A queue of tasks for the worker function to complete.\n * @typedef {Object} QueueObject\n * @memberOf module:ControlFlow\n * @property {Function} length - a function returning the number of items\n * waiting to be processed. Invoke with `queue.length()`.\n * @property {boolean} started - a boolean indicating whether or not any\n * items have been pushed and processed by the queue.\n * @property {Function} running - a function returning the number of items\n * currently being processed. Invoke with `queue.running()`.\n * @property {Function} workersList - a function returning the array of items\n * currently being processed. Invoke with `queue.workersList()`.\n * @property {Function} idle - a function returning false if there are items\n * waiting or being processed, or true if not. Invoke with `queue.idle()`.\n * @property {number} concurrency - an integer for determining how many `worker`\n * functions should be run in parallel. This property can be changed after a\n * `queue` is created to alter the concurrency on-the-fly.\n * @property {Function} push - add a new task to the `queue`. Calls `callback`\n * once the `worker` has finished processing the task. Instead of a single task,\n * a `tasks` array can be submitted. The respective callback is used for every\n * task in the list. Invoke with `queue.push(task, [callback])`,\n * @property {Function} unshift - add a new task to the front of the `queue`.\n * Invoke with `queue.unshift(task, [callback])`.\n * @property {Function} remove - remove items from the queue that match a test\n * function.  The test function will be passed an object with a `data` property,\n * and a `priority` property, if this is a\n * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.\n * Invoked with `queue.remove(testFn)`, where `testFn` is of the form\n * `function ({data, priority}) {}` and returns a Boolean.\n * @property {Function} saturated - a callback that is called when the number of\n * running workers hits the `concurrency` limit, and further tasks will be\n * queued.\n * @property {Function} unsaturated - a callback that is called when the number\n * of running workers is less than the `concurrency` & `buffer` limits, and\n * further tasks will not be queued.\n * @property {number} buffer - A minimum threshold buffer in order to say that\n * the `queue` is `unsaturated`.\n * @property {Function} empty - a callback that is called when the last item\n * from the `queue` is given to a `worker`.\n * @property {Function} drain - a callback that is called when the last item\n * from the `queue` has returned from the `worker`.\n * @property {Function} error - a callback that is called when a task errors.\n * Has the signature `function(error, task)`.\n * @property {boolean} paused - a boolean for determining whether the queue is\n * in a paused state.\n * @property {Function} pause - a function that pauses the processing of tasks\n * until `resume()` is called. Invoke with `queue.pause()`.\n * @property {Function} resume - a function that resumes the processing of\n * queued tasks when the queue is paused. Invoke with `queue.resume()`.\n * @property {Function} kill - a function that removes the `drain` callback and\n * empties remaining tasks from the queue forcing it to go idle. No more tasks\n * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.\n */\n\n/**\n * Creates a `queue` object with the specified `concurrency`. Tasks added to the\n * `queue` are processed in parallel (up to the `concurrency` limit). If all\n * `worker`s are in progress, the task is queued until one becomes available.\n * Once a `worker` completes a `task`, that `task`'s callback is called.\n *\n * @name queue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`. Invoked with (task, callback).\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the queue.\n * @example\n *\n * // create a queue object with concurrency 2\n * var q = async.queue(function(task, callback) {\n *     console.log('hello ' + task.name);\n *     callback();\n * }, 2);\n *\n * // assign a callback\n * q.drain = function() {\n *     console.log('all items have been processed');\n * };\n *\n * // add some items to the queue\n * q.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * q.push({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n *\n * // add some items to the queue (batch-wise)\n * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {\n *     console.log('finished processing item');\n * });\n *\n * // add some items to the front of the queue\n * q.unshift({name: 'bar'}, function (err) {\n *     console.log('finished processing bar');\n * });\n */\nvar queue$1 = function (worker, concurrency) {\n    var _worker = wrapAsync(worker);\n    return queue(function (items, cb) {\n        _worker(items[0], cb);\n    }, concurrency, 1);\n};\n\n/**\n * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and\n * completed in ascending priority order.\n *\n * @name priorityQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An async function for processing a queued task.\n * If you want to handle errors from an individual task, pass a callback to\n * `q.push()`.\n * Invoked with (task, callback).\n * @param {number} concurrency - An `integer` for determining how many `worker`\n * functions should be run in parallel.  If omitted, the concurrency defaults to\n * `1`.  If the concurrency is `0`, an error is thrown.\n * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two\n * differences between `queue` and `priorityQueue` objects:\n * * `push(task, priority, [callback])` - `priority` should be a number. If an\n *   array of `tasks` is given, all tasks will be assigned the same priority.\n * * The `unshift` method was removed.\n */\nvar priorityQueue = function(worker, concurrency) {\n    // Start with a normal queue\n    var q = queue$1(worker, concurrency);\n\n    // Override push to accept second parameter representing priority\n    q.push = function(data, priority, callback) {\n        if (callback == null) callback = noop;\n        if (typeof callback !== 'function') {\n            throw new Error('task callback must be a function');\n        }\n        q.started = true;\n        if (!isArray(data)) {\n            data = [data];\n        }\n        if (data.length === 0) {\n            // call drain immediately if there are no tasks\n            return setImmediate$1(function() {\n                q.drain();\n            });\n        }\n\n        priority = priority || 0;\n        var nextNode = q._tasks.head;\n        while (nextNode && priority >= nextNode.priority) {\n            nextNode = nextNode.next;\n        }\n\n        for (var i = 0, l = data.length; i < l; i++) {\n            var item = {\n                data: data[i],\n                priority: priority,\n                callback: callback\n            };\n\n            if (nextNode) {\n                q._tasks.insertBefore(nextNode, item);\n            } else {\n                q._tasks.push(item);\n            }\n        }\n        setImmediate$1(q.process);\n    };\n\n    // Remove unshift function\n    delete q.unshift;\n\n    return q;\n};\n\n/**\n * Runs the `tasks` array of functions in parallel, without waiting until the\n * previous function has completed. Once any of the `tasks` complete or pass an\n * error to its callback, the main `callback` is immediately called. It's\n * equivalent to `Promise.race()`.\n *\n * @name race\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}\n * to run. Each function can complete with an optional `result` value.\n * @param {Function} callback - A callback to run once any of the functions have\n * completed. This function gets an error or result from the first function that\n * completed. Invoked with (err, result).\n * @returns undefined\n * @example\n *\n * async.race([\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ],\n * // main callback\n * function(err, result) {\n *     // the result will be equal to 'two' as it finishes earlier\n * });\n */\nfunction race(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));\n    if (!tasks.length) return callback();\n    for (var i = 0, l = tasks.length; i < l; i++) {\n        wrapAsync(tasks[i])(callback);\n    }\n}\n\n/**\n * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.\n *\n * @name reduceRight\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reduce]{@link module:Collections.reduce}\n * @alias foldr\n * @category Collection\n * @param {Array} array - A collection to iterate over.\n * @param {*} memo - The initial state of the reduction.\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * array to produce the next step in the reduction.\n * The `iteratee` should complete with the next state of the reduction.\n * If the iteratee complete with an error, the reduction is stopped and the\n * main `callback` is immediately called with the error.\n * Invoked with (memo, item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the reduced value. Invoked with\n * (err, result).\n */\nfunction reduceRight (array, memo, iteratee, callback) {\n    var reversed = slice(array).reverse();\n    reduce(reversed, memo, iteratee, callback);\n}\n\n/**\n * Wraps the async function in another function that always completes with a\n * result object, even when it errors.\n *\n * The result object has either the property `error` or `value`.\n *\n * @name reflect\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} fn - The async function you want to wrap\n * @returns {Function} - A function that always passes null to it's callback as\n * the error. The second argument to the callback will be an `object` with\n * either an `error` or a `value` property.\n * @example\n *\n * async.parallel([\n *     async.reflect(function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff but error ...\n *         callback('bad stuff happened');\n *     }),\n *     async.reflect(function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     })\n * ],\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = 'bad stuff happened'\n *     // results[2].value = 'two'\n * });\n */\nfunction reflect(fn) {\n    var _fn = wrapAsync(fn);\n    return initialParams(function reflectOn(args, reflectCallback) {\n        args.push(function callback(error, cbArg) {\n            if (error) {\n                reflectCallback(null, { error: error });\n            } else {\n                var value;\n                if (arguments.length <= 2) {\n                    value = cbArg;\n                } else {\n                    value = slice(arguments, 1);\n                }\n                reflectCallback(null, { value: value });\n            }\n        });\n\n        return _fn.apply(this, args);\n    });\n}\n\n/**\n * A helper function that wraps an array or an object of functions with `reflect`.\n *\n * @name reflectAll\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.reflect]{@link module:Utils.reflect}\n * @category Util\n * @param {Array|Object|Iterable} tasks - The collection of\n * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.\n * @returns {Array} Returns an array of async functions, each wrapped in\n * `async.reflect`\n * @example\n *\n * let tasks = [\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     function(callback) {\n *         // do some more stuff but error ...\n *         callback(new Error('bad stuff happened'));\n *     },\n *     function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'two');\n *         }, 100);\n *     }\n * ];\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results[0].value = 'one'\n *     // results[1].error = Error('bad stuff happened')\n *     // results[2].value = 'two'\n * });\n *\n * // an example using an object instead of an array\n * let tasks = {\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'one');\n *         }, 200);\n *     },\n *     two: function(callback) {\n *         callback('two');\n *     },\n *     three: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 'three');\n *         }, 100);\n *     }\n * };\n *\n * async.parallel(async.reflectAll(tasks),\n * // optional callback\n * function(err, results) {\n *     // values\n *     // results.one.value = 'one'\n *     // results.two.error = 'two'\n *     // results.three.value = 'three'\n * });\n */\nfunction reflectAll(tasks) {\n    var results;\n    if (isArray(tasks)) {\n        results = arrayMap(tasks, reflect);\n    } else {\n        results = {};\n        baseForOwn(tasks, function(task, key) {\n            results[key] = reflect.call(this, task);\n        });\n    }\n    return results;\n}\n\nfunction reject$1(eachfn, arr, iteratee, callback) {\n    _filter(eachfn, arr, function(value, cb) {\n        iteratee(value, function(err, v) {\n            cb(err, !v);\n        });\n    }, callback);\n}\n\n/**\n * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.\n *\n * @name reject\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.filter]{@link module:Collections.filter}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n * @example\n *\n * async.reject(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, results) {\n *     // results now equals an array of missing files\n *     createFiles(results);\n * });\n */\nvar reject = doParallel(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name rejectLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectLimit = doParallelLimit(reject$1);\n\n/**\n * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.\n *\n * @name rejectSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.reject]{@link module:Collections.reject}\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {Function} iteratee - An async truth test to apply to each item in\n * `coll`.\n * The should complete with a boolean value as its `result`.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Invoked with (err, results).\n */\nvar rejectSeries = doLimit(rejectLimit, 1);\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant$1(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * Attempts to get a successful response from `task` no more than `times` times\n * before returning an error. If the task is successful, the `callback` will be\n * passed the result of the successful task. If all attempts fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name retry\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @see [async.retryable]{@link module:ControlFlow.retryable}\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an\n * object with `times` and `interval` or a number.\n * * `times` - The number of attempts to make before giving up.  The default\n *   is `5`.\n * * `interval` - The time to wait between retries, in milliseconds.  The\n *   default is `0`. The interval may also be specified as a function of the\n *   retry count (see example).\n * * `errorFilter` - An optional synchronous function that is invoked on\n *   erroneous result. If it returns `true` the retry attempts will continue;\n *   if the function returns `false` the retry flow is aborted with the current\n *   attempt's error and result being returned to the final callback.\n *   Invoked with (err).\n * * If `opts` is a number, the number specifies the number of times to retry,\n *   with the default interval of `0`.\n * @param {AsyncFunction} task - An async function to retry.\n * Invoked with (callback).\n * @param {Function} [callback] - An optional callback which is called when the\n * task has succeeded, or after the final failed attempt. It receives the `err`\n * and `result` arguments of the last attempt at completing the `task`. Invoked\n * with (err, results).\n *\n * @example\n *\n * // The `retry` function can be used as a stand-alone control flow by passing\n * // a callback, as shown below:\n *\n * // try calling apiMethod 3 times\n * async.retry(3, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 3 times, waiting 200 ms between each retry\n * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod 10 times with exponential backoff\n * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)\n * async.retry({\n *   times: 10,\n *   interval: function(retryCount) {\n *     return 50 * Math.pow(2, retryCount);\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod the default 5 times no delay between each retry\n * async.retry(apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // try calling apiMethod only when error condition satisfies, all other\n * // errors will abort the retry control flow and return to final callback\n * async.retry({\n *   errorFilter: function(err) {\n *     return err.message === 'Temporary error'; // only retry on a specific error\n *   }\n * }, apiMethod, function(err, result) {\n *     // do something with the result\n * });\n *\n * // to retry individual methods that are not as reliable within other\n * // control flow functions, use the `retryable` wrapper:\n * async.auto({\n *     users: api.getUsers.bind(api),\n *     payments: async.retryable(3, api.getPayments.bind(api))\n * }, function(err, results) {\n *     // do something with the results\n * });\n *\n */\nfunction retry(opts, task, callback) {\n    var DEFAULT_TIMES = 5;\n    var DEFAULT_INTERVAL = 0;\n\n    var options = {\n        times: DEFAULT_TIMES,\n        intervalFunc: constant$1(DEFAULT_INTERVAL)\n    };\n\n    function parseTimes(acc, t) {\n        if (typeof t === 'object') {\n            acc.times = +t.times || DEFAULT_TIMES;\n\n            acc.intervalFunc = typeof t.interval === 'function' ?\n                t.interval :\n                constant$1(+t.interval || DEFAULT_INTERVAL);\n\n            acc.errorFilter = t.errorFilter;\n        } else if (typeof t === 'number' || typeof t === 'string') {\n            acc.times = +t || DEFAULT_TIMES;\n        } else {\n            throw new Error(\"Invalid arguments for async.retry\");\n        }\n    }\n\n    if (arguments.length < 3 && typeof opts === 'function') {\n        callback = task || noop;\n        task = opts;\n    } else {\n        parseTimes(options, opts);\n        callback = callback || noop;\n    }\n\n    if (typeof task !== 'function') {\n        throw new Error(\"Invalid arguments for async.retry\");\n    }\n\n    var _task = wrapAsync(task);\n\n    var attempt = 1;\n    function retryAttempt() {\n        _task(function(err) {\n            if (err && attempt++ < options.times &&\n                (typeof options.errorFilter != 'function' ||\n                    options.errorFilter(err))) {\n                setTimeout(retryAttempt, options.intervalFunc(attempt));\n            } else {\n                callback.apply(null, arguments);\n            }\n        });\n    }\n\n    retryAttempt();\n}\n\n/**\n * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method\n * wraps a task and makes it retryable, rather than immediately calling it\n * with retries.\n *\n * @name retryable\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.retry]{@link module:ControlFlow.retry}\n * @category Control Flow\n * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional\n * options, exactly the same as from `retry`\n * @param {AsyncFunction} task - the asynchronous function to wrap.\n * This function will be passed any arguments passed to the returned wrapper.\n * Invoked with (...args, callback).\n * @returns {AsyncFunction} The wrapped function, which when invoked, will\n * retry on an error, based on the parameters specified in `opts`.\n * This function will accept the same parameters as `task`.\n * @example\n *\n * async.auto({\n *     dep1: async.retryable(3, getFromFlakyService),\n *     process: [\"dep1\", async.retryable(3, function (results, cb) {\n *         maybeProcessData(results.dep1, cb);\n *     })]\n * }, callback);\n */\nvar retryable = function (opts, task) {\n    if (!task) {\n        task = opts;\n        opts = null;\n    }\n    var _task = wrapAsync(task);\n    return initialParams(function (args, callback) {\n        function taskFn(cb) {\n            _task.apply(null, args.concat(cb));\n        }\n\n        if (opts) retry(opts, taskFn, callback);\n        else retry(taskFn, callback);\n\n    });\n};\n\n/**\n * Run the functions in the `tasks` collection in series, each one running once\n * the previous function has completed. If any functions in the series pass an\n * error to its callback, no more functions are run, and `callback` is\n * immediately called with the value of the error. Otherwise, `callback`\n * receives an array of results when `tasks` have completed.\n *\n * It is also possible to use an object instead of an array. Each property will\n * be run as a function, and the results will be passed to the final `callback`\n * as an object instead of an array. This can be a more readable way of handling\n *  results from {@link async.series}.\n *\n * **Note** that while many implementations preserve the order of object\n * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)\n * explicitly states that\n *\n * > The mechanics and order of enumerating the properties is not specified.\n *\n * So if you rely on the order in which your series of functions are executed,\n * and want this to work on all platforms, consider using an array.\n *\n * @name series\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing\n * [async functions]{@link AsyncFunction} to run in series.\n * Each function can complete with any number of optional `result` values.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This function gets a results array (or object)\n * containing all the result arguments passed to the `task` callbacks. Invoked\n * with (err, result).\n * @example\n * async.series([\n *     function(callback) {\n *         // do some stuff ...\n *         callback(null, 'one');\n *     },\n *     function(callback) {\n *         // do some more stuff ...\n *         callback(null, 'two');\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     // results is now equal to ['one', 'two']\n * });\n *\n * async.series({\n *     one: function(callback) {\n *         setTimeout(function() {\n *             callback(null, 1);\n *         }, 200);\n *     },\n *     two: function(callback){\n *         setTimeout(function() {\n *             callback(null, 2);\n *         }, 100);\n *     }\n * }, function(err, results) {\n *     // results is now equal to: {one: 1, two: 2}\n * });\n */\nfunction series(tasks, callback) {\n    _parallel(eachOfSeries, tasks, callback);\n}\n\n/**\n * Returns `true` if at least one element in the `coll` satisfies an async test.\n * If any iteratee call returns `true`, the main `callback` is immediately\n * called.\n *\n * @name some\n * @static\n * @memberOf module:Collections\n * @method\n * @alias any\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n * @example\n *\n * async.some(['file1','file2','file3'], function(filePath, callback) {\n *     fs.access(filePath, function(err) {\n *         callback(null, !err)\n *     });\n * }, function(err, result) {\n *     // if result is true then at least one of the files exists\n * });\n */\nvar some = doParallel(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.\n *\n * @name someLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anyLimit\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in parallel.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someLimit = doParallelLimit(_createTester(Boolean, identity));\n\n/**\n * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.\n *\n * @name someSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.some]{@link module:Collections.some}\n * @alias anySeries\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async truth test to apply to each item\n * in the collections in series.\n * The iteratee should complete with a boolean `result` value.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the iteratee functions have finished.\n * Result will be either `true` or `false` depending on the values of the async\n * tests. Invoked with (err, result).\n */\nvar someSeries = doLimit(someLimit, 1);\n\n/**\n * Sorts a list by the results of running each `coll` value through an async\n * `iteratee`.\n *\n * @name sortBy\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - An async function to apply to each item in\n * `coll`.\n * The iteratee should complete with a value to use as the sort criteria as\n * its `result`.\n * Invoked with (item, callback).\n * @param {Function} callback - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is the items\n * from the original `coll` sorted by the values returned by the `iteratee`\n * calls. Invoked with (err, results).\n * @example\n *\n * async.sortBy(['file1','file2','file3'], function(file, callback) {\n *     fs.stat(file, function(err, stats) {\n *         callback(err, stats.mtime);\n *     });\n * }, function(err, results) {\n *     // results is now the original array of files sorted by\n *     // modified date\n * });\n *\n * // By modifying the callback parameter the\n * // sorting order can be influenced:\n *\n * // ascending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x);\n * }, function(err,result) {\n *     // result callback\n * });\n *\n * // descending order\n * async.sortBy([1,9,3,5], function(x, callback) {\n *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around\n * }, function(err,result) {\n *     // result callback\n * });\n */\nfunction sortBy (coll, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    map(coll, function (x, callback) {\n        _iteratee(x, function (err, criteria) {\n            if (err) return callback(err);\n            callback(null, {value: x, criteria: criteria});\n        });\n    }, function (err, results) {\n        if (err) return callback(err);\n        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));\n    });\n\n    function comparator(left, right) {\n        var a = left.criteria, b = right.criteria;\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n}\n\n/**\n * Sets a time limit on an asynchronous function. If the function does not call\n * its callback within the specified milliseconds, it will be called with a\n * timeout error. The code property for the error object will be `'ETIMEDOUT'`.\n *\n * @name timeout\n * @static\n * @memberOf module:Utils\n * @method\n * @category Util\n * @param {AsyncFunction} asyncFn - The async function to limit in time.\n * @param {number} milliseconds - The specified time limit.\n * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)\n * to timeout Error for more information..\n * @returns {AsyncFunction} Returns a wrapped function that can be used with any\n * of the control flow functions.\n * Invoke this function with the same parameters as you would `asyncFunc`.\n * @example\n *\n * function myFunction(foo, callback) {\n *     doAsyncTask(foo, function(err, data) {\n *         // handle errors\n *         if (err) return callback(err);\n *\n *         // do some stuff ...\n *\n *         // return processed data\n *         return callback(null, data);\n *     });\n * }\n *\n * var wrapped = async.timeout(myFunction, 1000);\n *\n * // call `wrapped` as you would `myFunction`\n * wrapped({ bar: 'bar' }, function(err, data) {\n *     // if `myFunction` takes < 1000 ms to execute, `err`\n *     // and `data` will have their expected values\n *\n *     // else `err` will be an Error with the code 'ETIMEDOUT'\n * });\n */\nfunction timeout(asyncFn, milliseconds, info) {\n    var fn = wrapAsync(asyncFn);\n\n    return initialParams(function (args, callback) {\n        var timedOut = false;\n        var timer;\n\n        function timeoutCallback() {\n            var name = asyncFn.name || 'anonymous';\n            var error  = new Error('Callback function \"' + name + '\" timed out.');\n            error.code = 'ETIMEDOUT';\n            if (info) {\n                error.info = info;\n            }\n            timedOut = true;\n            callback(error);\n        }\n\n        args.push(function () {\n            if (!timedOut) {\n                callback.apply(null, arguments);\n                clearTimeout(timer);\n            }\n        });\n\n        // setup timer and call original function\n        timer = setTimeout(timeoutCallback, milliseconds);\n        fn.apply(null, args);\n    });\n}\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil;\nvar nativeMax = Math.max;\n\n/**\n * The base implementation of `_.range` and `_.rangeRight` which doesn't\n * coerce arguments.\n *\n * @private\n * @param {number} start The start of the range.\n * @param {number} end The end of the range.\n * @param {number} step The value to increment or decrement by.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Array} Returns the range of numbers.\n */\nfunction baseRange(start, end, step, fromRight) {\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (length--) {\n    result[fromRight ? length : ++index] = start;\n    start += step;\n  }\n  return result;\n}\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a\n * time.\n *\n * @name timesLimit\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} count - The number of times to run the function.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see [async.map]{@link module:Collections.map}.\n */\nfunction timeLimit(count, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);\n}\n\n/**\n * Calls the `iteratee` function `n` times, and accumulates results in the same\n * manner you would use with [map]{@link module:Collections.map}.\n *\n * @name times\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.map]{@link module:Collections.map}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n * @example\n *\n * // Pretend this is some complicated async factory\n * var createUser = function(id, callback) {\n *     callback(null, {\n *         id: 'user' + id\n *     });\n * };\n *\n * // generate 5 users\n * async.times(5, function(n, next) {\n *     createUser(n, function(err, user) {\n *         next(err, user);\n *     });\n * }, function(err, users) {\n *     // we should now have 5 users\n * });\n */\nvar times = doLimit(timeLimit, Infinity);\n\n/**\n * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.\n *\n * @name timesSeries\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.times]{@link module:ControlFlow.times}\n * @category Control Flow\n * @param {number} n - The number of times to run the function.\n * @param {AsyncFunction} iteratee - The async function to call `n` times.\n * Invoked with the iteration index and a callback: (n, next).\n * @param {Function} callback - see {@link module:Collections.map}.\n */\nvar timesSeries = doLimit(timeLimit, 1);\n\n/**\n * A relative of `reduce`.  Takes an Object or Array, and iterates over each\n * element in series, each step potentially mutating an `accumulator` value.\n * The type of the accumulator defaults to the type of collection passed in.\n *\n * @name transform\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @param {Array|Iterable|Object} coll - A collection to iterate over.\n * @param {*} [accumulator] - The initial state of the transform.  If omitted,\n * it will default to an empty Object or Array, depending on the type of `coll`\n * @param {AsyncFunction} iteratee - A function applied to each item in the\n * collection that potentially modifies the accumulator.\n * Invoked with (accumulator, item, key, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished. Result is the transformed accumulator.\n * Invoked with (err, result).\n * @example\n *\n * async.transform([1,2,3], function(acc, item, index, callback) {\n *     // pointless async:\n *     process.nextTick(function() {\n *         acc.push(item * 2)\n *         callback(null)\n *     });\n * }, function(err, result) {\n *     // result is now equal to [2, 4, 6]\n * });\n *\n * @example\n *\n * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {\n *     setImmediate(function () {\n *         obj[key] = val * 2;\n *         callback();\n *     })\n * }, function (err, result) {\n *     // result is equal to {a: 2, b: 4, c: 6}\n * })\n */\nfunction transform (coll, accumulator, iteratee, callback) {\n    if (arguments.length <= 3) {\n        callback = iteratee;\n        iteratee = accumulator;\n        accumulator = isArray(coll) ? [] : {};\n    }\n    callback = once(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n\n    eachOf(coll, function(v, k, cb) {\n        _iteratee(accumulator, v, k, cb);\n    }, function(err) {\n        callback(err, accumulator);\n    });\n}\n\n/**\n * It runs each task in series but stops whenever any of the functions were\n * successful. If one of the tasks were successful, the `callback` will be\n * passed the result of the successful task. If all tasks fail, the callback\n * will be passed the error and result (if any) of the final attempt.\n *\n * @name tryEach\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array|Iterable|Object} tasks - A collection containing functions to\n * run, each function is passed a `callback(err, result)` it must call on\n * completion with an error `err` (which can be `null`) and an optional `result`\n * value.\n * @param {Function} [callback] - An optional callback which is called when one\n * of the tasks has succeeded, or all have failed. It receives the `err` and\n * `result` arguments of the last attempt at completing the `task`. Invoked with\n * (err, results).\n * @example\n * async.tryEach([\n *     function getDataFromFirstWebsite(callback) {\n *         // Try getting the data from the first website\n *         callback(err, data);\n *     },\n *     function getDataFromSecondWebsite(callback) {\n *         // First website failed,\n *         // Try getting the data from the backup website\n *         callback(err, data);\n *     }\n * ],\n * // optional callback\n * function(err, results) {\n *     Now do something with the data.\n * });\n *\n */\nfunction tryEach(tasks, callback) {\n    var error = null;\n    var result;\n    callback = callback || noop;\n    eachSeries(tasks, function(task, callback) {\n        wrapAsync(task)(function (err, res/*, ...args*/) {\n            if (arguments.length > 2) {\n                result = slice(arguments, 1);\n            } else {\n                result = res;\n            }\n            error = err;\n            callback(!err);\n        });\n    }, function () {\n        callback(error, result);\n    });\n}\n\n/**\n * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,\n * unmemoized form. Handy for testing.\n *\n * @name unmemoize\n * @static\n * @memberOf module:Utils\n * @method\n * @see [async.memoize]{@link module:Utils.memoize}\n * @category Util\n * @param {AsyncFunction} fn - the memoized function\n * @returns {AsyncFunction} a function that calls the original unmemoized function\n */\nfunction unmemoize(fn) {\n    return function () {\n        return (fn.unmemoized || fn).apply(null, arguments);\n    };\n}\n\n/**\n * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs.\n *\n * @name whilst\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` passes. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has failed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n * @returns undefined\n * @example\n *\n * var count = 0;\n * async.whilst(\n *     function() { return count < 5; },\n *     function(callback) {\n *         count++;\n *         setTimeout(function() {\n *             callback(null, count);\n *         }, 1000);\n *     },\n *     function (err, n) {\n *         // 5 seconds have passed, n = 5\n *     }\n * );\n */\nfunction whilst(test, iteratee, callback) {\n    callback = onlyOnce(callback || noop);\n    var _iteratee = wrapAsync(iteratee);\n    if (!test()) return callback(null);\n    var next = function(err/*, ...args*/) {\n        if (err) return callback(err);\n        if (test()) return _iteratee(next);\n        var args = slice(arguments, 1);\n        callback.apply(null, [null].concat(args));\n    };\n    _iteratee(next);\n}\n\n/**\n * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when\n * stopped, or an error occurs. `callback` will be passed an error and any\n * arguments passed to the final `iteratee`'s callback.\n *\n * The inverse of [whilst]{@link module:ControlFlow.whilst}.\n *\n * @name until\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.whilst]{@link module:ControlFlow.whilst}\n * @category Control Flow\n * @param {Function} test - synchronous truth test to perform before each\n * execution of `iteratee`. Invoked with ().\n * @param {AsyncFunction} iteratee - An async function which is called each time\n * `test` fails. Invoked with (callback).\n * @param {Function} [callback] - A callback which is called after the test\n * function has passed and repeated execution of `iteratee` has stopped. `callback`\n * will be passed an error and any arguments passed to the final `iteratee`'s\n * callback. Invoked with (err, [results]);\n */\nfunction until(test, iteratee, callback) {\n    whilst(function() {\n        return !test.apply(this, arguments);\n    }, iteratee, callback);\n}\n\n/**\n * Runs the `tasks` array of functions in series, each passing their results to\n * the next in the array. However, if any of the `tasks` pass an error to their\n * own callback, the next function is not executed, and the main `callback` is\n * immediately called with the error.\n *\n * @name waterfall\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}\n * to run.\n * Each function should complete with any number of `result` values.\n * The `result` values will be passed as arguments, in order, to the next task.\n * @param {Function} [callback] - An optional callback to run once all the\n * functions have completed. This will be passed the results of the last task's\n * callback. Invoked with (err, [results]).\n * @returns undefined\n * @example\n *\n * async.waterfall([\n *     function(callback) {\n *         callback(null, 'one', 'two');\n *     },\n *     function(arg1, arg2, callback) {\n *         // arg1 now equals 'one' and arg2 now equals 'two'\n *         callback(null, 'three');\n *     },\n *     function(arg1, callback) {\n *         // arg1 now equals 'three'\n *         callback(null, 'done');\n *     }\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n *\n * // Or, with named functions:\n * async.waterfall([\n *     myFirstFunction,\n *     mySecondFunction,\n *     myLastFunction,\n * ], function (err, result) {\n *     // result now equals 'done'\n * });\n * function myFirstFunction(callback) {\n *     callback(null, 'one', 'two');\n * }\n * function mySecondFunction(arg1, arg2, callback) {\n *     // arg1 now equals 'one' and arg2 now equals 'two'\n *     callback(null, 'three');\n * }\n * function myLastFunction(arg1, callback) {\n *     // arg1 now equals 'three'\n *     callback(null, 'done');\n * }\n */\nvar waterfall = function(tasks, callback) {\n    callback = once(callback || noop);\n    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));\n    if (!tasks.length) return callback();\n    var taskIndex = 0;\n\n    function nextTask(args) {\n        var task = wrapAsync(tasks[taskIndex++]);\n        args.push(onlyOnce(next));\n        task.apply(null, args);\n    }\n\n    function next(err/*, ...args*/) {\n        if (err || taskIndex === tasks.length) {\n            return callback.apply(null, arguments);\n        }\n        nextTask(slice(arguments, 1));\n    }\n\n    nextTask([]);\n};\n\n/**\n * An \"async function\" in the context of Async is an asynchronous function with\n * a variable number of parameters, with the final parameter being a callback.\n * (`function (arg1, arg2, ..., callback) {}`)\n * The final callback is of the form `callback(err, results...)`, which must be\n * called once the function is completed.  The callback should be called with a\n * Error as its first argument to signal that an error occurred.\n * Otherwise, if no error occurred, it should be called with `null` as the first\n * argument, and any additional `result` arguments that may apply, to signal\n * successful completion.\n * The callback must be called exactly once, ideally on a later tick of the\n * JavaScript event loop.\n *\n * This type of function is also referred to as a \"Node-style async function\",\n * or a \"continuation passing-style function\" (CPS). Most of the methods of this\n * library are themselves CPS/Node-style async functions, or functions that\n * return CPS/Node-style async functions.\n *\n * Wherever we accept a Node-style async function, we also directly accept an\n * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.\n * In this case, the `async` function will not be passed a final callback\n * argument, and any thrown error will be used as the `err` argument of the\n * implicit callback, and the return value will be used as the `result` value.\n * (i.e. a `rejected` of the returned Promise becomes the `err` callback\n * argument, and a `resolved` value becomes the `result`.)\n *\n * Note, due to JavaScript limitations, we can only detect native `async`\n * functions and not transpilied implementations.\n * Your environment must have `async`/`await` support for this to work.\n * (e.g. Node > v7.6, or a recent version of a modern browser).\n * If you are using `async` functions through a transpiler (e.g. Babel), you\n * must still wrap the function with [asyncify]{@link module:Utils.asyncify},\n * because the `async function` will be compiled to an ordinary function that\n * returns a promise.\n *\n * @typedef {Function} AsyncFunction\n * @static\n */\n\n/**\n * Async is a utility module which provides straight-forward, powerful functions\n * for working with asynchronous JavaScript. Although originally designed for\n * use with [Node.js](http://nodejs.org) and installable via\n * `npm install --save async`, it can also be used directly in the browser.\n * @module async\n * @see AsyncFunction\n */\n\n\n/**\n * A collection of `async` functions for manipulating collections, such as\n * arrays and objects.\n * @module Collections\n */\n\n/**\n * A collection of `async` functions for controlling the flow through a script.\n * @module ControlFlow\n */\n\n/**\n * A collection of `async` utility functions.\n * @module Utils\n */\n\nvar index = {\n    apply: apply,\n    applyEach: applyEach,\n    applyEachSeries: applyEachSeries,\n    asyncify: asyncify,\n    auto: auto,\n    autoInject: autoInject,\n    cargo: cargo,\n    compose: compose,\n    concat: concat,\n    concatLimit: concatLimit,\n    concatSeries: concatSeries,\n    constant: constant,\n    detect: detect,\n    detectLimit: detectLimit,\n    detectSeries: detectSeries,\n    dir: dir,\n    doDuring: doDuring,\n    doUntil: doUntil,\n    doWhilst: doWhilst,\n    during: during,\n    each: eachLimit,\n    eachLimit: eachLimit$1,\n    eachOf: eachOf,\n    eachOfLimit: eachOfLimit,\n    eachOfSeries: eachOfSeries,\n    eachSeries: eachSeries,\n    ensureAsync: ensureAsync,\n    every: every,\n    everyLimit: everyLimit,\n    everySeries: everySeries,\n    filter: filter,\n    filterLimit: filterLimit,\n    filterSeries: filterSeries,\n    forever: forever,\n    groupBy: groupBy,\n    groupByLimit: groupByLimit,\n    groupBySeries: groupBySeries,\n    log: log,\n    map: map,\n    mapLimit: mapLimit,\n    mapSeries: mapSeries,\n    mapValues: mapValues,\n    mapValuesLimit: mapValuesLimit,\n    mapValuesSeries: mapValuesSeries,\n    memoize: memoize,\n    nextTick: nextTick,\n    parallel: parallelLimit,\n    parallelLimit: parallelLimit$1,\n    priorityQueue: priorityQueue,\n    queue: queue$1,\n    race: race,\n    reduce: reduce,\n    reduceRight: reduceRight,\n    reflect: reflect,\n    reflectAll: reflectAll,\n    reject: reject,\n    rejectLimit: rejectLimit,\n    rejectSeries: rejectSeries,\n    retry: retry,\n    retryable: retryable,\n    seq: seq,\n    series: series,\n    setImmediate: setImmediate$1,\n    some: some,\n    someLimit: someLimit,\n    someSeries: someSeries,\n    sortBy: sortBy,\n    timeout: timeout,\n    times: times,\n    timesLimit: timeLimit,\n    timesSeries: timesSeries,\n    transform: transform,\n    tryEach: tryEach,\n    unmemoize: unmemoize,\n    until: until,\n    waterfall: waterfall,\n    whilst: whilst,\n\n    // aliases\n    all: every,\n    allLimit: everyLimit,\n    allSeries: everySeries,\n    any: some,\n    anyLimit: someLimit,\n    anySeries: someSeries,\n    find: detect,\n    findLimit: detectLimit,\n    findSeries: detectSeries,\n    forEach: eachLimit,\n    forEachSeries: eachSeries,\n    forEachLimit: eachLimit$1,\n    forEachOf: eachOf,\n    forEachOfSeries: eachOfSeries,\n    forEachOfLimit: eachOfLimit,\n    inject: reduce,\n    foldl: reduce,\n    foldr: reduceRight,\n    select: filter,\n    selectLimit: filterLimit,\n    selectSeries: filterSeries,\n    wrapSync: asyncify\n};\n\nexports['default'] = index;\nexports.apply = apply;\nexports.applyEach = applyEach;\nexports.applyEachSeries = applyEachSeries;\nexports.asyncify = asyncify;\nexports.auto = auto;\nexports.autoInject = autoInject;\nexports.cargo = cargo;\nexports.compose = compose;\nexports.concat = concat;\nexports.concatLimit = concatLimit;\nexports.concatSeries = concatSeries;\nexports.constant = constant;\nexports.detect = detect;\nexports.detectLimit = detectLimit;\nexports.detectSeries = detectSeries;\nexports.dir = dir;\nexports.doDuring = doDuring;\nexports.doUntil = doUntil;\nexports.doWhilst = doWhilst;\nexports.during = during;\nexports.each = eachLimit;\nexports.eachLimit = eachLimit$1;\nexports.eachOf = eachOf;\nexports.eachOfLimit = eachOfLimit;\nexports.eachOfSeries = eachOfSeries;\nexports.eachSeries = eachSeries;\nexports.ensureAsync = ensureAsync;\nexports.every = every;\nexports.everyLimit = everyLimit;\nexports.everySeries = everySeries;\nexports.filter = filter;\nexports.filterLimit = filterLimit;\nexports.filterSeries = filterSeries;\nexports.forever = forever;\nexports.groupBy = groupBy;\nexports.groupByLimit = groupByLimit;\nexports.groupBySeries = groupBySeries;\nexports.log = log;\nexports.map = map;\nexports.mapLimit = mapLimit;\nexports.mapSeries = mapSeries;\nexports.mapValues = mapValues;\nexports.mapValuesLimit = mapValuesLimit;\nexports.mapValuesSeries = mapValuesSeries;\nexports.memoize = memoize;\nexports.nextTick = nextTick;\nexports.parallel = parallelLimit;\nexports.parallelLimit = parallelLimit$1;\nexports.priorityQueue = priorityQueue;\nexports.queue = queue$1;\nexports.race = race;\nexports.reduce = reduce;\nexports.reduceRight = reduceRight;\nexports.reflect = reflect;\nexports.reflectAll = reflectAll;\nexports.reject = reject;\nexports.rejectLimit = rejectLimit;\nexports.rejectSeries = rejectSeries;\nexports.retry = retry;\nexports.retryable = retryable;\nexports.seq = seq;\nexports.series = series;\nexports.setImmediate = setImmediate$1;\nexports.some = some;\nexports.someLimit = someLimit;\nexports.someSeries = someSeries;\nexports.sortBy = sortBy;\nexports.timeout = timeout;\nexports.times = times;\nexports.timesLimit = timeLimit;\nexports.timesSeries = timesSeries;\nexports.transform = transform;\nexports.tryEach = tryEach;\nexports.unmemoize = unmemoize;\nexports.until = until;\nexports.waterfall = waterfall;\nexports.whilst = whilst;\nexports.all = every;\nexports.allLimit = everyLimit;\nexports.allSeries = everySeries;\nexports.any = some;\nexports.anyLimit = someLimit;\nexports.anySeries = someSeries;\nexports.find = detect;\nexports.findLimit = detectLimit;\nexports.findSeries = detectSeries;\nexports.forEach = eachLimit;\nexports.forEachSeries = eachSeries;\nexports.forEachLimit = eachLimit$1;\nexports.forEachOf = eachOf;\nexports.forEachOfSeries = eachOfSeries;\nexports.forEachOfLimit = eachOfLimit;\nexports.inject = reduce;\nexports.foldl = reduce;\nexports.foldr = reduceRight;\nexports.select = filter;\nexports.selectLimit = filterLimit;\nexports.selectSeries = filterSeries;\nexports.wrapSync = asyncify;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ \"../node_modules/process/browser.js\"), __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../webpack/buildin/module.js */ \"../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://STK/../node_modules/async/dist/async.js?");

/***/ }),

/***/ "../node_modules/base64-js/index.js":
/*!******************************************!*\
  !*** ../node_modules/base64-js/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://STK/../node_modules/base64-js/index.js?");

/***/ }),

/***/ "../node_modules/charenc/charenc.js":
/*!******************************************!*\
  !*** ../node_modules/charenc/charenc.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n\n\n//# sourceURL=webpack://STK/../node_modules/charenc/charenc.js?");

/***/ }),

/***/ "../node_modules/crypt/crypt.js":
/*!**************************************!*\
  !*** ../node_modules/crypt/crypt.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n\n\n//# sourceURL=webpack://STK/../node_modules/crypt/crypt.js?");

/***/ }),

/***/ "../node_modules/d3-queue/build/d3-queue.js":
/*!**************************************************!*\
  !*** ../node_modules/d3-queue/build/d3-queue.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function (global, factory) {\n   true ? factory(exports) :\n  undefined;\n}(this, function (exports) { 'use strict';\n\n  var version = \"2.0.3\";\n\n  var slice = [].slice;\n\n  var noabort = {};\n\n  function Queue(size) {\n    if (!(size >= 1)) throw new Error;\n    this._size = size;\n    this._call =\n    this._error = null;\n    this._tasks = [];\n    this._data = [];\n    this._waiting =\n    this._active =\n    this._ended =\n    this._start = 0; // inside a synchronous task callback?\n  }\n\n  Queue.prototype = queue.prototype = {\n    constructor: Queue,\n    defer: function(callback) {\n      if (typeof callback !== \"function\" || this._call) throw new Error;\n      if (this._error != null) return this;\n      var t = slice.call(arguments, 1);\n      t.push(callback);\n      ++this._waiting, this._tasks.push(t);\n      poke(this);\n      return this;\n    },\n    abort: function() {\n      if (this._error == null) abort(this, new Error(\"abort\"));\n      return this;\n    },\n    await: function(callback) {\n      if (typeof callback !== \"function\" || this._call) throw new Error;\n      this._call = function(error, results) { callback.apply(null, [error].concat(results)); };\n      maybeNotify(this);\n      return this;\n    },\n    awaitAll: function(callback) {\n      if (typeof callback !== \"function\" || this._call) throw new Error;\n      this._call = callback;\n      maybeNotify(this);\n      return this;\n    }\n  };\n\n  function poke(q) {\n    if (!q._start) try { start(q); } // let the current task complete\n    catch (e) { if (q._tasks[q._ended + q._active - 1]) abort(q, e); } // task errored synchronously\n  }\n\n  function start(q) {\n    while (q._start = q._waiting && q._active < q._size) {\n      var i = q._ended + q._active,\n          t = q._tasks[i],\n          j = t.length - 1,\n          c = t[j];\n      t[j] = end(q, i);\n      --q._waiting, ++q._active;\n      t = c.apply(null, t);\n      if (!q._tasks[i]) continue; // task finished synchronously\n      q._tasks[i] = t || noabort;\n    }\n  }\n\n  function end(q, i) {\n    return function(e, r) {\n      if (!q._tasks[i]) return; // ignore multiple callbacks\n      --q._active, ++q._ended;\n      q._tasks[i] = null;\n      if (q._error != null) return; // ignore secondary errors\n      if (e != null) {\n        abort(q, e);\n      } else {\n        q._data[i] = r;\n        if (q._waiting) poke(q);\n        else maybeNotify(q);\n      }\n    };\n  }\n\n  function abort(q, e) {\n    var i = q._tasks.length, t;\n    q._error = e; // ignore active callbacks\n    q._data = undefined; // allow gc\n    q._waiting = NaN; // prevent starting\n\n    while (--i >= 0) {\n      if (t = q._tasks[i]) {\n        q._tasks[i] = null;\n        if (t.abort) try { t.abort(); }\n        catch (e) { /* ignore */ }\n      }\n    }\n\n    q._active = NaN; // allow notification\n    maybeNotify(q);\n  }\n\n  function maybeNotify(q) {\n    if (!q._active && q._call) q._call(q._error, q._data);\n  }\n\n  function queue(concurrency) {\n    return new Queue(arguments.length ? +concurrency : Infinity);\n  }\n\n  exports.version = version;\n  exports.queue = queue;\n\n}));\n\n//# sourceURL=webpack://STK/../node_modules/d3-queue/build/d3-queue.js?");

/***/ }),

/***/ "../node_modules/file-saver/FileSaver.js":
/*!***********************************************!*\
  !*** ../node_modules/file-saver/FileSaver.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 1.3.2\n * 2016-06-16 18:25:19\n *\n * By Eli Grey, http://eligrey.com\n * License: MIT\n *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs || (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n// `self` is undefined in Firefox for Android content script context\n// while `this` is nsIContentFrameMessageManager\n// with an attribute `content` that corresponds to the window\n\nif ( true && module.exports) {\n  module.exports.saveAs = saveAs;\n} else if (( true && __webpack_require__(/*! !webpack amd define */ \"../node_modules/webpack/buildin/amd-define.js\") !== null) && (__webpack_require__(/*! !webpack amd options */ \"../node_modules/webpack/buildin/amd-options.js\") !== null)) {\n  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return saveAs;\n  }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n//# sourceURL=webpack://STK/../node_modules/file-saver/FileSaver.js?");

/***/ }),

/***/ "../node_modules/ieee754/index.js":
/*!****************************************!*\
  !*** ../node_modules/ieee754/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://STK/../node_modules/ieee754/index.js?");

/***/ }),

/***/ "../node_modules/is-buffer/index.js":
/*!******************************************!*\
  !*** ../node_modules/is-buffer/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack://STK/../node_modules/is-buffer/index.js?");

/***/ }),

/***/ "../node_modules/isarray/index.js":
/*!****************************************!*\
  !*** ../node_modules/isarray/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/isarray/index.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/arrayReader.js":
/*!************************************************!*\
  !*** ../node_modules/jszip/lib/arrayReader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./dataReader */ \"../node_modules/jszip/lib/dataReader.js\");\n\nfunction ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n\n        for(var i = 0; i < this.data.length; i++) {\n            data[i] = data[i] & 0xFF;\n        }\n    }\n}\nArrayReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nArrayReader.prototype.byteAt = function(i) {\n    return this.data[this.zero + i];\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nArrayReader.prototype.lastIndexOfSignature = function(sig) {\n    var sig0 = sig.charCodeAt(0),\n        sig1 = sig.charCodeAt(1),\n        sig2 = sig.charCodeAt(2),\n        sig3 = sig.charCodeAt(3);\n    for (var i = this.length - 4; i >= 0; --i) {\n        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {\n            return i - this.zero;\n        }\n    }\n\n    return -1;\n};\n/**\n * @see DataReader.readData\n */\nArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        return [];\n    }\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = ArrayReader;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/arrayReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/base64.js":
/*!*******************************************!*\
  !*** ../node_modules/jszip/lib/base64.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// private property\nvar _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n\n// public method for encoding\nexports.encode = function(input, utf8) {\n    var output = \"\";\n    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    while (i < input.length) {\n\n        chr1 = input.charCodeAt(i++);\n        chr2 = input.charCodeAt(i++);\n        chr3 = input.charCodeAt(i++);\n\n        enc1 = chr1 >> 2;\n        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);\n        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);\n        enc4 = chr3 & 63;\n\n        if (isNaN(chr2)) {\n            enc3 = enc4 = 64;\n        }\n        else if (isNaN(chr3)) {\n            enc4 = 64;\n        }\n\n        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);\n\n    }\n\n    return output;\n};\n\n// public method for decoding\nexports.decode = function(input, utf8) {\n    var output = \"\";\n    var chr1, chr2, chr3;\n    var enc1, enc2, enc3, enc4;\n    var i = 0;\n\n    input = input.replace(/[^A-Za-z0-9\\+\\/\\=]/g, \"\");\n\n    while (i < input.length) {\n\n        enc1 = _keyStr.indexOf(input.charAt(i++));\n        enc2 = _keyStr.indexOf(input.charAt(i++));\n        enc3 = _keyStr.indexOf(input.charAt(i++));\n        enc4 = _keyStr.indexOf(input.charAt(i++));\n\n        chr1 = (enc1 << 2) | (enc2 >> 4);\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);\n        chr3 = ((enc3 & 3) << 6) | enc4;\n\n        output = output + String.fromCharCode(chr1);\n\n        if (enc3 != 64) {\n            output = output + String.fromCharCode(chr2);\n        }\n        if (enc4 != 64) {\n            output = output + String.fromCharCode(chr3);\n        }\n\n    }\n\n    return output;\n\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/base64.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/compressedObject.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/compressedObject.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction CompressedObject() {\n    this.compressedSize = 0;\n    this.uncompressedSize = 0;\n    this.crc32 = 0;\n    this.compressionMethod = null;\n    this.compressedContent = null;\n}\n\nCompressedObject.prototype = {\n    /**\n     * Return the decompressed content in an unspecified format.\n     * The format will depend on the decompressor.\n     * @return {Object} the decompressed content.\n     */\n    getContent: function() {\n        return null; // see implementation\n    },\n    /**\n     * Return the compressed content in an unspecified format.\n     * The format will depend on the compressed conten source.\n     * @return {Object} the compressed content.\n     */\n    getCompressedContent: function() {\n        return null; // see implementation\n    }\n};\nmodule.exports = CompressedObject;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/compressedObject.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/compressions.js":
/*!*************************************************!*\
  !*** ../node_modules/jszip/lib/compressions.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.STORE = {\n    magic: \"\\x00\\x00\",\n    compress: function(content, compressionOptions) {\n        return content; // no compression\n    },\n    uncompress: function(content) {\n        return content; // no compression\n    },\n    compressInputType: null,\n    uncompressInputType: null\n};\nexports.DEFLATE = __webpack_require__(/*! ./flate */ \"../node_modules/jszip/lib/flate.js\");\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/compressions.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/crc32.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/crc32.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\nvar table = [\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n];\n\n/**\n *\n *  Javascript crc32\n *  http://www.webtoolkit.info/\n *\n */\nmodule.exports = function crc32(input, crc) {\n    if (typeof input === \"undefined\" || !input.length) {\n        return 0;\n    }\n\n    var isArray = utils.getTypeOf(input) !== \"string\";\n\n    if (typeof(crc) == \"undefined\") {\n        crc = 0;\n    }\n    var x = 0;\n    var y = 0;\n    var b = 0;\n\n    crc = crc ^ (-1);\n    for (var i = 0, iTop = input.length; i < iTop; i++) {\n        b = isArray ? input[i] : input.charCodeAt(i);\n        y = (crc ^ b) & 0xFF;\n        x = table[y];\n        crc = (crc >>> 8) ^ x;\n    }\n\n    return crc ^ (-1);\n};\n// vim: set shiftwidth=4 softtabstop=4:\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/crc32.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/dataReader.js":
/*!***********************************************!*\
  !*** ../node_modules/jszip/lib/dataReader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction DataReader(data) {\n    this.data = null; // type : see implementation\n    this.length = 0;\n    this.index = 0;\n    this.zero = 0;\n}\nDataReader.prototype = {\n    /**\n     * Check that the offset will not go too far.\n     * @param {string} offset the additional offset to check.\n     * @throws {Error} an Error if the offset is out of bounds.\n     */\n    checkOffset: function(offset) {\n        this.checkIndex(this.index + offset);\n    },\n    /**\n     * Check that the specifed index will not be too far.\n     * @param {string} newIndex the index to check.\n     * @throws {Error} an Error if the index is out of bounds.\n     */\n    checkIndex: function(newIndex) {\n        if (this.length < this.zero + newIndex || newIndex < 0) {\n            throw new Error(\"End of data reached (data length = \" + this.length + \", asked index = \" + (newIndex) + \"). Corrupted zip ?\");\n        }\n    },\n    /**\n     * Change the index.\n     * @param {number} newIndex The new index.\n     * @throws {Error} if the new index is out of the data.\n     */\n    setIndex: function(newIndex) {\n        this.checkIndex(newIndex);\n        this.index = newIndex;\n    },\n    /**\n     * Skip the next n bytes.\n     * @param {number} n the number of bytes to skip.\n     * @throws {Error} if the new index is out of the data.\n     */\n    skip: function(n) {\n        this.setIndex(this.index + n);\n    },\n    /**\n     * Get the byte at the specified index.\n     * @param {number} i the index to use.\n     * @return {number} a byte.\n     */\n    byteAt: function(i) {\n        // see implementations\n    },\n    /**\n     * Get the next number with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {number} the corresponding number.\n     */\n    readInt: function(size) {\n        var result = 0,\n            i;\n        this.checkOffset(size);\n        for (i = this.index + size - 1; i >= this.index; i--) {\n            result = (result << 8) + this.byteAt(i);\n        }\n        this.index += size;\n        return result;\n    },\n    /**\n     * Get the next string with a given byte size.\n     * @param {number} size the number of bytes to read.\n     * @return {string} the corresponding string.\n     */\n    readString: function(size) {\n        return utils.transformTo(\"string\", this.readData(size));\n    },\n    /**\n     * Get raw data without conversion, <size> bytes.\n     * @param {number} size the number of bytes to read.\n     * @return {Object} the raw data, implementation specific.\n     */\n    readData: function(size) {\n        // see implementations\n    },\n    /**\n     * Find the last occurence of a zip signature (4 bytes).\n     * @param {string} sig the signature to find.\n     * @return {number} the index of the last occurence, -1 if not found.\n     */\n    lastIndexOfSignature: function(sig) {\n        // see implementations\n    },\n    /**\n     * Get the next date.\n     * @return {Date} the date.\n     */\n    readDate: function() {\n        var dostime = this.readInt(4);\n        return new Date(\n        ((dostime >> 25) & 0x7f) + 1980, // year\n        ((dostime >> 21) & 0x0f) - 1, // month\n        (dostime >> 16) & 0x1f, // day\n        (dostime >> 11) & 0x1f, // hour\n        (dostime >> 5) & 0x3f, // minute\n        (dostime & 0x1f) << 1); // second\n    }\n};\nmodule.exports = DataReader;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/dataReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/defaults.js":
/*!*********************************************!*\
  !*** ../node_modules/jszip/lib/defaults.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.base64 = false;\nexports.binary = false;\nexports.dir = false;\nexports.createFolders = false;\nexports.date = null;\nexports.compression = null;\nexports.compressionOptions = null;\nexports.comment = null;\nexports.unixPermissions = null;\nexports.dosPermissions = null;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/defaults.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/deprecatedPublicUtils.js":
/*!**********************************************************!*\
  !*** ../node_modules/jszip/lib/deprecatedPublicUtils.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2binary = function(str) {\n    return utils.string2binary(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Uint8Array = function(str) {\n    return utils.transformTo(\"uint8array\", str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.uint8Array2String = function(array) {\n    return utils.transformTo(\"string\", array);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.string2Blob = function(str) {\n    var buffer = utils.transformTo(\"arraybuffer\", str);\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.arrayBuffer2Blob = function(buffer) {\n    return utils.arrayBuffer2Blob(buffer);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.transformTo = function(outputType, input) {\n    return utils.transformTo(outputType, input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.getTypeOf = function(input) {\n    return utils.getTypeOf(input);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.checkSupport = function(type) {\n    return utils.checkSupport(type);\n};\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;\n\n/**\n * @deprecated\n * This value will be removed in a future version without replacement.\n */\nexports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;\n\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.pretty = function(str) {\n    return utils.pretty(str);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.findCompression = function(compressionMethod) {\n    return utils.findCompression(compressionMethod);\n};\n\n/**\n * @deprecated\n * This function will be removed in a future version without replacement.\n */\nexports.isRegExp = function (object) {\n    return utils.isRegExp(object);\n};\n\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/deprecatedPublicUtils.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/flate.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/flate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');\n\nvar pako = __webpack_require__(/*! pako */ \"../node_modules/pako/index.js\");\nexports.uncompressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\nexports.compressInputType = USE_TYPEDARRAY ? \"uint8array\" : \"array\";\n\nexports.magic = \"\\x08\\x00\";\nexports.compress = function(input, compressionOptions) {\n    return pako.deflateRaw(input, {\n        level : compressionOptions.level || -1 // default compression\n    });\n};\nexports.uncompress =  function(input) {\n    return pako.inflateRaw(input);\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/flate.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/index.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar base64 = __webpack_require__(/*! ./base64 */ \"../node_modules/jszip/lib/base64.js\");\n\n/**\nUsage:\n   zip = new JSZip();\n   zip.file(\"hello.txt\", \"Hello, World!\").file(\"tempfile\", \"nothing\");\n   zip.folder(\"images\").file(\"smile.gif\", base64Data, {base64: true});\n   zip.file(\"Xmas.txt\", \"Ho ho ho !\", {date : new Date(\"December 25, 2007 00:00:01\")});\n   zip.remove(\"tempfile\");\n\n   base64zip = zip.generate();\n\n**/\n\n/**\n * Representation a of zip file in js\n * @constructor\n * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).\n * @param {Object=} options the options for creating this objects (optional).\n */\nfunction JSZip(data, options) {\n    // if this constructor isused without`new`, itadds `new` beforeitself:\n    if(!(this instanceof JSZip)) return new JSZip(data, options);\n\n    // object containing the files :\n    // {\n    //   \"folder/\" : {...},\n    //   \"folder/data.txt\" : {...}\n    // }\n    this.files = {};\n\n    this.comment = null;\n\n    // Where we are in the hierarchy\n    this.root = \"\";\n    if (data) {\n        this.load(data, options);\n    }\n    this.clone = function() {\n        var newObj = new JSZip();\n        for (var i in this) {\n            if (typeof this[i] !== \"function\") {\n                newObj[i] = this[i];\n            }\n        }\n        return newObj;\n    };\n}\nJSZip.prototype = __webpack_require__(/*! ./object */ \"../node_modules/jszip/lib/object.js\");\nJSZip.prototype.load = __webpack_require__(/*! ./load */ \"../node_modules/jszip/lib/load.js\");\nJSZip.support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nJSZip.defaults = __webpack_require__(/*! ./defaults */ \"../node_modules/jszip/lib/defaults.js\");\n\n/**\n * @deprecated\n * This namespace will be removed in a future version without replacement.\n */\nJSZip.utils = __webpack_require__(/*! ./deprecatedPublicUtils */ \"../node_modules/jszip/lib/deprecatedPublicUtils.js\");\n\nJSZip.base64 = {\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    encode : function(input) {\n        return base64.encode(input);\n    },\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    decode : function(input) {\n        return base64.decode(input);\n    }\n};\nJSZip.compressions = __webpack_require__(/*! ./compressions */ \"../node_modules/jszip/lib/compressions.js\");\nmodule.exports = JSZip;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/index.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/load.js":
/*!*****************************************!*\
  !*** ../node_modules/jszip/lib/load.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar base64 = __webpack_require__(/*! ./base64 */ \"../node_modules/jszip/lib/base64.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar ZipEntries = __webpack_require__(/*! ./zipEntries */ \"../node_modules/jszip/lib/zipEntries.js\");\nmodule.exports = function(data, options) {\n    var files, zipEntries, i, input;\n    options = utils.extend(options || {}, {\n        base64: false,\n        checkCRC32: false,\n        optimizedBinaryString : false,\n        createFolders: false,\n        decodeFileName: utf8.utf8decode\n    });\n    if (options.base64) {\n        data = base64.decode(data);\n    }\n\n    zipEntries = new ZipEntries(data, options);\n    files = zipEntries.files;\n    for (i = 0; i < files.length; i++) {\n        input = files[i];\n        this.file(input.fileNameStr, input.decompressed, {\n            binary: true,\n            optimizedBinaryString: true,\n            date: input.date,\n            dir: input.dir,\n            comment : input.fileCommentStr.length ? input.fileCommentStr : null,\n            unixPermissions : input.unixPermissions,\n            dosPermissions : input.dosPermissions,\n            createFolders: options.createFolders\n        });\n    }\n    if (zipEntries.zipComment.length) {\n        this.comment = zipEntries.zipComment;\n    }\n\n    return this;\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/load.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/nodeBuffer.js":
/*!***********************************************!*\
  !*** ../node_modules/jszip/lib/nodeBuffer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nmodule.exports = function(data, encoding){\n    return new Buffer(data, encoding);\n};\nmodule.exports.test = function(b){\n    return Buffer.isBuffer(b);\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"../node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/nodeBuffer.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/nodeBufferReader.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/nodeBufferReader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar Uint8ArrayReader = __webpack_require__(/*! ./uint8ArrayReader */ \"../node_modules/jszip/lib/uint8ArrayReader.js\");\n\nfunction NodeBufferReader(data) {\n    this.data = data;\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nNodeBufferReader.prototype = new Uint8ArrayReader();\n\n/**\n * @see DataReader.readData\n */\nNodeBufferReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = NodeBufferReader;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/nodeBufferReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/object.js":
/*!*******************************************!*\
  !*** ../node_modules/jszip/lib/object.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar crc32 = __webpack_require__(/*! ./crc32 */ \"../node_modules/jszip/lib/crc32.js\");\nvar signature = __webpack_require__(/*! ./signature */ \"../node_modules/jszip/lib/signature.js\");\nvar defaults = __webpack_require__(/*! ./defaults */ \"../node_modules/jszip/lib/defaults.js\");\nvar base64 = __webpack_require__(/*! ./base64 */ \"../node_modules/jszip/lib/base64.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"../node_modules/jszip/lib/compressions.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"../node_modules/jszip/lib/compressedObject.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"../node_modules/jszip/lib/nodeBuffer.js\");\nvar utf8 = __webpack_require__(/*! ./utf8 */ \"../node_modules/jszip/lib/utf8.js\");\nvar StringWriter = __webpack_require__(/*! ./stringWriter */ \"../node_modules/jszip/lib/stringWriter.js\");\nvar Uint8ArrayWriter = __webpack_require__(/*! ./uint8ArrayWriter */ \"../node_modules/jszip/lib/uint8ArrayWriter.js\");\n\n/**\n * Returns the raw data of a ZipObject, decompress the content if necessary.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getRawData = function(file) {\n    if (file._data instanceof CompressedObject) {\n        file._data = file._data.getContent();\n        file.options.binary = true;\n        file.options.base64 = false;\n\n        if (utils.getTypeOf(file._data) === \"uint8array\") {\n            var copy = file._data;\n            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.\n            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).\n            file._data = new Uint8Array(copy.length);\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            if (copy.length !== 0) {\n                file._data.set(copy, 0);\n            }\n        }\n    }\n    return file._data;\n};\n\n/**\n * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.\n * @param {ZipObject} file the file to use.\n * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.\n */\nvar getBinaryData = function(file) {\n    var result = getRawData(file),\n        type = utils.getTypeOf(result);\n    if (type === \"string\") {\n        if (!file.options.binary) {\n            // unicode text !\n            // unicode string => binary string is a painful process, check if we can avoid it.\n            if (support.nodebuffer) {\n                return nodeBuffer(result, \"utf-8\");\n            }\n        }\n        return file.asBinary();\n    }\n    return result;\n};\n\n/**\n * Transform this._data into a string.\n * @param {function} filter a function String -> String, applied if not null on the result.\n * @return {String} the string representing this._data.\n */\nvar dataToString = function(asUTF8) {\n    var result = getRawData(this);\n    if (result === null || typeof result === \"undefined\") {\n        return \"\";\n    }\n    // if the data is a base64 string, we decode it before checking the encoding !\n    if (this.options.base64) {\n        result = base64.decode(result);\n    }\n    if (asUTF8 && this.options.binary) {\n        // JSZip.prototype.utf8decode supports arrays as input\n        // skip to array => string step, utf8decode will do it.\n        result = out.utf8decode(result);\n    }\n    else {\n        // no utf8 transformation, do the array => string step.\n        result = utils.transformTo(\"string\", result);\n    }\n\n    if (!asUTF8 && !this.options.binary) {\n        result = utils.transformTo(\"string\", out.utf8encode(result));\n    }\n    return result;\n};\n/**\n * A simple object representing a file in the zip file.\n * @constructor\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data\n * @param {Object} options the options of the file\n */\nvar ZipObject = function(name, data, options) {\n    this.name = name;\n    this.dir = options.dir;\n    this.date = options.date;\n    this.comment = options.comment;\n    this.unixPermissions = options.unixPermissions;\n    this.dosPermissions = options.dosPermissions;\n\n    this._data = data;\n    this.options = options;\n\n    /*\n     * This object contains initial values for dir and date.\n     * With them, we can check if the user changed the deprecated metadata in\n     * `ZipObject#options` or not.\n     */\n    this._initialMetadata = {\n      dir : options.dir,\n      date : options.date\n    };\n};\n\nZipObject.prototype = {\n    /**\n     * Return the content as UTF8 string.\n     * @return {string} the UTF8 string.\n     */\n    asText: function() {\n        return dataToString.call(this, true);\n    },\n    /**\n     * Returns the binary content.\n     * @return {string} the content as binary.\n     */\n    asBinary: function() {\n        return dataToString.call(this, false);\n    },\n    /**\n     * Returns the content as a nodejs Buffer.\n     * @return {Buffer} the content as a Buffer.\n     */\n    asNodeBuffer: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"nodebuffer\", result);\n    },\n    /**\n     * Returns the content as an Uint8Array.\n     * @return {Uint8Array} the content as an Uint8Array.\n     */\n    asUint8Array: function() {\n        var result = getBinaryData(this);\n        return utils.transformTo(\"uint8array\", result);\n    },\n    /**\n     * Returns the content as an ArrayBuffer.\n     * @return {ArrayBuffer} the content as an ArrayBufer.\n     */\n    asArrayBuffer: function() {\n        return this.asUint8Array().buffer;\n    }\n};\n\n/**\n * Transform an integer into a string in hexadecimal.\n * @private\n * @param {number} dec the number to convert.\n * @param {number} bytes the number of bytes to generate.\n * @returns {string} the result.\n */\nvar decToHex = function(dec, bytes) {\n    var hex = \"\",\n        i;\n    for (i = 0; i < bytes; i++) {\n        hex += String.fromCharCode(dec & 0xff);\n        dec = dec >>> 8;\n    }\n    return hex;\n};\n\n/**\n * Transforms the (incomplete) options from the user into the complete\n * set of options to create a file.\n * @private\n * @param {Object} o the options from the user.\n * @return {Object} the complete set of options.\n */\nvar prepareFileAttrs = function(o) {\n    o = o || {};\n    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {\n        o.binary = true;\n    }\n    o = utils.extend(o, defaults);\n    o.date = o.date || new Date();\n    if (o.compression !== null) o.compression = o.compression.toUpperCase();\n\n    return o;\n};\n\n/**\n * Add a file in the current folder.\n * @private\n * @param {string} name the name of the file\n * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file\n * @param {Object} o the options of the file\n * @return {Object} the new file.\n */\nvar fileAdd = function(name, data, o) {\n    // be sure sub folders exist\n    var dataType = utils.getTypeOf(data),\n        parent;\n\n    o = prepareFileAttrs(o);\n\n    if (typeof o.unixPermissions === \"string\") {\n        o.unixPermissions = parseInt(o.unixPermissions, 8);\n    }\n\n    // UNX_IFDIR  0040000 see zipinfo.c\n    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {\n        o.dir = true;\n    }\n    // Bit 4    Directory\n    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {\n        o.dir = true;\n    }\n\n    if (o.dir) {\n        name = forceTrailingSlash(name);\n    }\n\n    if (o.createFolders && (parent = parentFolder(name))) {\n        folderAdd.call(this, parent, true);\n    }\n\n    if (o.dir || data === null || typeof data === \"undefined\") {\n        o.base64 = false;\n        o.binary = false;\n        data = null;\n        dataType = null;\n    }\n    else if (dataType === \"string\") {\n        if (o.binary && !o.base64) {\n            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask\n            if (o.optimizedBinaryString !== true) {\n                // this is a string, not in a base64 format.\n                // Be sure that this is a correct \"binary string\"\n                data = utils.string2binary(data);\n            }\n        }\n    }\n    else { // arraybuffer, uint8array, ...\n        o.base64 = false;\n        o.binary = true;\n\n        if (!dataType && !(data instanceof CompressedObject)) {\n            throw new Error(\"The data of '\" + name + \"' is in an unsupported format !\");\n        }\n\n        // special case : it's way easier to work with Uint8Array than with ArrayBuffer\n        if (dataType === \"arraybuffer\") {\n            data = utils.transformTo(\"uint8array\", data);\n        }\n    }\n\n    var object = new ZipObject(name, data, o);\n    this.files[name] = object;\n    return object;\n};\n\n/**\n * Find the parent folder of the path.\n * @private\n * @param {string} path the path to use\n * @return {string} the parent folder, or \"\"\n */\nvar parentFolder = function (path) {\n    if (path.slice(-1) == '/') {\n        path = path.substring(0, path.length - 1);\n    }\n    var lastSlash = path.lastIndexOf('/');\n    return (lastSlash > 0) ? path.substring(0, lastSlash) : \"\";\n};\n\n\n/**\n * Returns the path with a slash at the end.\n * @private\n * @param {String} path the path to check.\n * @return {String} the path with a trailing slash.\n */\nvar forceTrailingSlash = function(path) {\n    // Check the name ends with a /\n    if (path.slice(-1) != \"/\") {\n        path += \"/\"; // IE doesn't like substr(-1)\n    }\n    return path;\n};\n/**\n * Add a (sub) folder in the current folder.\n * @private\n * @param {string} name the folder's name\n * @param {boolean=} [createFolders] If true, automatically create sub\n *  folders. Defaults to false.\n * @return {Object} the new folder.\n */\nvar folderAdd = function(name, createFolders) {\n    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;\n\n    name = forceTrailingSlash(name);\n\n    // Does this folder already exist?\n    if (!this.files[name]) {\n        fileAdd.call(this, name, null, {\n            dir: true,\n            createFolders: createFolders\n        });\n    }\n    return this.files[name];\n};\n\n/**\n * Generate a JSZip.CompressedObject for a given zipOject.\n * @param {ZipObject} file the object to read.\n * @param {JSZip.compression} compression the compression to use.\n * @param {Object} compressionOptions the options to use when compressing.\n * @return {JSZip.CompressedObject} the compressed result.\n */\nvar generateCompressedObjectFrom = function(file, compression, compressionOptions) {\n    var result = new CompressedObject(),\n        content;\n\n    // the data has not been decompressed, we might reuse things !\n    if (file._data instanceof CompressedObject) {\n        result.uncompressedSize = file._data.uncompressedSize;\n        result.crc32 = file._data.crc32;\n\n        if (result.uncompressedSize === 0 || file.dir) {\n            compression = compressions['STORE'];\n            result.compressedContent = \"\";\n            result.crc32 = 0;\n        }\n        else if (file._data.compressionMethod === compression.magic) {\n            result.compressedContent = file._data.getCompressedContent();\n        }\n        else {\n            content = file._data.getContent();\n            // need to decompress / recompress\n            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n        }\n    }\n    else {\n        // have uncompressed data\n        content = getBinaryData(file);\n        if (!content || content.length === 0 || file.dir) {\n            compression = compressions['STORE'];\n            content = \"\";\n        }\n        result.uncompressedSize = content.length;\n        result.crc32 = crc32(content);\n        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);\n    }\n\n    result.compressedSize = result.compressedContent.length;\n    result.compressionMethod = compression.magic;\n\n    return result;\n};\n\n\n\n\n/**\n * Generate the UNIX part of the external file attributes.\n * @param {Object} unixPermissions the unix permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :\n *\n * TTTTsstrwxrwxrwx0000000000ADVSHR\n * ^^^^____________________________ file type, see zipinfo.c (UNX_*)\n *     ^^^_________________________ setuid, setgid, sticky\n *        ^^^^^^^^^________________ permissions\n *                 ^^^^^^^^^^______ not used ?\n *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only\n */\nvar generateUnixExternalFileAttr = function (unixPermissions, isDir) {\n\n    var result = unixPermissions;\n    if (!unixPermissions) {\n        // I can't use octal values in strict mode, hence the hexa.\n        //  040775 => 0x41fd\n        // 0100664 => 0x81b4\n        result = isDir ? 0x41fd : 0x81b4;\n    }\n\n    return (result & 0xFFFF) << 16;\n};\n\n/**\n * Generate the DOS part of the external file attributes.\n * @param {Object} dosPermissions the dos permissions or null.\n * @param {Boolean} isDir true if the entry is a directory, false otherwise.\n * @return {Number} a 32 bit integer.\n *\n * Bit 0     Read-Only\n * Bit 1     Hidden\n * Bit 2     System\n * Bit 3     Volume Label\n * Bit 4     Directory\n * Bit 5     Archive\n */\nvar generateDosExternalFileAttr = function (dosPermissions, isDir) {\n\n    // the dir flag is already set for compatibility\n\n    return (dosPermissions || 0)  & 0x3F;\n};\n\n/**\n * Generate the various parts used in the construction of the final zip file.\n * @param {string} name the file name.\n * @param {ZipObject} file the file content.\n * @param {JSZip.CompressedObject} compressedObject the compressed object.\n * @param {number} offset the current offset from the start of the zip file.\n * @param {String} platform let's pretend we are this platform (change platform dependents fields)\n * @param {Function} encodeFileName the function to encode the file name / comment.\n * @return {object} the zip parts.\n */\nvar generateZipParts = function(name, file, compressedObject, offset, platform, encodeFileName) {\n    var data = compressedObject.compressedContent,\n        useCustomEncoding = encodeFileName !== utf8.utf8encode,\n        encodedFileName = utils.transformTo(\"string\", encodeFileName(file.name)),\n        utfEncodedFileName = utils.transformTo(\"string\", utf8.utf8encode(file.name)),\n        comment = file.comment || \"\",\n        encodedComment = utils.transformTo(\"string\", encodeFileName(comment)),\n        utfEncodedComment = utils.transformTo(\"string\", utf8.utf8encode(comment)),\n        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,\n        useUTF8ForComment = utfEncodedComment.length !== comment.length,\n        o = file.options,\n        dosTime,\n        dosDate,\n        extraFields = \"\",\n        unicodePathExtraField = \"\",\n        unicodeCommentExtraField = \"\",\n        dir, date;\n\n\n    // handle the deprecated options.dir\n    if (file._initialMetadata.dir !== file.dir) {\n        dir = file.dir;\n    } else {\n        dir = o.dir;\n    }\n\n    // handle the deprecated options.date\n    if(file._initialMetadata.date !== file.date) {\n        date = file.date;\n    } else {\n        date = o.date;\n    }\n\n    var extFileAttr = 0;\n    var versionMadeBy = 0;\n    if (dir) {\n        // dos or unix, we set the dos dir flag\n        extFileAttr |= 0x00010;\n    }\n    if(platform === \"UNIX\") {\n        versionMadeBy = 0x031E; // UNIX, version 3.0\n        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);\n    } else { // DOS or other, fallback to DOS\n        versionMadeBy = 0x0014; // DOS, version 2.0\n        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);\n    }\n\n    // date\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html\n    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html\n\n    dosTime = date.getHours();\n    dosTime = dosTime << 6;\n    dosTime = dosTime | date.getMinutes();\n    dosTime = dosTime << 5;\n    dosTime = dosTime | date.getSeconds() / 2;\n\n    dosDate = date.getFullYear() - 1980;\n    dosDate = dosDate << 4;\n    dosDate = dosDate | (date.getMonth() + 1);\n    dosDate = dosDate << 5;\n    dosDate = dosDate | date.getDate();\n\n    if (useUTF8ForFileName) {\n        // set the unicode path extra field. unzip needs at least one extra\n        // field to correctly handle unicode path, so using the path is as good\n        // as any other information. This could improve the situation with\n        // other archive managers too.\n        // This field is usually used without the utf8 flag, with a non\n        // unicode path in the header (winrar, winzip). This helps (a bit)\n        // with the messy Windows' default compressed folders feature but\n        // breaks on p7zip which doesn't seek the unicode path extra field.\n        // So for now, UTF-8 everywhere !\n        unicodePathExtraField =\n            // Version\n            decToHex(1, 1) +\n            // NameCRC32\n            decToHex(crc32(encodedFileName), 4) +\n            // UnicodeName\n            utfEncodedFileName;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x70\" +\n            // size\n            decToHex(unicodePathExtraField.length, 2) +\n            // content\n            unicodePathExtraField;\n    }\n\n    if(useUTF8ForComment) {\n\n        unicodeCommentExtraField =\n            // Version\n            decToHex(1, 1) +\n            // CommentCRC32\n            decToHex(this.crc32(encodedComment), 4) +\n            // UnicodeName\n            utfEncodedComment;\n\n        extraFields +=\n            // Info-ZIP Unicode Path Extra Field\n            \"\\x75\\x63\" +\n            // size\n            decToHex(unicodeCommentExtraField.length, 2) +\n            // content\n            unicodeCommentExtraField;\n    }\n\n    var header = \"\";\n\n    // version needed to extract\n    header += \"\\x0A\\x00\";\n    // general purpose bit flag\n    // set bit 11 if utf8\n    header += !useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment) ? \"\\x00\\x08\" : \"\\x00\\x00\";\n    // compression method\n    header += compressedObject.compressionMethod;\n    // last mod file time\n    header += decToHex(dosTime, 2);\n    // last mod file date\n    header += decToHex(dosDate, 2);\n    // crc-32\n    header += decToHex(compressedObject.crc32, 4);\n    // compressed size\n    header += decToHex(compressedObject.compressedSize, 4);\n    // uncompressed size\n    header += decToHex(compressedObject.uncompressedSize, 4);\n    // file name length\n    header += decToHex(encodedFileName.length, 2);\n    // extra field length\n    header += decToHex(extraFields.length, 2);\n\n\n    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;\n\n    var dirRecord = signature.CENTRAL_FILE_HEADER +\n    // version made by (00: DOS)\n    decToHex(versionMadeBy, 2) +\n    // file header (common to file and central directory)\n    header +\n    // file comment length\n    decToHex(encodedComment.length, 2) +\n    // disk number start\n    \"\\x00\\x00\" +\n    // internal file attributes TODO\n    \"\\x00\\x00\" +\n    // external file attributes\n    decToHex(extFileAttr, 4) +\n    // relative offset of local header\n    decToHex(offset, 4) +\n    // file name\n    encodedFileName +\n    // extra field\n    extraFields +\n    // file comment\n    encodedComment;\n\n    return {\n        fileRecord: fileRecord,\n        dirRecord: dirRecord,\n        compressedObject: compressedObject\n    };\n};\n\n\n// return the actual prototype of JSZip\nvar out = {\n    /**\n     * Read an existing zip and merge the data in the current JSZip object.\n     * The implementation is in jszip-load.js, don't forget to include it.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load\n     * @param {Object} options Options for loading the stream.\n     *  options.base64 : is the stream in base64 ? default : false\n     * @return {JSZip} the current JSZip object\n     */\n    load: function(stream, options) {\n        throw new Error(\"Load method is not defined. Is the file jszip-load.js included ?\");\n    },\n\n    /**\n     * Filter nested files/folders with the specified function.\n     * @param {Function} search the predicate to use :\n     * function (relativePath, file) {...}\n     * It takes 2 arguments : the relative path and the file.\n     * @return {Array} An array of matching elements.\n     */\n    filter: function(search) {\n        var result = [],\n            filename, relativePath, file, fileClone;\n        for (filename in this.files) {\n            if (!this.files.hasOwnProperty(filename)) {\n                continue;\n            }\n            file = this.files[filename];\n            // return a new object, don't let the user mess with our internal objects :)\n            fileClone = new ZipObject(file.name, file._data, utils.extend(file.options));\n            relativePath = filename.slice(this.root.length, filename.length);\n            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root\n            search(relativePath, fileClone)) { // and the file matches the function\n                result.push(fileClone);\n            }\n        }\n        return result;\n    },\n\n    /**\n     * Add a file to the zip file, or search a file.\n     * @param   {string|RegExp} name The name of the file to add (if data is defined),\n     * the name of the file to find (if no data) or a regex to match files.\n     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded\n     * @param   {Object} o     File options\n     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),\n     * a file (when searching by string) or an array of files (when searching by regex).\n     */\n    file: function(name, data, o) {\n        if (arguments.length === 1) {\n            if (utils.isRegExp(name)) {\n                var regexp = name;\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && regexp.test(relativePath);\n                });\n            }\n            else { // text\n                return this.filter(function(relativePath, file) {\n                    return !file.dir && relativePath === name;\n                })[0] || null;\n            }\n        }\n        else { // more than one argument : we have data !\n            name = this.root + name;\n            fileAdd.call(this, name, data, o);\n        }\n        return this;\n    },\n\n    /**\n     * Add a directory to the zip file, or search.\n     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.\n     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.\n     */\n    folder: function(arg) {\n        if (!arg) {\n            return this;\n        }\n\n        if (utils.isRegExp(arg)) {\n            return this.filter(function(relativePath, file) {\n                return file.dir && arg.test(relativePath);\n            });\n        }\n\n        // else, name is a new folder\n        var name = this.root + arg;\n        var newFolder = folderAdd.call(this, name);\n\n        // Allow chaining by returning a new object with this folder as the root\n        var ret = this.clone();\n        ret.root = newFolder.name;\n        return ret;\n    },\n\n    /**\n     * Delete a file, or a directory and all sub-files, from the zip\n     * @param {string} name the name of the file to delete\n     * @return {JSZip} this JSZip object\n     */\n    remove: function(name) {\n        name = this.root + name;\n        var file = this.files[name];\n        if (!file) {\n            // Look for any folders\n            if (name.slice(-1) != \"/\") {\n                name += \"/\";\n            }\n            file = this.files[name];\n        }\n\n        if (file && !file.dir) {\n            // file\n            delete this.files[name];\n        } else {\n            // maybe a folder, delete recursively\n            var kids = this.filter(function(relativePath, file) {\n                return file.name.slice(0, name.length) === name;\n            });\n            for (var i = 0; i < kids.length; i++) {\n                delete this.files[kids[i].name];\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Generate the complete zip file\n     * @param {Object} options the options to generate the zip file :\n     * - base64, (deprecated, use type instead) true to generate base64.\n     * - compression, \"STORE\" by default.\n     * - type, \"base64\" by default. Values are : string, base64, uint8array, arraybuffer, blob.\n     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file\n     */\n    generate: function(options) {\n        options = utils.extend(options || {}, {\n            base64: true,\n            compression: \"STORE\",\n            compressionOptions : null,\n            type: \"base64\",\n            platform: \"DOS\",\n            comment: null,\n            mimeType: 'application/zip',\n            encodeFileName: utf8.utf8encode\n        });\n\n        utils.checkSupport(options.type);\n\n        // accept nodejs `process.platform`\n        if(\n          options.platform === 'darwin' ||\n          options.platform === 'freebsd' ||\n          options.platform === 'linux' ||\n          options.platform === 'sunos'\n        ) {\n          options.platform = \"UNIX\";\n        }\n        if (options.platform === 'win32') {\n          options.platform = \"DOS\";\n        }\n\n        var zipData = [],\n            localDirLength = 0,\n            centralDirLength = 0,\n            writer, i,\n            encodedComment = utils.transformTo(\"string\", options.encodeFileName(options.comment || this.comment || \"\"));\n\n        // first, generate all the zip parts.\n        for (var name in this.files) {\n            if (!this.files.hasOwnProperty(name)) {\n                continue;\n            }\n            var file = this.files[name];\n\n            var compressionName = file.options.compression || options.compression.toUpperCase();\n            var compression = compressions[compressionName];\n            if (!compression) {\n                throw new Error(compressionName + \" is not a valid compression method !\");\n            }\n            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};\n\n            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);\n\n            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform, options.encodeFileName);\n            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;\n            centralDirLength += zipPart.dirRecord.length;\n            zipData.push(zipPart);\n        }\n\n        var dirEnd = \"\";\n\n        // end of central dir signature\n        dirEnd = signature.CENTRAL_DIRECTORY_END +\n        // number of this disk\n        \"\\x00\\x00\" +\n        // number of the disk with the start of the central directory\n        \"\\x00\\x00\" +\n        // total number of entries in the central directory on this disk\n        decToHex(zipData.length, 2) +\n        // total number of entries in the central directory\n        decToHex(zipData.length, 2) +\n        // size of the central directory   4 bytes\n        decToHex(centralDirLength, 4) +\n        // offset of start of central directory with respect to the starting disk number\n        decToHex(localDirLength, 4) +\n        // .ZIP file comment length\n        decToHex(encodedComment.length, 2) +\n        // .ZIP file comment\n        encodedComment;\n\n\n        // we have all the parts (and the total length)\n        // time to create a writer !\n        var typeName = options.type.toLowerCase();\n        if(typeName===\"uint8array\"||typeName===\"arraybuffer\"||typeName===\"blob\"||typeName===\"nodebuffer\") {\n            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);\n        }else{\n            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);\n        }\n\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].fileRecord);\n            writer.append(zipData[i].compressedObject.compressedContent);\n        }\n        for (i = 0; i < zipData.length; i++) {\n            writer.append(zipData[i].dirRecord);\n        }\n\n        writer.append(dirEnd);\n\n        var zip = writer.finalize();\n\n\n\n        switch(options.type.toLowerCase()) {\n            // case \"zip is an Uint8Array\"\n            case \"uint8array\" :\n            case \"arraybuffer\" :\n            case \"nodebuffer\" :\n               return utils.transformTo(options.type.toLowerCase(), zip);\n            case \"blob\" :\n               return utils.arrayBuffer2Blob(utils.transformTo(\"arraybuffer\", zip), options.mimeType);\n            // case \"zip is a string\"\n            case \"base64\" :\n               return (options.base64) ? base64.encode(zip) : zip;\n            default : // case \"string\" :\n               return zip;\n         }\n\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    crc32: function (input, crc) {\n        return crc32(input, crc);\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8encode: function (string) {\n        return utils.transformTo(\"string\", utf8.utf8encode(string));\n    },\n\n    /**\n     * @deprecated\n     * This method will be removed in a future version without replacement.\n     */\n    utf8decode: function (input) {\n        return utf8.utf8decode(input);\n    }\n};\nmodule.exports = out;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/object.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/signature.js":
/*!**********************************************!*\
  !*** ../node_modules/jszip/lib/signature.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nexports.LOCAL_FILE_HEADER = \"PK\\x03\\x04\";\nexports.CENTRAL_FILE_HEADER = \"PK\\x01\\x02\";\nexports.CENTRAL_DIRECTORY_END = \"PK\\x05\\x06\";\nexports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = \"PK\\x06\\x07\";\nexports.ZIP64_CENTRAL_DIRECTORY_END = \"PK\\x06\\x06\";\nexports.DATA_DESCRIPTOR = \"PK\\x07\\x08\";\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/signature.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stringReader.js":
/*!*************************************************!*\
  !*** ../node_modules/jszip/lib/stringReader.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar DataReader = __webpack_require__(/*! ./dataReader */ \"../node_modules/jszip/lib/dataReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\nfunction StringReader(data, optimizedBinaryString) {\n    this.data = data;\n    if (!optimizedBinaryString) {\n        this.data = utils.string2binary(this.data);\n    }\n    this.length = this.data.length;\n    this.index = 0;\n    this.zero = 0;\n}\nStringReader.prototype = new DataReader();\n/**\n * @see DataReader.byteAt\n */\nStringReader.prototype.byteAt = function(i) {\n    return this.data.charCodeAt(this.zero + i);\n};\n/**\n * @see DataReader.lastIndexOfSignature\n */\nStringReader.prototype.lastIndexOfSignature = function(sig) {\n    return this.data.lastIndexOf(sig) - this.zero;\n};\n/**\n * @see DataReader.readData\n */\nStringReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    // this will work because the constructor applied the \"& 0xff\" mask.\n    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = StringReader;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/stringReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/stringWriter.js":
/*!*************************************************!*\
  !*** ../node_modules/jszip/lib/stringWriter.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * An object to write any content to a string.\n * @constructor\n */\nvar StringWriter = function() {\n    this.data = [];\n};\nStringWriter.prototype = {\n    /**\n     * Append any content to the current string.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        input = utils.transformTo(\"string\", input);\n        this.data.push(input);\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {string} the generated string.\n     */\n    finalize: function() {\n        return this.data.join(\"\");\n    }\n};\n\nmodule.exports = StringWriter;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/stringWriter.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/support.js":
/*!********************************************!*\
  !*** ../node_modules/jszip/lib/support.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\nexports.base64 = true;\nexports.array = true;\nexports.string = true;\nexports.arraybuffer = typeof ArrayBuffer !== \"undefined\" && typeof Uint8Array !== \"undefined\";\n// contains true if JSZip can read/generate nodejs Buffer, false otherwise.\n// Browserify will provide a Buffer implementation for browsers, which is\n// an augmented Uint8Array (i.e., can be used as either Buffer or U8).\nexports.nodebuffer = typeof Buffer !== \"undefined\";\n// contains true if JSZip can read/generate Uint8Array, false otherwise.\nexports.uint8array = typeof Uint8Array !== \"undefined\";\n\nif (typeof ArrayBuffer === \"undefined\") {\n    exports.blob = false;\n}\nelse {\n    var buffer = new ArrayBuffer(0);\n    try {\n        exports.blob = new Blob([buffer], {\n            type: \"application/zip\"\n        }).size === 0;\n    }\n    catch (e) {\n        try {\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            exports.blob = builder.getBlob('application/zip').size === 0;\n        }\n        catch (e) {\n            exports.blob = false;\n        }\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node-libs-browser/node_modules/buffer/index.js */ \"../node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/support.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/uint8ArrayReader.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/uint8ArrayReader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar ArrayReader = __webpack_require__(/*! ./arrayReader */ \"../node_modules/jszip/lib/arrayReader.js\");\n\nfunction Uint8ArrayReader(data) {\n    if (data) {\n        this.data = data;\n        this.length = this.data.length;\n        this.index = 0;\n        this.zero = 0;\n    }\n}\nUint8ArrayReader.prototype = new ArrayReader();\n/**\n * @see DataReader.readData\n */\nUint8ArrayReader.prototype.readData = function(size) {\n    this.checkOffset(size);\n    if(size === 0) {\n        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].\n        return new Uint8Array(0);\n    }\n    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);\n    this.index += size;\n    return result;\n};\nmodule.exports = Uint8ArrayReader;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/uint8ArrayReader.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/uint8ArrayWriter.js":
/*!*****************************************************!*\
  !*** ../node_modules/jszip/lib/uint8ArrayWriter.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\n\n/**\n * An object to write any content to an Uint8Array.\n * @constructor\n * @param {number} length The length of the array.\n */\nvar Uint8ArrayWriter = function(length) {\n    this.data = new Uint8Array(length);\n    this.index = 0;\n};\nUint8ArrayWriter.prototype = {\n    /**\n     * Append any content to the current array.\n     * @param {Object} input the content to add.\n     */\n    append: function(input) {\n        if (input.length !== 0) {\n            // with an empty Uint8Array, Opera fails with a \"Offset larger than array size\"\n            input = utils.transformTo(\"uint8array\", input);\n            this.data.set(input, this.index);\n            this.index += input.length;\n        }\n    },\n    /**\n     * Finalize the construction an return the result.\n     * @return {Uint8Array} the generated array.\n     */\n    finalize: function() {\n        return this.data;\n    }\n};\n\nmodule.exports = Uint8ArrayWriter;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/uint8ArrayWriter.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/utf8.js":
/*!*****************************************!*\
  !*** ../node_modules/jszip/lib/utf8.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"../node_modules/jszip/lib/nodeBuffer.js\");\n\n/**\n * The following functions come from pako, from pako/lib/utils/strings\n * released under the MIT license, see pako https://github.com/nodeca/pako/\n */\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new Array(256);\nfor (var i=0; i<256; i++) {\n  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n// convert string to array (typed, when possible)\nvar string2buf = function (str) {\n    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n    // count binary size\n    for (m_pos = 0; m_pos < str_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n    }\n\n    // allocate buffer\n    if (support.uint8array) {\n        buf = new Uint8Array(buf_len);\n    } else {\n        buf = new Array(buf_len);\n    }\n\n    // convert\n    for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n        c = str.charCodeAt(m_pos);\n        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n            c2 = str.charCodeAt(m_pos+1);\n            if ((c2 & 0xfc00) === 0xdc00) {\n                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n                m_pos++;\n            }\n        }\n        if (c < 0x80) {\n            /* one byte */\n            buf[i++] = c;\n        } else if (c < 0x800) {\n            /* two bytes */\n            buf[i++] = 0xC0 | (c >>> 6);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else if (c < 0x10000) {\n            /* three bytes */\n            buf[i++] = 0xE0 | (c >>> 12);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        } else {\n            /* four bytes */\n            buf[i++] = 0xf0 | (c >>> 18);\n            buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n            buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n            buf[i++] = 0x80 | (c & 0x3f);\n        }\n    }\n\n    return buf;\n};\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nvar utf8border = function(buf, max) {\n    var pos;\n\n    max = max || buf.length;\n    if (max > buf.length) { max = buf.length; }\n\n    // go back from last position, until start of sequence found\n    pos = max-1;\n    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n    // Fuckup - very small and broken sequence,\n    // return max, because we should return something anyway.\n    if (pos < 0) { return max; }\n\n    // If we came to start of buffer - that means vuffer is too small,\n    // return max too.\n    if (pos === 0) { return max; }\n\n    return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n// convert array to string\nvar buf2string = function (buf) {\n    var str, i, out, c, c_len;\n    var len = buf.length;\n\n    // Reserve max possible length (2 words per char)\n    // NB: by unknown reasons, Array is significantly faster for\n    //     String.fromCharCode.apply than Uint16Array.\n    var utf16buf = new Array(len*2);\n\n    for (out=0, i=0; i<len;) {\n        c = buf[i++];\n        // quick process ascii\n        if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n        c_len = _utf8len[c];\n        // skip 5 & 6 byte codes\n        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n        // apply mask on first byte\n        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n        // join the rest\n        while (c_len > 1 && i < len) {\n            c = (c << 6) | (buf[i++] & 0x3f);\n            c_len--;\n        }\n\n        // terminated by end of string?\n        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n        if (c < 0x10000) {\n            utf16buf[out++] = c;\n        } else {\n            c -= 0x10000;\n            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n            utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n        }\n    }\n\n    // shrinkBuf(utf16buf, out)\n    if (utf16buf.length !== out) {\n        if(utf16buf.subarray) {\n            utf16buf = utf16buf.subarray(0, out);\n        } else {\n            utf16buf.length = out;\n        }\n    }\n\n    // return String.fromCharCode.apply(null, utf16buf);\n    return utils.applyFromCharCode(utf16buf);\n};\n\n\n// That's all for the pako functions.\n\n\n/**\n * Transform a javascript string into an array (typed if possible) of bytes,\n * UTF-8 encoded.\n * @param {String} str the string to encode\n * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.\n */\nexports.utf8encode = function utf8encode(str) {\n    if (support.nodebuffer) {\n        return nodeBuffer(str, \"utf-8\");\n    }\n\n    return string2buf(str);\n};\n\n\n/**\n * Transform a bytes array (or a representation) representing an UTF-8 encoded\n * string into a javascript string.\n * @param {Array|Uint8Array|Buffer} buf the data de decode\n * @return {String} the decoded string.\n */\nexports.utf8decode = function utf8decode(buf) {\n    if (support.nodebuffer) {\n        return utils.transformTo(\"nodebuffer\", buf).toString(\"utf-8\");\n    }\n\n    buf = utils.transformTo(support.uint8array ? \"uint8array\" : \"array\", buf);\n\n    // return buf2string(buf);\n    // Chrome prefers to work with \"small\" chunks of data\n    // for the method buf2string.\n    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.\n    var result = [], k = 0, len = buf.length, chunk = 65536;\n    while (k < len) {\n        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));\n        if (support.uint8array) {\n            result.push(buf2string(buf.subarray(k, nextBoundary)));\n        } else {\n            result.push(buf2string(buf.slice(k, nextBoundary)));\n        }\n        k = nextBoundary;\n    }\n    return result.join(\"\");\n\n};\n// vim: set shiftwidth=4 softtabstop=4:\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/utf8.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/utils.js":
/*!******************************************!*\
  !*** ../node_modules/jszip/lib/utils.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar compressions = __webpack_require__(/*! ./compressions */ \"../node_modules/jszip/lib/compressions.js\");\nvar nodeBuffer = __webpack_require__(/*! ./nodeBuffer */ \"../node_modules/jszip/lib/nodeBuffer.js\");\n/**\n * Convert a string to a \"binary string\" : a string containing only char codes between 0 and 255.\n * @param {string} str the string to transform.\n * @return {String} the binary string.\n */\nexports.string2binary = function(str) {\n    var result = \"\";\n    for (var i = 0; i < str.length; i++) {\n        result += String.fromCharCode(str.charCodeAt(i) & 0xff);\n    }\n    return result;\n};\nexports.arrayBuffer2Blob = function(buffer, mimeType) {\n    exports.checkSupport(\"blob\");\n\tmimeType = mimeType || 'application/zip';\n\n    try {\n        // Blob constructor\n        return new Blob([buffer], {\n            type: mimeType\n        });\n    }\n    catch (e) {\n\n        try {\n            // deprecated, browser only, old way\n            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n            var builder = new Builder();\n            builder.append(buffer);\n            return builder.getBlob(mimeType);\n        }\n        catch (e) {\n\n            // well, fuck ?!\n            throw new Error(\"Bug : can't construct the Blob.\");\n        }\n    }\n\n\n};\n/**\n * The identity function.\n * @param {Object} input the input.\n * @return {Object} the same input.\n */\nfunction identity(input) {\n    return input;\n}\n\n/**\n * Fill in an array with a string.\n * @param {String} str the string to use.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.\n */\nfunction stringToArrayLike(str, array) {\n    for (var i = 0; i < str.length; ++i) {\n        array[i] = str.charCodeAt(i) & 0xFF;\n    }\n    return array;\n}\n\n/**\n * Transform an array-like object to a string.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.\n * @return {String} the result.\n */\nfunction arrayLikeToString(array) {\n    // Performances notes :\n    // --------------------\n    // String.fromCharCode.apply(null, array) is the fastest, see\n    // see http://jsperf.com/converting-a-uint8array-to-a-string/2\n    // but the stack is limited (and we can get huge arrays !).\n    //\n    // result += String.fromCharCode(array[i]); generate too many strings !\n    //\n    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2\n    var chunk = 65536;\n    var result = [],\n        len = array.length,\n        type = exports.getTypeOf(array),\n        k = 0,\n        canUseApply = true;\n      try {\n         switch(type) {\n            case \"uint8array\":\n               String.fromCharCode.apply(null, new Uint8Array(0));\n               break;\n            case \"nodebuffer\":\n               String.fromCharCode.apply(null, nodeBuffer(0));\n               break;\n         }\n      } catch(e) {\n         canUseApply = false;\n      }\n\n      // no apply : slow and painful algorithm\n      // default browser on android 4.*\n      if (!canUseApply) {\n         var resultStr = \"\";\n         for(var i = 0; i < array.length;i++) {\n            resultStr += String.fromCharCode(array[i]);\n         }\n    return resultStr;\n    }\n    while (k < len && chunk > 1) {\n        try {\n            if (type === \"array\" || type === \"nodebuffer\") {\n                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));\n            }\n            else {\n                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));\n            }\n            k += chunk;\n        }\n        catch (e) {\n            chunk = Math.floor(chunk / 2);\n        }\n    }\n    return result.join(\"\");\n}\n\nexports.applyFromCharCode = arrayLikeToString;\n\n\n/**\n * Copy the data from an array-like to an other array-like.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.\n * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.\n * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.\n */\nfunction arrayLikeToArrayLike(arrayFrom, arrayTo) {\n    for (var i = 0; i < arrayFrom.length; i++) {\n        arrayTo[i] = arrayFrom[i];\n    }\n    return arrayTo;\n}\n\n// a matrix containing functions to transform everything into everything.\nvar transform = {};\n\n// string to ?\ntransform[\"string\"] = {\n    \"string\": identity,\n    \"array\": function(input) {\n        return stringToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"string\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return stringToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": function(input) {\n        return stringToArrayLike(input, nodeBuffer(input.length));\n    }\n};\n\n// array to ?\ntransform[\"array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": identity,\n    \"arraybuffer\": function(input) {\n        return (new Uint8Array(input)).buffer;\n    },\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// arraybuffer to ?\ntransform[\"arraybuffer\"] = {\n    \"string\": function(input) {\n        return arrayLikeToString(new Uint8Array(input));\n    },\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));\n    },\n    \"arraybuffer\": identity,\n    \"uint8array\": function(input) {\n        return new Uint8Array(input);\n    },\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(new Uint8Array(input));\n    }\n};\n\n// uint8array to ?\ntransform[\"uint8array\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return input.buffer;\n    },\n    \"uint8array\": identity,\n    \"nodebuffer\": function(input) {\n        return nodeBuffer(input);\n    }\n};\n\n// nodebuffer to ?\ntransform[\"nodebuffer\"] = {\n    \"string\": arrayLikeToString,\n    \"array\": function(input) {\n        return arrayLikeToArrayLike(input, new Array(input.length));\n    },\n    \"arraybuffer\": function(input) {\n        return transform[\"nodebuffer\"][\"uint8array\"](input).buffer;\n    },\n    \"uint8array\": function(input) {\n        return arrayLikeToArrayLike(input, new Uint8Array(input.length));\n    },\n    \"nodebuffer\": identity\n};\n\n/**\n * Transform an input into any type.\n * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.\n * If no output type is specified, the unmodified input will be returned.\n * @param {String} outputType the output type.\n * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.\n * @throws {Error} an Error if the browser doesn't support the requested output type.\n */\nexports.transformTo = function(outputType, input) {\n    if (!input) {\n        // undefined, null, etc\n        // an empty string won't harm.\n        input = \"\";\n    }\n    if (!outputType) {\n        return input;\n    }\n    exports.checkSupport(outputType);\n    var inputType = exports.getTypeOf(input);\n    var result = transform[inputType][outputType](input);\n    return result;\n};\n\n/**\n * Return the type of the input.\n * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.\n * @param {Object} input the input to identify.\n * @return {String} the (lowercase) type of the input.\n */\nexports.getTypeOf = function(input) {\n    if (typeof input === \"string\") {\n        return \"string\";\n    }\n    if (Object.prototype.toString.call(input) === \"[object Array]\") {\n        return \"array\";\n    }\n    if (support.nodebuffer && nodeBuffer.test(input)) {\n        return \"nodebuffer\";\n    }\n    if (support.uint8array && input instanceof Uint8Array) {\n        return \"uint8array\";\n    }\n    if (support.arraybuffer && input instanceof ArrayBuffer) {\n        return \"arraybuffer\";\n    }\n};\n\n/**\n * Throw an exception if the type is not supported.\n * @param {String} type the type to check.\n * @throws {Error} an Error if the browser doesn't support the requested type.\n */\nexports.checkSupport = function(type) {\n    var supported = support[type.toLowerCase()];\n    if (!supported) {\n        throw new Error(type + \" is not supported by this browser\");\n    }\n};\nexports.MAX_VALUE_16BITS = 65535;\nexports.MAX_VALUE_32BITS = -1; // well, \"\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\\xFF\" is parsed as -1\n\n/**\n * Prettify a string read as binary.\n * @param {string} str the string to prettify.\n * @return {string} a pretty string.\n */\nexports.pretty = function(str) {\n    var res = '',\n        code, i;\n    for (i = 0; i < (str || \"\").length; i++) {\n        code = str.charCodeAt(i);\n        res += '\\\\x' + (code < 16 ? \"0\" : \"\") + code.toString(16).toUpperCase();\n    }\n    return res;\n};\n\n/**\n * Find a compression registered in JSZip.\n * @param {string} compressionMethod the method magic to find.\n * @return {Object|null} the JSZip compression object, null if none found.\n */\nexports.findCompression = function(compressionMethod) {\n    for (var method in compressions) {\n        if (!compressions.hasOwnProperty(method)) {\n            continue;\n        }\n        if (compressions[method].magic === compressionMethod) {\n            return compressions[method];\n        }\n    }\n    return null;\n};\n/**\n* Cross-window, cross-Node-context regular expression detection\n* @param  {Object}  object Anything\n* @return {Boolean}        true if the object is a regular expression,\n* false otherwise\n*/\nexports.isRegExp = function (object) {\n    return Object.prototype.toString.call(object) === \"[object RegExp]\";\n};\n\n/**\n * Merge the objects passed as parameters into a new one.\n * @private\n * @param {...Object} var_args All objects to merge.\n * @return {Object} a new object with the data of the others.\n */\nexports.extend = function() {\n    var result = {}, i, attr;\n    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers\n        for (attr in arguments[i]) {\n            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === \"undefined\") {\n                result[attr] = arguments[i][attr];\n            }\n        }\n    }\n    return result;\n};\n\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/utils.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/zipEntries.js":
/*!***********************************************!*\
  !*** ../node_modules/jszip/lib/zipEntries.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar StringReader = __webpack_require__(/*! ./stringReader */ \"../node_modules/jszip/lib/stringReader.js\");\nvar NodeBufferReader = __webpack_require__(/*! ./nodeBufferReader */ \"../node_modules/jszip/lib/nodeBufferReader.js\");\nvar Uint8ArrayReader = __webpack_require__(/*! ./uint8ArrayReader */ \"../node_modules/jszip/lib/uint8ArrayReader.js\");\nvar ArrayReader = __webpack_require__(/*! ./arrayReader */ \"../node_modules/jszip/lib/arrayReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar sig = __webpack_require__(/*! ./signature */ \"../node_modules/jszip/lib/signature.js\");\nvar ZipEntry = __webpack_require__(/*! ./zipEntry */ \"../node_modules/jszip/lib/zipEntry.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\nvar jszipProto = __webpack_require__(/*! ./object */ \"../node_modules/jszip/lib/object.js\");\n//  class ZipEntries {{{\n/**\n * All the entries in the zip file.\n * @constructor\n * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntries(data, loadOptions) {\n    this.files = [];\n    this.loadOptions = loadOptions;\n    if (data) {\n        this.load(data);\n    }\n}\nZipEntries.prototype = {\n    /**\n     * Check that the reader is on the speficied signature.\n     * @param {string} expectedSignature the expected signature.\n     * @throws {Error} if it is an other signature.\n     */\n    checkSignature: function(expectedSignature) {\n        var signature = this.reader.readString(4);\n        if (signature !== expectedSignature) {\n            throw new Error(\"Corrupted zip or bug : unexpected signature \" + \"(\" + utils.pretty(signature) + \", expected \" + utils.pretty(expectedSignature) + \")\");\n        }\n    },\n    /**\n     * Check if the given signature is at the given index.\n     * @param {number} askedIndex the index to check.\n     * @param {string} expectedSignature the signature to expect.\n     * @return {boolean} true if the signature is here, false otherwise.\n     */\n    isSignature: function(askedIndex, expectedSignature) {\n        var currentIndex = this.reader.index;\n        this.reader.setIndex(askedIndex);\n        var signature = this.reader.readString(4);\n        var result = signature === expectedSignature;\n        this.reader.setIndex(currentIndex);\n        return result;\n    },\n    /**\n     * Read the end of the central directory.\n     */\n    readBlockEndOfCentral: function() {\n        this.diskNumber = this.reader.readInt(2);\n        this.diskWithCentralDirStart = this.reader.readInt(2);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);\n        this.centralDirRecords = this.reader.readInt(2);\n        this.centralDirSize = this.reader.readInt(4);\n        this.centralDirOffset = this.reader.readInt(4);\n\n        this.zipCommentLength = this.reader.readInt(2);\n        // warning : the encoding depends of the system locale\n        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.\n        // On a windows machine, this field is encoded with the localized windows code page.\n        var zipComment = this.reader.readData(this.zipCommentLength);\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        // To get consistent behavior with the generation part, we will assume that\n        // this is utf8 encoded unless specified otherwise.\n        var decodeContent = utils.transformTo(decodeParamType, zipComment);\n        this.zipComment = this.loadOptions.decodeFileName(decodeContent);\n    },\n    /**\n     * Read the end of the Zip 64 central directory.\n     * Not merged with the method readEndOfCentral :\n     * The end of central can coexist with its Zip64 brother,\n     * I don't want to read the wrong number of bytes !\n     */\n    readBlockZip64EndOfCentral: function() {\n        this.zip64EndOfCentralSize = this.reader.readInt(8);\n        this.versionMadeBy = this.reader.readString(2);\n        this.versionNeeded = this.reader.readInt(2);\n        this.diskNumber = this.reader.readInt(4);\n        this.diskWithCentralDirStart = this.reader.readInt(4);\n        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);\n        this.centralDirRecords = this.reader.readInt(8);\n        this.centralDirSize = this.reader.readInt(8);\n        this.centralDirOffset = this.reader.readInt(8);\n\n        this.zip64ExtensibleData = {};\n        var extraDataSize = this.zip64EndOfCentralSize - 44,\n            index = 0,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n        while (index < extraDataSize) {\n            extraFieldId = this.reader.readInt(2);\n            extraFieldLength = this.reader.readInt(4);\n            extraFieldValue = this.reader.readString(extraFieldLength);\n            this.zip64ExtensibleData[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Read the end of the Zip 64 central directory locator.\n     */\n    readBlockZip64EndOfCentralLocator: function() {\n        this.diskWithZip64CentralDirStart = this.reader.readInt(4);\n        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);\n        this.disksCount = this.reader.readInt(4);\n        if (this.disksCount > 1) {\n            throw new Error(\"Multi-volumes zip are not supported\");\n        }\n    },\n    /**\n     * Read the local files, based on the offset read in the central part.\n     */\n    readLocalFiles: function() {\n        var i, file;\n        for (i = 0; i < this.files.length; i++) {\n            file = this.files[i];\n            this.reader.setIndex(file.localHeaderOffset);\n            this.checkSignature(sig.LOCAL_FILE_HEADER);\n            file.readLocalPart(this.reader);\n            file.handleUTF8();\n            file.processAttributes();\n        }\n    },\n    /**\n     * Read the central directory.\n     */\n    readCentralDir: function() {\n        var file;\n\n        this.reader.setIndex(this.centralDirOffset);\n        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {\n            file = new ZipEntry({\n                zip64: this.zip64\n            }, this.loadOptions);\n            file.readCentralPart(this.reader);\n            this.files.push(file);\n        }\n\n        if (this.centralDirRecords !== this.files.length) {\n            if (this.centralDirRecords !== 0 && this.files.length === 0) {\n                // We expected some records but couldn't find ANY.\n                // This is really suspicious, as if something went wrong.\n                throw new Error(\"Corrupted zip or bug: expected \" + this.centralDirRecords + \" records in central dir, got \" + this.files.length);\n            } else {\n                // We found some records but not all.\n                // Something is wrong but we got something for the user: no error here.\n                // console.warn(\"expected\", this.centralDirRecords, \"records in central dir, got\", this.files.length);\n            }\n        }\n    },\n    /**\n     * Read the end of central directory.\n     */\n    readEndOfCentral: function() {\n        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);\n        if (offset < 0) {\n            // Check if the content is a truncated zip or complete garbage.\n            // A \"LOCAL_FILE_HEADER\" is not required at the beginning (auto\n            // extractible zip for example) but it can give a good hint.\n            // If an ajax request was used without responseType, we will also\n            // get unreadable data.\n            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);\n\n            if (isGarbage) {\n                throw new Error(\"Can't find end of central directory : is this a zip file ? \" +\n                                \"If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html\");\n            } else {\n                throw new Error(\"Corrupted zip : can't find end of central directory\");\n            }\n        }\n        this.reader.setIndex(offset);\n        var endOfCentralDirOffset = offset;\n        this.checkSignature(sig.CENTRAL_DIRECTORY_END);\n        this.readBlockEndOfCentral();\n\n\n        /* extract from the zip spec :\n            4)  If one of the fields in the end of central directory\n                record is too small to hold required data, the field\n                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the\n                ZIP64 format record should be created.\n            5)  The end of central directory record and the\n                Zip64 end of central directory locator record must\n                reside on the same disk when splitting or spanning\n                an archive.\n         */\n        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {\n            this.zip64 = true;\n\n            /*\n            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from\n            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents\n            all numbers as 64-bit double precision IEEE 754 floating point numbers.\n            So, we have 53bits for integers and bitwise operations treat everything as 32bits.\n            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators\n            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5\n            */\n\n            // should look for a zip64 EOCD locator\n            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            if (offset < 0) {\n                throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory locator\");\n            }\n            this.reader.setIndex(offset);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);\n            this.readBlockZip64EndOfCentralLocator();\n\n            // now the zip64 EOCD record\n            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {\n                // console.warn(\"ZIP64 end of central directory not where expected.\");\n                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n                if (this.relativeOffsetEndOfZip64CentralDir < 0) {\n                    throw new Error(\"Corrupted zip : can't find the ZIP64 end of central directory\");\n                }\n            }\n            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);\n            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);\n            this.readBlockZip64EndOfCentral();\n        }\n\n        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;\n        if (this.zip64) {\n            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator\n            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;\n        }\n\n        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;\n\n        if (extraBytes > 0) {\n            // console.warn(extraBytes, \"extra bytes at beginning or within zipfile\");\n            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {\n                // The offsets seem wrong, but we have something at the specified offset.\n                // So we keep it.\n            } else {\n                // the offset is wrong, update the \"zero\" of the reader\n                // this happens if data has been prepended (crx files for example)\n                this.reader.zero = extraBytes;\n            }\n        } else if (extraBytes < 0) {\n            throw new Error(\"Corrupted zip: missing \" + Math.abs(extraBytes) + \" bytes.\");\n        }\n    },\n    prepareReader: function(data) {\n        var type = utils.getTypeOf(data);\n        utils.checkSupport(type);\n        if (type === \"string\" && !support.uint8array) {\n            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);\n        }\n        else if (type === \"nodebuffer\") {\n            this.reader = new NodeBufferReader(data);\n        }\n        else if (support.uint8array) {\n            this.reader = new Uint8ArrayReader(utils.transformTo(\"uint8array\", data));\n        } else if (support.array) {\n            this.reader = new ArrayReader(utils.transformTo(\"array\", data));\n        } else {\n            throw new Error(\"Unexpected error: unsupported type '\" + type + \"'\");\n        }\n    },\n    /**\n     * Read a zip file and create ZipEntries.\n     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.\n     */\n    load: function(data) {\n        this.prepareReader(data);\n        this.readEndOfCentral();\n        this.readCentralDir();\n        this.readLocalFiles();\n    }\n};\n// }}} end of ZipEntries\nmodule.exports = ZipEntries;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/zipEntries.js?");

/***/ }),

/***/ "../node_modules/jszip/lib/zipEntry.js":
/*!*********************************************!*\
  !*** ../node_modules/jszip/lib/zipEntry.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar StringReader = __webpack_require__(/*! ./stringReader */ \"../node_modules/jszip/lib/stringReader.js\");\nvar utils = __webpack_require__(/*! ./utils */ \"../node_modules/jszip/lib/utils.js\");\nvar CompressedObject = __webpack_require__(/*! ./compressedObject */ \"../node_modules/jszip/lib/compressedObject.js\");\nvar jszipProto = __webpack_require__(/*! ./object */ \"../node_modules/jszip/lib/object.js\");\nvar support = __webpack_require__(/*! ./support */ \"../node_modules/jszip/lib/support.js\");\n\nvar MADE_BY_DOS = 0x00;\nvar MADE_BY_UNIX = 0x03;\n\n// class ZipEntry {{{\n/**\n * An entry in the zip file.\n * @constructor\n * @param {Object} options Options of the current file.\n * @param {Object} loadOptions Options for loading the stream.\n */\nfunction ZipEntry(options, loadOptions) {\n    this.options = options;\n    this.loadOptions = loadOptions;\n}\nZipEntry.prototype = {\n    /**\n     * say if the file is encrypted.\n     * @return {boolean} true if the file is encrypted, false otherwise.\n     */\n    isEncrypted: function() {\n        // bit 1 is set\n        return (this.bitFlag & 0x0001) === 0x0001;\n    },\n    /**\n     * say if the file has utf-8 filename/comment.\n     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.\n     */\n    useUTF8: function() {\n        // bit 11 is set\n        return (this.bitFlag & 0x0800) === 0x0800;\n    },\n    /**\n     * Prepare the function used to generate the compressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).\n     */\n    prepareCompressedContent: function(reader, from, length) {\n        return function() {\n            var previousIndex = reader.index;\n            reader.setIndex(from);\n            var compressedFileData = reader.readData(length);\n            reader.setIndex(previousIndex);\n\n            return compressedFileData;\n        };\n    },\n    /**\n     * Prepare the function used to generate the uncompressed content from this ZipFile.\n     * @param {DataReader} reader the reader to use.\n     * @param {number} from the offset from where we should read the data.\n     * @param {number} length the length of the data to read.\n     * @param {JSZip.compression} compression the compression used on this file.\n     * @param {number} uncompressedSize the uncompressed size to expect.\n     * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).\n     */\n    prepareContent: function(reader, from, length, compression, uncompressedSize) {\n        return function() {\n\n            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());\n            var uncompressedFileData = compression.uncompress(compressedFileData);\n\n            if (uncompressedFileData.length !== uncompressedSize) {\n                throw new Error(\"Bug : uncompressed data size mismatch\");\n            }\n\n            return uncompressedFileData;\n        };\n    },\n    /**\n     * Read the local part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readLocalPart: function(reader) {\n        var compression, localExtraFieldsLength;\n\n        // we already know everything from the central dir !\n        // If the central dir data are false, we are doomed.\n        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.\n        // The less data we get here, the more reliable this should be.\n        // Let's skip the whole header and dash to the data !\n        reader.skip(22);\n        // in some zip created on windows, the filename stored in the central dir contains \\ instead of /.\n        // Strangely, the filename here is OK.\n        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes\n        // or APPNOTE#4.4.17.1, \"All slashes MUST be forward slashes '/'\") but there are a lot of bad zip generators...\n        // Search \"unzip mismatching \"local\" filename continuing with \"central\" filename version\" on\n        // the internet.\n        //\n        // I think I see the logic here : the central directory is used to display\n        // content and the local directory is used to extract the files. Mixing / and \\\n        // may be used to display \\ to windows users and use / when extracting the files.\n        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394\n        this.fileNameLength = reader.readInt(2);\n        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir\n        this.fileName = reader.readData(this.fileNameLength);\n        reader.skip(localExtraFieldsLength);\n\n        if (this.compressedSize == -1 || this.uncompressedSize == -1) {\n            throw new Error(\"Bug or corrupted zip : didn't get enough informations from the central directory \" + \"(compressedSize == -1 || uncompressedSize == -1)\");\n        }\n\n        compression = utils.findCompression(this.compressionMethod);\n        if (compression === null) { // no compression found\n            throw new Error(\"Corrupted zip : compression \" + utils.pretty(this.compressionMethod) + \" unknown (inner file : \" +  utils.transformTo(\"string\", this.fileName) + \")\");\n        }\n        this.decompressed = new CompressedObject();\n        this.decompressed.compressedSize = this.compressedSize;\n        this.decompressed.uncompressedSize = this.uncompressedSize;\n        this.decompressed.crc32 = this.crc32;\n        this.decompressed.compressionMethod = this.compressionMethod;\n        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);\n        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);\n\n        // we need to compute the crc32...\n        if (this.loadOptions.checkCRC32) {\n            this.decompressed = utils.transformTo(\"string\", this.decompressed.getContent());\n            if (jszipProto.crc32(this.decompressed) !== this.crc32) {\n                throw new Error(\"Corrupted zip : CRC32 mismatch\");\n            }\n        }\n    },\n\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readCentralPart: function(reader) {\n        this.versionMadeBy = reader.readInt(2);\n        this.versionNeeded = reader.readInt(2);\n        this.bitFlag = reader.readInt(2);\n        this.compressionMethod = reader.readString(2);\n        this.date = reader.readDate();\n        this.crc32 = reader.readInt(4);\n        this.compressedSize = reader.readInt(4);\n        this.uncompressedSize = reader.readInt(4);\n        this.fileNameLength = reader.readInt(2);\n        this.extraFieldsLength = reader.readInt(2);\n        this.fileCommentLength = reader.readInt(2);\n        this.diskNumberStart = reader.readInt(2);\n        this.internalFileAttributes = reader.readInt(2);\n        this.externalFileAttributes = reader.readInt(4);\n        this.localHeaderOffset = reader.readInt(4);\n\n        if (this.isEncrypted()) {\n            throw new Error(\"Encrypted zip are not supported\");\n        }\n\n        this.fileName = reader.readData(this.fileNameLength);\n        this.readExtraFields(reader);\n        this.parseZIP64ExtraField(reader);\n        this.fileComment = reader.readData(this.fileCommentLength);\n    },\n\n    /**\n     * Parse the external file attributes and get the unix/dos permissions.\n     */\n    processAttributes: function () {\n        this.unixPermissions = null;\n        this.dosPermissions = null;\n        var madeBy = this.versionMadeBy >> 8;\n\n        // Check if we have the DOS directory flag set.\n        // We look for it in the DOS and UNIX permissions\n        // but some unknown platform could set it as a compatibility flag.\n        this.dir = this.externalFileAttributes & 0x0010 ? true : false;\n\n        if(madeBy === MADE_BY_DOS) {\n            // first 6 bits (0 to 5)\n            this.dosPermissions = this.externalFileAttributes & 0x3F;\n        }\n\n        if(madeBy === MADE_BY_UNIX) {\n            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;\n            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);\n        }\n\n        // fail safe : if the name ends with a / it probably means a folder\n        if (!this.dir && this.fileNameStr.slice(-1) === '/') {\n            this.dir = true;\n        }\n    },\n\n    /**\n     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.\n     * @param {DataReader} reader the reader to use.\n     */\n    parseZIP64ExtraField: function(reader) {\n\n        if (!this.extraFields[0x0001]) {\n            return;\n        }\n\n        // should be something, preparing the extra reader\n        var extraReader = new StringReader(this.extraFields[0x0001].value);\n\n        // I really hope that these 64bits integer can fit in 32 bits integer, because js\n        // won't let us have more.\n        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {\n            this.uncompressedSize = extraReader.readInt(8);\n        }\n        if (this.compressedSize === utils.MAX_VALUE_32BITS) {\n            this.compressedSize = extraReader.readInt(8);\n        }\n        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {\n            this.localHeaderOffset = extraReader.readInt(8);\n        }\n        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {\n            this.diskNumberStart = extraReader.readInt(4);\n        }\n    },\n    /**\n     * Read the central part of a zip file and add the info in this object.\n     * @param {DataReader} reader the reader to use.\n     */\n    readExtraFields: function(reader) {\n        var start = reader.index,\n            extraFieldId,\n            extraFieldLength,\n            extraFieldValue;\n\n        this.extraFields = this.extraFields || {};\n\n        while (reader.index < start + this.extraFieldsLength) {\n            extraFieldId = reader.readInt(2);\n            extraFieldLength = reader.readInt(2);\n            extraFieldValue = reader.readString(extraFieldLength);\n\n            this.extraFields[extraFieldId] = {\n                id: extraFieldId,\n                length: extraFieldLength,\n                value: extraFieldValue\n            };\n        }\n    },\n    /**\n     * Apply an UTF8 transformation if needed.\n     */\n    handleUTF8: function() {\n        var decodeParamType = support.uint8array ? \"uint8array\" : \"array\";\n        if (this.useUTF8()) {\n            this.fileNameStr = jszipProto.utf8decode(this.fileName);\n            this.fileCommentStr = jszipProto.utf8decode(this.fileComment);\n        } else {\n            var upath = this.findExtraFieldUnicodePath();\n            if (upath !== null) {\n                this.fileNameStr = upath;\n            } else {\n                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);\n                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);\n            }\n\n            var ucomment = this.findExtraFieldUnicodeComment();\n            if (ucomment !== null) {\n                this.fileCommentStr = ucomment;\n            } else {\n                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);\n                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);\n            }\n        }\n    },\n\n    /**\n     * Find the unicode path declared in the extra field, if any.\n     * @return {String} the unicode path, null otherwise.\n     */\n    findExtraFieldUnicodePath: function() {\n        var upathField = this.extraFields[0x7075];\n        if (upathField) {\n            var extraReader = new StringReader(upathField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the filename changed, this field is out of date.\n            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));\n        }\n        return null;\n    },\n\n    /**\n     * Find the unicode comment declared in the extra field, if any.\n     * @return {String} the unicode comment, null otherwise.\n     */\n    findExtraFieldUnicodeComment: function() {\n        var ucommentField = this.extraFields[0x6375];\n        if (ucommentField) {\n            var extraReader = new StringReader(ucommentField.value);\n\n            // wrong version\n            if (extraReader.readInt(1) !== 1) {\n                return null;\n            }\n\n            // the crc of the comment changed, this field is out of date.\n            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {\n                return null;\n            }\n\n            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));\n        }\n        return null;\n    }\n};\nmodule.exports = ZipEntry;\n\n\n//# sourceURL=webpack://STK/../node_modules/jszip/lib/zipEntry.js?");

/***/ }),

/***/ "../node_modules/lodash/lodash.js":
/*!****************************************!*\
  !*** ../node_modules/lodash/lodash.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**\n * @license\n * Lodash <https://lodash.com/>\n * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n;(function() {\n\n  /** Used as a safe reference for `undefined` in pre-ES5 environments. */\n  var undefined;\n\n  /** Used as the semantic version number. */\n  var VERSION = '4.17.15';\n\n  /** Used as the size to enable large array optimizations. */\n  var LARGE_ARRAY_SIZE = 200;\n\n  /** Error message constants. */\n  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',\n      FUNC_ERROR_TEXT = 'Expected a function';\n\n  /** Used to stand-in for `undefined` hash values. */\n  var HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n  /** Used as the maximum memoize cache size. */\n  var MAX_MEMOIZE_SIZE = 500;\n\n  /** Used as the internal argument placeholder. */\n  var PLACEHOLDER = '__lodash_placeholder__';\n\n  /** Used to compose bitmasks for cloning. */\n  var CLONE_DEEP_FLAG = 1,\n      CLONE_FLAT_FLAG = 2,\n      CLONE_SYMBOLS_FLAG = 4;\n\n  /** Used to compose bitmasks for value comparisons. */\n  var COMPARE_PARTIAL_FLAG = 1,\n      COMPARE_UNORDERED_FLAG = 2;\n\n  /** Used to compose bitmasks for function metadata. */\n  var WRAP_BIND_FLAG = 1,\n      WRAP_BIND_KEY_FLAG = 2,\n      WRAP_CURRY_BOUND_FLAG = 4,\n      WRAP_CURRY_FLAG = 8,\n      WRAP_CURRY_RIGHT_FLAG = 16,\n      WRAP_PARTIAL_FLAG = 32,\n      WRAP_PARTIAL_RIGHT_FLAG = 64,\n      WRAP_ARY_FLAG = 128,\n      WRAP_REARG_FLAG = 256,\n      WRAP_FLIP_FLAG = 512;\n\n  /** Used as default options for `_.truncate`. */\n  var DEFAULT_TRUNC_LENGTH = 30,\n      DEFAULT_TRUNC_OMISSION = '...';\n\n  /** Used to detect hot functions by number of calls within a span of milliseconds. */\n  var HOT_COUNT = 800,\n      HOT_SPAN = 16;\n\n  /** Used to indicate the type of lazy iteratees. */\n  var LAZY_FILTER_FLAG = 1,\n      LAZY_MAP_FLAG = 2,\n      LAZY_WHILE_FLAG = 3;\n\n  /** Used as references for various `Number` constants. */\n  var INFINITY = 1 / 0,\n      MAX_SAFE_INTEGER = 9007199254740991,\n      MAX_INTEGER = 1.7976931348623157e+308,\n      NAN = 0 / 0;\n\n  /** Used as references for the maximum length and index of an array. */\n  var MAX_ARRAY_LENGTH = 4294967295,\n      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,\n      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n\n  /** Used to associate wrap methods with their bit flags. */\n  var wrapFlags = [\n    ['ary', WRAP_ARY_FLAG],\n    ['bind', WRAP_BIND_FLAG],\n    ['bindKey', WRAP_BIND_KEY_FLAG],\n    ['curry', WRAP_CURRY_FLAG],\n    ['curryRight', WRAP_CURRY_RIGHT_FLAG],\n    ['flip', WRAP_FLIP_FLAG],\n    ['partial', WRAP_PARTIAL_FLAG],\n    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],\n    ['rearg', WRAP_REARG_FLAG]\n  ];\n\n  /** `Object#toString` result references. */\n  var argsTag = '[object Arguments]',\n      arrayTag = '[object Array]',\n      asyncTag = '[object AsyncFunction]',\n      boolTag = '[object Boolean]',\n      dateTag = '[object Date]',\n      domExcTag = '[object DOMException]',\n      errorTag = '[object Error]',\n      funcTag = '[object Function]',\n      genTag = '[object GeneratorFunction]',\n      mapTag = '[object Map]',\n      numberTag = '[object Number]',\n      nullTag = '[object Null]',\n      objectTag = '[object Object]',\n      promiseTag = '[object Promise]',\n      proxyTag = '[object Proxy]',\n      regexpTag = '[object RegExp]',\n      setTag = '[object Set]',\n      stringTag = '[object String]',\n      symbolTag = '[object Symbol]',\n      undefinedTag = '[object Undefined]',\n      weakMapTag = '[object WeakMap]',\n      weakSetTag = '[object WeakSet]';\n\n  var arrayBufferTag = '[object ArrayBuffer]',\n      dataViewTag = '[object DataView]',\n      float32Tag = '[object Float32Array]',\n      float64Tag = '[object Float64Array]',\n      int8Tag = '[object Int8Array]',\n      int16Tag = '[object Int16Array]',\n      int32Tag = '[object Int32Array]',\n      uint8Tag = '[object Uint8Array]',\n      uint8ClampedTag = '[object Uint8ClampedArray]',\n      uint16Tag = '[object Uint16Array]',\n      uint32Tag = '[object Uint32Array]';\n\n  /** Used to match empty string literals in compiled template source. */\n  var reEmptyStringLeading = /\\b__p \\+= '';/g,\n      reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g,\n      reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n\n  /** Used to match HTML entities and HTML characters. */\n  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,\n      reUnescapedHtml = /[&<>\"']/g,\n      reHasEscapedHtml = RegExp(reEscapedHtml.source),\n      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n\n  /** Used to match template delimiters. */\n  var reEscape = /<%-([\\s\\S]+?)%>/g,\n      reEvaluate = /<%([\\s\\S]+?)%>/g,\n      reInterpolate = /<%=([\\s\\S]+?)%>/g;\n\n  /** Used to match property names within property paths. */\n  var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n      reIsPlainProp = /^\\w*$/,\n      rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n  /**\n   * Used to match `RegExp`\n   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n   */\n  var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n      reHasRegExpChar = RegExp(reRegExpChar.source);\n\n  /** Used to match leading and trailing whitespace. */\n  var reTrim = /^\\s+|\\s+$/g,\n      reTrimStart = /^\\s+/,\n      reTrimEnd = /\\s+$/;\n\n  /** Used to match wrap detail comments. */\n  var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/,\n      reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/,\n      reSplitDetails = /,? & /;\n\n  /** Used to match words composed of alphanumeric characters. */\n  var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n\n  /** Used to match backslashes in property paths. */\n  var reEscapeChar = /\\\\(\\\\)?/g;\n\n  /**\n   * Used to match\n   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).\n   */\n  var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n\n  /** Used to match `RegExp` flags from their coerced string values. */\n  var reFlags = /\\w*$/;\n\n  /** Used to detect bad signed hexadecimal string values. */\n  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n  /** Used to detect binary string values. */\n  var reIsBinary = /^0b[01]+$/i;\n\n  /** Used to detect host constructors (Safari). */\n  var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n  /** Used to detect octal string values. */\n  var reIsOctal = /^0o[0-7]+$/i;\n\n  /** Used to detect unsigned integer values. */\n  var reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n\n  /** Used to ensure capturing order of template delimiters. */\n  var reNoMatch = /($^)/;\n\n  /** Used to match unescaped characters in compiled string literals. */\n  var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n\n  /** Used to compose unicode character classes. */\n  var rsAstralRange = '\\\\ud800-\\\\udfff',\n      rsComboMarksRange = '\\\\u0300-\\\\u036f',\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,\n      rsDingbatRange = '\\\\u2700-\\\\u27bf',\n      rsLowerRange = 'a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff',\n      rsMathOpRange = '\\\\xac\\\\xb1\\\\xd7\\\\xf7',\n      rsNonCharRange = '\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf',\n      rsPunctuationRange = '\\\\u2000-\\\\u206f',\n      rsSpaceRange = ' \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000',\n      rsUpperRange = 'A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde',\n      rsVarRange = '\\\\ufe0e\\\\ufe0f',\n      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n\n  /** Used to compose unicode capture groups. */\n  var rsApos = \"['\\u2019]\",\n      rsAstral = '[' + rsAstralRange + ']',\n      rsBreak = '[' + rsBreakRange + ']',\n      rsCombo = '[' + rsComboRange + ']',\n      rsDigits = '\\\\d+',\n      rsDingbat = '[' + rsDingbatRange + ']',\n      rsLower = '[' + rsLowerRange + ']',\n      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',\n      rsFitz = '\\\\ud83c[\\\\udffb-\\\\udfff]',\n      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',\n      rsNonAstral = '[^' + rsAstralRange + ']',\n      rsRegional = '(?:\\\\ud83c[\\\\udde6-\\\\uddff]){2}',\n      rsSurrPair = '[\\\\ud800-\\\\udbff][\\\\udc00-\\\\udfff]',\n      rsUpper = '[' + rsUpperRange + ']',\n      rsZWJ = '\\\\u200d';\n\n  /** Used to compose unicode regexes. */\n  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',\n      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',\n      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',\n      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',\n      reOptMod = rsModifier + '?',\n      rsOptVar = '[' + rsVarRange + ']?',\n      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',\n      rsOrdLower = '\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])',\n      rsOrdUpper = '\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])',\n      rsSeq = rsOptVar + reOptMod + rsOptJoin,\n      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,\n      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';\n\n  /** Used to match apostrophes. */\n  var reApos = RegExp(rsApos, 'g');\n\n  /**\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\n   */\n  var reComboMark = RegExp(rsCombo, 'g');\n\n  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */\n  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');\n\n  /** Used to match complex or compound words. */\n  var reUnicodeWord = RegExp([\n    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',\n    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',\n    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,\n    rsUpper + '+' + rsOptContrUpper,\n    rsOrdUpper,\n    rsOrdLower,\n    rsDigits,\n    rsEmoji\n  ].join('|'), 'g');\n\n  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */\n  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');\n\n  /** Used to detect strings that need a more robust regexp to match words. */\n  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n\n  /** Used to assign default `context` object properties. */\n  var contextProps = [\n    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',\n    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',\n    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',\n    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',\n    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'\n  ];\n\n  /** Used to make template sourceURLs easier to identify. */\n  var templateCounter = -1;\n\n  /** Used to identify `toStringTag` values of typed arrays. */\n  var typedArrayTags = {};\n  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\n  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\n  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\n  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\n  typedArrayTags[uint32Tag] = true;\n  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =\n  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\n  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\n  typedArrayTags[errorTag] = typedArrayTags[funcTag] =\n  typedArrayTags[mapTag] = typedArrayTags[numberTag] =\n  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =\n  typedArrayTags[setTag] = typedArrayTags[stringTag] =\n  typedArrayTags[weakMapTag] = false;\n\n  /** Used to identify `toStringTag` values supported by `_.clone`. */\n  var cloneableTags = {};\n  cloneableTags[argsTag] = cloneableTags[arrayTag] =\n  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\n  cloneableTags[boolTag] = cloneableTags[dateTag] =\n  cloneableTags[float32Tag] = cloneableTags[float64Tag] =\n  cloneableTags[int8Tag] = cloneableTags[int16Tag] =\n  cloneableTags[int32Tag] = cloneableTags[mapTag] =\n  cloneableTags[numberTag] = cloneableTags[objectTag] =\n  cloneableTags[regexpTag] = cloneableTags[setTag] =\n  cloneableTags[stringTag] = cloneableTags[symbolTag] =\n  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\n  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n  cloneableTags[errorTag] = cloneableTags[funcTag] =\n  cloneableTags[weakMapTag] = false;\n\n  /** Used to map Latin Unicode letters to basic Latin letters. */\n  var deburredLetters = {\n    // Latin-1 Supplement block.\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\n    '\\xc7': 'C',  '\\xe7': 'c',\n    '\\xd0': 'D',  '\\xf0': 'd',\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\n    '\\xd1': 'N',  '\\xf1': 'n',\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\n    '\\xc6': 'Ae', '\\xe6': 'ae',\n    '\\xde': 'Th', '\\xfe': 'th',\n    '\\xdf': 'ss',\n    // Latin Extended-A block.\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\n    '\\u0134': 'J',  '\\u0135': 'j',\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\n    '\\u0174': 'W',  '\\u0175': 'w',\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\n    '\\u0132': 'IJ', '\\u0133': 'ij',\n    '\\u0152': 'Oe', '\\u0153': 'oe',\n    '\\u0149': \"'n\", '\\u017f': 's'\n  };\n\n  /** Used to map characters to HTML entities. */\n  var htmlEscapes = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  /** Used to map HTML entities to characters. */\n  var htmlUnescapes = {\n    '&amp;': '&',\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&#39;': \"'\"\n  };\n\n  /** Used to escape characters for inclusion in compiled string literals. */\n  var stringEscapes = {\n    '\\\\': '\\\\',\n    \"'\": \"'\",\n    '\\n': 'n',\n    '\\r': 'r',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  /** Built-in method references without a dependency on `root`. */\n  var freeParseFloat = parseFloat,\n      freeParseInt = parseInt;\n\n  /** Detect free variable `global` from Node.js. */\n  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n  /** Detect free variable `self`. */\n  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n  /** Used as a reference to the global object. */\n  var root = freeGlobal || freeSelf || Function('return this')();\n\n  /** Detect free variable `exports`. */\n  var freeExports =  true && exports && !exports.nodeType && exports;\n\n  /** Detect free variable `module`. */\n  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n  /** Detect the popular CommonJS extension `module.exports`. */\n  var moduleExports = freeModule && freeModule.exports === freeExports;\n\n  /** Detect free variable `process` from Node.js. */\n  var freeProcess = moduleExports && freeGlobal.process;\n\n  /** Used to access faster Node.js helpers. */\n  var nodeUtil = (function() {\n    try {\n      // Use `util.types` for Node.js 10+.\n      var types = freeModule && freeModule.require && freeModule.require('util').types;\n\n      if (types) {\n        return types;\n      }\n\n      // Legacy `process.binding('util')` for Node.js < 10.\n      return freeProcess && freeProcess.binding && freeProcess.binding('util');\n    } catch (e) {}\n  }());\n\n  /* Node.js helper references. */\n  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,\n      nodeIsDate = nodeUtil && nodeUtil.isDate,\n      nodeIsMap = nodeUtil && nodeUtil.isMap,\n      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,\n      nodeIsSet = nodeUtil && nodeUtil.isSet,\n      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * A faster alternative to `Function#apply`, this function invokes `func`\n   * with the `this` binding of `thisArg` and the arguments of `args`.\n   *\n   * @private\n   * @param {Function} func The function to invoke.\n   * @param {*} thisArg The `this` binding of `func`.\n   * @param {Array} args The arguments to invoke `func` with.\n   * @returns {*} Returns the result of `func`.\n   */\n  function apply(func, thisArg, args) {\n    switch (args.length) {\n      case 0: return func.call(thisArg);\n      case 1: return func.call(thisArg, args[0]);\n      case 2: return func.call(thisArg, args[0], args[1]);\n      case 3: return func.call(thisArg, args[0], args[1], args[2]);\n    }\n    return func.apply(thisArg, args);\n  }\n\n  /**\n   * A specialized version of `baseAggregator` for arrays.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} setter The function to set `accumulator` values.\n   * @param {Function} iteratee The iteratee to transform keys.\n   * @param {Object} accumulator The initial aggregated object.\n   * @returns {Function} Returns `accumulator`.\n   */\n  function arrayAggregator(array, setter, iteratee, accumulator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      var value = array[index];\n      setter(accumulator, value, iteratee(value), array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.forEach` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEach(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (iteratee(array[index], index, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.forEachRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayEachRight(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n\n    while (length--) {\n      if (iteratee(array[length], length, array) === false) {\n        break;\n      }\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.every` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if all elements pass the predicate check,\n   *  else `false`.\n   */\n  function arrayEvery(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (!predicate(array[index], index, array)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * A specialized version of `_.filter` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {Array} Returns the new filtered array.\n   */\n  function arrayFilter(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (predicate(value, index, array)) {\n        result[resIndex++] = value;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.includes` for arrays without support for\n   * specifying an index to search from.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludes(array, value) {\n    var length = array == null ? 0 : array.length;\n    return !!length && baseIndexOf(array, value, 0) > -1;\n  }\n\n  /**\n   * This function is like `arrayIncludes` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} [array] The array to inspect.\n   * @param {*} target The value to search for.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {boolean} Returns `true` if `target` is found, else `false`.\n   */\n  function arrayIncludesWith(array, value, comparator) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (comparator(value, array[index])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * A specialized version of `_.map` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the new mapped array.\n   */\n  function arrayMap(array, iteratee) {\n    var index = -1,\n        length = array == null ? 0 : array.length,\n        result = Array(length);\n\n    while (++index < length) {\n      result[index] = iteratee(array[index], index, array);\n    }\n    return result;\n  }\n\n  /**\n   * Appends the elements of `values` to `array`.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {Array} values The values to append.\n   * @returns {Array} Returns `array`.\n   */\n  function arrayPush(array, values) {\n    var index = -1,\n        length = values.length,\n        offset = array.length;\n\n    while (++index < length) {\n      array[offset + index] = values[index];\n    }\n    return array;\n  }\n\n  /**\n   * A specialized version of `_.reduce` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the first element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduce(array, iteratee, accumulator, initAccum) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    if (initAccum && length) {\n      accumulator = array[++index];\n    }\n    while (++index < length) {\n      accumulator = iteratee(accumulator, array[index], index, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.reduceRight` for arrays without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} [accumulator] The initial value.\n   * @param {boolean} [initAccum] Specify using the last element of `array` as\n   *  the initial value.\n   * @returns {*} Returns the accumulated value.\n   */\n  function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n    var length = array == null ? 0 : array.length;\n    if (initAccum && length) {\n      accumulator = array[--length];\n    }\n    while (length--) {\n      accumulator = iteratee(accumulator, array[length], length, array);\n    }\n    return accumulator;\n  }\n\n  /**\n   * A specialized version of `_.some` for arrays without support for iteratee\n   * shorthands.\n   *\n   * @private\n   * @param {Array} [array] The array to iterate over.\n   * @param {Function} predicate The function invoked per iteration.\n   * @returns {boolean} Returns `true` if any element passes the predicate check,\n   *  else `false`.\n   */\n  function arraySome(array, predicate) {\n    var index = -1,\n        length = array == null ? 0 : array.length;\n\n    while (++index < length) {\n      if (predicate(array[index], index, array)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Gets the size of an ASCII `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  var asciiSize = baseProperty('length');\n\n  /**\n   * Converts an ASCII `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function asciiToArray(string) {\n    return string.split('');\n  }\n\n  /**\n   * Splits an ASCII `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function asciiWords(string) {\n    return string.match(reAsciiWord) || [];\n  }\n\n  /**\n   * The base implementation of methods like `_.findKey` and `_.findLastKey`,\n   * without support for iteratee shorthands, which iterates over `collection`\n   * using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the found element or its key, else `undefined`.\n   */\n  function baseFindKey(collection, predicate, eachFunc) {\n    var result;\n    eachFunc(collection, function(value, key, collection) {\n      if (predicate(value, key, collection)) {\n        result = key;\n        return false;\n      }\n    });\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.findIndex` and `_.findLastIndex` without\n   * support for iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {Function} predicate The function invoked per iteration.\n   * @param {number} fromIndex The index to search from.\n   * @param {boolean} [fromRight] Specify iterating from right to left.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseFindIndex(array, predicate, fromIndex, fromRight) {\n    var length = array.length,\n        index = fromIndex + (fromRight ? 1 : -1);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (predicate(array[index], index, array)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOf(array, value, fromIndex) {\n    return value === value\n      ? strictIndexOf(array, value, fromIndex)\n      : baseFindIndex(array, baseIsNaN, fromIndex);\n  }\n\n  /**\n   * This function is like `baseIndexOf` except that it accepts a comparator.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @param {Function} comparator The comparator invoked per element.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function baseIndexOfWith(array, value, fromIndex, comparator) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (comparator(array[index], value)) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * The base implementation of `_.isNaN` without support for number objects.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n   */\n  function baseIsNaN(value) {\n    return value !== value;\n  }\n\n  /**\n   * The base implementation of `_.mean` and `_.meanBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the mean.\n   */\n  function baseMean(array, iteratee) {\n    var length = array == null ? 0 : array.length;\n    return length ? (baseSum(array, iteratee) / length) : NAN;\n  }\n\n  /**\n   * The base implementation of `_.property` without support for deep paths.\n   *\n   * @private\n   * @param {string} key The key of the property to get.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function baseProperty(key) {\n    return function(object) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.propertyOf` without support for deep paths.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @returns {Function} Returns the new accessor function.\n   */\n  function basePropertyOf(object) {\n    return function(key) {\n      return object == null ? undefined : object[key];\n    };\n  }\n\n  /**\n   * The base implementation of `_.reduce` and `_.reduceRight`, without support\n   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\n   *\n   * @private\n   * @param {Array|Object} collection The collection to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @param {*} accumulator The initial value.\n   * @param {boolean} initAccum Specify using the first or last element of\n   *  `collection` as the initial value.\n   * @param {Function} eachFunc The function to iterate over `collection`.\n   * @returns {*} Returns the accumulated value.\n   */\n  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n    eachFunc(collection, function(value, index, collection) {\n      accumulator = initAccum\n        ? (initAccum = false, value)\n        : iteratee(accumulator, value, index, collection);\n    });\n    return accumulator;\n  }\n\n  /**\n   * The base implementation of `_.sortBy` which uses `comparer` to define the\n   * sort order of `array` and replaces criteria objects with their corresponding\n   * values.\n   *\n   * @private\n   * @param {Array} array The array to sort.\n   * @param {Function} comparer The function to define sort order.\n   * @returns {Array} Returns `array`.\n   */\n  function baseSortBy(array, comparer) {\n    var length = array.length;\n\n    array.sort(comparer);\n    while (length--) {\n      array[length] = array[length].value;\n    }\n    return array;\n  }\n\n  /**\n   * The base implementation of `_.sum` and `_.sumBy` without support for\n   * iteratee shorthands.\n   *\n   * @private\n   * @param {Array} array The array to iterate over.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {number} Returns the sum.\n   */\n  function baseSum(array, iteratee) {\n    var result,\n        index = -1,\n        length = array.length;\n\n    while (++index < length) {\n      var current = iteratee(array[index]);\n      if (current !== undefined) {\n        result = result === undefined ? current : (result + current);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.times` without support for iteratee shorthands\n   * or max array length checks.\n   *\n   * @private\n   * @param {number} n The number of times to invoke `iteratee`.\n   * @param {Function} iteratee The function invoked per iteration.\n   * @returns {Array} Returns the array of results.\n   */\n  function baseTimes(n, iteratee) {\n    var index = -1,\n        result = Array(n);\n\n    while (++index < n) {\n      result[index] = iteratee(index);\n    }\n    return result;\n  }\n\n  /**\n   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array\n   * of key-value pairs for `object` corresponding to the property names of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the key-value pairs.\n   */\n  function baseToPairs(object, props) {\n    return arrayMap(props, function(key) {\n      return [key, object[key]];\n    });\n  }\n\n  /**\n   * The base implementation of `_.unary` without support for storing metadata.\n   *\n   * @private\n   * @param {Function} func The function to cap arguments for.\n   * @returns {Function} Returns the new capped function.\n   */\n  function baseUnary(func) {\n    return function(value) {\n      return func(value);\n    };\n  }\n\n  /**\n   * The base implementation of `_.values` and `_.valuesIn` which creates an\n   * array of `object` property values corresponding to the property names\n   * of `props`.\n   *\n   * @private\n   * @param {Object} object The object to query.\n   * @param {Array} props The property names to get values for.\n   * @returns {Object} Returns the array of property values.\n   */\n  function baseValues(object, props) {\n    return arrayMap(props, function(key) {\n      return object[key];\n    });\n  }\n\n  /**\n   * Checks if a `cache` value for `key` exists.\n   *\n   * @private\n   * @param {Object} cache The cache to query.\n   * @param {string} key The key of the entry to check.\n   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n   */\n  function cacheHas(cache, key) {\n    return cache.has(key);\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the first unmatched string symbol.\n   */\n  function charsStartIndex(strSymbols, chrSymbols) {\n    var index = -1,\n        length = strSymbols.length;\n\n    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol\n   * that is not found in the character symbols.\n   *\n   * @private\n   * @param {Array} strSymbols The string symbols to inspect.\n   * @param {Array} chrSymbols The character symbols to find.\n   * @returns {number} Returns the index of the last unmatched string symbol.\n   */\n  function charsEndIndex(strSymbols, chrSymbols) {\n    var index = strSymbols.length;\n\n    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}\n    return index;\n  }\n\n  /**\n   * Gets the number of `placeholder` occurrences in `array`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} placeholder The placeholder to search for.\n   * @returns {number} Returns the placeholder count.\n   */\n  function countHolders(array, placeholder) {\n    var length = array.length,\n        result = 0;\n\n    while (length--) {\n      if (array[length] === placeholder) {\n        ++result;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A\n   * letters to basic Latin letters.\n   *\n   * @private\n   * @param {string} letter The matched letter to deburr.\n   * @returns {string} Returns the deburred letter.\n   */\n  var deburrLetter = basePropertyOf(deburredLetters);\n\n  /**\n   * Used by `_.escape` to convert characters to HTML entities.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  var escapeHtmlChar = basePropertyOf(htmlEscapes);\n\n  /**\n   * Used by `_.template` to escape characters for inclusion in compiled string literals.\n   *\n   * @private\n   * @param {string} chr The matched character to escape.\n   * @returns {string} Returns the escaped character.\n   */\n  function escapeStringChar(chr) {\n    return '\\\\' + stringEscapes[chr];\n  }\n\n  /**\n   * Gets the value at `key` of `object`.\n   *\n   * @private\n   * @param {Object} [object] The object to query.\n   * @param {string} key The key of the property to get.\n   * @returns {*} Returns the property value.\n   */\n  function getValue(object, key) {\n    return object == null ? undefined : object[key];\n  }\n\n  /**\n   * Checks if `string` contains Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a symbol is found, else `false`.\n   */\n  function hasUnicode(string) {\n    return reHasUnicode.test(string);\n  }\n\n  /**\n   * Checks if `string` contains a word composed of Unicode symbols.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {boolean} Returns `true` if a word is found, else `false`.\n   */\n  function hasUnicodeWord(string) {\n    return reHasUnicodeWord.test(string);\n  }\n\n  /**\n   * Converts `iterator` to an array.\n   *\n   * @private\n   * @param {Object} iterator The iterator to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function iteratorToArray(iterator) {\n    var data,\n        result = [];\n\n    while (!(data = iterator.next()).done) {\n      result.push(data.value);\n    }\n    return result;\n  }\n\n  /**\n   * Converts `map` to its key-value pairs.\n   *\n   * @private\n   * @param {Object} map The map to convert.\n   * @returns {Array} Returns the key-value pairs.\n   */\n  function mapToArray(map) {\n    var index = -1,\n        result = Array(map.size);\n\n    map.forEach(function(value, key) {\n      result[++index] = [key, value];\n    });\n    return result;\n  }\n\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n  function overArg(func, transform) {\n    return function(arg) {\n      return func(transform(arg));\n    };\n  }\n\n  /**\n   * Replaces all `placeholder` elements in `array` with an internal placeholder\n   * and returns an array of their indexes.\n   *\n   * @private\n   * @param {Array} array The array to modify.\n   * @param {*} placeholder The placeholder to replace.\n   * @returns {Array} Returns the new array of placeholder indexes.\n   */\n  function replaceHolders(array, placeholder) {\n    var index = -1,\n        length = array.length,\n        resIndex = 0,\n        result = [];\n\n    while (++index < length) {\n      var value = array[index];\n      if (value === placeholder || value === PLACEHOLDER) {\n        array[index] = PLACEHOLDER;\n        result[resIndex++] = index;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Converts `set` to an array of its values.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the values.\n   */\n  function setToArray(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = value;\n    });\n    return result;\n  }\n\n  /**\n   * Converts `set` to its value-value pairs.\n   *\n   * @private\n   * @param {Object} set The set to convert.\n   * @returns {Array} Returns the value-value pairs.\n   */\n  function setToPairs(set) {\n    var index = -1,\n        result = Array(set.size);\n\n    set.forEach(function(value) {\n      result[++index] = [value, value];\n    });\n    return result;\n  }\n\n  /**\n   * A specialized version of `_.indexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictIndexOf(array, value, fromIndex) {\n    var index = fromIndex - 1,\n        length = array.length;\n\n    while (++index < length) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * A specialized version of `_.lastIndexOf` which performs strict equality\n   * comparisons of values, i.e. `===`.\n   *\n   * @private\n   * @param {Array} array The array to inspect.\n   * @param {*} value The value to search for.\n   * @param {number} fromIndex The index to search from.\n   * @returns {number} Returns the index of the matched value, else `-1`.\n   */\n  function strictLastIndexOf(array, value, fromIndex) {\n    var index = fromIndex + 1;\n    while (index--) {\n      if (array[index] === value) {\n        return index;\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Gets the number of symbols in `string`.\n   *\n   * @private\n   * @param {string} string The string to inspect.\n   * @returns {number} Returns the string size.\n   */\n  function stringSize(string) {\n    return hasUnicode(string)\n      ? unicodeSize(string)\n      : asciiSize(string);\n  }\n\n  /**\n   * Converts `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function stringToArray(string) {\n    return hasUnicode(string)\n      ? unicodeToArray(string)\n      : asciiToArray(string);\n  }\n\n  /**\n   * Used by `_.unescape` to convert HTML entities to characters.\n   *\n   * @private\n   * @param {string} chr The matched character to unescape.\n   * @returns {string} Returns the unescaped character.\n   */\n  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n\n  /**\n   * Gets the size of a Unicode `string`.\n   *\n   * @private\n   * @param {string} string The string inspect.\n   * @returns {number} Returns the string size.\n   */\n  function unicodeSize(string) {\n    var result = reUnicode.lastIndex = 0;\n    while (reUnicode.test(string)) {\n      ++result;\n    }\n    return result;\n  }\n\n  /**\n   * Converts a Unicode `string` to an array.\n   *\n   * @private\n   * @param {string} string The string to convert.\n   * @returns {Array} Returns the converted array.\n   */\n  function unicodeToArray(string) {\n    return string.match(reUnicode) || [];\n  }\n\n  /**\n   * Splits a Unicode `string` into an array of its words.\n   *\n   * @private\n   * @param {string} The string to inspect.\n   * @returns {Array} Returns the words of `string`.\n   */\n  function unicodeWords(string) {\n    return string.match(reUnicodeWord) || [];\n  }\n\n  /*--------------------------------------------------------------------------*/\n\n  /**\n   * Create a new pristine `lodash` function using the `context` object.\n   *\n   * @static\n   * @memberOf _\n   * @since 1.1.0\n   * @category Util\n   * @param {Object} [context=root] The context object.\n   * @returns {Function} Returns a new `lodash` function.\n   * @example\n   *\n   * _.mixin({ 'foo': _.constant('foo') });\n   *\n   * var lodash = _.runInContext();\n   * lodash.mixin({ 'bar': lodash.constant('bar') });\n   *\n   * _.isFunction(_.foo);\n   * // => true\n   * _.isFunction(_.bar);\n   * // => false\n   *\n   * lodash.isFunction(lodash.foo);\n   * // => false\n   * lodash.isFunction(lodash.bar);\n   * // => true\n   *\n   * // Create a suped-up `defer` in Node.js.\n   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;\n   */\n  var runInContext = (function runInContext(context) {\n    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n\n    /** Built-in constructor references. */\n    var Array = context.Array,\n        Date = context.Date,\n        Error = context.Error,\n        Function = context.Function,\n        Math = context.Math,\n        Object = context.Object,\n        RegExp = context.RegExp,\n        String = context.String,\n        TypeError = context.TypeError;\n\n    /** Used for built-in method references. */\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n\n    /** Used to detect overreaching core-js shims. */\n    var coreJsData = context['__core-js_shared__'];\n\n    /** Used to resolve the decompiled source of functions. */\n    var funcToString = funcProto.toString;\n\n    /** Used to check objects for own properties. */\n    var hasOwnProperty = objectProto.hasOwnProperty;\n\n    /** Used to generate unique IDs. */\n    var idCounter = 0;\n\n    /** Used to detect methods masquerading as native. */\n    var maskSrcKey = (function() {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? ('Symbol(src)_1.' + uid) : '';\n    }());\n\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n    var nativeObjectToString = objectProto.toString;\n\n    /** Used to infer the `Object` constructor. */\n    var objectCtorString = funcToString.call(Object);\n\n    /** Used to restore the original `_` reference in `_.noConflict`. */\n    var oldDash = root._;\n\n    /** Used to detect if a method is native. */\n    var reIsNative = RegExp('^' +\n      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n      .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n    );\n\n    /** Built-in value references. */\n    var Buffer = moduleExports ? context.Buffer : undefined,\n        Symbol = context.Symbol,\n        Uint8Array = context.Uint8Array,\n        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice,\n        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n        symIterator = Symbol ? Symbol.iterator : undefined,\n        symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n    var defineProperty = (function() {\n      try {\n        var func = getNative(Object, 'defineProperty');\n        func({}, '', {});\n        return func;\n      } catch (e) {}\n    }());\n\n    /** Mocked built-ins. */\n    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,\n        ctxNow = Date && Date.now !== root.Date.now && Date.now,\n        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n    var nativeCeil = Math.ceil,\n        nativeFloor = Math.floor,\n        nativeGetSymbols = Object.getOwnPropertySymbols,\n        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeIsFinite = context.isFinite,\n        nativeJoin = arrayProto.join,\n        nativeKeys = overArg(Object.keys, Object),\n        nativeMax = Math.max,\n        nativeMin = Math.min,\n        nativeNow = Date.now,\n        nativeParseInt = context.parseInt,\n        nativeRandom = Math.random,\n        nativeReverse = arrayProto.reverse;\n\n    /* Built-in method references that are verified to be native. */\n    var DataView = getNative(context, 'DataView'),\n        Map = getNative(context, 'Map'),\n        Promise = getNative(context, 'Promise'),\n        Set = getNative(context, 'Set'),\n        WeakMap = getNative(context, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n\n    /** Used to store function metadata. */\n    var metaMap = WeakMap && new WeakMap;\n\n    /** Used to lookup unminified function names. */\n    var realNames = {};\n\n    /** Used to detect maps, sets, and weakmaps. */\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n\n    /** Used to convert symbols to primitives and strings. */\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` object which wraps `value` to enable implicit method\n     * chain sequences. Methods that operate on and return arrays, collections,\n     * and functions can be chained together. Methods that retrieve a single value\n     * or may return a primitive value will automatically end the chain sequence\n     * and return the unwrapped value. Otherwise, the value must be unwrapped\n     * with `_#value`.\n     *\n     * Explicit chain sequences, which must be unwrapped with `_#value`, may be\n     * enabled using `_.chain`.\n     *\n     * The execution of chained methods is lazy, that is, it's deferred until\n     * `_#value` is implicitly or explicitly called.\n     *\n     * Lazy evaluation allows several methods to support shortcut fusion.\n     * Shortcut fusion is an optimization to merge iteratee calls; this avoids\n     * the creation of intermediate arrays and can greatly reduce the number of\n     * iteratee executions. Sections of a chain sequence qualify for shortcut\n     * fusion if the section is applied to an array and iteratees accept only\n     * one argument. The heuristic for whether a section qualifies for shortcut\n     * fusion is subject to change.\n     *\n     * Chaining is supported in custom builds as long as the `_#value` method is\n     * directly or indirectly included in the build.\n     *\n     * In addition to lodash methods, wrappers have `Array` and `String` methods.\n     *\n     * The wrapper `Array` methods are:\n     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`\n     *\n     * The wrapper `String` methods are:\n     * `replace` and `split`\n     *\n     * The wrapper methods that support shortcut fusion are:\n     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,\n     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,\n     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`\n     *\n     * The chainable wrapper methods are:\n     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,\n     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,\n     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,\n     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,\n     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,\n     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,\n     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,\n     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,\n     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,\n     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,\n     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,\n     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,\n     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,\n     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,\n     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,\n     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,\n     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,\n     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,\n     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,\n     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,\n     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,\n     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,\n     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,\n     * `zipObject`, `zipObjectDeep`, and `zipWith`\n     *\n     * The wrapper methods that are **not** chainable by default are:\n     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,\n     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,\n     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,\n     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,\n     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,\n     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,\n     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,\n     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,\n     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,\n     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,\n     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,\n     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,\n     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,\n     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,\n     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,\n     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,\n     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,\n     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,\n     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,\n     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,\n     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,\n     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,\n     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,\n     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,\n     * `upperFirst`, `value`, and `words`\n     *\n     * @name _\n     * @constructor\n     * @category Seq\n     * @param {*} value The value to wrap in a `lodash` instance.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2, 3]);\n     *\n     * // Returns an unwrapped value.\n     * wrapped.reduce(_.add);\n     * // => 6\n     *\n     * // Returns a wrapped value.\n     * var squares = wrapped.map(square);\n     *\n     * _.isArray(squares);\n     * // => false\n     *\n     * _.isArray(squares.value());\n     * // => true\n     */\n    function lodash(value) {\n      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n        if (value instanceof LodashWrapper) {\n          return value;\n        }\n        if (hasOwnProperty.call(value, '__wrapped__')) {\n          return wrapperClone(value);\n        }\n      }\n      return new LodashWrapper(value);\n    }\n\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} proto The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n    var baseCreate = (function() {\n      function object() {}\n      return function(proto) {\n        if (!isObject(proto)) {\n          return {};\n        }\n        if (objectCreate) {\n          return objectCreate(proto);\n        }\n        object.prototype = proto;\n        var result = new object;\n        object.prototype = undefined;\n        return result;\n      };\n    }());\n\n    /**\n     * The function whose prototype chain sequence wrappers inherit from.\n     *\n     * @private\n     */\n    function baseLodash() {\n      // No operation performed.\n    }\n\n    /**\n     * The base constructor for creating `lodash` wrapper objects.\n     *\n     * @private\n     * @param {*} value The value to wrap.\n     * @param {boolean} [chainAll] Enable explicit method chain sequences.\n     */\n    function LodashWrapper(value, chainAll) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__chain__ = !!chainAll;\n      this.__index__ = 0;\n      this.__values__ = undefined;\n    }\n\n    /**\n     * By default, the template delimiters used by lodash are like those in\n     * embedded Ruby (ERB) as well as ES2015 template strings. Change the\n     * following template settings to use alternative delimiters.\n     *\n     * @static\n     * @memberOf _\n     * @type {Object}\n     */\n    lodash.templateSettings = {\n\n      /**\n       * Used to detect `data` property values to be HTML-escaped.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'escape': reEscape,\n\n      /**\n       * Used to detect code to be evaluated.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'evaluate': reEvaluate,\n\n      /**\n       * Used to detect `data` property values to inject.\n       *\n       * @memberOf _.templateSettings\n       * @type {RegExp}\n       */\n      'interpolate': reInterpolate,\n\n      /**\n       * Used to reference the data object in the template text.\n       *\n       * @memberOf _.templateSettings\n       * @type {string}\n       */\n      'variable': '',\n\n      /**\n       * Used to import variables into the compiled template.\n       *\n       * @memberOf _.templateSettings\n       * @type {Object}\n       */\n      'imports': {\n\n        /**\n         * A reference to the `lodash` function.\n         *\n         * @memberOf _.templateSettings.imports\n         * @type {Function}\n         */\n        '_': lodash\n      }\n    };\n\n    // Ensure wrappers are instances of `baseLodash`.\n    lodash.prototype = baseLodash.prototype;\n    lodash.prototype.constructor = lodash;\n\n    LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n    LodashWrapper.prototype.constructor = LodashWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.\n     *\n     * @private\n     * @constructor\n     * @param {*} value The value to wrap.\n     */\n    function LazyWrapper(value) {\n      this.__wrapped__ = value;\n      this.__actions__ = [];\n      this.__dir__ = 1;\n      this.__filtered__ = false;\n      this.__iteratees__ = [];\n      this.__takeCount__ = MAX_ARRAY_LENGTH;\n      this.__views__ = [];\n    }\n\n    /**\n     * Creates a clone of the lazy wrapper object.\n     *\n     * @private\n     * @name clone\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the cloned `LazyWrapper` object.\n     */\n    function lazyClone() {\n      var result = new LazyWrapper(this.__wrapped__);\n      result.__actions__ = copyArray(this.__actions__);\n      result.__dir__ = this.__dir__;\n      result.__filtered__ = this.__filtered__;\n      result.__iteratees__ = copyArray(this.__iteratees__);\n      result.__takeCount__ = this.__takeCount__;\n      result.__views__ = copyArray(this.__views__);\n      return result;\n    }\n\n    /**\n     * Reverses the direction of lazy iteration.\n     *\n     * @private\n     * @name reverse\n     * @memberOf LazyWrapper\n     * @returns {Object} Returns the new reversed `LazyWrapper` object.\n     */\n    function lazyReverse() {\n      if (this.__filtered__) {\n        var result = new LazyWrapper(this);\n        result.__dir__ = -1;\n        result.__filtered__ = true;\n      } else {\n        result = this.clone();\n        result.__dir__ *= -1;\n      }\n      return result;\n    }\n\n    /**\n     * Extracts the unwrapped value from its lazy wrapper.\n     *\n     * @private\n     * @name value\n     * @memberOf LazyWrapper\n     * @returns {*} Returns the unwrapped value.\n     */\n    function lazyValue() {\n      var array = this.__wrapped__.value(),\n          dir = this.__dir__,\n          isArr = isArray(array),\n          isRight = dir < 0,\n          arrLength = isArr ? array.length : 0,\n          view = getView(0, arrLength, this.__views__),\n          start = view.start,\n          end = view.end,\n          length = end - start,\n          index = isRight ? end : (start - 1),\n          iteratees = this.__iteratees__,\n          iterLength = iteratees.length,\n          resIndex = 0,\n          takeCount = nativeMin(length, this.__takeCount__);\n\n      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {\n        return baseWrapperValue(array, this.__actions__);\n      }\n      var result = [];\n\n      outer:\n      while (length-- && resIndex < takeCount) {\n        index += dir;\n\n        var iterIndex = -1,\n            value = array[index];\n\n        while (++iterIndex < iterLength) {\n          var data = iteratees[iterIndex],\n              iteratee = data.iteratee,\n              type = data.type,\n              computed = iteratee(value);\n\n          if (type == LAZY_MAP_FLAG) {\n            value = computed;\n          } else if (!computed) {\n            if (type == LAZY_FILTER_FLAG) {\n              continue outer;\n            } else {\n              break outer;\n            }\n          }\n        }\n        result[resIndex++] = value;\n      }\n      return result;\n    }\n\n    // Ensure `LazyWrapper` is an instance of `baseLodash`.\n    LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n    LazyWrapper.prototype.constructor = LazyWrapper;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Hash(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function hashDelete(key) {\n      var result = this.has(key) && delete this.__data__[key];\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function hashGet(key) {\n      var data = this.__data__;\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n    }\n\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n    function hashSet(key, value) {\n      var data = this.__data__;\n      this.size += this.has(key) ? 0 : 1;\n      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n      return this;\n    }\n\n    // Add methods to `Hash`.\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function ListCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n    function listCacheClear() {\n      this.__data__ = [];\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n      var lastIndex = data.length - 1;\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n      --this.size;\n      return true;\n    }\n\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      return index < 0 ? undefined : data[index][1];\n    }\n\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        ++this.size;\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n      return this;\n    }\n\n    // Add methods to `ListCache`.\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function MapCache(entries) {\n      var index = -1,\n          length = entries == null ? 0 : entries.length;\n\n      this.clear();\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n    function mapCacheClear() {\n      this.size = 0;\n      this.__data__ = {\n        'hash': new Hash,\n        'map': new (Map || ListCache),\n        'string': new Hash\n      };\n    }\n\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function mapCacheDelete(key) {\n      var result = getMapData(this, key)['delete'](key);\n      this.size -= result ? 1 : 0;\n      return result;\n    }\n\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n    function mapCacheSet(key, value) {\n      var data = getMapData(this, key),\n          size = data.size;\n\n      data.set(key, value);\n      this.size += data.size == size ? 0 : 1;\n      return this;\n    }\n\n    // Add methods to `MapCache`.\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n    function SetCache(values) {\n      var index = -1,\n          length = values == null ? 0 : values.length;\n\n      this.__data__ = new MapCache;\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n      return this;\n    }\n\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    }\n\n    // Add methods to `SetCache`.\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n    function Stack(entries) {\n      var data = this.__data__ = new ListCache(entries);\n      this.size = data.size;\n    }\n\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n    function stackClear() {\n      this.__data__ = new ListCache;\n      this.size = 0;\n    }\n\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n    function stackDelete(key) {\n      var data = this.__data__,\n          result = data['delete'](key);\n\n      this.size = data.size;\n      return result;\n    }\n\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n    function stackSet(key, value) {\n      var data = this.__data__;\n      if (data instanceof ListCache) {\n        var pairs = data.__data__;\n        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n          pairs.push([key, value]);\n          this.size = ++data.size;\n          return this;\n        }\n        data = this.__data__ = new MapCache(pairs);\n      }\n      data.set(key, value);\n      this.size = data.size;\n      return this;\n    }\n\n    // Add methods to `Stack`.\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n    function arrayLikeKeys(value, inherited) {\n      var isArr = isArray(value),\n          isArg = !isArr && isArguments(value),\n          isBuff = !isArr && !isArg && isBuffer(value),\n          isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n          skipIndexes = isArr || isArg || isBuff || isType,\n          result = skipIndexes ? baseTimes(value.length, String) : [],\n          length = result.length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) &&\n            !(skipIndexes && (\n               // Safari 9 has enumerable `arguments.length` in strict mode.\n               key == 'length' ||\n               // Node.js 0.10 has enumerable non-index properties on buffers.\n               (isBuff && (key == 'offset' || key == 'parent')) ||\n               // PhantomJS 2 has enumerable non-index properties on typed arrays.\n               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n               // Skip index properties.\n               isIndex(key, length)\n            ))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `_.sample` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @returns {*} Returns the random element.\n     */\n    function arraySample(array) {\n      var length = array.length;\n      return length ? array[baseRandom(0, length - 1)] : undefined;\n    }\n\n    /**\n     * A specialized version of `_.sampleSize` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function arraySampleSize(array, n) {\n      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * A specialized version of `_.shuffle` for arrays.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function arrayShuffle(array) {\n      return shuffleSelf(copyArray(array));\n    }\n\n    /**\n     * This function is like `assignValue` except that it doesn't assign\n     * `undefined` values.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignMergeValue(object, key, value) {\n      if ((value !== undefined && !eq(object[key], value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Assigns `value` to `key` of `object` if the existing value is not equivalent\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function assignValue(object, key, value) {\n      var objValue = object[key];\n      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n          (value === undefined && !(key in object))) {\n        baseAssignValue(object, key, value);\n      }\n    }\n\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n    function assocIndexOf(array, key) {\n      var length = array.length;\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * Aggregates elements of `collection` on `accumulator` with keys transformed\n     * by `iteratee` and values set by `setter`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform keys.\n     * @param {Object} accumulator The initial aggregated object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseAggregator(collection, setter, iteratee, accumulator) {\n      baseEach(collection, function(value, key, collection) {\n        setter(accumulator, value, iteratee(value), collection);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.assign` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssign(object, source) {\n      return object && copyObject(source, keys(source), object);\n    }\n\n    /**\n     * The base implementation of `_.assignIn` without support for multiple sources\n     * or `customizer` functions.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @returns {Object} Returns `object`.\n     */\n    function baseAssignIn(object, source) {\n      return object && copyObject(source, keysIn(source), object);\n    }\n\n    /**\n     * The base implementation of `assignValue` and `assignMergeValue` without\n     * value checks.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {string} key The key of the property to assign.\n     * @param {*} value The value to assign.\n     */\n    function baseAssignValue(object, key, value) {\n      if (key == '__proto__' && defineProperty) {\n        defineProperty(object, key, {\n          'configurable': true,\n          'enumerable': true,\n          'value': value,\n          'writable': true\n        });\n      } else {\n        object[key] = value;\n      }\n    }\n\n    /**\n     * The base implementation of `_.at` without support for individual paths.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Array} Returns the picked elements.\n     */\n    function baseAt(object, paths) {\n      var index = -1,\n          length = paths.length,\n          result = Array(length),\n          skip = object == null;\n\n      while (++index < length) {\n        result[index] = skip ? undefined : get(object, paths[index]);\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.clamp` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     */\n    function baseClamp(number, lower, upper) {\n      if (number === number) {\n        if (upper !== undefined) {\n          number = number <= upper ? number : upper;\n        }\n        if (lower !== undefined) {\n          number = number >= lower ? number : lower;\n        }\n      }\n      return number;\n    }\n\n    /**\n     * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n     * traversed objects.\n     *\n     * @private\n     * @param {*} value The value to clone.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Deep clone\n     *  2 - Flatten inherited properties\n     *  4 - Clone symbols\n     * @param {Function} [customizer] The function to customize cloning.\n     * @param {string} [key] The key of `value`.\n     * @param {Object} [object] The parent object of `value`.\n     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n     * @returns {*} Returns the cloned value.\n     */\n    function baseClone(value, bitmask, customizer, key, object, stack) {\n      var result,\n          isDeep = bitmask & CLONE_DEEP_FLAG,\n          isFlat = bitmask & CLONE_FLAT_FLAG,\n          isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n      if (customizer) {\n        result = object ? customizer(value, key, object, stack) : customizer(value);\n      }\n      if (result !== undefined) {\n        return result;\n      }\n      if (!isObject(value)) {\n        return value;\n      }\n      var isArr = isArray(value);\n      if (isArr) {\n        result = initCloneArray(value);\n        if (!isDeep) {\n          return copyArray(value, result);\n        }\n      } else {\n        var tag = getTag(value),\n            isFunc = tag == funcTag || tag == genTag;\n\n        if (isBuffer(value)) {\n          return cloneBuffer(value, isDeep);\n        }\n        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n          result = (isFlat || isFunc) ? {} : initCloneObject(value);\n          if (!isDeep) {\n            return isFlat\n              ? copySymbolsIn(value, baseAssignIn(result, value))\n              : copySymbols(value, baseAssign(result, value));\n          }\n        } else {\n          if (!cloneableTags[tag]) {\n            return object ? value : {};\n          }\n          result = initCloneByTag(value, tag, isDeep);\n        }\n      }\n      // Check for circular references and return its corresponding clone.\n      stack || (stack = new Stack);\n      var stacked = stack.get(value);\n      if (stacked) {\n        return stacked;\n      }\n      stack.set(value, result);\n\n      if (isSet(value)) {\n        value.forEach(function(subValue) {\n          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n        });\n      } else if (isMap(value)) {\n        value.forEach(function(subValue, key) {\n          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n        });\n      }\n\n      var keysFunc = isFull\n        ? (isFlat ? getAllKeysIn : getAllKeys)\n        : (isFlat ? keysIn : keys);\n\n      var props = isArr ? undefined : keysFunc(value);\n      arrayEach(props || value, function(subValue, key) {\n        if (props) {\n          key = subValue;\n          subValue = value[key];\n        }\n        // Recursively populate clone (susceptible to call stack limits).\n        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.conforms` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseConforms(source) {\n      var props = keys(source);\n      return function(object) {\n        return baseConformsTo(object, source, props);\n      };\n    }\n\n    /**\n     * The base implementation of `_.conformsTo` which accepts `props` to check.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     */\n    function baseConformsTo(object, source, props) {\n      var length = props.length;\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (length--) {\n        var key = props[length],\n            predicate = source[key],\n            value = object[key];\n\n        if ((value === undefined && !(key in object)) || !predicate(value)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.delay` and `_.defer` which accepts `args`\n     * to provide to `func`.\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {Array} args The arguments to provide to `func`.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    function baseDelay(func, wait, args) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return setTimeout(function() { func.apply(undefined, args); }, wait);\n    }\n\n    /**\n     * The base implementation of methods like `_.difference` without support\n     * for excluding multiple arrays or iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Array} values The values to exclude.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     */\n    function baseDifference(array, values, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          isCommon = true,\n          length = array.length,\n          result = [],\n          valuesLength = values.length;\n\n      if (!length) {\n        return result;\n      }\n      if (iteratee) {\n        values = arrayMap(values, baseUnary(iteratee));\n      }\n      if (comparator) {\n        includes = arrayIncludesWith;\n        isCommon = false;\n      }\n      else if (values.length >= LARGE_ARRAY_SIZE) {\n        includes = cacheHas;\n        isCommon = false;\n        values = new SetCache(values);\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee == null ? value : iteratee(value);\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var valuesIndex = valuesLength;\n          while (valuesIndex--) {\n            if (values[valuesIndex] === computed) {\n              continue outer;\n            }\n          }\n          result.push(value);\n        }\n        else if (!includes(values, computed, comparator)) {\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.forEach` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEach = createBaseEach(baseForOwn);\n\n    /**\n     * The base implementation of `_.forEachRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     */\n    var baseEachRight = createBaseEach(baseForOwnRight, true);\n\n    /**\n     * The base implementation of `_.every` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`\n     */\n    function baseEvery(collection, predicate) {\n      var result = true;\n      baseEach(collection, function(value, index, collection) {\n        result = !!predicate(value, index, collection);\n        return result;\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of methods like `_.max` and `_.min` which accepts a\n     * `comparator` to determine the extremum value.\n     *\n     * @private\n     * @param {Array} array The array to iterate over.\n     * @param {Function} iteratee The iteratee invoked per iteration.\n     * @param {Function} comparator The comparator used to compare values.\n     * @returns {*} Returns the extremum value.\n     */\n    function baseExtremum(array, iteratee, comparator) {\n      var index = -1,\n          length = array.length;\n\n      while (++index < length) {\n        var value = array[index],\n            current = iteratee(value);\n\n        if (current != null && (computed === undefined\n              ? (current === current && !isSymbol(current))\n              : comparator(current, computed)\n            )) {\n          var computed = current,\n              result = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.fill` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     */\n    function baseFill(array, value, start, end) {\n      var length = array.length;\n\n      start = toInteger(start);\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = (end === undefined || end > length) ? length : toInteger(end);\n      if (end < 0) {\n        end += length;\n      }\n      end = start > end ? 0 : toLength(end);\n      while (start < end) {\n        array[start++] = value;\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.filter` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     */\n    function baseFilter(collection, predicate) {\n      var result = [];\n      baseEach(collection, function(value, index, collection) {\n        if (predicate(value, index, collection)) {\n          result.push(value);\n        }\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.flatten` with support for restricting flattening.\n     *\n     * @private\n     * @param {Array} array The array to flatten.\n     * @param {number} depth The maximum recursion depth.\n     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n     * @param {Array} [result=[]] The initial result value.\n     * @returns {Array} Returns the new flattened array.\n     */\n    function baseFlatten(array, depth, predicate, isStrict, result) {\n      var index = -1,\n          length = array.length;\n\n      predicate || (predicate = isFlattenable);\n      result || (result = []);\n\n      while (++index < length) {\n        var value = array[index];\n        if (depth > 0 && predicate(value)) {\n          if (depth > 1) {\n            // Recursively flatten arrays (susceptible to call stack limits).\n            baseFlatten(value, depth - 1, predicate, isStrict, result);\n          } else {\n            arrayPush(result, value);\n          }\n        } else if (!isStrict) {\n          result[result.length] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseFor = createBaseFor();\n\n    /**\n     * This function is like `baseFor` except that it iterates over properties\n     * in the opposite order.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n    var baseForRight = createBaseFor(true);\n\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n    function baseForOwnRight(object, iteratee) {\n      return object && baseForRight(object, iteratee, keys);\n    }\n\n    /**\n     * The base implementation of `_.functions` which creates an array of\n     * `object` function property names filtered from `props`.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Array} props The property names to filter.\n     * @returns {Array} Returns the function names.\n     */\n    function baseFunctions(object, props) {\n      return arrayFilter(props, function(key) {\n        return isFunction(object[key]);\n      });\n    }\n\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseGet(object, path) {\n      path = castPath(path, object);\n\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n      return (index && index == length) ? object : undefined;\n    }\n\n    /**\n     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n     * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @param {Function} symbolsFunc The function to get the symbols of `object`.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n      var result = keysFunc(object);\n      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n    }\n\n    /**\n     * The base implementation of `getTag` without fallbacks for buggy environments.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    function baseGetTag(value) {\n      if (value == null) {\n        return value === undefined ? undefinedTag : nullTag;\n      }\n      return (symToStringTag && symToStringTag in Object(value))\n        ? getRawTag(value)\n        : objectToString(value);\n    }\n\n    /**\n     * The base implementation of `_.gt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     */\n    function baseGt(value, other) {\n      return value > other;\n    }\n\n    /**\n     * The base implementation of `_.has` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHas(object, key) {\n      return object != null && hasOwnProperty.call(object, key);\n    }\n\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n\n    /**\n     * The base implementation of `_.inRange` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {number} number The number to check.\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     */\n    function baseInRange(number, start, end) {\n      return number >= nativeMin(start, end) && number < nativeMax(start, end);\n    }\n\n    /**\n     * The base implementation of methods like `_.intersection`, without support\n     * for iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of shared values.\n     */\n    function baseIntersection(arrays, iteratee, comparator) {\n      var includes = comparator ? arrayIncludesWith : arrayIncludes,\n          length = arrays[0].length,\n          othLength = arrays.length,\n          othIndex = othLength,\n          caches = Array(othLength),\n          maxLength = Infinity,\n          result = [];\n\n      while (othIndex--) {\n        var array = arrays[othIndex];\n        if (othIndex && iteratee) {\n          array = arrayMap(array, baseUnary(iteratee));\n        }\n        maxLength = nativeMin(array.length, maxLength);\n        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n          ? new SetCache(othIndex && array)\n          : undefined;\n      }\n      array = arrays[0];\n\n      var index = -1,\n          seen = caches[0];\n\n      outer:\n      while (++index < length && result.length < maxLength) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (!(seen\n              ? cacheHas(seen, computed)\n              : includes(result, computed, comparator)\n            )) {\n          othIndex = othLength;\n          while (--othIndex) {\n            var cache = caches[othIndex];\n            if (!(cache\n                  ? cacheHas(cache, computed)\n                  : includes(arrays[othIndex], computed, comparator))\n                ) {\n              continue outer;\n            }\n          }\n          if (seen) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.invert` and `_.invertBy` which inverts\n     * `object` with values transformed by `iteratee` and set by `setter`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} setter The function to set `accumulator` values.\n     * @param {Function} iteratee The iteratee to transform values.\n     * @param {Object} accumulator The initial inverted object.\n     * @returns {Function} Returns `accumulator`.\n     */\n    function baseInverter(object, setter, iteratee, accumulator) {\n      baseForOwn(object, function(value, key, object) {\n        setter(accumulator, iteratee(value), key, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * The base implementation of `_.invoke` without support for individual\n     * method arguments.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {Array} args The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     */\n    function baseInvoke(object, path, args) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      var func = object == null ? object : object[toKey(last(path))];\n      return func == null ? undefined : apply(func, object, args);\n    }\n\n    /**\n     * The base implementation of `_.isArguments`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     */\n    function baseIsArguments(value) {\n      return isObjectLike(value) && baseGetTag(value) == argsTag;\n    }\n\n    /**\n     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     */\n    function baseIsArrayBuffer(value) {\n      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n    }\n\n    /**\n     * The base implementation of `_.isDate` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     */\n    function baseIsDate(value) {\n      return isObjectLike(value) && baseGetTag(value) == dateTag;\n    }\n\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {boolean} bitmask The bitmask flags.\n     *  1 - Unordered comparison\n     *  2 - Partial comparison\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n    function baseIsEqual(value, other, bitmask, customizer, stack) {\n      if (value === other) {\n        return true;\n      }\n      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n        return value !== value && other !== other;\n      }\n      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n    }\n\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = objIsArr ? arrayTag : getTag(object),\n          othTag = othIsArr ? arrayTag : getTag(other);\n\n      objTag = objTag == argsTag ? objectTag : objTag;\n      othTag = othTag == argsTag ? objectTag : othTag;\n\n      var objIsObj = objTag == objectTag,\n          othIsObj = othTag == objectTag,\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && isBuffer(object)) {\n        if (!isBuffer(other)) {\n          return false;\n        }\n        objIsArr = true;\n        objIsObj = false;\n      }\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack);\n        return (objIsArr || isTypedArray(object))\n          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n      }\n      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n\n          stack || (stack = new Stack);\n          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n        }\n      }\n      if (!isSameTag) {\n        return false;\n      }\n      stack || (stack = new Stack);\n      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n    }\n\n    /**\n     * The base implementation of `_.isMap` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     */\n    function baseIsMap(value) {\n      return isObjectLike(value) && getTag(value) == mapTag;\n    }\n\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n      object = Object(object);\n      while (index--) {\n        var data = matchData[index];\n        if ((noCustomizer && data[2])\n              ? data[1] !== object[data[0]]\n              : !(data[0] in object)\n            ) {\n          return false;\n        }\n      }\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack;\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n          if (!(result === undefined\n                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n                : result\n              )) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n\n    /**\n     * The base implementation of `_.isRegExp` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     */\n    function baseIsRegExp(value) {\n      return isObjectLike(value) && baseGetTag(value) == regexpTag;\n    }\n\n    /**\n     * The base implementation of `_.isSet` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     */\n    function baseIsSet(value) {\n      return isObjectLike(value) && getTag(value) == setTag;\n    }\n\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) &&\n        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n    }\n\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n      if (value == null) {\n        return identity;\n      }\n      if (typeof value == 'object') {\n        return isArray(value)\n          ? baseMatchesProperty(value[0], value[1])\n          : baseMatches(value);\n      }\n      return property(value);\n    }\n\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n      var result = [];\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function baseKeysIn(object) {\n      if (!isObject(object)) {\n        return nativeKeysIn(object);\n      }\n      var isProto = isPrototype(object),\n          result = [];\n\n      for (var key in object) {\n        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.lt` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     */\n    function baseLt(value, other) {\n      return value < other;\n    }\n\n    /**\n     * The base implementation of `_.map` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     */\n    function baseMap(collection, iteratee) {\n      var index = -1,\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value, key, collection) {\n        result[++index] = iteratee(value, key, collection);\n      });\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n      return function(object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n      return function(object) {\n        var objValue = get(object, path);\n        return (objValue === undefined && objValue === srcValue)\n          ? hasIn(object, path)\n          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n      };\n    }\n\n    /**\n     * The base implementation of `_.merge` without support for multiple sources.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} [customizer] The function to customize merged values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMerge(object, source, srcIndex, customizer, stack) {\n      if (object === source) {\n        return;\n      }\n      baseFor(source, function(srcValue, key) {\n        stack || (stack = new Stack);\n        if (isObject(srcValue)) {\n          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n        }\n        else {\n          var newValue = customizer\n            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n            : undefined;\n\n          if (newValue === undefined) {\n            newValue = srcValue;\n          }\n          assignMergeValue(object, key, newValue);\n        }\n      }, keysIn);\n    }\n\n    /**\n     * A specialized version of `baseMerge` for arrays and objects which performs\n     * deep merges and tracks traversed objects enabling objects with circular\n     * references to be merged.\n     *\n     * @private\n     * @param {Object} object The destination object.\n     * @param {Object} source The source object.\n     * @param {string} key The key of the value to merge.\n     * @param {number} srcIndex The index of `source`.\n     * @param {Function} mergeFunc The function to merge values.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     */\n    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n      var objValue = safeGet(object, key),\n          srcValue = safeGet(source, key),\n          stacked = stack.get(srcValue);\n\n      if (stacked) {\n        assignMergeValue(object, key, stacked);\n        return;\n      }\n      var newValue = customizer\n        ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      var isCommon = newValue === undefined;\n\n      if (isCommon) {\n        var isArr = isArray(srcValue),\n            isBuff = !isArr && isBuffer(srcValue),\n            isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n        newValue = srcValue;\n        if (isArr || isBuff || isTyped) {\n          if (isArray(objValue)) {\n            newValue = objValue;\n          }\n          else if (isArrayLikeObject(objValue)) {\n            newValue = copyArray(objValue);\n          }\n          else if (isBuff) {\n            isCommon = false;\n            newValue = cloneBuffer(srcValue, true);\n          }\n          else if (isTyped) {\n            isCommon = false;\n            newValue = cloneTypedArray(srcValue, true);\n          }\n          else {\n            newValue = [];\n          }\n        }\n        else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n          newValue = objValue;\n          if (isArguments(objValue)) {\n            newValue = toPlainObject(objValue);\n          }\n          else if (!isObject(objValue) || isFunction(objValue)) {\n            newValue = initCloneObject(srcValue);\n          }\n        }\n        else {\n          isCommon = false;\n        }\n      }\n      if (isCommon) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, newValue);\n        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n        stack['delete'](srcValue);\n      }\n      assignMergeValue(object, key, newValue);\n    }\n\n    /**\n     * The base implementation of `_.nth` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {number} n The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     */\n    function baseNth(array, n) {\n      var length = array.length;\n      if (!length) {\n        return;\n      }\n      n += n < 0 ? length : 0;\n      return isIndex(n, length) ? array[n] : undefined;\n    }\n\n    /**\n     * The base implementation of `_.orderBy` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n     * @param {string[]} orders The sort orders of `iteratees`.\n     * @returns {Array} Returns the new sorted array.\n     */\n    function baseOrderBy(collection, iteratees, orders) {\n      var index = -1;\n      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));\n\n      var result = baseMap(collection, function(value, key, collection) {\n        var criteria = arrayMap(iteratees, function(iteratee) {\n          return iteratee(value);\n        });\n        return { 'criteria': criteria, 'index': ++index, 'value': value };\n      });\n\n      return baseSortBy(result, function(object, other) {\n        return compareMultiple(object, other, orders);\n      });\n    }\n\n    /**\n     * The base implementation of `_.pick` without support for individual\n     * property identifiers.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @returns {Object} Returns the new object.\n     */\n    function basePick(object, paths) {\n      return basePickBy(object, paths, function(value, path) {\n        return hasIn(object, path);\n      });\n    }\n\n    /**\n     * The base implementation of  `_.pickBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The source object.\n     * @param {string[]} paths The property paths to pick.\n     * @param {Function} predicate The function invoked per property.\n     * @returns {Object} Returns the new object.\n     */\n    function basePickBy(object, paths, predicate) {\n      var index = -1,\n          length = paths.length,\n          result = {};\n\n      while (++index < length) {\n        var path = paths[index],\n            value = baseGet(object, path);\n\n        if (predicate(value, path)) {\n          baseSet(result, castPath(path, object), value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n    function basePropertyDeep(path) {\n      return function(object) {\n        return baseGet(object, path);\n      };\n    }\n\n    /**\n     * The base implementation of `_.pullAllBy` without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAll(array, values, iteratee, comparator) {\n      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,\n          index = -1,\n          length = values.length,\n          seen = array;\n\n      if (array === values) {\n        values = copyArray(values);\n      }\n      if (iteratee) {\n        seen = arrayMap(array, baseUnary(iteratee));\n      }\n      while (++index < length) {\n        var fromIndex = 0,\n            value = values[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {\n          if (seen !== array) {\n            splice.call(seen, fromIndex, 1);\n          }\n          splice.call(array, fromIndex, 1);\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.pullAt` without support for individual\n     * indexes or capturing the removed elements.\n     *\n     * @private\n     * @param {Array} array The array to modify.\n     * @param {number[]} indexes The indexes of elements to remove.\n     * @returns {Array} Returns `array`.\n     */\n    function basePullAt(array, indexes) {\n      var length = array ? indexes.length : 0,\n          lastIndex = length - 1;\n\n      while (length--) {\n        var index = indexes[length];\n        if (length == lastIndex || index !== previous) {\n          var previous = index;\n          if (isIndex(index)) {\n            splice.call(array, index, 1);\n          } else {\n            baseUnset(array, index);\n          }\n        }\n      }\n      return array;\n    }\n\n    /**\n     * The base implementation of `_.random` without support for returning\n     * floating-point numbers.\n     *\n     * @private\n     * @param {number} lower The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the random number.\n     */\n    function baseRandom(lower, upper) {\n      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n    }\n\n    /**\n     * The base implementation of `_.range` and `_.rangeRight` which doesn't\n     * coerce arguments.\n     *\n     * @private\n     * @param {number} start The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} step The value to increment or decrement by.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the range of numbers.\n     */\n    function baseRange(start, end, step, fromRight) {\n      var index = -1,\n          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n          result = Array(length);\n\n      while (length--) {\n        result[fromRight ? length : ++index] = start;\n        start += step;\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.repeat` which doesn't coerce arguments.\n     *\n     * @private\n     * @param {string} string The string to repeat.\n     * @param {number} n The number of times to repeat the string.\n     * @returns {string} Returns the repeated string.\n     */\n    function baseRepeat(string, n) {\n      var result = '';\n      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n        return result;\n      }\n      // Leverage the exponentiation by squaring algorithm for a faster repeat.\n      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.\n      do {\n        if (n % 2) {\n          result += string;\n        }\n        n = nativeFloor(n / 2);\n        if (n) {\n          string += string;\n        }\n      } while (n);\n\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     */\n    function baseRest(func, start) {\n      return setToString(overRest(func, start, identity), func + '');\n    }\n\n    /**\n     * The base implementation of `_.sample`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     */\n    function baseSample(collection) {\n      return arraySample(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.sampleSize` without param guards.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} n The number of elements to sample.\n     * @returns {Array} Returns the random elements.\n     */\n    function baseSampleSize(collection, n) {\n      var array = values(collection);\n      return shuffleSelf(array, baseClamp(n, 0, array.length));\n    }\n\n    /**\n     * The base implementation of `_.set`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseSet(object, path, value, customizer) {\n      if (!isObject(object)) {\n        return object;\n      }\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          lastIndex = length - 1,\n          nested = object;\n\n      while (nested != null && ++index < length) {\n        var key = toKey(path[index]),\n            newValue = value;\n\n        if (index != lastIndex) {\n          var objValue = nested[key];\n          newValue = customizer ? customizer(objValue, key, nested) : undefined;\n          if (newValue === undefined) {\n            newValue = isObject(objValue)\n              ? objValue\n              : (isIndex(path[index + 1]) ? [] : {});\n          }\n        }\n        assignValue(nested, key, newValue);\n        nested = nested[key];\n      }\n      return object;\n    }\n\n    /**\n     * The base implementation of `setData` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetData = !metaMap ? identity : function(func, data) {\n      metaMap.set(func, data);\n      return func;\n    };\n\n    /**\n     * The base implementation of `setToString` without support for hot loop shorting.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var baseSetToString = !defineProperty ? identity : function(func, string) {\n      return defineProperty(func, 'toString', {\n        'configurable': true,\n        'enumerable': false,\n        'value': constant(string),\n        'writable': true\n      });\n    };\n\n    /**\n     * The base implementation of `_.shuffle`.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     */\n    function baseShuffle(collection) {\n      return shuffleSelf(values(collection));\n    }\n\n    /**\n     * The base implementation of `_.slice` without an iteratee call guard.\n     *\n     * @private\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseSlice(array, start, end) {\n      var index = -1,\n          length = array.length;\n\n      if (start < 0) {\n        start = -start > length ? 0 : (length + start);\n      }\n      end = end > length ? length : end;\n      if (end < 0) {\n        end += length;\n      }\n      length = start > end ? 0 : ((end - start) >>> 0);\n      start >>>= 0;\n\n      var result = Array(length);\n      while (++index < length) {\n        result[index] = array[index + start];\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.some` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n    function baseSome(collection, predicate) {\n      var result;\n\n      baseEach(collection, function(value, index, collection) {\n        result = predicate(value, index, collection);\n        return !result;\n      });\n      return !!result;\n    }\n\n    /**\n     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which\n     * performs a binary search of `array` to determine the index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndex(array, value, retHighest) {\n      var low = 0,\n          high = array == null ? low : array.length;\n\n      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n        while (low < high) {\n          var mid = (low + high) >>> 1,\n              computed = array[mid];\n\n          if (computed !== null && !isSymbol(computed) &&\n              (retHighest ? (computed <= value) : (computed < value))) {\n            low = mid + 1;\n          } else {\n            high = mid;\n          }\n        }\n        return high;\n      }\n      return baseSortedIndexBy(array, value, identity, retHighest);\n    }\n\n    /**\n     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`\n     * which invokes `iteratee` for `value` and each element of `array` to compute\n     * their sort ranking. The iteratee is invoked with one argument; (value).\n     *\n     * @private\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} iteratee The iteratee invoked per element.\n     * @param {boolean} [retHighest] Specify returning the highest qualified index.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     */\n    function baseSortedIndexBy(array, value, iteratee, retHighest) {\n      value = iteratee(value);\n\n      var low = 0,\n          high = array == null ? 0 : array.length,\n          valIsNaN = value !== value,\n          valIsNull = value === null,\n          valIsSymbol = isSymbol(value),\n          valIsUndefined = value === undefined;\n\n      while (low < high) {\n        var mid = nativeFloor((low + high) / 2),\n            computed = iteratee(array[mid]),\n            othIsDefined = computed !== undefined,\n            othIsNull = computed === null,\n            othIsReflexive = computed === computed,\n            othIsSymbol = isSymbol(computed);\n\n        if (valIsNaN) {\n          var setLow = retHighest || othIsReflexive;\n        } else if (valIsUndefined) {\n          setLow = othIsReflexive && (retHighest || othIsDefined);\n        } else if (valIsNull) {\n          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n        } else if (valIsSymbol) {\n          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n        } else if (othIsNull || othIsSymbol) {\n          setLow = false;\n        } else {\n          setLow = retHighest ? (computed <= value) : (computed < value);\n        }\n        if (setLow) {\n          low = mid + 1;\n        } else {\n          high = mid;\n        }\n      }\n      return nativeMin(high, MAX_ARRAY_INDEX);\n    }\n\n    /**\n     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without\n     * support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseSortedUniq(array, iteratee) {\n      var index = -1,\n          length = array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        if (!index || !eq(computed, seen)) {\n          var seen = computed;\n          result[resIndex++] = value === 0 ? 0 : value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.toNumber` which doesn't ensure correct\n     * conversions of binary, hexadecimal, or octal string values.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     */\n    function baseToNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      return +value;\n    }\n\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n      if (isArray(value)) {\n        // Recursively convert values (susceptible to call stack limits).\n        return arrayMap(value, baseToString) + '';\n      }\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * The base implementation of `_.uniqBy` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     */\n    function baseUniq(array, iteratee, comparator) {\n      var index = -1,\n          includes = arrayIncludes,\n          length = array.length,\n          isCommon = true,\n          result = [],\n          seen = result;\n\n      if (comparator) {\n        isCommon = false;\n        includes = arrayIncludesWith;\n      }\n      else if (length >= LARGE_ARRAY_SIZE) {\n        var set = iteratee ? null : createSet(array);\n        if (set) {\n          return setToArray(set);\n        }\n        isCommon = false;\n        includes = cacheHas;\n        seen = new SetCache;\n      }\n      else {\n        seen = iteratee ? [] : result;\n      }\n      outer:\n      while (++index < length) {\n        var value = array[index],\n            computed = iteratee ? iteratee(value) : value;\n\n        value = (comparator || value !== 0) ? value : 0;\n        if (isCommon && computed === computed) {\n          var seenIndex = seen.length;\n          while (seenIndex--) {\n            if (seen[seenIndex] === computed) {\n              continue outer;\n            }\n          }\n          if (iteratee) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n        else if (!includes(seen, computed, comparator)) {\n          if (seen !== result) {\n            seen.push(computed);\n          }\n          result.push(value);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * The base implementation of `_.unset`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The property path to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     */\n    function baseUnset(object, path) {\n      path = castPath(path, object);\n      object = parent(object, path);\n      return object == null || delete object[toKey(last(path))];\n    }\n\n    /**\n     * The base implementation of `_.update`.\n     *\n     * @private\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to update.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize path creation.\n     * @returns {Object} Returns `object`.\n     */\n    function baseUpdate(object, path, updater, customizer) {\n      return baseSet(object, path, updater(baseGet(object, path)), customizer);\n    }\n\n    /**\n     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`\n     * without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Array} array The array to query.\n     * @param {Function} predicate The function invoked per iteration.\n     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function baseWhile(array, predicate, isDrop, fromRight) {\n      var length = array.length,\n          index = fromRight ? length : -1;\n\n      while ((fromRight ? index-- : ++index < length) &&\n        predicate(array[index], index, array)) {}\n\n      return isDrop\n        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))\n        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));\n    }\n\n    /**\n     * The base implementation of `wrapperValue` which returns the result of\n     * performing a sequence of actions on the unwrapped `value`, where each\n     * successive action is supplied the return value of the previous.\n     *\n     * @private\n     * @param {*} value The unwrapped value.\n     * @param {Array} actions Actions to perform to resolve the unwrapped value.\n     * @returns {*} Returns the resolved value.\n     */\n    function baseWrapperValue(value, actions) {\n      var result = value;\n      if (result instanceof LazyWrapper) {\n        result = result.value();\n      }\n      return arrayReduce(actions, function(result, action) {\n        return action.func.apply(action.thisArg, arrayPush([result], action.args));\n      }, result);\n    }\n\n    /**\n     * The base implementation of methods like `_.xor`, without support for\n     * iteratee shorthands, that accepts an array of arrays to inspect.\n     *\n     * @private\n     * @param {Array} arrays The arrays to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of values.\n     */\n    function baseXor(arrays, iteratee, comparator) {\n      var length = arrays.length;\n      if (length < 2) {\n        return length ? baseUniq(arrays[0]) : [];\n      }\n      var index = -1,\n          result = Array(length);\n\n      while (++index < length) {\n        var array = arrays[index],\n            othIndex = -1;\n\n        while (++othIndex < length) {\n          if (othIndex != index) {\n            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);\n          }\n        }\n      }\n      return baseUniq(baseFlatten(result, 1), iteratee, comparator);\n    }\n\n    /**\n     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.\n     *\n     * @private\n     * @param {Array} props The property identifiers.\n     * @param {Array} values The property values.\n     * @param {Function} assignFunc The function to assign values.\n     * @returns {Object} Returns the new object.\n     */\n    function baseZipObject(props, values, assignFunc) {\n      var index = -1,\n          length = props.length,\n          valsLength = values.length,\n          result = {};\n\n      while (++index < length) {\n        var value = index < valsLength ? values[index] : undefined;\n        assignFunc(result, props[index], value);\n      }\n      return result;\n    }\n\n    /**\n     * Casts `value` to an empty array if it's not an array like object.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array|Object} Returns the cast array-like object.\n     */\n    function castArrayLikeObject(value) {\n      return isArrayLikeObject(value) ? value : [];\n    }\n\n    /**\n     * Casts `value` to `identity` if it's not a function.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Function} Returns cast function.\n     */\n    function castFunction(value) {\n      return typeof value == 'function' ? value : identity;\n    }\n\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {Array} Returns the cast property path array.\n     */\n    function castPath(value, object) {\n      if (isArray(value)) {\n        return value;\n      }\n      return isKey(value, object) ? [value] : stringToPath(toString(value));\n    }\n\n    /**\n     * A `baseRest` alias which can be replaced with `identity` by module\n     * replacement plugins.\n     *\n     * @private\n     * @type {Function}\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    var castRest = baseRest;\n\n    /**\n     * Casts `array` to a slice if it's needed.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {number} start The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the cast slice.\n     */\n    function castSlice(array, start, end) {\n      var length = array.length;\n      end = end === undefined ? length : end;\n      return (!start && end >= length) ? array : baseSlice(array, start, end);\n    }\n\n    /**\n     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).\n     *\n     * @private\n     * @param {number|Object} id The timer id or timeout object of the timer to clear.\n     */\n    var clearTimeout = ctxClearTimeout || function(id) {\n      return root.clearTimeout(id);\n    };\n\n    /**\n     * Creates a clone of  `buffer`.\n     *\n     * @private\n     * @param {Buffer} buffer The buffer to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Buffer} Returns the cloned buffer.\n     */\n    function cloneBuffer(buffer, isDeep) {\n      if (isDeep) {\n        return buffer.slice();\n      }\n      var length = buffer.length,\n          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n      buffer.copy(result);\n      return result;\n    }\n\n    /**\n     * Creates a clone of `arrayBuffer`.\n     *\n     * @private\n     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n     * @returns {ArrayBuffer} Returns the cloned array buffer.\n     */\n    function cloneArrayBuffer(arrayBuffer) {\n      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n      new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n      return result;\n    }\n\n    /**\n     * Creates a clone of `dataView`.\n     *\n     * @private\n     * @param {Object} dataView The data view to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned data view.\n     */\n    function cloneDataView(dataView, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n    }\n\n    /**\n     * Creates a clone of `regexp`.\n     *\n     * @private\n     * @param {Object} regexp The regexp to clone.\n     * @returns {Object} Returns the cloned regexp.\n     */\n    function cloneRegExp(regexp) {\n      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n      result.lastIndex = regexp.lastIndex;\n      return result;\n    }\n\n    /**\n     * Creates a clone of the `symbol` object.\n     *\n     * @private\n     * @param {Object} symbol The symbol object to clone.\n     * @returns {Object} Returns the cloned symbol object.\n     */\n    function cloneSymbol(symbol) {\n      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n    }\n\n    /**\n     * Creates a clone of `typedArray`.\n     *\n     * @private\n     * @param {Object} typedArray The typed array to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the cloned typed array.\n     */\n    function cloneTypedArray(typedArray, isDeep) {\n      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n    }\n\n    /**\n     * Compares values to sort them in ascending order.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {number} Returns the sort order indicator for `value`.\n     */\n    function compareAscending(value, other) {\n      if (value !== other) {\n        var valIsDefined = value !== undefined,\n            valIsNull = value === null,\n            valIsReflexive = value === value,\n            valIsSymbol = isSymbol(value);\n\n        var othIsDefined = other !== undefined,\n            othIsNull = other === null,\n            othIsReflexive = other === other,\n            othIsSymbol = isSymbol(other);\n\n        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n            (valIsNull && othIsDefined && othIsReflexive) ||\n            (!valIsDefined && othIsReflexive) ||\n            !valIsReflexive) {\n          return 1;\n        }\n        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n            (othIsNull && valIsDefined && valIsReflexive) ||\n            (!othIsDefined && valIsReflexive) ||\n            !othIsReflexive) {\n          return -1;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * Used by `_.orderBy` to compare multiple properties of a value to another\n     * and stable sort them.\n     *\n     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n     * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n     * of corresponding values.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {boolean[]|string[]} orders The order to sort by for each property.\n     * @returns {number} Returns the sort order indicator for `object`.\n     */\n    function compareMultiple(object, other, orders) {\n      var index = -1,\n          objCriteria = object.criteria,\n          othCriteria = other.criteria,\n          length = objCriteria.length,\n          ordersLength = orders.length;\n\n      while (++index < length) {\n        var result = compareAscending(objCriteria[index], othCriteria[index]);\n        if (result) {\n          if (index >= ordersLength) {\n            return result;\n          }\n          var order = orders[index];\n          return result * (order == 'desc' ? -1 : 1);\n        }\n      }\n      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n      // that causes it, under certain circumstances, to provide the same value for\n      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n      // for more details.\n      //\n      // This also ensures a stable sort in V8 and other engines.\n      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n      return object.index - other.index;\n    }\n\n    /**\n     * Creates an array that is the composition of partially applied arguments,\n     * placeholders, and provided arguments into a single array of arguments.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to prepend to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgs(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersLength = holders.length,\n          leftIndex = -1,\n          leftLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(leftLength + rangeLength),\n          isUncurried = !isCurried;\n\n      while (++leftIndex < leftLength) {\n        result[leftIndex] = partials[leftIndex];\n      }\n      while (++argsIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[holders[argsIndex]] = args[argsIndex];\n        }\n      }\n      while (rangeLength--) {\n        result[leftIndex++] = args[argsIndex++];\n      }\n      return result;\n    }\n\n    /**\n     * This function is like `composeArgs` except that the arguments composition\n     * is tailored for `_.partialRight`.\n     *\n     * @private\n     * @param {Array} args The provided arguments.\n     * @param {Array} partials The arguments to append to those provided.\n     * @param {Array} holders The `partials` placeholder indexes.\n     * @params {boolean} [isCurried] Specify composing for a curried function.\n     * @returns {Array} Returns the new array of composed arguments.\n     */\n    function composeArgsRight(args, partials, holders, isCurried) {\n      var argsIndex = -1,\n          argsLength = args.length,\n          holdersIndex = -1,\n          holdersLength = holders.length,\n          rightIndex = -1,\n          rightLength = partials.length,\n          rangeLength = nativeMax(argsLength - holdersLength, 0),\n          result = Array(rangeLength + rightLength),\n          isUncurried = !isCurried;\n\n      while (++argsIndex < rangeLength) {\n        result[argsIndex] = args[argsIndex];\n      }\n      var offset = argsIndex;\n      while (++rightIndex < rightLength) {\n        result[offset + rightIndex] = partials[rightIndex];\n      }\n      while (++holdersIndex < holdersLength) {\n        if (isUncurried || argsIndex < argsLength) {\n          result[offset + holders[holdersIndex]] = args[argsIndex++];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Copies the values of `source` to `array`.\n     *\n     * @private\n     * @param {Array} source The array to copy values from.\n     * @param {Array} [array=[]] The array to copy values to.\n     * @returns {Array} Returns `array`.\n     */\n    function copyArray(source, array) {\n      var index = -1,\n          length = source.length;\n\n      array || (array = Array(length));\n      while (++index < length) {\n        array[index] = source[index];\n      }\n      return array;\n    }\n\n    /**\n     * Copies properties of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy properties from.\n     * @param {Array} props The property identifiers to copy.\n     * @param {Object} [object={}] The object to copy properties to.\n     * @param {Function} [customizer] The function to customize copied values.\n     * @returns {Object} Returns `object`.\n     */\n    function copyObject(source, props, object, customizer) {\n      var isNew = !object;\n      object || (object = {});\n\n      var index = -1,\n          length = props.length;\n\n      while (++index < length) {\n        var key = props[index];\n\n        var newValue = customizer\n          ? customizer(object[key], source[key], key, object, source)\n          : undefined;\n\n        if (newValue === undefined) {\n          newValue = source[key];\n        }\n        if (isNew) {\n          baseAssignValue(object, key, newValue);\n        } else {\n          assignValue(object, key, newValue);\n        }\n      }\n      return object;\n    }\n\n    /**\n     * Copies own symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbols(source, object) {\n      return copyObject(source, getSymbols(source), object);\n    }\n\n    /**\n     * Copies own and inherited symbols of `source` to `object`.\n     *\n     * @private\n     * @param {Object} source The object to copy symbols from.\n     * @param {Object} [object={}] The object to copy symbols to.\n     * @returns {Object} Returns `object`.\n     */\n    function copySymbolsIn(source, object) {\n      return copyObject(source, getSymbolsIn(source), object);\n    }\n\n    /**\n     * Creates a function like `_.groupBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} [initializer] The accumulator object initializer.\n     * @returns {Function} Returns the new aggregator function.\n     */\n    function createAggregator(setter, initializer) {\n      return function(collection, iteratee) {\n        var func = isArray(collection) ? arrayAggregator : baseAggregator,\n            accumulator = initializer ? initializer() : {};\n\n        return func(collection, setter, getIteratee(iteratee, 2), accumulator);\n      };\n    }\n\n    /**\n     * Creates a function like `_.assign`.\n     *\n     * @private\n     * @param {Function} assigner The function to assign values.\n     * @returns {Function} Returns the new assigner function.\n     */\n    function createAssigner(assigner) {\n      return baseRest(function(object, sources) {\n        var index = -1,\n            length = sources.length,\n            customizer = length > 1 ? sources[length - 1] : undefined,\n            guard = length > 2 ? sources[2] : undefined;\n\n        customizer = (assigner.length > 3 && typeof customizer == 'function')\n          ? (length--, customizer)\n          : undefined;\n\n        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n          customizer = length < 3 ? undefined : customizer;\n          length = 1;\n        }\n        object = Object(object);\n        while (++index < length) {\n          var source = sources[index];\n          if (source) {\n            assigner(object, source, index, customizer);\n          }\n        }\n        return object;\n      });\n    }\n\n    /**\n     * Creates a `baseEach` or `baseEachRight` function.\n     *\n     * @private\n     * @param {Function} eachFunc The function to iterate over a collection.\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseEach(eachFunc, fromRight) {\n      return function(collection, iteratee) {\n        if (collection == null) {\n          return collection;\n        }\n        if (!isArrayLike(collection)) {\n          return eachFunc(collection, iteratee);\n        }\n        var length = collection.length,\n            index = fromRight ? length : -1,\n            iterable = Object(collection);\n\n        while ((fromRight ? index-- : ++index < length)) {\n          if (iteratee(iterable[index], index, iterable) === false) {\n            break;\n          }\n        }\n        return collection;\n      };\n    }\n\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n    function createBaseFor(fromRight) {\n      return function(object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n        return object;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the optional `this`\n     * binding of `thisArg`.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createBind(func, bitmask, thisArg) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return fn.apply(isBind ? thisArg : this, arguments);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.lowerFirst`.\n     *\n     * @private\n     * @param {string} methodName The name of the `String` case method to use.\n     * @returns {Function} Returns the new case function.\n     */\n    function createCaseFirst(methodName) {\n      return function(string) {\n        string = toString(string);\n\n        var strSymbols = hasUnicode(string)\n          ? stringToArray(string)\n          : undefined;\n\n        var chr = strSymbols\n          ? strSymbols[0]\n          : string.charAt(0);\n\n        var trailing = strSymbols\n          ? castSlice(strSymbols, 1).join('')\n          : string.slice(1);\n\n        return chr[methodName]() + trailing;\n      };\n    }\n\n    /**\n     * Creates a function like `_.camelCase`.\n     *\n     * @private\n     * @param {Function} callback The function to combine each word.\n     * @returns {Function} Returns the new compounder function.\n     */\n    function createCompounder(callback) {\n      return function(string) {\n        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');\n      };\n    }\n\n    /**\n     * Creates a function that produces an instance of `Ctor` regardless of\n     * whether it was invoked as part of a `new` expression or by `call` or `apply`.\n     *\n     * @private\n     * @param {Function} Ctor The constructor to wrap.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCtor(Ctor) {\n      return function() {\n        // Use a `switch` statement to work with class constructors. See\n        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist\n        // for more details.\n        var args = arguments;\n        switch (args.length) {\n          case 0: return new Ctor;\n          case 1: return new Ctor(args[0]);\n          case 2: return new Ctor(args[0], args[1]);\n          case 3: return new Ctor(args[0], args[1], args[2]);\n          case 4: return new Ctor(args[0], args[1], args[2], args[3]);\n          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        }\n        var thisBinding = baseCreate(Ctor.prototype),\n            result = Ctor.apply(thisBinding, args);\n\n        // Mimic the constructor's `return` behavior.\n        // See https://es5.github.io/#x13.2.2 for more details.\n        return isObject(result) ? result : thisBinding;\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to enable currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {number} arity The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createCurry(func, bitmask, arity) {\n      var Ctor = createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length,\n            placeholder = getHolder(wrapper);\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)\n          ? []\n          : replaceHolders(args, placeholder);\n\n        length -= holders.length;\n        if (length < arity) {\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, undefined,\n            args, holders, undefined, undefined, arity - length);\n        }\n        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n        return apply(fn, this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.find` or `_.findLast` function.\n     *\n     * @private\n     * @param {Function} findIndexFunc The function to find the collection index.\n     * @returns {Function} Returns the new find function.\n     */\n    function createFind(findIndexFunc) {\n      return function(collection, predicate, fromIndex) {\n        var iterable = Object(collection);\n        if (!isArrayLike(collection)) {\n          var iteratee = getIteratee(predicate, 3);\n          collection = keys(collection);\n          predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n        }\n        var index = findIndexFunc(collection, predicate, fromIndex);\n        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n      };\n    }\n\n    /**\n     * Creates a `_.flow` or `_.flowRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new flow function.\n     */\n    function createFlow(fromRight) {\n      return flatRest(function(funcs) {\n        var length = funcs.length,\n            index = length,\n            prereq = LodashWrapper.prototype.thru;\n\n        if (fromRight) {\n          funcs.reverse();\n        }\n        while (index--) {\n          var func = funcs[index];\n          if (typeof func != 'function') {\n            throw new TypeError(FUNC_ERROR_TEXT);\n          }\n          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {\n            var wrapper = new LodashWrapper([], true);\n          }\n        }\n        index = wrapper ? index : length;\n        while (++index < length) {\n          func = funcs[index];\n\n          var funcName = getFuncName(func),\n              data = funcName == 'wrapper' ? getData(func) : undefined;\n\n          if (data && isLaziable(data[0]) &&\n                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&\n                !data[4].length && data[9] == 1\n              ) {\n            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n          } else {\n            wrapper = (func.length == 1 && isLaziable(func))\n              ? wrapper[funcName]()\n              : wrapper.thru(func);\n          }\n        }\n        return function() {\n          var args = arguments,\n              value = args[0];\n\n          if (wrapper && args.length == 1 && isArray(value)) {\n            return wrapper.plant(value).value();\n          }\n          var index = 0,\n              result = length ? funcs[index].apply(this, args) : value;\n\n          while (++index < length) {\n            result = funcs[index].call(this, result);\n          }\n          return result;\n        };\n      });\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with optional `this`\n     * binding of `thisArg`, partial application, and currying.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [partialsRight] The arguments to append to those provided\n     *  to the new function.\n     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {\n      var isAry = bitmask & WRAP_ARY_FLAG,\n          isBind = bitmask & WRAP_BIND_FLAG,\n          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,\n          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),\n          isFlip = bitmask & WRAP_FLIP_FLAG,\n          Ctor = isBindKey ? undefined : createCtor(func);\n\n      function wrapper() {\n        var length = arguments.length,\n            args = Array(length),\n            index = length;\n\n        while (index--) {\n          args[index] = arguments[index];\n        }\n        if (isCurried) {\n          var placeholder = getHolder(wrapper),\n              holdersCount = countHolders(args, placeholder);\n        }\n        if (partials) {\n          args = composeArgs(args, partials, holders, isCurried);\n        }\n        if (partialsRight) {\n          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n        }\n        length -= holdersCount;\n        if (isCurried && length < arity) {\n          var newHolders = replaceHolders(args, placeholder);\n          return createRecurry(\n            func, bitmask, createHybrid, wrapper.placeholder, thisArg,\n            args, newHolders, argPos, ary, arity - length\n          );\n        }\n        var thisBinding = isBind ? thisArg : this,\n            fn = isBindKey ? thisBinding[func] : func;\n\n        length = args.length;\n        if (argPos) {\n          args = reorder(args, argPos);\n        } else if (isFlip && length > 1) {\n          args.reverse();\n        }\n        if (isAry && ary < length) {\n          args.length = ary;\n        }\n        if (this && this !== root && this instanceof wrapper) {\n          fn = Ctor || createCtor(fn);\n        }\n        return fn.apply(thisBinding, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a function like `_.invertBy`.\n     *\n     * @private\n     * @param {Function} setter The function to set accumulator values.\n     * @param {Function} toIteratee The function to resolve iteratees.\n     * @returns {Function} Returns the new inverter function.\n     */\n    function createInverter(setter, toIteratee) {\n      return function(object, iteratee) {\n        return baseInverter(object, setter, toIteratee(iteratee), {});\n      };\n    }\n\n    /**\n     * Creates a function that performs a mathematical operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @param {number} [defaultValue] The value used for `undefined` arguments.\n     * @returns {Function} Returns the new mathematical operation function.\n     */\n    function createMathOperation(operator, defaultValue) {\n      return function(value, other) {\n        var result;\n        if (value === undefined && other === undefined) {\n          return defaultValue;\n        }\n        if (value !== undefined) {\n          result = value;\n        }\n        if (other !== undefined) {\n          if (result === undefined) {\n            return other;\n          }\n          if (typeof value == 'string' || typeof other == 'string') {\n            value = baseToString(value);\n            other = baseToString(other);\n          } else {\n            value = baseToNumber(value);\n            other = baseToNumber(other);\n          }\n          result = operator(value, other);\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function like `_.over`.\n     *\n     * @private\n     * @param {Function} arrayFunc The function to iterate over iteratees.\n     * @returns {Function} Returns the new over function.\n     */\n    function createOver(arrayFunc) {\n      return flatRest(function(iteratees) {\n        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n        return baseRest(function(args) {\n          var thisArg = this;\n          return arrayFunc(iteratees, function(iteratee) {\n            return apply(iteratee, thisArg, args);\n          });\n        });\n      });\n    }\n\n    /**\n     * Creates the padding for `string` based on `length`. The `chars` string\n     * is truncated if the number of characters exceeds `length`.\n     *\n     * @private\n     * @param {number} length The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padding for `string`.\n     */\n    function createPadding(length, chars) {\n      chars = chars === undefined ? ' ' : baseToString(chars);\n\n      var charsLength = chars.length;\n      if (charsLength < 2) {\n        return charsLength ? baseRepeat(chars, length) : chars;\n      }\n      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n      return hasUnicode(chars)\n        ? castSlice(stringToArray(result), 0, length).join('')\n        : result.slice(0, length);\n    }\n\n    /**\n     * Creates a function that wraps `func` to invoke it with the `this` binding\n     * of `thisArg` and `partials` prepended to the arguments it receives.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {Array} partials The arguments to prepend to those provided to\n     *  the new function.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createPartial(func, bitmask, thisArg, partials) {\n      var isBind = bitmask & WRAP_BIND_FLAG,\n          Ctor = createCtor(func);\n\n      function wrapper() {\n        var argsIndex = -1,\n            argsLength = arguments.length,\n            leftIndex = -1,\n            leftLength = partials.length,\n            args = Array(leftLength + argsLength),\n            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;\n\n        while (++leftIndex < leftLength) {\n          args[leftIndex] = partials[leftIndex];\n        }\n        while (argsLength--) {\n          args[leftIndex++] = arguments[++argsIndex];\n        }\n        return apply(fn, isBind ? thisArg : this, args);\n      }\n      return wrapper;\n    }\n\n    /**\n     * Creates a `_.range` or `_.rangeRight` function.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new range function.\n     */\n    function createRange(fromRight) {\n      return function(start, end, step) {\n        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {\n          end = step = undefined;\n        }\n        // Ensure the sign of `-0` is preserved.\n        start = toFinite(start);\n        if (end === undefined) {\n          end = start;\n          start = 0;\n        } else {\n          end = toFinite(end);\n        }\n        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);\n        return baseRange(start, end, step, fromRight);\n      };\n    }\n\n    /**\n     * Creates a function that performs a relational operation on two values.\n     *\n     * @private\n     * @param {Function} operator The function to perform the operation.\n     * @returns {Function} Returns the new relational operation function.\n     */\n    function createRelationalOperation(operator) {\n      return function(value, other) {\n        if (!(typeof value == 'string' && typeof other == 'string')) {\n          value = toNumber(value);\n          other = toNumber(other);\n        }\n        return operator(value, other);\n      };\n    }\n\n    /**\n     * Creates a function that wraps `func` to continue currying.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @param {Function} wrapFunc The function to create the `func` wrapper.\n     * @param {*} placeholder The placeholder value.\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to prepend to those provided to\n     *  the new function.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {\n      var isCurry = bitmask & WRAP_CURRY_FLAG,\n          newHolders = isCurry ? holders : undefined,\n          newHoldersRight = isCurry ? undefined : holders,\n          newPartials = isCurry ? partials : undefined,\n          newPartialsRight = isCurry ? undefined : partials;\n\n      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);\n      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n\n      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n      }\n      var newData = [\n        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,\n        newHoldersRight, argPos, ary, arity\n      ];\n\n      var result = wrapFunc.apply(undefined, newData);\n      if (isLaziable(func)) {\n        setData(result, newData);\n      }\n      result.placeholder = placeholder;\n      return setWrapToString(result, func, bitmask);\n    }\n\n    /**\n     * Creates a function like `_.round`.\n     *\n     * @private\n     * @param {string} methodName The name of the `Math` method to use when rounding.\n     * @returns {Function} Returns the new round function.\n     */\n    function createRound(methodName) {\n      var func = Math[methodName];\n      return function(number, precision) {\n        number = toNumber(number);\n        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n        if (precision && nativeIsFinite(number)) {\n          // Shift with exponential notation to avoid floating-point issues.\n          // See [MDN](https://mdn.io/round#Examples) for more details.\n          var pair = (toString(number) + 'e').split('e'),\n              value = func(pair[0] + 'e' + (+pair[1] + precision));\n\n          pair = (toString(value) + 'e').split('e');\n          return +(pair[0] + 'e' + (+pair[1] - precision));\n        }\n        return func(number);\n      };\n    }\n\n    /**\n     * Creates a set object of `values`.\n     *\n     * @private\n     * @param {Array} values The values to add to the set.\n     * @returns {Object} Returns the new set.\n     */\n    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\n      return new Set(values);\n    };\n\n    /**\n     * Creates a `_.toPairs` or `_.toPairsIn` function.\n     *\n     * @private\n     * @param {Function} keysFunc The function to get the keys of a given object.\n     * @returns {Function} Returns the new pairs function.\n     */\n    function createToPairs(keysFunc) {\n      return function(object) {\n        var tag = getTag(object);\n        if (tag == mapTag) {\n          return mapToArray(object);\n        }\n        if (tag == setTag) {\n          return setToPairs(object);\n        }\n        return baseToPairs(object, keysFunc(object));\n      };\n    }\n\n    /**\n     * Creates a function that either curries or invokes `func` with optional\n     * `this` binding and partially applied arguments.\n     *\n     * @private\n     * @param {Function|string} func The function or method name to wrap.\n     * @param {number} bitmask The bitmask flags.\n     *    1 - `_.bind`\n     *    2 - `_.bindKey`\n     *    4 - `_.curry` or `_.curryRight` of a bound function\n     *    8 - `_.curry`\n     *   16 - `_.curryRight`\n     *   32 - `_.partial`\n     *   64 - `_.partialRight`\n     *  128 - `_.rearg`\n     *  256 - `_.ary`\n     *  512 - `_.flip`\n     * @param {*} [thisArg] The `this` binding of `func`.\n     * @param {Array} [partials] The arguments to be partially applied.\n     * @param {Array} [holders] The `partials` placeholder indexes.\n     * @param {Array} [argPos] The argument positions of the new function.\n     * @param {number} [ary] The arity cap of `func`.\n     * @param {number} [arity] The arity of `func`.\n     * @returns {Function} Returns the new wrapped function.\n     */\n    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {\n      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n      if (!isBindKey && typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var length = partials ? partials.length : 0;\n      if (!length) {\n        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n        partials = holders = undefined;\n      }\n      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);\n      arity = arity === undefined ? arity : toInteger(arity);\n      length -= holders ? holders.length : 0;\n\n      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n        var partialsRight = partials,\n            holdersRight = holders;\n\n        partials = holders = undefined;\n      }\n      var data = isBindKey ? undefined : getData(func);\n\n      var newData = [\n        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,\n        argPos, ary, arity\n      ];\n\n      if (data) {\n        mergeData(newData, data);\n      }\n      func = newData[0];\n      bitmask = newData[1];\n      thisArg = newData[2];\n      partials = newData[3];\n      holders = newData[4];\n      arity = newData[9] = newData[9] === undefined\n        ? (isBindKey ? 0 : func.length)\n        : nativeMax(newData[9] - length, 0);\n\n      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n      }\n      if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n        var result = createBind(func, bitmask, thisArg);\n      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n        result = createCurry(func, bitmask, arity);\n      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n        result = createPartial(func, bitmask, thisArg, partials);\n      } else {\n        result = createHybrid.apply(undefined, newData);\n      }\n      var setter = data ? baseSetData : setData;\n      return setWrapToString(setter(result, newData), func, bitmask);\n    }\n\n    /**\n     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties\n     * of source objects to the destination object for all destination properties\n     * that resolve to `undefined`.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to assign.\n     * @param {Object} object The parent object of `objValue`.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsAssignIn(objValue, srcValue, key, object) {\n      if (objValue === undefined ||\n          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n        return srcValue;\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source\n     * objects into destination objects that are passed thru.\n     *\n     * @private\n     * @param {*} objValue The destination value.\n     * @param {*} srcValue The source value.\n     * @param {string} key The key of the property to merge.\n     * @param {Object} object The parent object of `objValue`.\n     * @param {Object} source The parent object of `srcValue`.\n     * @param {Object} [stack] Tracks traversed source values and their merged\n     *  counterparts.\n     * @returns {*} Returns the value to assign.\n     */\n    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n      if (isObject(objValue) && isObject(srcValue)) {\n        // Recursively merge objects and arrays (susceptible to call stack limits).\n        stack.set(srcValue, objValue);\n        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);\n        stack['delete'](srcValue);\n      }\n      return objValue;\n    }\n\n    /**\n     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain\n     * objects.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @param {string} key The key of the property to inspect.\n     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.\n     */\n    function customOmitClone(value) {\n      return isPlainObject(value) ? undefined : value;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(array);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var index = -1,\n          result = true,\n          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n      stack.set(array, other);\n      stack.set(other, array);\n\n      // Ignore non-index properties.\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, arrValue, index, other, array, stack)\n            : customizer(arrValue, othValue, index, array, other, stack);\n        }\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n          result = false;\n          break;\n        }\n        // Recursively compare arrays (susceptible to call stack limits).\n        if (seen) {\n          if (!arraySome(other, function(othValue, othIndex) {\n                if (!cacheHas(seen, othIndex) &&\n                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                  return seen.push(othIndex);\n                }\n              })) {\n            result = false;\n            break;\n          }\n        } else if (!(\n              arrValue === othValue ||\n                equalFunc(arrValue, othValue, bitmask, customizer, stack)\n            )) {\n          result = false;\n          break;\n        }\n      }\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if ((object.byteLength != other.byteLength) ||\n              (object.byteOffset != other.byteOffset)) {\n            return false;\n          }\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if ((object.byteLength != other.byteLength) ||\n              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == (other + '');\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          }\n          // Assume cyclic values are equal.\n          var stacked = stack.get(object);\n          if (stacked) {\n            return stacked == other;\n          }\n          bitmask |= COMPARE_UNORDERED_FLAG;\n\n          // Recursively compare objects (susceptible to call stack limits).\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n      }\n      return false;\n    }\n\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n          objProps = getAllKeys(object),\n          objLength = objProps.length,\n          othProps = getAllKeys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n      var index = objLength;\n      while (index--) {\n        var key = objProps[index];\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n\n      var skipCtor = isPartial;\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial\n            ? customizer(othValue, objValue, key, other, object, stack)\n            : customizer(objValue, othValue, key, object, other, stack);\n        }\n        // Recursively compare objects (susceptible to call stack limits).\n        if (!(compared === undefined\n              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n              : compared\n            )) {\n          result = false;\n          break;\n        }\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor;\n\n        // Non `Object` object instances with different constructors are not equal.\n        if (objCtor != othCtor &&\n            ('constructor' in object && 'constructor' in other) &&\n            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n              typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n\n    /**\n     * A specialized version of `baseRest` which flattens the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @returns {Function} Returns the new function.\n     */\n    function flatRest(func) {\n      return setToString(overRest(func, undefined, flatten), func + '');\n    }\n\n    /**\n     * Creates an array of own enumerable property names and symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeys(object) {\n      return baseGetAllKeys(object, keys, getSymbols);\n    }\n\n    /**\n     * Creates an array of own and inherited enumerable property names and\n     * symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names and symbols.\n     */\n    function getAllKeysIn(object) {\n      return baseGetAllKeys(object, keysIn, getSymbolsIn);\n    }\n\n    /**\n     * Gets metadata for `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {*} Returns the metadata for `func`.\n     */\n    var getData = !metaMap ? noop : function(func) {\n      return metaMap.get(func);\n    };\n\n    /**\n     * Gets the name of `func`.\n     *\n     * @private\n     * @param {Function} func The function to query.\n     * @returns {string} Returns the function name.\n     */\n    function getFuncName(func) {\n      var result = (func.name + ''),\n          array = realNames[result],\n          length = hasOwnProperty.call(realNames, result) ? array.length : 0;\n\n      while (length--) {\n        var data = array[length],\n            otherFunc = data.func;\n        if (otherFunc == null || otherFunc == func) {\n          return data.name;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Gets the argument placeholder value for `func`.\n     *\n     * @private\n     * @param {Function} func The function to inspect.\n     * @returns {*} Returns the placeholder value.\n     */\n    function getHolder(func) {\n      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;\n      return object.placeholder;\n    }\n\n    /**\n     * Gets the appropriate \"iteratee\" function. If `_.iteratee` is customized,\n     * this function returns the custom method, otherwise it returns `baseIteratee`.\n     * If arguments are provided, the chosen function is invoked with them and\n     * its result is returned.\n     *\n     * @private\n     * @param {*} [value] The value to convert to an iteratee.\n     * @param {number} [arity] The arity of the created iteratee.\n     * @returns {Function} Returns the chosen function or its result.\n     */\n    function getIteratee() {\n      var result = lodash.iteratee || iteratee;\n      result = result === iteratee ? baseIteratee : result;\n      return arguments.length ? result(arguments[0], arguments[1]) : result;\n    }\n\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key)\n        ? data[typeof key == 'string' ? 'string' : 'hash']\n        : data.map;\n    }\n\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n\n    /**\n     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the raw `toStringTag`.\n     */\n    function getRawTag(value) {\n      var isOwn = hasOwnProperty.call(value, symToStringTag),\n          tag = value[symToStringTag];\n\n      try {\n        value[symToStringTag] = undefined;\n        var unmasked = true;\n      } catch (e) {}\n\n      var result = nativeObjectToString.call(value);\n      if (unmasked) {\n        if (isOwn) {\n          value[symToStringTag] = tag;\n        } else {\n          delete value[symToStringTag];\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array of the own enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n      if (object == null) {\n        return [];\n      }\n      object = Object(object);\n      return arrayFilter(nativeGetSymbols(object), function(symbol) {\n        return propertyIsEnumerable.call(object, symbol);\n      });\n    };\n\n    /**\n     * Creates an array of the own and inherited enumerable symbols of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of symbols.\n     */\n    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n      var result = [];\n      while (object) {\n        arrayPush(result, getSymbols(object));\n        object = getPrototype(object);\n      }\n      return result;\n    };\n\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n    var getTag = baseGetTag;\n\n    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\n    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n        (Map && getTag(new Map) != mapTag) ||\n        (Promise && getTag(Promise.resolve()) != promiseTag) ||\n        (Set && getTag(new Set) != setTag) ||\n        (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n      getTag = function(value) {\n        var result = baseGetTag(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : '';\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString: return dataViewTag;\n            case mapCtorString: return mapTag;\n            case promiseCtorString: return promiseTag;\n            case setCtorString: return setTag;\n            case weakMapCtorString: return weakMapTag;\n          }\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Gets the view, applying any `transforms` to the `start` and `end` positions.\n     *\n     * @private\n     * @param {number} start The start of the view.\n     * @param {number} end The end of the view.\n     * @param {Array} transforms The transformations to apply to the view.\n     * @returns {Object} Returns an object containing the `start` and `end`\n     *  positions of the view.\n     */\n    function getView(start, end, transforms) {\n      var index = -1,\n          length = transforms.length;\n\n      while (++index < length) {\n        var data = transforms[index],\n            size = data.size;\n\n        switch (data.type) {\n          case 'drop':      start += size; break;\n          case 'dropRight': end -= size; break;\n          case 'take':      end = nativeMin(end, start + size); break;\n          case 'takeRight': start = nativeMax(start, end - size); break;\n        }\n      }\n      return { 'start': start, 'end': end };\n    }\n\n    /**\n     * Extracts wrapper details from the `source` body comment.\n     *\n     * @private\n     * @param {string} source The source to inspect.\n     * @returns {Array} Returns the wrapper details.\n     */\n    function getWrapDetails(source) {\n      var match = source.match(reWrapDetails);\n      return match ? match[1].split(reSplitDetails) : [];\n    }\n\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n    function hasPath(object, path, hasFunc) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length,\n          result = false;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n        object = object[key];\n      }\n      if (result || ++index != length) {\n        return result;\n      }\n      length = object == null ? 0 : object.length;\n      return !!length && isLength(length) && isIndex(key, length) &&\n        (isArray(object) || isArguments(object));\n    }\n\n    /**\n     * Initializes an array clone.\n     *\n     * @private\n     * @param {Array} array The array to clone.\n     * @returns {Array} Returns the initialized clone.\n     */\n    function initCloneArray(array) {\n      var length = array.length,\n          result = new array.constructor(length);\n\n      // Add properties assigned by `RegExp#exec`.\n      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n        result.index = array.index;\n        result.input = array.input;\n      }\n      return result;\n    }\n\n    /**\n     * Initializes an object clone.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneObject(object) {\n      return (typeof object.constructor == 'function' && !isPrototype(object))\n        ? baseCreate(getPrototype(object))\n        : {};\n    }\n\n    /**\n     * Initializes an object clone based on its `toStringTag`.\n     *\n     * **Note:** This function only supports cloning values with tags of\n     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to clone.\n     * @param {string} tag The `toStringTag` of the object to clone.\n     * @param {boolean} [isDeep] Specify a deep clone.\n     * @returns {Object} Returns the initialized clone.\n     */\n    function initCloneByTag(object, tag, isDeep) {\n      var Ctor = object.constructor;\n      switch (tag) {\n        case arrayBufferTag:\n          return cloneArrayBuffer(object);\n\n        case boolTag:\n        case dateTag:\n          return new Ctor(+object);\n\n        case dataViewTag:\n          return cloneDataView(object, isDeep);\n\n        case float32Tag: case float64Tag:\n        case int8Tag: case int16Tag: case int32Tag:\n        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n          return cloneTypedArray(object, isDeep);\n\n        case mapTag:\n          return new Ctor;\n\n        case numberTag:\n        case stringTag:\n          return new Ctor(object);\n\n        case regexpTag:\n          return cloneRegExp(object);\n\n        case setTag:\n          return new Ctor;\n\n        case symbolTag:\n          return cloneSymbol(object);\n      }\n    }\n\n    /**\n     * Inserts wrapper `details` in a comment at the top of the `source` body.\n     *\n     * @private\n     * @param {string} source The source to modify.\n     * @returns {Array} details The details to insert.\n     * @returns {string} Returns the modified source.\n     */\n    function insertWrapDetails(source, details) {\n      var length = details.length;\n      if (!length) {\n        return source;\n      }\n      var lastIndex = length - 1;\n      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];\n      details = details.join(length > 2 ? ', ' : ' ');\n      return source.replace(reWrapComment, '{\\n/* [wrapped with ' + details + '] */\\n');\n    }\n\n    /**\n     * Checks if `value` is a flattenable `arguments` object or array.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n     */\n    function isFlattenable(value) {\n      return isArray(value) || isArguments(value) ||\n        !!(spreadableSymbol && value && value[spreadableSymbol]);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n    function isIndex(value, length) {\n      var type = typeof value;\n      length = length == null ? MAX_SAFE_INTEGER : length;\n\n      return !!length &&\n        (type == 'number' ||\n          (type != 'symbol' && reIsUint.test(value))) &&\n            (value > -1 && value % 1 == 0 && value < length);\n    }\n\n    /**\n     * Checks if the given arguments are from an iteratee call.\n     *\n     * @private\n     * @param {*} value The potential iteratee value argument.\n     * @param {*} index The potential iteratee index or key argument.\n     * @param {*} object The potential iteratee object argument.\n     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n     *  else `false`.\n     */\n    function isIterateeCall(value, index, object) {\n      if (!isObject(object)) {\n        return false;\n      }\n      var type = typeof index;\n      if (type == 'number'\n            ? (isArrayLike(object) && isIndex(index, object.length))\n            : (type == 'string' && index in object)\n          ) {\n        return eq(object[index], value);\n      }\n      return false;\n    }\n\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n      var type = typeof value;\n      if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n          value == null || isSymbol(value)) {\n        return true;\n      }\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n        (object != null && value in Object(object));\n    }\n\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n    function isKeyable(value) {\n      var type = typeof value;\n      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n        ? (value !== '__proto__')\n        : (value === null);\n    }\n\n    /**\n     * Checks if `func` has a lazy counterpart.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,\n     *  else `false`.\n     */\n    function isLaziable(func) {\n      var funcName = getFuncName(func),\n          other = lodash[funcName];\n\n      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {\n        return false;\n      }\n      if (func === other) {\n        return true;\n      }\n      var data = getData(other);\n      return !!data && func === data[0];\n    }\n\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n    function isMasked(func) {\n      return !!maskSrcKey && (maskSrcKey in func);\n    }\n\n    /**\n     * Checks if `func` is capable of being masked.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.\n     */\n    var isMaskable = coreJsData ? isFunction : stubFalse;\n\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n      return value === proto;\n    }\n\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n    function matchesStrictComparable(key, srcValue) {\n      return function(object) {\n        if (object == null) {\n          return false;\n        }\n        return object[key] === srcValue &&\n          (srcValue !== undefined || (key in Object(object)));\n      };\n    }\n\n    /**\n     * A specialized version of `_.memoize` which clears the memoized function's\n     * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n     *\n     * @private\n     * @param {Function} func The function to have its output memoized.\n     * @returns {Function} Returns the new memoized function.\n     */\n    function memoizeCapped(func) {\n      var result = memoize(func, function(key) {\n        if (cache.size === MAX_MEMOIZE_SIZE) {\n          cache.clear();\n        }\n        return key;\n      });\n\n      var cache = result.cache;\n      return result;\n    }\n\n    /**\n     * Merges the function metadata of `source` into `data`.\n     *\n     * Merging metadata reduces the number of wrappers used to invoke a function.\n     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`\n     * may be applied regardless of execution order. Methods like `_.ary` and\n     * `_.rearg` modify function arguments, making the order in which they are\n     * executed important, preventing the merging of metadata. However, we make\n     * an exception for a safe combined case where curried functions have `_.ary`\n     * and or `_.rearg` applied.\n     *\n     * @private\n     * @param {Array} data The destination metadata.\n     * @param {Array} source The source metadata.\n     * @returns {Array} Returns `data`.\n     */\n    function mergeData(data, source) {\n      var bitmask = data[1],\n          srcBitmask = source[1],\n          newBitmask = bitmask | srcBitmask,\n          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n\n      var isCombo =\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||\n        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||\n        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));\n\n      // Exit early if metadata can't be merged.\n      if (!(isCommon || isCombo)) {\n        return data;\n      }\n      // Use source `thisArg` if available.\n      if (srcBitmask & WRAP_BIND_FLAG) {\n        data[2] = source[2];\n        // Set when currying a bound function.\n        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n      }\n      // Compose partial arguments.\n      var value = source[3];\n      if (value) {\n        var partials = data[3];\n        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n      }\n      // Compose partial right arguments.\n      value = source[5];\n      if (value) {\n        partials = data[5];\n        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n      }\n      // Use source `argPos` if available.\n      value = source[7];\n      if (value) {\n        data[7] = value;\n      }\n      // Use source `ary` if it's smaller.\n      if (srcBitmask & WRAP_ARY_FLAG) {\n        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n      }\n      // Use source `arity` if one is not provided.\n      if (data[9] == null) {\n        data[9] = source[9];\n      }\n      // Use source `func` and merge bitmasks.\n      data[0] = source[0];\n      data[1] = newBitmask;\n\n      return data;\n    }\n\n    /**\n     * This function is like\n     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * except that it includes inherited enumerable properties.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n    function nativeKeysIn(object) {\n      var result = [];\n      if (object != null) {\n        for (var key in Object(object)) {\n          result.push(key);\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a string using `Object.prototype.toString`.\n     *\n     * @private\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     */\n    function objectToString(value) {\n      return nativeObjectToString.call(value);\n    }\n\n    /**\n     * A specialized version of `baseRest` which transforms the rest array.\n     *\n     * @private\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @param {Function} transform The rest array transform.\n     * @returns {Function} Returns the new function.\n     */\n    function overRest(func, start, transform) {\n      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n      return function() {\n        var args = arguments,\n            index = -1,\n            length = nativeMax(args.length - start, 0),\n            array = Array(length);\n\n        while (++index < length) {\n          array[index] = args[start + index];\n        }\n        index = -1;\n        var otherArgs = Array(start + 1);\n        while (++index < start) {\n          otherArgs[index] = args[index];\n        }\n        otherArgs[start] = transform(array);\n        return apply(func, this, otherArgs);\n      };\n    }\n\n    /**\n     * Gets the parent value at `path` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array} path The path to get the parent value of.\n     * @returns {*} Returns the parent value.\n     */\n    function parent(object, path) {\n      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n    }\n\n    /**\n     * Reorder `array` according to the specified indexes where the element at\n     * the first index is assigned as the first element, the element at\n     * the second index is assigned as the second element, and so on.\n     *\n     * @private\n     * @param {Array} array The array to reorder.\n     * @param {Array} indexes The arranged array indexes.\n     * @returns {Array} Returns `array`.\n     */\n    function reorder(array, indexes) {\n      var arrLength = array.length,\n          length = nativeMin(indexes.length, arrLength),\n          oldArray = copyArray(array);\n\n      while (length--) {\n        var index = indexes[length];\n        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;\n      }\n      return array;\n    }\n\n    /**\n     * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n    function safeGet(object, key) {\n      if (key === 'constructor' && typeof object[key] === 'function') {\n        return;\n      }\n\n      if (key == '__proto__') {\n        return;\n      }\n\n      return object[key];\n    }\n\n    /**\n     * Sets metadata for `func`.\n     *\n     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short\n     * period of time, it will trip its breaker and transition to an identity\n     * function to avoid garbage collection pauses in V8. See\n     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)\n     * for more details.\n     *\n     * @private\n     * @param {Function} func The function to associate metadata with.\n     * @param {*} data The metadata.\n     * @returns {Function} Returns `func`.\n     */\n    var setData = shortOut(baseSetData);\n\n    /**\n     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).\n     *\n     * @private\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @returns {number|Object} Returns the timer id or timeout object.\n     */\n    var setTimeout = ctxSetTimeout || function(func, wait) {\n      return root.setTimeout(func, wait);\n    };\n\n    /**\n     * Sets the `toString` method of `func` to return `string`.\n     *\n     * @private\n     * @param {Function} func The function to modify.\n     * @param {Function} string The `toString` result.\n     * @returns {Function} Returns `func`.\n     */\n    var setToString = shortOut(baseSetToString);\n\n    /**\n     * Sets the `toString` method of `wrapper` to mimic the source of `reference`\n     * with wrapper details in a comment at the top of the source body.\n     *\n     * @private\n     * @param {Function} wrapper The function to modify.\n     * @param {Function} reference The reference function.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Function} Returns `wrapper`.\n     */\n    function setWrapToString(wrapper, reference, bitmask) {\n      var source = (reference + '');\n      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n    }\n\n    /**\n     * Creates a function that'll short out and invoke `identity` instead\n     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n     * milliseconds.\n     *\n     * @private\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new shortable function.\n     */\n    function shortOut(func) {\n      var count = 0,\n          lastCalled = 0;\n\n      return function() {\n        var stamp = nativeNow(),\n            remaining = HOT_SPAN - (stamp - lastCalled);\n\n        lastCalled = stamp;\n        if (remaining > 0) {\n          if (++count >= HOT_COUNT) {\n            return arguments[0];\n          }\n        } else {\n          count = 0;\n        }\n        return func.apply(undefined, arguments);\n      };\n    }\n\n    /**\n     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.\n     *\n     * @private\n     * @param {Array} array The array to shuffle.\n     * @param {number} [size=array.length] The size of `array`.\n     * @returns {Array} Returns `array`.\n     */\n    function shuffleSelf(array, size) {\n      var index = -1,\n          length = array.length,\n          lastIndex = length - 1;\n\n      size = size === undefined ? length : size;\n      while (++index < size) {\n        var rand = baseRandom(index, lastIndex),\n            value = array[rand];\n\n        array[rand] = array[index];\n        array[index] = value;\n      }\n      array.length = size;\n      return array;\n    }\n\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n    var stringToPath = memoizeCapped(function(string) {\n      var result = [];\n      if (string.charCodeAt(0) === 46 /* . */) {\n        result.push('');\n      }\n      string.replace(rePropName, function(match, number, quote, subString) {\n        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n      });\n      return result;\n    });\n\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n      var result = (value + '');\n      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n    }\n\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to convert.\n     * @returns {string} Returns the source code.\n     */\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n        try {\n          return (func + '');\n        } catch (e) {}\n      }\n      return '';\n    }\n\n    /**\n     * Updates wrapper `details` based on `bitmask` flags.\n     *\n     * @private\n     * @returns {Array} details The details to modify.\n     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.\n     * @returns {Array} Returns `details`.\n     */\n    function updateWrapDetails(details, bitmask) {\n      arrayEach(wrapFlags, function(pair) {\n        var value = '_.' + pair[0];\n        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {\n          details.push(value);\n        }\n      });\n      return details.sort();\n    }\n\n    /**\n     * Creates a clone of `wrapper`.\n     *\n     * @private\n     * @param {Object} wrapper The wrapper to clone.\n     * @returns {Object} Returns the cloned wrapper.\n     */\n    function wrapperClone(wrapper) {\n      if (wrapper instanceof LazyWrapper) {\n        return wrapper.clone();\n      }\n      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n      result.__actions__ = copyArray(wrapper.__actions__);\n      result.__index__  = wrapper.__index__;\n      result.__values__ = wrapper.__values__;\n      return result;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an array of elements split into groups the length of `size`.\n     * If `array` can't be split evenly, the final chunk will be the remaining\n     * elements.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to process.\n     * @param {number} [size=1] The length of each chunk\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the new array of chunks.\n     * @example\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 2);\n     * // => [['a', 'b'], ['c', 'd']]\n     *\n     * _.chunk(['a', 'b', 'c', 'd'], 3);\n     * // => [['a', 'b', 'c'], ['d']]\n     */\n    function chunk(array, size, guard) {\n      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {\n        size = 1;\n      } else {\n        size = nativeMax(toInteger(size), 0);\n      }\n      var length = array == null ? 0 : array.length;\n      if (!length || size < 1) {\n        return [];\n      }\n      var index = 0,\n          resIndex = 0,\n          result = Array(nativeCeil(length / size));\n\n      while (index < length) {\n        result[resIndex++] = baseSlice(array, index, (index += size));\n      }\n      return result;\n    }\n\n    /**\n     * Creates an array with all falsey values removed. The values `false`, `null`,\n     * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to compact.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.compact([0, 1, false, 2, '', 3]);\n     * // => [1, 2, 3]\n     */\n    function compact(array) {\n      var index = -1,\n          length = array == null ? 0 : array.length,\n          resIndex = 0,\n          result = [];\n\n      while (++index < length) {\n        var value = array[index];\n        if (value) {\n          result[resIndex++] = value;\n        }\n      }\n      return result;\n    }\n\n    /**\n     * Creates a new array concatenating `array` with any additional arrays\n     * and/or values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to concatenate.\n     * @param {...*} [values] The values to concatenate.\n     * @returns {Array} Returns the new concatenated array.\n     * @example\n     *\n     * var array = [1];\n     * var other = _.concat(array, 2, [3], [[4]]);\n     *\n     * console.log(other);\n     * // => [1, 2, 3, [4]]\n     *\n     * console.log(array);\n     * // => [1]\n     */\n    function concat() {\n      var length = arguments.length;\n      if (!length) {\n        return [];\n      }\n      var args = Array(length - 1),\n          array = arguments[0],\n          index = length;\n\n      while (index--) {\n        args[index - 1] = arguments[index];\n      }\n      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));\n    }\n\n    /**\n     * Creates an array of `array` values not included in the other given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * **Note:** Unlike `_.pullAll`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.without, _.xor\n     * @example\n     *\n     * _.difference([2, 1], [2, 3]);\n     * // => [1]\n     */\n    var difference = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `iteratee` which\n     * is invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var differenceBy = baseRest(function(array, values) {\n      var iteratee = last(values);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.difference` except that it accepts `comparator`\n     * which is invoked to compare elements of `array` to `values`. The order and\n     * references of result values are determined by the first array. The comparator\n     * is invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...Array} [values] The values to exclude.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     *\n     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }]\n     */\n    var differenceWith = baseRest(function(array, values) {\n      var comparator = last(values);\n      if (isArrayLikeObject(comparator)) {\n        comparator = undefined;\n      }\n      return isArrayLikeObject(array)\n        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.drop([1, 2, 3]);\n     * // => [2, 3]\n     *\n     * _.drop([1, 2, 3], 2);\n     * // => [3]\n     *\n     * _.drop([1, 2, 3], 5);\n     * // => []\n     *\n     * _.drop([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function drop(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements dropped from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to drop.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.dropRight([1, 2, 3]);\n     * // => [1, 2]\n     *\n     * _.dropRight([1, 2, 3], 2);\n     * // => [1]\n     *\n     * _.dropRight([1, 2, 3], 5);\n     * // => []\n     *\n     * _.dropRight([1, 2, 3], 0);\n     * // => [1, 2, 3]\n     */\n    function dropRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the end.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.dropRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropRightWhile(users, ['active', false]);\n     * // => objects for ['barney']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropRightWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` excluding elements dropped from the beginning.\n     * Elements are dropped until `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.dropWhile(users, function(o) { return !o.active; });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.dropWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.dropWhile(users, ['active', false]);\n     * // => objects for ['pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.dropWhile(users, 'active');\n     * // => objects for ['barney', 'fred', 'pebbles']\n     */\n    function dropWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), true)\n        : [];\n    }\n\n    /**\n     * Fills elements of `array` with `value` from `start` up to, but not\n     * including, `end`.\n     *\n     * **Note:** This method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Array\n     * @param {Array} array The array to fill.\n     * @param {*} value The value to fill `array` with.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.fill(array, 'a');\n     * console.log(array);\n     * // => ['a', 'a', 'a']\n     *\n     * _.fill(Array(3), 2);\n     * // => [2, 2, 2]\n     *\n     * _.fill([4, 6, 8, 10], '*', 1, 3);\n     * // => [4, '*', '*', 10]\n     */\n    function fill(array, value, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {\n        start = 0;\n        end = length;\n      }\n      return baseFill(array, value, start, end);\n    }\n\n    /**\n     * This method is like `_.find` except that it returns the index of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.findIndex(users, function(o) { return o.user == 'barney'; });\n     * // => 0\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findIndex(users, { 'user': 'fred', 'active': false });\n     * // => 1\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findIndex(users, ['active', false]);\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findIndex(users, 'active');\n     * // => 2\n     */\n    function findIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index);\n    }\n\n    /**\n     * This method is like `_.findIndex` except that it iterates over elements\n     * of `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the found element, else `-1`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });\n     * // => 2\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastIndex(users, { 'user': 'barney', 'active': true });\n     * // => 0\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastIndex(users, ['active', false]);\n     * // => 2\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastIndex(users, 'active');\n     * // => 0\n     */\n    function findLastIndex(array, predicate, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length - 1;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = fromIndex < 0\n          ? nativeMax(length + index, 0)\n          : nativeMin(index, length - 1);\n      }\n      return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n    }\n\n    /**\n     * Flattens `array` a single level deep.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flatten([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, [3, [4]], 5]\n     */\n    function flatten(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, 1) : [];\n    }\n\n    /**\n     * Recursively flattens `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * _.flattenDeep([1, [2, [3, [4]], 5]]);\n     * // => [1, 2, 3, 4, 5]\n     */\n    function flattenDeep(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseFlatten(array, INFINITY) : [];\n    }\n\n    /**\n     * Recursively flatten `array` up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Array\n     * @param {Array} array The array to flatten.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * var array = [1, [2, [3, [4]], 5]];\n     *\n     * _.flattenDepth(array, 1);\n     * // => [1, 2, [3, [4]], 5]\n     *\n     * _.flattenDepth(array, 2);\n     * // => [1, 2, 3, [4], 5]\n     */\n    function flattenDepth(array, depth) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(array, depth);\n    }\n\n    /**\n     * The inverse of `_.toPairs`; this method returns an object composed\n     * from key-value `pairs`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} pairs The key-value pairs.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.fromPairs([['a', 1], ['b', 2]]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function fromPairs(pairs) {\n      var index = -1,\n          length = pairs == null ? 0 : pairs.length,\n          result = {};\n\n      while (++index < length) {\n        var pair = pairs[index];\n        result[pair[0]] = pair[1];\n      }\n      return result;\n    }\n\n    /**\n     * Gets the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias first\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the first element of `array`.\n     * @example\n     *\n     * _.head([1, 2, 3]);\n     * // => 1\n     *\n     * _.head([]);\n     * // => undefined\n     */\n    function head(array) {\n      return (array && array.length) ? array[0] : undefined;\n    }\n\n    /**\n     * Gets the index at which the first occurrence of `value` is found in `array`\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. If `fromIndex` is negative, it's used as the\n     * offset from the end of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.indexOf([1, 2, 1, 2], 2);\n     * // => 1\n     *\n     * // Search from the `fromIndex`.\n     * _.indexOf([1, 2, 1, 2], 2, 2);\n     * // => 3\n     */\n    function indexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = fromIndex == null ? 0 : toInteger(fromIndex);\n      if (index < 0) {\n        index = nativeMax(length + index, 0);\n      }\n      return baseIndexOf(array, value, index);\n    }\n\n    /**\n     * Gets all but the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.initial([1, 2, 3]);\n     * // => [1, 2]\n     */\n    function initial(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 0, -1) : [];\n    }\n\n    /**\n     * Creates an array of unique values that are included in all given arrays\n     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons. The order and references of result values are\n     * determined by the first array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersection([2, 1], [2, 3]);\n     * // => [2]\n     */\n    var intersection = baseRest(function(arrays) {\n      var mapped = arrayMap(arrays, castArrayLikeObject);\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped)\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `iteratee`\n     * which is invoked for each element of each `arrays` to generate the criterion\n     * by which they're compared. The order and references of result values are\n     * determined by the first array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [2.1]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }]\n     */\n    var intersectionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      if (iteratee === last(mapped)) {\n        iteratee = undefined;\n      } else {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, getIteratee(iteratee, 2))\n        : [];\n    });\n\n    /**\n     * This method is like `_.intersection` except that it accepts `comparator`\n     * which is invoked to compare elements of `arrays`. The order and references\n     * of result values are determined by the first array. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of intersecting values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.intersectionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }]\n     */\n    var intersectionWith = baseRest(function(arrays) {\n      var comparator = last(arrays),\n          mapped = arrayMap(arrays, castArrayLikeObject);\n\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      if (comparator) {\n        mapped.pop();\n      }\n      return (mapped.length && mapped[0] === arrays[0])\n        ? baseIntersection(mapped, undefined, comparator)\n        : [];\n    });\n\n    /**\n     * Converts all elements in `array` into a string separated by `separator`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to convert.\n     * @param {string} [separator=','] The element separator.\n     * @returns {string} Returns the joined string.\n     * @example\n     *\n     * _.join(['a', 'b', 'c'], '~');\n     * // => 'a~b~c'\n     */\n    function join(array, separator) {\n      return array == null ? '' : nativeJoin.call(array, separator);\n    }\n\n    /**\n     * Gets the last element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {*} Returns the last element of `array`.\n     * @example\n     *\n     * _.last([1, 2, 3]);\n     * // => 3\n     */\n    function last(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? array[length - 1] : undefined;\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it iterates over elements of\n     * `array` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=array.length-1] The index to search from.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.lastIndexOf([1, 2, 1, 2], 2);\n     * // => 3\n     *\n     * // Search from the `fromIndex`.\n     * _.lastIndexOf([1, 2, 1, 2], 2, 2);\n     * // => 1\n     */\n    function lastIndexOf(array, value, fromIndex) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return -1;\n      }\n      var index = length;\n      if (fromIndex !== undefined) {\n        index = toInteger(fromIndex);\n        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n      }\n      return value === value\n        ? strictLastIndexOf(array, value, index)\n        : baseFindIndex(array, baseIsNaN, index, true);\n    }\n\n    /**\n     * Gets the element at index `n` of `array`. If `n` is negative, the nth\n     * element from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.11.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=0] The index of the element to return.\n     * @returns {*} Returns the nth element of `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     *\n     * _.nth(array, 1);\n     * // => 'b'\n     *\n     * _.nth(array, -2);\n     * // => 'c';\n     */\n    function nth(array, n) {\n      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;\n    }\n\n    /**\n     * Removes all given values from `array` using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`\n     * to remove elements from an array by predicate.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...*} [values] The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pull(array, 'a', 'c');\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    var pull = baseRest(pullAll);\n\n    /**\n     * This method is like `_.pull` except that it accepts an array of values to remove.\n     *\n     * **Note:** Unlike `_.difference`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];\n     *\n     * _.pullAll(array, ['a', 'c']);\n     * console.log(array);\n     * // => ['b', 'b']\n     */\n    function pullAll(array, values) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values)\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `iteratee` which is\n     * invoked for each element of `array` and `values` to generate the criterion\n     * by which they're compared. The iteratee is invoked with one argument: (value).\n     *\n     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];\n     *\n     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');\n     * console.log(array);\n     * // => [{ 'x': 2 }]\n     */\n    function pullAllBy(array, values, iteratee) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, getIteratee(iteratee, 2))\n        : array;\n    }\n\n    /**\n     * This method is like `_.pullAll` except that it accepts `comparator` which\n     * is invoked to compare elements of `array` to `values`. The comparator is\n     * invoked with two arguments: (arrVal, othVal).\n     *\n     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Array} values The values to remove.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];\n     *\n     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);\n     * console.log(array);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]\n     */\n    function pullAllWith(array, values, comparator) {\n      return (array && array.length && values && values.length)\n        ? basePullAll(array, values, undefined, comparator)\n        : array;\n    }\n\n    /**\n     * Removes elements from `array` corresponding to `indexes` and returns an\n     * array of removed elements.\n     *\n     * **Note:** Unlike `_.at`, this method mutates `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {...(number|number[])} [indexes] The indexes of elements to remove.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = ['a', 'b', 'c', 'd'];\n     * var pulled = _.pullAt(array, [1, 3]);\n     *\n     * console.log(array);\n     * // => ['a', 'c']\n     *\n     * console.log(pulled);\n     * // => ['b', 'd']\n     */\n    var pullAt = flatRest(function(array, indexes) {\n      var length = array == null ? 0 : array.length,\n          result = baseAt(array, indexes);\n\n      basePullAt(array, arrayMap(indexes, function(index) {\n        return isIndex(index, length) ? +index : index;\n      }).sort(compareAscending));\n\n      return result;\n    });\n\n    /**\n     * Removes all elements from `array` that `predicate` returns truthy for\n     * and returns an array of the removed elements. The predicate is invoked\n     * with three arguments: (value, index, array).\n     *\n     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`\n     * to pull elements from an array by value.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new array of removed elements.\n     * @example\n     *\n     * var array = [1, 2, 3, 4];\n     * var evens = _.remove(array, function(n) {\n     *   return n % 2 == 0;\n     * });\n     *\n     * console.log(array);\n     * // => [1, 3]\n     *\n     * console.log(evens);\n     * // => [2, 4]\n     */\n    function remove(array, predicate) {\n      var result = [];\n      if (!(array && array.length)) {\n        return result;\n      }\n      var index = -1,\n          indexes = [],\n          length = array.length;\n\n      predicate = getIteratee(predicate, 3);\n      while (++index < length) {\n        var value = array[index];\n        if (predicate(value, index, array)) {\n          result.push(value);\n          indexes.push(index);\n        }\n      }\n      basePullAt(array, indexes);\n      return result;\n    }\n\n    /**\n     * Reverses `array` so that the first element becomes the last, the second\n     * element becomes the second to last, and so on.\n     *\n     * **Note:** This method mutates `array` and is based on\n     * [`Array#reverse`](https://mdn.io/Array/reverse).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to modify.\n     * @returns {Array} Returns `array`.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _.reverse(array);\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function reverse(array) {\n      return array == null ? array : nativeReverse.call(array);\n    }\n\n    /**\n     * Creates a slice of `array` from `start` up to, but not including, `end`.\n     *\n     * **Note:** This method is used instead of\n     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are\n     * returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to slice.\n     * @param {number} [start=0] The start position.\n     * @param {number} [end=array.length] The end position.\n     * @returns {Array} Returns the slice of `array`.\n     */\n    function slice(array, start, end) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {\n        start = 0;\n        end = length;\n      }\n      else {\n        start = start == null ? 0 : toInteger(start);\n        end = end === undefined ? length : toInteger(end);\n      }\n      return baseSlice(array, start, end);\n    }\n\n    /**\n     * Uses a binary search to determine the lowest index at which `value`\n     * should be inserted into `array` in order to maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedIndex([30, 50], 40);\n     * // => 1\n     */\n    function sortedIndex(array, value) {\n      return baseSortedIndex(array, value);\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 0\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 0\n     */\n    function sortedIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * This method is like `_.indexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 1\n     */\n    function sortedIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value);\n        if (index < length && eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.sortedIndex` except that it returns the highest\n     * index at which `value` should be inserted into `array` in order to\n     * maintain its sort order.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);\n     * // => 4\n     */\n    function sortedLastIndex(array, value) {\n      return baseSortedIndex(array, value, true);\n    }\n\n    /**\n     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`\n     * which is invoked for `value` and each element of `array` to compute their\n     * sort ranking. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The sorted array to inspect.\n     * @param {*} value The value to evaluate.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the index at which `value` should be inserted\n     *  into `array`.\n     * @example\n     *\n     * var objects = [{ 'x': 4 }, { 'x': 5 }];\n     *\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });\n     * // => 1\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');\n     * // => 1\n     */\n    function sortedLastIndexBy(array, value, iteratee) {\n      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);\n    }\n\n    /**\n     * This method is like `_.lastIndexOf` except that it performs a binary\n     * search on a sorted `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {*} value The value to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     * @example\n     *\n     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);\n     * // => 3\n     */\n    function sortedLastIndexOf(array, value) {\n      var length = array == null ? 0 : array.length;\n      if (length) {\n        var index = baseSortedIndex(array, value, true) - 1;\n        if (eq(array[index], value)) {\n          return index;\n        }\n      }\n      return -1;\n    }\n\n    /**\n     * This method is like `_.uniq` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniq([1, 1, 2]);\n     * // => [1, 2]\n     */\n    function sortedUniq(array) {\n      return (array && array.length)\n        ? baseSortedUniq(array)\n        : [];\n    }\n\n    /**\n     * This method is like `_.uniqBy` except that it's designed and optimized\n     * for sorted arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);\n     * // => [1.1, 2.3]\n     */\n    function sortedUniqBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSortedUniq(array, getIteratee(iteratee, 2))\n        : [];\n    }\n\n    /**\n     * Gets all but the first element of `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.tail([1, 2, 3]);\n     * // => [2, 3]\n     */\n    function tail(array) {\n      var length = array == null ? 0 : array.length;\n      return length ? baseSlice(array, 1, length) : [];\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the beginning.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.take([1, 2, 3]);\n     * // => [1]\n     *\n     * _.take([1, 2, 3], 2);\n     * // => [1, 2]\n     *\n     * _.take([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.take([1, 2, 3], 0);\n     * // => []\n     */\n    function take(array, n, guard) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      return baseSlice(array, 0, n < 0 ? 0 : n);\n    }\n\n    /**\n     * Creates a slice of `array` with `n` elements taken from the end.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {number} [n=1] The number of elements to take.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * _.takeRight([1, 2, 3]);\n     * // => [3]\n     *\n     * _.takeRight([1, 2, 3], 2);\n     * // => [2, 3]\n     *\n     * _.takeRight([1, 2, 3], 5);\n     * // => [1, 2, 3]\n     *\n     * _.takeRight([1, 2, 3], 0);\n     * // => []\n     */\n    function takeRight(array, n, guard) {\n      var length = array == null ? 0 : array.length;\n      if (!length) {\n        return [];\n      }\n      n = (guard || n === undefined) ? 1 : toInteger(n);\n      n = length - n;\n      return baseSlice(array, n < 0 ? 0 : n, length);\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the end. Elements are\n     * taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': true },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': false }\n     * ];\n     *\n     * _.takeRightWhile(users, function(o) { return !o.active; });\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });\n     * // => objects for ['pebbles']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeRightWhile(users, ['active', false]);\n     * // => objects for ['fred', 'pebbles']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeRightWhile(users, 'active');\n     * // => []\n     */\n    function takeRightWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3), false, true)\n        : [];\n    }\n\n    /**\n     * Creates a slice of `array` with elements taken from the beginning. Elements\n     * are taken until `predicate` returns falsey. The predicate is invoked with\n     * three arguments: (value, index, array).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Array\n     * @param {Array} array The array to query.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the slice of `array`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'active': false },\n     *   { 'user': 'fred',    'active': false },\n     *   { 'user': 'pebbles', 'active': true }\n     * ];\n     *\n     * _.takeWhile(users, function(o) { return !o.active; });\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.takeWhile(users, { 'user': 'barney', 'active': false });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.takeWhile(users, ['active', false]);\n     * // => objects for ['barney', 'fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.takeWhile(users, 'active');\n     * // => []\n     */\n    function takeWhile(array, predicate) {\n      return (array && array.length)\n        ? baseWhile(array, getIteratee(predicate, 3))\n        : [];\n    }\n\n    /**\n     * Creates an array of unique values, in order, from all given arrays using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.union([2], [1, 2]);\n     * // => [2, 1]\n     */\n    var union = baseRest(function(arrays) {\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which uniqueness is computed. Result values are chosen from the first\n     * array in which the value occurs. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * _.unionBy([2.1], [1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    var unionBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.union` except that it accepts `comparator` which\n     * is invoked to compare elements of `arrays`. Result values are chosen from\n     * the first array in which the value occurs. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of combined values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.unionWith(objects, others, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var unionWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);\n    });\n\n    /**\n     * Creates a duplicate-free version of an array, using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons, in which only the first occurrence of each element\n     * is kept. The order of result values is determined by the order they occur\n     * in the array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniq([2, 1, 2]);\n     * // => [2, 1]\n     */\n    function uniq(array) {\n      return (array && array.length) ? baseUniq(array) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * uniqueness is computed. The order of result values is determined by the\n     * order they occur in the array. The iteratee is invoked with one argument:\n     * (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\n     * // => [2.1, 1.2]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 1 }, { 'x': 2 }]\n     */\n    function uniqBy(array, iteratee) {\n      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];\n    }\n\n    /**\n     * This method is like `_.uniq` except that it accepts `comparator` which\n     * is invoked to compare elements of `array`. The order of result values is\n     * determined by the order they occur in the array.The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new duplicate free array.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.uniqWith(objects, _.isEqual);\n     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]\n     */\n    function uniqWith(array, comparator) {\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts an array of grouped\n     * elements and creates an array regrouping the elements to their pre-zip\n     * configuration.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.2.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     *\n     * _.unzip(zipped);\n     * // => [['a', 'b'], [1, 2], [true, false]]\n     */\n    function unzip(array) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var length = 0;\n      array = arrayFilter(array, function(group) {\n        if (isArrayLikeObject(group)) {\n          length = nativeMax(group.length, length);\n          return true;\n        }\n      });\n      return baseTimes(length, function(index) {\n        return arrayMap(array, baseProperty(index));\n      });\n    }\n\n    /**\n     * This method is like `_.unzip` except that it accepts `iteratee` to specify\n     * how regrouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {Array} array The array of grouped elements to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  regrouped values.\n     * @returns {Array} Returns the new array of regrouped elements.\n     * @example\n     *\n     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);\n     * // => [[1, 10, 100], [2, 20, 200]]\n     *\n     * _.unzipWith(zipped, _.add);\n     * // => [3, 30, 300]\n     */\n    function unzipWith(array, iteratee) {\n      if (!(array && array.length)) {\n        return [];\n      }\n      var result = unzip(array);\n      if (iteratee == null) {\n        return result;\n      }\n      return arrayMap(result, function(group) {\n        return apply(iteratee, undefined, group);\n      });\n    }\n\n    /**\n     * Creates an array excluding all given values using\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * for equality comparisons.\n     *\n     * **Note:** Unlike `_.pull`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {Array} array The array to inspect.\n     * @param {...*} [values] The values to exclude.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.xor\n     * @example\n     *\n     * _.without([2, 1, 2, 3], 1, 2);\n     * // => [3]\n     */\n    var without = baseRest(function(array, values) {\n      return isArrayLikeObject(array)\n        ? baseDifference(array, values)\n        : [];\n    });\n\n    /**\n     * Creates an array of unique values that is the\n     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)\n     * of the given arrays. The order of result values is determined by the order\n     * they occur in the arrays.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @returns {Array} Returns the new array of filtered values.\n     * @see _.difference, _.without\n     * @example\n     *\n     * _.xor([2, 1], [2, 3]);\n     * // => [1, 3]\n     */\n    var xor = baseRest(function(arrays) {\n      return baseXor(arrayFilter(arrays, isArrayLikeObject));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `iteratee` which is\n     * invoked for each element of each `arrays` to generate the criterion by\n     * which by which they're compared. The order of result values is determined\n     * by the order they occur in the arrays. The iteratee is invoked with one\n     * argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);\n     * // => [1.2, 3.4]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');\n     * // => [{ 'x': 2 }]\n     */\n    var xorBy = baseRest(function(arrays) {\n      var iteratee = last(arrays);\n      if (isArrayLikeObject(iteratee)) {\n        iteratee = undefined;\n      }\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));\n    });\n\n    /**\n     * This method is like `_.xor` except that it accepts `comparator` which is\n     * invoked to compare elements of `arrays`. The order of result values is\n     * determined by the order they occur in the arrays. The comparator is invoked\n     * with two arguments: (arrVal, othVal).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to inspect.\n     * @param {Function} [comparator] The comparator invoked per element.\n     * @returns {Array} Returns the new array of filtered values.\n     * @example\n     *\n     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];\n     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];\n     *\n     * _.xorWith(objects, others, _.isEqual);\n     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]\n     */\n    var xorWith = baseRest(function(arrays) {\n      var comparator = last(arrays);\n      comparator = typeof comparator == 'function' ? comparator : undefined;\n      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);\n    });\n\n    /**\n     * Creates an array of grouped elements, the first of which contains the\n     * first elements of the given arrays, the second of which contains the\n     * second elements of the given arrays, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zip(['a', 'b'], [1, 2], [true, false]);\n     * // => [['a', 1, true], ['b', 2, false]]\n     */\n    var zip = baseRest(unzip);\n\n    /**\n     * This method is like `_.fromPairs` except that it accepts two arrays,\n     * one of property identifiers and one of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.4.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObject(['a', 'b'], [1, 2]);\n     * // => { 'a': 1, 'b': 2 }\n     */\n    function zipObject(props, values) {\n      return baseZipObject(props || [], values || [], assignValue);\n    }\n\n    /**\n     * This method is like `_.zipObject` except that it supports property paths.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Array\n     * @param {Array} [props=[]] The property identifiers.\n     * @param {Array} [values=[]] The property values.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);\n     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }\n     */\n    function zipObjectDeep(props, values) {\n      return baseZipObject(props || [], values || [], baseSet);\n    }\n\n    /**\n     * This method is like `_.zip` except that it accepts `iteratee` to specify\n     * how grouped values should be combined. The iteratee is invoked with the\n     * elements of each group: (...group).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Array\n     * @param {...Array} [arrays] The arrays to process.\n     * @param {Function} [iteratee=_.identity] The function to combine\n     *  grouped values.\n     * @returns {Array} Returns the new array of grouped elements.\n     * @example\n     *\n     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {\n     *   return a + b + c;\n     * });\n     * // => [111, 222]\n     */\n    var zipWith = baseRest(function(arrays) {\n      var length = arrays.length,\n          iteratee = length > 1 ? arrays[length - 1] : undefined;\n\n      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;\n      return unzipWith(arrays, iteratee);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates a `lodash` wrapper instance that wraps `value` with explicit method\n     * chain sequences enabled. The result of such sequences must be unwrapped\n     * with `_#value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Seq\n     * @param {*} value The value to wrap.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36 },\n     *   { 'user': 'fred',    'age': 40 },\n     *   { 'user': 'pebbles', 'age': 1 }\n     * ];\n     *\n     * var youngest = _\n     *   .chain(users)\n     *   .sortBy('age')\n     *   .map(function(o) {\n     *     return o.user + ' is ' + o.age;\n     *   })\n     *   .head()\n     *   .value();\n     * // => 'pebbles is 1'\n     */\n    function chain(value) {\n      var result = lodash(value);\n      result.__chain__ = true;\n      return result;\n    }\n\n    /**\n     * This method invokes `interceptor` and returns `value`. The interceptor\n     * is invoked with one argument; (value). The purpose of this method is to\n     * \"tap into\" a method chain sequence in order to modify intermediate results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * _([1, 2, 3])\n     *  .tap(function(array) {\n     *    // Mutate input array.\n     *    array.pop();\n     *  })\n     *  .reverse()\n     *  .value();\n     * // => [2, 1]\n     */\n    function tap(value, interceptor) {\n      interceptor(value);\n      return value;\n    }\n\n    /**\n     * This method is like `_.tap` except that it returns the result of `interceptor`.\n     * The purpose of this method is to \"pass thru\" values replacing intermediate\n     * results in a method chain sequence.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Seq\n     * @param {*} value The value to provide to `interceptor`.\n     * @param {Function} interceptor The function to invoke.\n     * @returns {*} Returns the result of `interceptor`.\n     * @example\n     *\n     * _('  abc  ')\n     *  .chain()\n     *  .trim()\n     *  .thru(function(value) {\n     *    return [value];\n     *  })\n     *  .value();\n     * // => ['abc']\n     */\n    function thru(value, interceptor) {\n      return interceptor(value);\n    }\n\n    /**\n     * This method is the wrapper version of `_.at`.\n     *\n     * @name at\n     * @memberOf _\n     * @since 1.0.0\n     * @category Seq\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _(object).at(['a[0].b.c', 'a[1]']).value();\n     * // => [3, 4]\n     */\n    var wrapperAt = flatRest(function(paths) {\n      var length = paths.length,\n          start = length ? paths[0] : 0,\n          value = this.__wrapped__,\n          interceptor = function(object) { return baseAt(object, paths); };\n\n      if (length > 1 || this.__actions__.length ||\n          !(value instanceof LazyWrapper) || !isIndex(start)) {\n        return this.thru(interceptor);\n      }\n      value = value.slice(start, +start + (length ? 1 : 0));\n      value.__actions__.push({\n        'func': thru,\n        'args': [interceptor],\n        'thisArg': undefined\n      });\n      return new LodashWrapper(value, this.__chain__).thru(function(array) {\n        if (length && !array.length) {\n          array.push(undefined);\n        }\n        return array;\n      });\n    });\n\n    /**\n     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.\n     *\n     * @name chain\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 }\n     * ];\n     *\n     * // A sequence without explicit chaining.\n     * _(users).head();\n     * // => { 'user': 'barney', 'age': 36 }\n     *\n     * // A sequence with explicit chaining.\n     * _(users)\n     *   .chain()\n     *   .head()\n     *   .pick('user')\n     *   .value();\n     * // => { 'user': 'barney' }\n     */\n    function wrapperChain() {\n      return chain(this);\n    }\n\n    /**\n     * Executes the chain sequence and returns the wrapped result.\n     *\n     * @name commit\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2];\n     * var wrapped = _(array).push(3);\n     *\n     * console.log(array);\n     * // => [1, 2]\n     *\n     * wrapped = wrapped.commit();\n     * console.log(array);\n     * // => [1, 2, 3]\n     *\n     * wrapped.last();\n     * // => 3\n     *\n     * console.log(array);\n     * // => [1, 2, 3]\n     */\n    function wrapperCommit() {\n      return new LodashWrapper(this.value(), this.__chain__);\n    }\n\n    /**\n     * Gets the next value on a wrapped object following the\n     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).\n     *\n     * @name next\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the next iterator value.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 1 }\n     *\n     * wrapped.next();\n     * // => { 'done': false, 'value': 2 }\n     *\n     * wrapped.next();\n     * // => { 'done': true, 'value': undefined }\n     */\n    function wrapperNext() {\n      if (this.__values__ === undefined) {\n        this.__values__ = toArray(this.value());\n      }\n      var done = this.__index__ >= this.__values__.length,\n          value = done ? undefined : this.__values__[this.__index__++];\n\n      return { 'done': done, 'value': value };\n    }\n\n    /**\n     * Enables the wrapper to be iterable.\n     *\n     * @name Symbol.iterator\n     * @memberOf _\n     * @since 4.0.0\n     * @category Seq\n     * @returns {Object} Returns the wrapper object.\n     * @example\n     *\n     * var wrapped = _([1, 2]);\n     *\n     * wrapped[Symbol.iterator]() === wrapped;\n     * // => true\n     *\n     * Array.from(wrapped);\n     * // => [1, 2]\n     */\n    function wrapperToIterator() {\n      return this;\n    }\n\n    /**\n     * Creates a clone of the chain sequence planting `value` as the wrapped value.\n     *\n     * @name plant\n     * @memberOf _\n     * @since 3.2.0\n     * @category Seq\n     * @param {*} value The value to plant.\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var wrapped = _([1, 2]).map(square);\n     * var other = wrapped.plant([3, 4]);\n     *\n     * other.value();\n     * // => [9, 16]\n     *\n     * wrapped.value();\n     * // => [1, 4]\n     */\n    function wrapperPlant(value) {\n      var result,\n          parent = this;\n\n      while (parent instanceof baseLodash) {\n        var clone = wrapperClone(parent);\n        clone.__index__ = 0;\n        clone.__values__ = undefined;\n        if (result) {\n          previous.__wrapped__ = clone;\n        } else {\n          result = clone;\n        }\n        var previous = clone;\n        parent = parent.__wrapped__;\n      }\n      previous.__wrapped__ = value;\n      return result;\n    }\n\n    /**\n     * This method is the wrapper version of `_.reverse`.\n     *\n     * **Note:** This method mutates the wrapped array.\n     *\n     * @name reverse\n     * @memberOf _\n     * @since 0.1.0\n     * @category Seq\n     * @returns {Object} Returns the new `lodash` wrapper instance.\n     * @example\n     *\n     * var array = [1, 2, 3];\n     *\n     * _(array).reverse().value()\n     * // => [3, 2, 1]\n     *\n     * console.log(array);\n     * // => [3, 2, 1]\n     */\n    function wrapperReverse() {\n      var value = this.__wrapped__;\n      if (value instanceof LazyWrapper) {\n        var wrapped = value;\n        if (this.__actions__.length) {\n          wrapped = new LazyWrapper(this);\n        }\n        wrapped = wrapped.reverse();\n        wrapped.__actions__.push({\n          'func': thru,\n          'args': [reverse],\n          'thisArg': undefined\n        });\n        return new LodashWrapper(wrapped, this.__chain__);\n      }\n      return this.thru(reverse);\n    }\n\n    /**\n     * Executes the chain sequence to resolve the unwrapped value.\n     *\n     * @name value\n     * @memberOf _\n     * @since 0.1.0\n     * @alias toJSON, valueOf\n     * @category Seq\n     * @returns {*} Returns the resolved unwrapped value.\n     * @example\n     *\n     * _([1, 2, 3]).value();\n     * // => [1, 2, 3]\n     */\n    function wrapperValue() {\n      return baseWrapperValue(this.__wrapped__, this.__actions__);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the number of times the key was returned by `iteratee`. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.countBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': 1, '6': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.countBy(['one', 'two', 'three'], 'length');\n     * // => { '3': 2, '5': 1 }\n     */\n    var countBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        ++result[key];\n      } else {\n        baseAssignValue(result, key, 1);\n      }\n    });\n\n    /**\n     * Checks if `predicate` returns truthy for **all** elements of `collection`.\n     * Iteration is stopped once `predicate` returns falsey. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * **Note:** This method returns `true` for\n     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\n     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\n     * elements of empty collections.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if all elements pass the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.every([true, 1, null, 'yes'], Boolean);\n     * // => false\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.every(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.every(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.every(users, 'active');\n     * // => false\n     */\n    function every(collection, predicate, guard) {\n      var func = isArray(collection) ? arrayEvery : baseEvery;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning an array of all elements\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * **Note:** Unlike `_.remove`, this method returns a new array.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.reject\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * _.filter(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, { 'age': 36, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.filter(users, 'active');\n     * // => objects for ['barney']\n     */\n    function filter(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Iterates over elements of `collection`, returning the first element\n     * `predicate` returns truthy for. The predicate is invoked with three\n     * arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': true },\n     *   { 'user': 'fred',    'age': 40, 'active': false },\n     *   { 'user': 'pebbles', 'age': 1,  'active': true }\n     * ];\n     *\n     * _.find(users, function(o) { return o.age < 40; });\n     * // => object for 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.find(users, { 'age': 1, 'active': true });\n     * // => object for 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.find(users, ['active', false]);\n     * // => object for 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.find(users, 'active');\n     * // => object for 'barney'\n     */\n    var find = createFind(findIndex);\n\n    /**\n     * This method is like `_.find` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param {number} [fromIndex=collection.length-1] The index to search from.\n     * @returns {*} Returns the matched element, else `undefined`.\n     * @example\n     *\n     * _.findLast([1, 2, 3, 4], function(n) {\n     *   return n % 2 == 1;\n     * });\n     * // => 3\n     */\n    var findLast = createFind(findLastIndex);\n\n    /**\n     * Creates a flattened array of values by running each element in `collection`\n     * thru `iteratee` and flattening the mapped results. The iteratee is invoked\n     * with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [n, n];\n     * }\n     *\n     * _.flatMap([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMap(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), 1);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDeep([1, 2], duplicate);\n     * // => [1, 1, 2, 2]\n     */\n    function flatMapDeep(collection, iteratee) {\n      return baseFlatten(map(collection, iteratee), INFINITY);\n    }\n\n    /**\n     * This method is like `_.flatMap` except that it recursively flattens the\n     * mapped results up to `depth` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {number} [depth=1] The maximum recursion depth.\n     * @returns {Array} Returns the new flattened array.\n     * @example\n     *\n     * function duplicate(n) {\n     *   return [[[n, n]]];\n     * }\n     *\n     * _.flatMapDepth([1, 2], duplicate, 2);\n     * // => [[1, 1], [2, 2]]\n     */\n    function flatMapDepth(collection, iteratee, depth) {\n      depth = depth === undefined ? 1 : toInteger(depth);\n      return baseFlatten(map(collection, iteratee), depth);\n    }\n\n    /**\n     * Iterates over elements of `collection` and invokes `iteratee` for each element.\n     * The iteratee is invoked with three arguments: (value, index|key, collection).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * **Note:** As with other \"Collections\" methods, objects with a \"length\"\n     * property are iterated like arrays. To avoid this behavior use `_.forIn`\n     * or `_.forOwn` for object iteration.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @alias each\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEachRight\n     * @example\n     *\n     * _.forEach([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `1` then `2`.\n     *\n     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forEach(collection, iteratee) {\n      var func = isArray(collection) ? arrayEach : baseEach;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forEach` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @alias eachRight\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array|Object} Returns `collection`.\n     * @see _.forEach\n     * @example\n     *\n     * _.forEachRight([1, 2], function(value) {\n     *   console.log(value);\n     * });\n     * // => Logs `2` then `1`.\n     */\n    function forEachRight(collection, iteratee) {\n      var func = isArray(collection) ? arrayEachRight : baseEachRight;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The order of grouped values\n     * is determined by the order they occur in `collection`. The corresponding\n     * value of each key is an array of elements responsible for generating the\n     * key. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * _.groupBy([6.1, 4.2, 6.3], Math.floor);\n     * // => { '4': [4.2], '6': [6.1, 6.3] }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.groupBy(['one', 'two', 'three'], 'length');\n     * // => { '3': ['one', 'two'], '5': ['three'] }\n     */\n    var groupBy = createAggregator(function(result, value, key) {\n      if (hasOwnProperty.call(result, key)) {\n        result[key].push(value);\n      } else {\n        baseAssignValue(result, key, [value]);\n      }\n    });\n\n    /**\n     * Checks if `value` is in `collection`. If `collection` is a string, it's\n     * checked for a substring of `value`, otherwise\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * is used for equality comparisons. If `fromIndex` is negative, it's used as\n     * the offset from the end of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @param {*} value The value to search for.\n     * @param {number} [fromIndex=0] The index to search from.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {boolean} Returns `true` if `value` is found, else `false`.\n     * @example\n     *\n     * _.includes([1, 2, 3], 1);\n     * // => true\n     *\n     * _.includes([1, 2, 3], 1, 2);\n     * // => false\n     *\n     * _.includes({ 'a': 1, 'b': 2 }, 1);\n     * // => true\n     *\n     * _.includes('abcd', 'bc');\n     * // => true\n     */\n    function includes(collection, value, fromIndex, guard) {\n      collection = isArrayLike(collection) ? collection : values(collection);\n      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\n\n      var length = collection.length;\n      if (fromIndex < 0) {\n        fromIndex = nativeMax(length + fromIndex, 0);\n      }\n      return isString(collection)\n        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\n        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\n    }\n\n    /**\n     * Invokes the method at `path` of each element in `collection`, returning\n     * an array of the results of each invoked method. Any additional arguments\n     * are provided to each invoked method. If `path` is a function, it's invoked\n     * for, and `this` bound to, each element in `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array|Function|string} path The path of the method to invoke or\n     *  the function invoked per iteration.\n     * @param {...*} [args] The arguments to invoke each method with.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');\n     * // => [[1, 5, 7], [1, 2, 3]]\n     *\n     * _.invokeMap([123, 456], String.prototype.split, '');\n     * // => [['1', '2', '3'], ['4', '5', '6']]\n     */\n    var invokeMap = baseRest(function(collection, path, args) {\n      var index = -1,\n          isFunc = typeof path == 'function',\n          result = isArrayLike(collection) ? Array(collection.length) : [];\n\n      baseEach(collection, function(value) {\n        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n      });\n      return result;\n    });\n\n    /**\n     * Creates an object composed of keys generated from the results of running\n     * each element of `collection` thru `iteratee`. The corresponding value of\n     * each key is the last element responsible for generating the key. The\n     * iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\n     * @returns {Object} Returns the composed aggregate object.\n     * @example\n     *\n     * var array = [\n     *   { 'dir': 'left', 'code': 97 },\n     *   { 'dir': 'right', 'code': 100 }\n     * ];\n     *\n     * _.keyBy(array, function(o) {\n     *   return String.fromCharCode(o.code);\n     * });\n     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }\n     *\n     * _.keyBy(array, 'dir');\n     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }\n     */\n    var keyBy = createAggregator(function(result, value, key) {\n      baseAssignValue(result, key, value);\n    });\n\n    /**\n     * Creates an array of values by running each element in `collection` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\n     *\n     * The guarded methods are:\n     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\n     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\n     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\n     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new mapped array.\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * _.map([4, 8], square);\n     * // => [16, 64]\n     *\n     * _.map({ 'a': 4, 'b': 8 }, square);\n     * // => [16, 64] (iteration order is not guaranteed)\n     *\n     * var users = [\n     *   { 'user': 'barney' },\n     *   { 'user': 'fred' }\n     * ];\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, 'user');\n     * // => ['barney', 'fred']\n     */\n    function map(collection, iteratee) {\n      var func = isArray(collection) ? arrayMap : baseMap;\n      return func(collection, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.sortBy` except that it allows specifying the sort\n     * orders of the iteratees to sort by. If `orders` is unspecified, all values\n     * are sorted in ascending order. Otherwise, specify an order of \"desc\" for\n     * descending or \"asc\" for ascending sort order of corresponding values.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @param {string[]} [orders] The sort orders of `iteratees`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 34 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 36 }\n     * ];\n     *\n     * // Sort by `user` in ascending order and by `age` in descending order.\n     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     */\n    function orderBy(collection, iteratees, orders, guard) {\n      if (collection == null) {\n        return [];\n      }\n      if (!isArray(iteratees)) {\n        iteratees = iteratees == null ? [] : [iteratees];\n      }\n      orders = guard ? undefined : orders;\n      if (!isArray(orders)) {\n        orders = orders == null ? [] : [orders];\n      }\n      return baseOrderBy(collection, iteratees, orders);\n    }\n\n    /**\n     * Creates an array of elements split into two groups, the first of which\n     * contains elements `predicate` returns truthy for, the second of which\n     * contains elements `predicate` returns falsey for. The predicate is\n     * invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of grouped elements.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney',  'age': 36, 'active': false },\n     *   { 'user': 'fred',    'age': 40, 'active': true },\n     *   { 'user': 'pebbles', 'age': 1,  'active': false }\n     * ];\n     *\n     * _.partition(users, function(o) { return o.active; });\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.partition(users, { 'age': 1, 'active': false });\n     * // => objects for [['pebbles'], ['barney', 'fred']]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.partition(users, ['active', false]);\n     * // => objects for [['barney', 'pebbles'], ['fred']]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.partition(users, 'active');\n     * // => objects for [['fred'], ['barney', 'pebbles']]\n     */\n    var partition = createAggregator(function(result, value, key) {\n      result[key ? 0 : 1].push(value);\n    }, function() { return [[], []]; });\n\n    /**\n     * Reduces `collection` to a value which is the accumulated result of running\n     * each element in `collection` thru `iteratee`, where each successive\n     * invocation is supplied the return value of the previous. If `accumulator`\n     * is not given, the first element of `collection` is used as the initial\n     * value. The iteratee is invoked with four arguments:\n     * (accumulator, value, index|key, collection).\n     *\n     * Many lodash methods are guarded to work as iteratees for methods like\n     * `_.reduce`, `_.reduceRight`, and `_.transform`.\n     *\n     * The guarded methods are:\n     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\n     * and `sortBy`\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduceRight\n     * @example\n     *\n     * _.reduce([1, 2], function(sum, n) {\n     *   return sum + n;\n     * }, 0);\n     * // => 3\n     *\n     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     *   return result;\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\n     */\n    function reduce(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduce : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);\n    }\n\n    /**\n     * This method is like `_.reduce` except that it iterates over elements of\n     * `collection` from right to left.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The initial value.\n     * @returns {*} Returns the accumulated value.\n     * @see _.reduce\n     * @example\n     *\n     * var array = [[0, 1], [2, 3], [4, 5]];\n     *\n     * _.reduceRight(array, function(flattened, other) {\n     *   return flattened.concat(other);\n     * }, []);\n     * // => [4, 5, 2, 3, 0, 1]\n     */\n    function reduceRight(collection, iteratee, accumulator) {\n      var func = isArray(collection) ? arrayReduceRight : baseReduce,\n          initAccum = arguments.length < 3;\n\n      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);\n    }\n\n    /**\n     * The opposite of `_.filter`; this method returns the elements of `collection`\n     * that `predicate` does **not** return truthy for.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the new filtered array.\n     * @see _.filter\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': false },\n     *   { 'user': 'fred',   'age': 40, 'active': true }\n     * ];\n     *\n     * _.reject(users, function(o) { return !o.active; });\n     * // => objects for ['fred']\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.reject(users, { 'age': 40, 'active': true });\n     * // => objects for ['barney']\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.reject(users, ['active', false]);\n     * // => objects for ['fred']\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.reject(users, 'active');\n     * // => objects for ['barney']\n     */\n    function reject(collection, predicate) {\n      var func = isArray(collection) ? arrayFilter : baseFilter;\n      return func(collection, negate(getIteratee(predicate, 3)));\n    }\n\n    /**\n     * Gets a random element from `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @returns {*} Returns the random element.\n     * @example\n     *\n     * _.sample([1, 2, 3, 4]);\n     * // => 2\n     */\n    function sample(collection) {\n      var func = isArray(collection) ? arraySample : baseSample;\n      return func(collection);\n    }\n\n    /**\n     * Gets `n` random elements at unique keys from `collection` up to the\n     * size of `collection`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to sample.\n     * @param {number} [n=1] The number of elements to sample.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the random elements.\n     * @example\n     *\n     * _.sampleSize([1, 2, 3], 2);\n     * // => [3, 1]\n     *\n     * _.sampleSize([1, 2, 3], 4);\n     * // => [2, 3, 1]\n     */\n    function sampleSize(collection, n, guard) {\n      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n      return func(collection, n);\n    }\n\n    /**\n     * Creates an array of shuffled values, using a version of the\n     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to shuffle.\n     * @returns {Array} Returns the new shuffled array.\n     * @example\n     *\n     * _.shuffle([1, 2, 3, 4]);\n     * // => [4, 1, 3, 2]\n     */\n    function shuffle(collection) {\n      var func = isArray(collection) ? arrayShuffle : baseShuffle;\n      return func(collection);\n    }\n\n    /**\n     * Gets the size of `collection` by returning its length for array-like\n     * values or the number of own enumerable string keyed properties for objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object|string} collection The collection to inspect.\n     * @returns {number} Returns the collection size.\n     * @example\n     *\n     * _.size([1, 2, 3]);\n     * // => 3\n     *\n     * _.size({ 'a': 1, 'b': 2 });\n     * // => 2\n     *\n     * _.size('pebbles');\n     * // => 7\n     */\n    function size(collection) {\n      if (collection == null) {\n        return 0;\n      }\n      if (isArrayLike(collection)) {\n        return isString(collection) ? stringSize(collection) : collection.length;\n      }\n      var tag = getTag(collection);\n      if (tag == mapTag || tag == setTag) {\n        return collection.size;\n      }\n      return baseKeys(collection).length;\n    }\n\n    /**\n     * Checks if `predicate` returns truthy for **any** element of `collection`.\n     * Iteration is stopped once `predicate` returns truthy. The predicate is\n     * invoked with three arguments: (value, index|key, collection).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     * @example\n     *\n     * _.some([null, 0, 'yes', false], Boolean);\n     * // => true\n     *\n     * var users = [\n     *   { 'user': 'barney', 'active': true },\n     *   { 'user': 'fred',   'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.some(users, { 'user': 'barney', 'active': false });\n     * // => false\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.some(users, ['active', false]);\n     * // => true\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.some(users, 'active');\n     * // => true\n     */\n    function some(collection, predicate, guard) {\n      var func = isArray(collection) ? arraySome : baseSome;\n      if (guard && isIterateeCall(collection, predicate, guard)) {\n        predicate = undefined;\n      }\n      return func(collection, getIteratee(predicate, 3));\n    }\n\n    /**\n     * Creates an array of elements, sorted in ascending order by the results of\n     * running each element in a collection thru each iteratee. This method\n     * performs a stable sort, that is, it preserves the original sort order of\n     * equal elements. The iteratees are invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Collection\n     * @param {Array|Object} collection The collection to iterate over.\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to sort by.\n     * @returns {Array} Returns the new sorted array.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'fred',   'age': 48 },\n     *   { 'user': 'barney', 'age': 36 },\n     *   { 'user': 'fred',   'age': 40 },\n     *   { 'user': 'barney', 'age': 34 }\n     * ];\n     *\n     * _.sortBy(users, [function(o) { return o.user; }]);\n     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n     *\n     * _.sortBy(users, ['user', 'age']);\n     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n     */\n    var sortBy = baseRest(function(collection, iteratees) {\n      if (collection == null) {\n        return [];\n      }\n      var length = iteratees.length;\n      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n        iteratees = [];\n      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n        iteratees = [iteratees[0]];\n      }\n      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n    });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Gets the timestamp of the number of milliseconds that have elapsed since\n     * the Unix epoch (1 January 1970 00:00:00 UTC).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Date\n     * @returns {number} Returns the timestamp.\n     * @example\n     *\n     * _.defer(function(stamp) {\n     *   console.log(_.now() - stamp);\n     * }, _.now());\n     * // => Logs the number of milliseconds it took for the deferred invocation.\n     */\n    var now = ctxNow || function() {\n      return root.Date.now();\n    };\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The opposite of `_.before`; this method creates a function that invokes\n     * `func` once it's called `n` or more times.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {number} n The number of calls before `func` is invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var saves = ['profile', 'settings'];\n     *\n     * var done = _.after(saves.length, function() {\n     *   console.log('done saving!');\n     * });\n     *\n     * _.forEach(saves, function(type) {\n     *   asyncSave({ 'type': type, 'complete': done });\n     * });\n     * // => Logs 'done saving!' after the two async saves have completed.\n     */\n    function after(n, func) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n < 1) {\n          return func.apply(this, arguments);\n        }\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func`, with up to `n` arguments,\n     * ignoring any additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @param {number} [n=func.length] The arity cap.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.ary(parseInt, 1));\n     * // => [6, 8, 10]\n     */\n    function ary(func, n, guard) {\n      n = guard ? undefined : n;\n      n = (func && n == null) ? func.length : n;\n      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);\n    }\n\n    /**\n     * Creates a function that invokes `func`, with the `this` binding and arguments\n     * of the created function, while it's called less than `n` times. Subsequent\n     * calls to the created function return the result of the last `func` invocation.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {number} n The number of calls at which `func` is no longer invoked.\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * jQuery(element).on('click', _.before(5, addContactToList));\n     * // => Allows adding up to 4 contacts to the list.\n     */\n    function before(n, func) {\n      var result;\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      n = toInteger(n);\n      return function() {\n        if (--n > 0) {\n          result = func.apply(this, arguments);\n        }\n        if (n <= 1) {\n          func = undefined;\n        }\n        return result;\n      };\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of `thisArg`\n     * and `partials` prepended to the arguments it receives.\n     *\n     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** Unlike native `Function#bind`, this method doesn't set the \"length\"\n     * property of bound functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to bind.\n     * @param {*} thisArg The `this` binding of `func`.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * function greet(greeting, punctuation) {\n     *   return greeting + ' ' + this.user + punctuation;\n     * }\n     *\n     * var object = { 'user': 'fred' };\n     *\n     * var bound = _.bind(greet, object, 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bind(greet, object, _, '!');\n     * bound('hi');\n     * // => 'hi fred!'\n     */\n    var bind = baseRest(function(func, thisArg, partials) {\n      var bitmask = WRAP_BIND_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bind));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(func, bitmask, thisArg, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes the method at `object[key]` with `partials`\n     * prepended to the arguments it receives.\n     *\n     * This method differs from `_.bind` by allowing bound functions to reference\n     * methods that may be redefined or don't yet exist. See\n     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)\n     * for more details.\n     *\n     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Function\n     * @param {Object} object The object to invoke the method on.\n     * @param {string} key The key of the method.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new bound function.\n     * @example\n     *\n     * var object = {\n     *   'user': 'fred',\n     *   'greet': function(greeting, punctuation) {\n     *     return greeting + ' ' + this.user + punctuation;\n     *   }\n     * };\n     *\n     * var bound = _.bindKey(object, 'greet', 'hi');\n     * bound('!');\n     * // => 'hi fred!'\n     *\n     * object.greet = function(greeting, punctuation) {\n     *   return greeting + 'ya ' + this.user + punctuation;\n     * };\n     *\n     * bound('!');\n     * // => 'hiya fred!'\n     *\n     * // Bound with placeholders.\n     * var bound = _.bindKey(object, 'greet', _, '!');\n     * bound('hi');\n     * // => 'hiya fred!'\n     */\n    var bindKey = baseRest(function(object, key, partials) {\n      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n      if (partials.length) {\n        var holders = replaceHolders(partials, getHolder(bindKey));\n        bitmask |= WRAP_PARTIAL_FLAG;\n      }\n      return createWrap(key, bitmask, object, partials, holders);\n    });\n\n    /**\n     * Creates a function that accepts arguments of `func` and either invokes\n     * `func` returning its result, if at least `arity` number of arguments have\n     * been provided, or returns a function that accepts the remaining `func`\n     * arguments, and so on. The arity of `func` may be specified if `func.length`\n     * is not sufficient.\n     *\n     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,\n     * may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curry(abc);\n     *\n     * curried(1)(2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2)(3);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(1)(_, 3)(2);\n     * // => [1, 2, 3]\n     */\n    function curry(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curry.placeholder;\n      return result;\n    }\n\n    /**\n     * This method is like `_.curry` except that arguments are applied to `func`\n     * in the manner of `_.partialRight` instead of `_.partial`.\n     *\n     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for provided arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of curried functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to curry.\n     * @param {number} [arity=func.length] The arity of `func`.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the new curried function.\n     * @example\n     *\n     * var abc = function(a, b, c) {\n     *   return [a, b, c];\n     * };\n     *\n     * var curried = _.curryRight(abc);\n     *\n     * curried(3)(2)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(2, 3)(1);\n     * // => [1, 2, 3]\n     *\n     * curried(1, 2, 3);\n     * // => [1, 2, 3]\n     *\n     * // Curried with placeholders.\n     * curried(3)(1, _)(2);\n     * // => [1, 2, 3]\n     */\n    function curryRight(func, arity, guard) {\n      arity = guard ? undefined : arity;\n      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);\n      result.placeholder = curryRight.placeholder;\n      return result;\n    }\n\n    /**\n     * Creates a debounced function that delays invoking `func` until after `wait`\n     * milliseconds have elapsed since the last time the debounced function was\n     * invoked. The debounced function comes with a `cancel` method to cancel\n     * delayed `func` invocations and a `flush` method to immediately invoke them.\n     * Provide `options` to indicate whether `func` should be invoked on the\n     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n     * with the last arguments provided to the debounced function. Subsequent\n     * calls to the debounced function return the result of the last `func`\n     * invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the debounced function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.debounce` and `_.throttle`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to debounce.\n     * @param {number} [wait=0] The number of milliseconds to delay.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=false]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {number} [options.maxWait]\n     *  The maximum time `func` is allowed to be delayed before it's invoked.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new debounced function.\n     * @example\n     *\n     * // Avoid costly calculations while the window size is in flux.\n     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n     *\n     * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n     * jQuery(element).on('click', _.debounce(sendMail, 300, {\n     *   'leading': true,\n     *   'trailing': false\n     * }));\n     *\n     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n     * var source = new EventSource('/stream');\n     * jQuery(source).on('message', debounced);\n     *\n     * // Cancel the trailing debounced invocation.\n     * jQuery(window).on('popstate', debounced.cancel);\n     */\n    function debounce(func, wait, options) {\n      var lastArgs,\n          lastThis,\n          maxWait,\n          result,\n          timerId,\n          lastCallTime,\n          lastInvokeTime = 0,\n          leading = false,\n          maxing = false,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      wait = toNumber(wait) || 0;\n      if (isObject(options)) {\n        leading = !!options.leading;\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n\n      function invokeFunc(time) {\n        var args = lastArgs,\n            thisArg = lastThis;\n\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n      }\n\n      function leadingEdge(time) {\n        // Reset any `maxWait` timer.\n        lastInvokeTime = time;\n        // Start the timer for the trailing edge.\n        timerId = setTimeout(timerExpired, wait);\n        // Invoke the leading edge.\n        return leading ? invokeFunc(time) : result;\n      }\n\n      function remainingWait(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime,\n            timeWaiting = wait - timeSinceLastCall;\n\n        return maxing\n          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n          : timeWaiting;\n      }\n\n      function shouldInvoke(time) {\n        var timeSinceLastCall = time - lastCallTime,\n            timeSinceLastInvoke = time - lastInvokeTime;\n\n        // Either this is the first call, activity has stopped and we're at the\n        // trailing edge, the system time has gone backwards and we're treating\n        // it as the trailing edge, or we've hit the `maxWait` limit.\n        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n      }\n\n      function timerExpired() {\n        var time = now();\n        if (shouldInvoke(time)) {\n          return trailingEdge(time);\n        }\n        // Restart the timer.\n        timerId = setTimeout(timerExpired, remainingWait(time));\n      }\n\n      function trailingEdge(time) {\n        timerId = undefined;\n\n        // Only invoke if we have `lastArgs` which means `func` has been\n        // debounced at least once.\n        if (trailing && lastArgs) {\n          return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n      }\n\n      function cancel() {\n        if (timerId !== undefined) {\n          clearTimeout(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n      }\n\n      function flush() {\n        return timerId === undefined ? result : trailingEdge(now());\n      }\n\n      function debounced() {\n        var time = now(),\n            isInvoking = shouldInvoke(time);\n\n        lastArgs = arguments;\n        lastThis = this;\n        lastCallTime = time;\n\n        if (isInvoking) {\n          if (timerId === undefined) {\n            return leadingEdge(lastCallTime);\n          }\n          if (maxing) {\n            // Handle invocations in a tight loop.\n            clearTimeout(timerId);\n            timerId = setTimeout(timerExpired, wait);\n            return invokeFunc(lastCallTime);\n          }\n        }\n        if (timerId === undefined) {\n          timerId = setTimeout(timerExpired, wait);\n        }\n        return result;\n      }\n      debounced.cancel = cancel;\n      debounced.flush = flush;\n      return debounced;\n    }\n\n    /**\n     * Defers invoking the `func` until the current call stack has cleared. Any\n     * additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to defer.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.defer(function(text) {\n     *   console.log(text);\n     * }, 'deferred');\n     * // => Logs 'deferred' after one millisecond.\n     */\n    var defer = baseRest(function(func, args) {\n      return baseDelay(func, 1, args);\n    });\n\n    /**\n     * Invokes `func` after `wait` milliseconds. Any additional arguments are\n     * provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to delay.\n     * @param {number} wait The number of milliseconds to delay invocation.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {number} Returns the timer id.\n     * @example\n     *\n     * _.delay(function(text) {\n     *   console.log(text);\n     * }, 1000, 'later');\n     * // => Logs 'later' after one second.\n     */\n    var delay = baseRest(function(func, wait, args) {\n      return baseDelay(func, toNumber(wait) || 0, args);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments reversed.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to flip arguments for.\n     * @returns {Function} Returns the new flipped function.\n     * @example\n     *\n     * var flipped = _.flip(function() {\n     *   return _.toArray(arguments);\n     * });\n     *\n     * flipped('a', 'b', 'c', 'd');\n     * // => ['d', 'c', 'b', 'a']\n     */\n    function flip(func) {\n      return createWrap(func, WRAP_FLIP_FLAG);\n    }\n\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      var memoized = function() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result) || cache;\n        return result;\n      };\n      memoized.cache = new (memoize.Cache || MapCache);\n      return memoized;\n    }\n\n    // Expose `MapCache`.\n    memoize.Cache = MapCache;\n\n    /**\n     * Creates a function that negates the result of the predicate `func`. The\n     * `func` predicate is invoked with the `this` binding and arguments of the\n     * created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} predicate The predicate to negate.\n     * @returns {Function} Returns the new negated function.\n     * @example\n     *\n     * function isEven(n) {\n     *   return n % 2 == 0;\n     * }\n     *\n     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\n     * // => [1, 3, 5]\n     */\n    function negate(predicate) {\n      if (typeof predicate != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      return function() {\n        var args = arguments;\n        switch (args.length) {\n          case 0: return !predicate.call(this);\n          case 1: return !predicate.call(this, args[0]);\n          case 2: return !predicate.call(this, args[0], args[1]);\n          case 3: return !predicate.call(this, args[0], args[1], args[2]);\n        }\n        return !predicate.apply(this, args);\n      };\n    }\n\n    /**\n     * Creates a function that is restricted to invoking `func` once. Repeat calls\n     * to the function return the value of the first invocation. The `func` is\n     * invoked with the `this` binding and arguments of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to restrict.\n     * @returns {Function} Returns the new restricted function.\n     * @example\n     *\n     * var initialize = _.once(createApplication);\n     * initialize();\n     * initialize();\n     * // => `createApplication` is invoked once\n     */\n    function once(func) {\n      return before(2, func);\n    }\n\n    /**\n     * Creates a function that invokes `func` with its arguments transformed.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Function\n     * @param {Function} func The function to wrap.\n     * @param {...(Function|Function[])} [transforms=[_.identity]]\n     *  The argument transforms.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * function doubled(n) {\n     *   return n * 2;\n     * }\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var func = _.overArgs(function(x, y) {\n     *   return [x, y];\n     * }, [square, doubled]);\n     *\n     * func(9, 3);\n     * // => [81, 6]\n     *\n     * func(10, 5);\n     * // => [100, 10]\n     */\n    var overArgs = castRest(function(func, transforms) {\n      transforms = (transforms.length == 1 && isArray(transforms[0]))\n        ? arrayMap(transforms[0], baseUnary(getIteratee()))\n        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n\n      var funcsLength = transforms.length;\n      return baseRest(function(args) {\n        var index = -1,\n            length = nativeMin(args.length, funcsLength);\n\n        while (++index < length) {\n          args[index] = transforms[index].call(this, args[index]);\n        }\n        return apply(func, this, args);\n      });\n    });\n\n    /**\n     * Creates a function that invokes `func` with `partials` prepended to the\n     * arguments it receives. This method is like `_.bind` except it does **not**\n     * alter the `this` binding.\n     *\n     * The `_.partial.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.2.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var sayHelloTo = _.partial(greet, 'hello');\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     *\n     * // Partially applied with placeholders.\n     * var greetFred = _.partial(greet, _, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     */\n    var partial = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partial));\n      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * This method is like `_.partial` except that partially applied arguments\n     * are appended to the arguments it receives.\n     *\n     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic\n     * builds, may be used as a placeholder for partially applied arguments.\n     *\n     * **Note:** This method doesn't set the \"length\" property of partially\n     * applied functions.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Function\n     * @param {Function} func The function to partially apply arguments to.\n     * @param {...*} [partials] The arguments to be partially applied.\n     * @returns {Function} Returns the new partially applied function.\n     * @example\n     *\n     * function greet(greeting, name) {\n     *   return greeting + ' ' + name;\n     * }\n     *\n     * var greetFred = _.partialRight(greet, 'fred');\n     * greetFred('hi');\n     * // => 'hi fred'\n     *\n     * // Partially applied with placeholders.\n     * var sayHelloTo = _.partialRight(greet, 'hello', _);\n     * sayHelloTo('fred');\n     * // => 'hello fred'\n     */\n    var partialRight = baseRest(function(func, partials) {\n      var holders = replaceHolders(partials, getHolder(partialRight));\n      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);\n    });\n\n    /**\n     * Creates a function that invokes `func` with arguments arranged according\n     * to the specified `indexes` where the argument value at the first index is\n     * provided as the first argument, the argument value at the second index is\n     * provided as the second argument, and so on.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Function\n     * @param {Function} func The function to rearrange arguments for.\n     * @param {...(number|number[])} indexes The arranged argument indexes.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var rearged = _.rearg(function(a, b, c) {\n     *   return [a, b, c];\n     * }, [2, 0, 1]);\n     *\n     * rearged('b', 'c', 'a')\n     * // => ['a', 'b', 'c']\n     */\n    var rearg = flatRest(function(func, indexes) {\n      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);\n    });\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * created function and arguments from `start` and beyond provided as\n     * an array.\n     *\n     * **Note:** This method is based on the\n     * [rest parameter](https://mdn.io/rest_parameters).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to apply a rest parameter to.\n     * @param {number} [start=func.length-1] The start position of the rest parameter.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.rest(function(what, names) {\n     *   return what + ' ' + _.initial(names).join(', ') +\n     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);\n     * });\n     *\n     * say('hello', 'fred', 'barney', 'pebbles');\n     * // => 'hello fred, barney, & pebbles'\n     */\n    function rest(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start === undefined ? start : toInteger(start);\n      return baseRest(func, start);\n    }\n\n    /**\n     * Creates a function that invokes `func` with the `this` binding of the\n     * create function and an array of arguments much like\n     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).\n     *\n     * **Note:** This method is based on the\n     * [spread operator](https://mdn.io/spread_operator).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Function\n     * @param {Function} func The function to spread arguments over.\n     * @param {number} [start=0] The start position of the spread.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var say = _.spread(function(who, what) {\n     *   return who + ' says ' + what;\n     * });\n     *\n     * say(['fred', 'hello']);\n     * // => 'fred says hello'\n     *\n     * var numbers = Promise.all([\n     *   Promise.resolve(40),\n     *   Promise.resolve(36)\n     * ]);\n     *\n     * numbers.then(_.spread(function(x, y) {\n     *   return x + y;\n     * }));\n     * // => a Promise of 76\n     */\n    function spread(func, start) {\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      start = start == null ? 0 : nativeMax(toInteger(start), 0);\n      return baseRest(function(args) {\n        var array = args[start],\n            otherArgs = castSlice(args, 0, start);\n\n        if (array) {\n          arrayPush(otherArgs, array);\n        }\n        return apply(func, this, otherArgs);\n      });\n    }\n\n    /**\n     * Creates a throttled function that only invokes `func` at most once per\n     * every `wait` milliseconds. The throttled function comes with a `cancel`\n     * method to cancel delayed `func` invocations and a `flush` method to\n     * immediately invoke them. Provide `options` to indicate whether `func`\n     * should be invoked on the leading and/or trailing edge of the `wait`\n     * timeout. The `func` is invoked with the last arguments provided to the\n     * throttled function. Subsequent calls to the throttled function return the\n     * result of the last `func` invocation.\n     *\n     * **Note:** If `leading` and `trailing` options are `true`, `func` is\n     * invoked on the trailing edge of the timeout only if the throttled function\n     * is invoked more than once during the `wait` timeout.\n     *\n     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n     * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n     *\n     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n     * for details over the differences between `_.throttle` and `_.debounce`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to throttle.\n     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.leading=true]\n     *  Specify invoking on the leading edge of the timeout.\n     * @param {boolean} [options.trailing=true]\n     *  Specify invoking on the trailing edge of the timeout.\n     * @returns {Function} Returns the new throttled function.\n     * @example\n     *\n     * // Avoid excessively updating the position while scrolling.\n     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n     *\n     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n     * jQuery(element).on('click', throttled);\n     *\n     * // Cancel the trailing throttled invocation.\n     * jQuery(window).on('popstate', throttled.cancel);\n     */\n    function throttle(func, wait, options) {\n      var leading = true,\n          trailing = true;\n\n      if (typeof func != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n      if (isObject(options)) {\n        leading = 'leading' in options ? !!options.leading : leading;\n        trailing = 'trailing' in options ? !!options.trailing : trailing;\n      }\n      return debounce(func, wait, {\n        'leading': leading,\n        'maxWait': wait,\n        'trailing': trailing\n      });\n    }\n\n    /**\n     * Creates a function that accepts up to one argument, ignoring any\n     * additional arguments.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Function\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     * @example\n     *\n     * _.map(['6', '8', '10'], _.unary(parseInt));\n     * // => [6, 8, 10]\n     */\n    function unary(func) {\n      return ary(func, 1);\n    }\n\n    /**\n     * Creates a function that provides `value` to `wrapper` as its first\n     * argument. Any additional arguments provided to the function are appended\n     * to those provided to the `wrapper`. The wrapper is invoked with the `this`\n     * binding of the created function.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {*} value The value to wrap.\n     * @param {Function} [wrapper=identity] The wrapper function.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var p = _.wrap(_.escape, function(func, text) {\n     *   return '<p>' + func(text) + '</p>';\n     * });\n     *\n     * p('fred, barney, & pebbles');\n     * // => '<p>fred, barney, &amp; pebbles</p>'\n     */\n    function wrap(value, wrapper) {\n      return partial(castFunction(wrapper), value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Casts `value` as an array if it's not one.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.4.0\n     * @category Lang\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast array.\n     * @example\n     *\n     * _.castArray(1);\n     * // => [1]\n     *\n     * _.castArray({ 'a': 1 });\n     * // => [{ 'a': 1 }]\n     *\n     * _.castArray('abc');\n     * // => ['abc']\n     *\n     * _.castArray(null);\n     * // => [null]\n     *\n     * _.castArray(undefined);\n     * // => [undefined]\n     *\n     * _.castArray();\n     * // => []\n     *\n     * var array = [1, 2, 3];\n     * console.log(_.castArray(array) === array);\n     * // => true\n     */\n    function castArray() {\n      if (!arguments.length) {\n        return [];\n      }\n      var value = arguments[0];\n      return isArray(value) ? value : [value];\n    }\n\n    /**\n     * Creates a shallow clone of `value`.\n     *\n     * **Note:** This method is loosely based on the\n     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\n     * and supports cloning arrays, array buffers, booleans, date objects, maps,\n     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\n     * arrays. The own enumerable properties of `arguments` objects are cloned\n     * as plain objects. An empty object is returned for uncloneable values such\n     * as error objects, functions, DOM nodes, and WeakMaps.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeep\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var shallow = _.clone(objects);\n     * console.log(shallow[0] === objects[0]);\n     * // => true\n     */\n    function clone(value) {\n      return baseClone(value, CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.clone` except that it accepts `customizer` which\n     * is invoked to produce the cloned value. If `customizer` returns `undefined`,\n     * cloning is handled by the method instead. The `customizer` is invoked with\n     * up to four arguments; (value [, index|key, object, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the cloned value.\n     * @see _.cloneDeepWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(false);\n     *   }\n     * }\n     *\n     * var el = _.cloneWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 0\n     */\n    function cloneWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * This method is like `_.clone` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.clone\n     * @example\n     *\n     * var objects = [{ 'a': 1 }, { 'b': 2 }];\n     *\n     * var deep = _.cloneDeep(objects);\n     * console.log(deep[0] === objects[0]);\n     * // => false\n     */\n    function cloneDeep(value) {\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n    }\n\n    /**\n     * This method is like `_.cloneWith` except that it recursively clones `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to recursively clone.\n     * @param {Function} [customizer] The function to customize cloning.\n     * @returns {*} Returns the deep cloned value.\n     * @see _.cloneWith\n     * @example\n     *\n     * function customizer(value) {\n     *   if (_.isElement(value)) {\n     *     return value.cloneNode(true);\n     *   }\n     * }\n     *\n     * var el = _.cloneDeepWith(document.body, customizer);\n     *\n     * console.log(el === document.body);\n     * // => false\n     * console.log(el.nodeName);\n     * // => 'BODY'\n     * console.log(el.childNodes.length);\n     * // => 20\n     */\n    function cloneDeepWith(value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n    }\n\n    /**\n     * Checks if `object` conforms to `source` by invoking the predicate\n     * properties of `source` with the corresponding property values of `object`.\n     *\n     * **Note:** This method is equivalent to `_.conforms` when `source` is\n     * partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {boolean} Returns `true` if `object` conforms, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });\n     * // => true\n     *\n     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });\n     * // => false\n     */\n    function conformsTo(object, source) {\n      return source == null || baseConformsTo(object, source, keys(source));\n    }\n\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n    function eq(value, other) {\n      return value === other || (value !== value && other !== other);\n    }\n\n    /**\n     * Checks if `value` is greater than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than `other`,\n     *  else `false`.\n     * @see _.lt\n     * @example\n     *\n     * _.gt(3, 1);\n     * // => true\n     *\n     * _.gt(3, 3);\n     * // => false\n     *\n     * _.gt(1, 3);\n     * // => false\n     */\n    var gt = createRelationalOperation(baseGt);\n\n    /**\n     * Checks if `value` is greater than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is greater than or equal to\n     *  `other`, else `false`.\n     * @see _.lte\n     * @example\n     *\n     * _.gte(3, 1);\n     * // => true\n     *\n     * _.gte(3, 3);\n     * // => true\n     *\n     * _.gte(1, 3);\n     * // => false\n     */\n    var gte = createRelationalOperation(function(value, other) {\n      return value >= other;\n    });\n\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n        !propertyIsEnumerable.call(value, 'callee');\n    };\n\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n    var isArray = Array.isArray;\n\n    /**\n     * Checks if `value` is classified as an `ArrayBuffer` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.\n     * @example\n     *\n     * _.isArrayBuffer(new ArrayBuffer(2));\n     * // => true\n     *\n     * _.isArrayBuffer(new Array(2));\n     * // => false\n     */\n    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a boolean primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.\n     * @example\n     *\n     * _.isBoolean(false);\n     * // => true\n     *\n     * _.isBoolean(null);\n     * // => false\n     */\n    function isBoolean(value) {\n      return value === true || value === false ||\n        (isObjectLike(value) && baseGetTag(value) == boolTag);\n    }\n\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n    var isBuffer = nativeIsBuffer || stubFalse;\n\n    /**\n     * Checks if `value` is classified as a `Date` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n     * @example\n     *\n     * _.isDate(new Date);\n     * // => true\n     *\n     * _.isDate('Mon April 23 2012');\n     * // => false\n     */\n    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\n    /**\n     * Checks if `value` is likely a DOM element.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.\n     * @example\n     *\n     * _.isElement(document.body);\n     * // => true\n     *\n     * _.isElement('<body>');\n     * // => false\n     */\n    function isElement(value) {\n      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n    }\n\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n    function isEmpty(value) {\n      if (value == null) {\n        return true;\n      }\n      if (isArrayLike(value) &&\n          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\n            isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n        return !value.length;\n      }\n      var tag = getTag(value);\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n      if (isPrototype(value)) {\n        return !baseKeys(value).length;\n      }\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    /**\n     * Performs a deep comparison between two values to determine if they are\n     * equivalent.\n     *\n     * **Note:** This method supports comparing arrays, array buffers, booleans,\n     * date objects, error objects, maps, numbers, `Object` objects, regexes,\n     * sets, strings, symbols, and typed arrays. `Object` objects are compared\n     * by their own, not inherited, enumerable properties. Functions and DOM\n     * nodes are compared by strict equality, i.e. `===`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.isEqual(object, other);\n     * // => true\n     *\n     * object === other;\n     * // => false\n     */\n    function isEqual(value, other) {\n      return baseIsEqual(value, other);\n    }\n\n    /**\n     * This method is like `_.isEqual` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with up to\n     * six arguments: (objValue, othValue [, index|key, object, other, stack]).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, othValue) {\n     *   if (isGreeting(objValue) && isGreeting(othValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var array = ['hello', 'goodbye'];\n     * var other = ['hi', 'goodbye'];\n     *\n     * _.isEqualWith(array, other, customizer);\n     * // => true\n     */\n    function isEqualWith(value, other, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      var result = customizer ? customizer(value, other) : undefined;\n      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;\n    }\n\n    /**\n     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,\n     * `SyntaxError`, `TypeError`, or `URIError` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.\n     * @example\n     *\n     * _.isError(new Error);\n     * // => true\n     *\n     * _.isError(Error);\n     * // => false\n     */\n    function isError(value) {\n      if (!isObjectLike(value)) {\n        return false;\n      }\n      var tag = baseGetTag(value);\n      return tag == errorTag || tag == domExcTag ||\n        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));\n    }\n\n    /**\n     * Checks if `value` is a finite primitive number.\n     *\n     * **Note:** This method is based on\n     * [`Number.isFinite`](https://mdn.io/Number/isFinite).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.\n     * @example\n     *\n     * _.isFinite(3);\n     * // => true\n     *\n     * _.isFinite(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isFinite(Infinity);\n     * // => false\n     *\n     * _.isFinite('3');\n     * // => false\n     */\n    function isFinite(value) {\n      return typeof value == 'number' && nativeIsFinite(value);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n    function isFunction(value) {\n      if (!isObject(value)) {\n        return false;\n      }\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 9 which returns 'object' for typed arrays and other constructors.\n      var tag = baseGetTag(value);\n      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n    }\n\n    /**\n     * Checks if `value` is an integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isInteger`](https://mdn.io/Number/isInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.\n     * @example\n     *\n     * _.isInteger(3);\n     * // => true\n     *\n     * _.isInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isInteger(Infinity);\n     * // => false\n     *\n     * _.isInteger('3');\n     * // => false\n     */\n    function isInteger(value) {\n      return typeof value == 'number' && value == toInteger(value);\n    }\n\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n    function isLength(value) {\n      return typeof value == 'number' &&\n        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n    function isObject(value) {\n      var type = typeof value;\n      return value != null && (type == 'object' || type == 'function');\n    }\n\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n    function isObjectLike(value) {\n      return value != null && typeof value == 'object';\n    }\n\n    /**\n     * Checks if `value` is classified as a `Map` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n     * @example\n     *\n     * _.isMap(new Map);\n     * // => true\n     *\n     * _.isMap(new WeakMap);\n     * // => false\n     */\n    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n    /**\n     * Performs a partial deep comparison between `object` and `source` to\n     * determine if `object` contains equivalent property values.\n     *\n     * **Note:** This method is equivalent to `_.matches` when `source` is\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     *\n     * _.isMatch(object, { 'b': 2 });\n     * // => true\n     *\n     * _.isMatch(object, { 'b': 1 });\n     * // => false\n     */\n    function isMatch(object, source) {\n      return object === source || baseIsMatch(object, source, getMatchData(source));\n    }\n\n    /**\n     * This method is like `_.isMatch` except that it accepts `customizer` which\n     * is invoked to compare values. If `customizer` returns `undefined`, comparisons\n     * are handled by the method instead. The `customizer` is invoked with five\n     * arguments: (objValue, srcValue, index|key, object, source).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     * @example\n     *\n     * function isGreeting(value) {\n     *   return /^h(?:i|ello)$/.test(value);\n     * }\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (isGreeting(objValue) && isGreeting(srcValue)) {\n     *     return true;\n     *   }\n     * }\n     *\n     * var object = { 'greeting': 'hello' };\n     * var source = { 'greeting': 'hi' };\n     *\n     * _.isMatchWith(object, source, customizer);\n     * // => true\n     */\n    function isMatchWith(object, source, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return baseIsMatch(object, source, getMatchData(source), customizer);\n    }\n\n    /**\n     * Checks if `value` is `NaN`.\n     *\n     * **Note:** This method is based on\n     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as\n     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for\n     * `undefined` and other non-number values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\n     * @example\n     *\n     * _.isNaN(NaN);\n     * // => true\n     *\n     * _.isNaN(new Number(NaN));\n     * // => true\n     *\n     * isNaN(undefined);\n     * // => true\n     *\n     * _.isNaN(undefined);\n     * // => false\n     */\n    function isNaN(value) {\n      // An `NaN` primitive is the only value that is not equal to itself.\n      // Perform the `toStringTag` check first to avoid errors with some\n      // ActiveX objects in IE.\n      return isNumber(value) && value != +value;\n    }\n\n    /**\n     * Checks if `value` is a pristine native function.\n     *\n     * **Note:** This method can't reliably detect native functions in the presence\n     * of the core-js package because core-js circumvents this kind of detection.\n     * Despite multiple requests, the core-js maintainer has made it clear: any\n     * attempt to fix the detection will be obstructed. As a result, we're left\n     * with little choice but to throw an error. Unfortunately, this also affects\n     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),\n     * which rely on core-js.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     * @example\n     *\n     * _.isNative(Array.prototype.push);\n     * // => true\n     *\n     * _.isNative(_);\n     * // => false\n     */\n    function isNative(value) {\n      if (isMaskable(value)) {\n        throw new Error(CORE_ERROR_TEXT);\n      }\n      return baseIsNative(value);\n    }\n\n    /**\n     * Checks if `value` is `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.\n     * @example\n     *\n     * _.isNull(null);\n     * // => true\n     *\n     * _.isNull(void 0);\n     * // => false\n     */\n    function isNull(value) {\n      return value === null;\n    }\n\n    /**\n     * Checks if `value` is `null` or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.\n     * @example\n     *\n     * _.isNil(null);\n     * // => true\n     *\n     * _.isNil(void 0);\n     * // => true\n     *\n     * _.isNil(NaN);\n     * // => false\n     */\n    function isNil(value) {\n      return value == null;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Number` primitive or object.\n     *\n     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are\n     * classified as numbers, use the `_.isFinite` method.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a number, else `false`.\n     * @example\n     *\n     * _.isNumber(3);\n     * // => true\n     *\n     * _.isNumber(Number.MIN_VALUE);\n     * // => true\n     *\n     * _.isNumber(Infinity);\n     * // => true\n     *\n     * _.isNumber('3');\n     * // => false\n     */\n    function isNumber(value) {\n      return typeof value == 'number' ||\n        (isObjectLike(value) && baseGetTag(value) == numberTag);\n    }\n\n    /**\n     * Checks if `value` is a plain object, that is, an object created by the\n     * `Object` constructor or one with a `[[Prototype]]` of `null`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.8.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * _.isPlainObject(new Foo);\n     * // => false\n     *\n     * _.isPlainObject([1, 2, 3]);\n     * // => false\n     *\n     * _.isPlainObject({ 'x': 0, 'y': 0 });\n     * // => true\n     *\n     * _.isPlainObject(Object.create(null));\n     * // => true\n     */\n    function isPlainObject(value) {\n      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n        return false;\n      }\n      var proto = getPrototype(value);\n      if (proto === null) {\n        return true;\n      }\n      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n      return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n        funcToString.call(Ctor) == objectCtorString;\n    }\n\n    /**\n     * Checks if `value` is classified as a `RegExp` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\n     * @example\n     *\n     * _.isRegExp(/abc/);\n     * // => true\n     *\n     * _.isRegExp('/abc/');\n     * // => false\n     */\n    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n\n    /**\n     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754\n     * double precision number which isn't the result of a rounded unsafe integer.\n     *\n     * **Note:** This method is based on\n     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.\n     * @example\n     *\n     * _.isSafeInteger(3);\n     * // => true\n     *\n     * _.isSafeInteger(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isSafeInteger(Infinity);\n     * // => false\n     *\n     * _.isSafeInteger('3');\n     * // => false\n     */\n    function isSafeInteger(value) {\n      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n    }\n\n    /**\n     * Checks if `value` is classified as a `Set` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n     * @example\n     *\n     * _.isSet(new Set);\n     * // => true\n     *\n     * _.isSet(new WeakSet);\n     * // => false\n     */\n    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n    /**\n     * Checks if `value` is classified as a `String` primitive or object.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a string, else `false`.\n     * @example\n     *\n     * _.isString('abc');\n     * // => true\n     *\n     * _.isString(1);\n     * // => false\n     */\n    function isString(value) {\n      return typeof value == 'string' ||\n        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n    function isSymbol(value) {\n      return typeof value == 'symbol' ||\n        (isObjectLike(value) && baseGetTag(value) == symbolTag);\n    }\n\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n    /**\n     * Checks if `value` is `undefined`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\n     * @example\n     *\n     * _.isUndefined(void 0);\n     * // => true\n     *\n     * _.isUndefined(null);\n     * // => false\n     */\n    function isUndefined(value) {\n      return value === undefined;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakMap` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.\n     * @example\n     *\n     * _.isWeakMap(new WeakMap);\n     * // => true\n     *\n     * _.isWeakMap(new Map);\n     * // => false\n     */\n    function isWeakMap(value) {\n      return isObjectLike(value) && getTag(value) == weakMapTag;\n    }\n\n    /**\n     * Checks if `value` is classified as a `WeakSet` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.\n     * @example\n     *\n     * _.isWeakSet(new WeakSet);\n     * // => true\n     *\n     * _.isWeakSet(new Set);\n     * // => false\n     */\n    function isWeakSet(value) {\n      return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n    }\n\n    /**\n     * Checks if `value` is less than `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than `other`,\n     *  else `false`.\n     * @see _.gt\n     * @example\n     *\n     * _.lt(1, 3);\n     * // => true\n     *\n     * _.lt(3, 3);\n     * // => false\n     *\n     * _.lt(3, 1);\n     * // => false\n     */\n    var lt = createRelationalOperation(baseLt);\n\n    /**\n     * Checks if `value` is less than or equal to `other`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.9.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if `value` is less than or equal to\n     *  `other`, else `false`.\n     * @see _.gte\n     * @example\n     *\n     * _.lte(1, 3);\n     * // => true\n     *\n     * _.lte(3, 3);\n     * // => true\n     *\n     * _.lte(3, 1);\n     * // => false\n     */\n    var lte = createRelationalOperation(function(value, other) {\n      return value <= other;\n    });\n\n    /**\n     * Converts `value` to an array.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the converted array.\n     * @example\n     *\n     * _.toArray({ 'a': 1, 'b': 2 });\n     * // => [1, 2]\n     *\n     * _.toArray('abc');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toArray(1);\n     * // => []\n     *\n     * _.toArray(null);\n     * // => []\n     */\n    function toArray(value) {\n      if (!value) {\n        return [];\n      }\n      if (isArrayLike(value)) {\n        return isString(value) ? stringToArray(value) : copyArray(value);\n      }\n      if (symIterator && value[symIterator]) {\n        return iteratorToArray(value[symIterator]());\n      }\n      var tag = getTag(value),\n          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);\n\n      return func(value);\n    }\n\n    /**\n     * Converts `value` to a finite number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.12.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted number.\n     * @example\n     *\n     * _.toFinite(3.2);\n     * // => 3.2\n     *\n     * _.toFinite(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toFinite(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toFinite('3.2');\n     * // => 3.2\n     */\n    function toFinite(value) {\n      if (!value) {\n        return value === 0 ? value : 0;\n      }\n      value = toNumber(value);\n      if (value === INFINITY || value === -INFINITY) {\n        var sign = (value < 0 ? -1 : 1);\n        return sign * MAX_INTEGER;\n      }\n      return value === value ? value : 0;\n    }\n\n    /**\n     * Converts `value` to an integer.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toInteger(3.2);\n     * // => 3\n     *\n     * _.toInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toInteger(Infinity);\n     * // => 1.7976931348623157e+308\n     *\n     * _.toInteger('3.2');\n     * // => 3\n     */\n    function toInteger(value) {\n      var result = toFinite(value),\n          remainder = result % 1;\n\n      return result === result ? (remainder ? result - remainder : result) : 0;\n    }\n\n    /**\n     * Converts `value` to an integer suitable for use as the length of an\n     * array-like object.\n     *\n     * **Note:** This method is based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toLength(3.2);\n     * // => 3\n     *\n     * _.toLength(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toLength(Infinity);\n     * // => 4294967295\n     *\n     * _.toLength('3.2');\n     * // => 3\n     */\n    function toLength(value) {\n      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n    }\n\n    /**\n     * Converts `value` to a number.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {number} Returns the number.\n     * @example\n     *\n     * _.toNumber(3.2);\n     * // => 3.2\n     *\n     * _.toNumber(Number.MIN_VALUE);\n     * // => 5e-324\n     *\n     * _.toNumber(Infinity);\n     * // => Infinity\n     *\n     * _.toNumber('3.2');\n     * // => 3.2\n     */\n    function toNumber(value) {\n      if (typeof value == 'number') {\n        return value;\n      }\n      if (isSymbol(value)) {\n        return NAN;\n      }\n      if (isObject(value)) {\n        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n        value = isObject(other) ? (other + '') : other;\n      }\n      if (typeof value != 'string') {\n        return value === 0 ? value : +value;\n      }\n      value = value.replace(reTrim, '');\n      var isBinary = reIsBinary.test(value);\n      return (isBinary || reIsOctal.test(value))\n        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n        : (reIsBadHex.test(value) ? NAN : +value);\n    }\n\n    /**\n     * Converts `value` to a plain object flattening inherited enumerable string\n     * keyed properties of `value` to own properties of the plain object.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {Object} Returns the converted plain object.\n     * @example\n     *\n     * function Foo() {\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.assign({ 'a': 1 }, new Foo);\n     * // => { 'a': 1, 'b': 2 }\n     *\n     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n     * // => { 'a': 1, 'b': 2, 'c': 3 }\n     */\n    function toPlainObject(value) {\n      return copyObject(value, keysIn(value));\n    }\n\n    /**\n     * Converts `value` to a safe integer. A safe integer can be compared and\n     * represented correctly.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.toSafeInteger(3.2);\n     * // => 3\n     *\n     * _.toSafeInteger(Number.MIN_VALUE);\n     * // => 0\n     *\n     * _.toSafeInteger(Infinity);\n     * // => 9007199254740991\n     *\n     * _.toSafeInteger('3.2');\n     * // => 3\n     */\n    function toSafeInteger(value) {\n      return value\n        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)\n        : (value === 0 ? value : 0);\n    }\n\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Assigns own enumerable string keyed properties of source objects to the\n     * destination object. Source objects are applied from left to right.\n     * Subsequent sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object` and is loosely based on\n     * [`Object.assign`](https://mdn.io/Object/assign).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assignIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assign({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var assign = createAssigner(function(object, source) {\n      if (isPrototype(source) || isArrayLike(source)) {\n        copyObject(source, keys(source), object);\n        return;\n      }\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          assignValue(object, key, source[key]);\n        }\n      }\n    });\n\n    /**\n     * This method is like `_.assign` except that it iterates over own and\n     * inherited source properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extend\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.assign\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     * }\n     *\n     * function Bar() {\n     *   this.c = 3;\n     * }\n     *\n     * Foo.prototype.b = 2;\n     * Bar.prototype.d = 4;\n     *\n     * _.assignIn({ 'a': 0 }, new Foo, new Bar);\n     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }\n     */\n    var assignIn = createAssigner(function(object, source) {\n      copyObject(source, keysIn(source), object);\n    });\n\n    /**\n     * This method is like `_.assignIn` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias extendWith\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignInWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keysIn(source), object, customizer);\n    });\n\n    /**\n     * This method is like `_.assign` except that it accepts `customizer`\n     * which is invoked to produce the assigned values. If `customizer` returns\n     * `undefined`, assignment is handled by the method instead. The `customizer`\n     * is invoked with five arguments: (objValue, srcValue, key, object, source).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @see _.assignInWith\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   return _.isUndefined(objValue) ? srcValue : objValue;\n     * }\n     *\n     * var defaults = _.partialRight(_.assignWith, customizer);\n     *\n     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n      copyObject(source, keys(source), object, customizer);\n    });\n\n    /**\n     * Creates an array of values corresponding to `paths` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Array} Returns the picked values.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };\n     *\n     * _.at(object, ['a[0].b.c', 'a[1]']);\n     * // => [3, 4]\n     */\n    var at = flatRest(baseAt);\n\n    /**\n     * Creates an object that inherits from the `prototype` object. If a\n     * `properties` object is given, its own enumerable string keyed properties\n     * are assigned to the created object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Object\n     * @param {Object} prototype The object to inherit from.\n     * @param {Object} [properties] The properties to assign to the object.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * function Shape() {\n     *   this.x = 0;\n     *   this.y = 0;\n     * }\n     *\n     * function Circle() {\n     *   Shape.call(this);\n     * }\n     *\n     * Circle.prototype = _.create(Shape.prototype, {\n     *   'constructor': Circle\n     * });\n     *\n     * var circle = new Circle;\n     * circle instanceof Circle;\n     * // => true\n     *\n     * circle instanceof Shape;\n     * // => true\n     */\n    function create(prototype, properties) {\n      var result = baseCreate(prototype);\n      return properties == null ? result : baseAssign(result, properties);\n    }\n\n    /**\n     * Assigns own and inherited enumerable string keyed properties of source\n     * objects to the destination object for all destination properties that\n     * resolve to `undefined`. Source objects are applied from left to right.\n     * Once a property is set, additional values of the same property are ignored.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaultsDeep\n     * @example\n     *\n     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n     * // => { 'a': 1, 'b': 2 }\n     */\n    var defaults = baseRest(function(object, sources) {\n      object = Object(object);\n\n      var index = -1;\n      var length = sources.length;\n      var guard = length > 2 ? sources[2] : undefined;\n\n      if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n        length = 1;\n      }\n\n      while (++index < length) {\n        var source = sources[index];\n        var props = keysIn(source);\n        var propsIndex = -1;\n        var propsLength = props.length;\n\n        while (++propsIndex < propsLength) {\n          var key = props[propsIndex];\n          var value = object[key];\n\n          if (value === undefined ||\n              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n            object[key] = source[key];\n          }\n        }\n      }\n\n      return object;\n    });\n\n    /**\n     * This method is like `_.defaults` except that it recursively assigns\n     * default properties.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @see _.defaults\n     * @example\n     *\n     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });\n     * // => { 'a': { 'b': 2, 'c': 3 } }\n     */\n    var defaultsDeep = baseRest(function(args) {\n      args.push(undefined, customDefaultsMerge);\n      return apply(mergeWith, undefined, args);\n    });\n\n    /**\n     * This method is like `_.find` except that it returns the key of the first\n     * element `predicate` returns truthy for instead of the element itself.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findKey(users, function(o) { return o.age < 40; });\n     * // => 'barney' (iteration order is not guaranteed)\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findKey(users, { 'age': 1, 'active': true });\n     * // => 'pebbles'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findKey(users, 'active');\n     * // => 'barney'\n     */\n    function findKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n    }\n\n    /**\n     * This method is like `_.findKey` except that it iterates over elements of\n     * a collection in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @param {Function} [predicate=_.identity] The function invoked per iteration.\n     * @returns {string|undefined} Returns the key of the matched element,\n     *  else `undefined`.\n     * @example\n     *\n     * var users = {\n     *   'barney':  { 'age': 36, 'active': true },\n     *   'fred':    { 'age': 40, 'active': false },\n     *   'pebbles': { 'age': 1,  'active': true }\n     * };\n     *\n     * _.findLastKey(users, function(o) { return o.age < 40; });\n     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.findLastKey(users, { 'age': 36, 'active': true });\n     * // => 'barney'\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.findLastKey(users, ['active', false]);\n     * // => 'fred'\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.findLastKey(users, 'active');\n     * // => 'pebbles'\n     */\n    function findLastKey(object, predicate) {\n      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n    }\n\n    /**\n     * Iterates over own and inherited enumerable string keyed properties of an\n     * object and invokes `iteratee` for each property. The iteratee is invoked\n     * with three arguments: (value, key, object). Iteratee functions may exit\n     * iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forInRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forIn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).\n     */\n    function forIn(object, iteratee) {\n      return object == null\n        ? object\n        : baseFor(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * This method is like `_.forIn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forInRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.\n     */\n    function forInRight(object, iteratee) {\n      return object == null\n        ? object\n        : baseForRight(object, getIteratee(iteratee, 3), keysIn);\n    }\n\n    /**\n     * Iterates over own enumerable string keyed properties of an object and\n     * invokes `iteratee` for each property. The iteratee is invoked with three\n     * arguments: (value, key, object). Iteratee functions may exit iteration\n     * early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwnRight\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwn(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'a' then 'b' (iteration order is not guaranteed).\n     */\n    function forOwn(object, iteratee) {\n      return object && baseForOwn(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * This method is like `_.forOwn` except that it iterates over properties of\n     * `object` in the opposite order.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.0.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     * @see _.forOwn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.forOwnRight(new Foo, function(value, key) {\n     *   console.log(key);\n     * });\n     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.\n     */\n    function forOwnRight(object, iteratee) {\n      return object && baseForOwnRight(object, getIteratee(iteratee, 3));\n    }\n\n    /**\n     * Creates an array of function property names from own enumerable properties\n     * of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functionsIn\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functions(new Foo);\n     * // => ['a', 'b']\n     */\n    function functions(object) {\n      return object == null ? [] : baseFunctions(object, keys(object));\n    }\n\n    /**\n     * Creates an array of function property names from own and inherited\n     * enumerable properties of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to inspect.\n     * @returns {Array} Returns the function names.\n     * @see _.functions\n     * @example\n     *\n     * function Foo() {\n     *   this.a = _.constant('a');\n     *   this.b = _.constant('b');\n     * }\n     *\n     * Foo.prototype.c = _.constant('c');\n     *\n     * _.functionsIn(new Foo);\n     * // => ['a', 'b', 'c']\n     */\n    function functionsIn(object) {\n      return object == null ? [] : baseFunctions(object, keysIn(object));\n    }\n\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n\n    /**\n     * Checks if `path` is a direct property of `object`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = { 'a': { 'b': 2 } };\n     * var other = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.has(object, 'a');\n     * // => true\n     *\n     * _.has(object, 'a.b');\n     * // => true\n     *\n     * _.has(object, ['a', 'b']);\n     * // => true\n     *\n     * _.has(other, 'a');\n     * // => false\n     */\n    function has(object, path) {\n      return object != null && hasPath(object, path, baseHas);\n    }\n\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n\n    /**\n     * Creates an object composed of the inverted keys and values of `object`.\n     * If `object` contains duplicate values, subsequent values overwrite\n     * property assignments of previous values.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invert(object);\n     * // => { '1': 'c', '2': 'b' }\n     */\n    var invert = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      result[value] = key;\n    }, constant(identity));\n\n    /**\n     * This method is like `_.invert` except that the inverted object is generated\n     * from the results of running each element of `object` thru `iteratee`. The\n     * corresponding inverted value of each inverted key is an array of keys\n     * responsible for generating the inverted value. The iteratee is invoked\n     * with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.1.0\n     * @category Object\n     * @param {Object} object The object to invert.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {Object} Returns the new inverted object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2, 'c': 1 };\n     *\n     * _.invertBy(object);\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     *\n     * _.invertBy(object, function(value) {\n     *   return 'group' + value;\n     * });\n     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }\n     */\n    var invertBy = createInverter(function(result, value, key) {\n      if (value != null &&\n          typeof value.toString != 'function') {\n        value = nativeObjectToString.call(value);\n      }\n\n      if (hasOwnProperty.call(result, value)) {\n        result[value].push(key);\n      } else {\n        result[value] = [key];\n      }\n    }, getIteratee);\n\n    /**\n     * Invokes the method at `path` of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {*} Returns the result of the invoked method.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };\n     *\n     * _.invoke(object, 'a[0].b.c.slice', 1, 3);\n     * // => [2, 3]\n     */\n    var invoke = baseRest(baseInvoke);\n\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keysIn(new Foo);\n     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n     */\n    function keysIn(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n    }\n\n    /**\n     * The opposite of `_.mapValues`; this method creates an object with the\n     * same values as `object` and keys generated by running each own enumerable\n     * string keyed property of `object` thru `iteratee`. The iteratee is invoked\n     * with three arguments: (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.8.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapValues\n     * @example\n     *\n     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {\n     *   return key + value;\n     * });\n     * // => { 'a1': 1, 'b2': 2 }\n     */\n    function mapKeys(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, iteratee(value, key, object), value);\n      });\n      return result;\n    }\n\n    /**\n     * Creates an object with the same keys as `object` and values generated\n     * by running each own enumerable string keyed property of `object` thru\n     * `iteratee`. The iteratee is invoked with three arguments:\n     * (value, key, object).\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Object} Returns the new mapped object.\n     * @see _.mapKeys\n     * @example\n     *\n     * var users = {\n     *   'fred':    { 'user': 'fred',    'age': 40 },\n     *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n     * };\n     *\n     * _.mapValues(users, function(o) { return o.age; });\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.mapValues(users, 'age');\n     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n     */\n    function mapValues(object, iteratee) {\n      var result = {};\n      iteratee = getIteratee(iteratee, 3);\n\n      baseForOwn(object, function(value, key, object) {\n        baseAssignValue(result, key, iteratee(value, key, object));\n      });\n      return result;\n    }\n\n    /**\n     * This method is like `_.assign` except that it recursively merges own and\n     * inherited enumerable string keyed properties of source objects into the\n     * destination object. Source properties that resolve to `undefined` are\n     * skipped if a destination value exists. Array and plain object properties\n     * are merged recursively. Other objects and value types are overridden by\n     * assignment. Source objects are applied from left to right. Subsequent\n     * sources overwrite property assignments of previous sources.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.5.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} [sources] The source objects.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {\n     *   'a': [{ 'b': 2 }, { 'd': 4 }]\n     * };\n     *\n     * var other = {\n     *   'a': [{ 'c': 3 }, { 'e': 5 }]\n     * };\n     *\n     * _.merge(object, other);\n     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n     */\n    var merge = createAssigner(function(object, source, srcIndex) {\n      baseMerge(object, source, srcIndex);\n    });\n\n    /**\n     * This method is like `_.merge` except that it accepts `customizer` which\n     * is invoked to produce the merged values of the destination and source\n     * properties. If `customizer` returns `undefined`, merging is handled by the\n     * method instead. The `customizer` is invoked with six arguments:\n     * (objValue, srcValue, key, object, source, stack).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The destination object.\n     * @param {...Object} sources The source objects.\n     * @param {Function} customizer The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * function customizer(objValue, srcValue) {\n     *   if (_.isArray(objValue)) {\n     *     return objValue.concat(srcValue);\n     *   }\n     * }\n     *\n     * var object = { 'a': [1], 'b': [2] };\n     * var other = { 'a': [3], 'b': [4] };\n     *\n     * _.mergeWith(object, other, customizer);\n     * // => { 'a': [1, 3], 'b': [2, 4] }\n     */\n    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n      baseMerge(object, source, srcIndex, customizer);\n    });\n\n    /**\n     * The opposite of `_.pick`; this method creates an object composed of the\n     * own and inherited enumerable property paths of `object` that are not omitted.\n     *\n     * **Note:** This method is considerably slower than `_.pick`.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to omit.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omit(object, ['a', 'c']);\n     * // => { 'b': '2' }\n     */\n    var omit = flatRest(function(object, paths) {\n      var result = {};\n      if (object == null) {\n        return result;\n      }\n      var isDeep = false;\n      paths = arrayMap(paths, function(path) {\n        path = castPath(path, object);\n        isDeep || (isDeep = path.length > 1);\n        return path;\n      });\n      copyObject(object, getAllKeysIn(object), result);\n      if (isDeep) {\n        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n      }\n      var length = paths.length;\n      while (length--) {\n        baseUnset(result, paths[length]);\n      }\n      return result;\n    });\n\n    /**\n     * The opposite of `_.pickBy`; this method creates an object composed of\n     * the own and inherited enumerable string keyed properties of `object` that\n     * `predicate` doesn't return truthy for. The predicate is invoked with two\n     * arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.omitBy(object, _.isNumber);\n     * // => { 'b': '2' }\n     */\n    function omitBy(object, predicate) {\n      return pickBy(object, negate(getIteratee(predicate)));\n    }\n\n    /**\n     * Creates an object composed of the picked `object` properties.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {...(string|string[])} [paths] The property paths to pick.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pick(object, ['a', 'c']);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    var pick = flatRest(function(object, paths) {\n      return object == null ? {} : basePick(object, paths);\n    });\n\n    /**\n     * Creates an object composed of the `object` properties `predicate` returns\n     * truthy for. The predicate is invoked with two arguments: (value, key).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The source object.\n     * @param {Function} [predicate=_.identity] The function invoked per property.\n     * @returns {Object} Returns the new object.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': '2', 'c': 3 };\n     *\n     * _.pickBy(object, _.isNumber);\n     * // => { 'a': 1, 'c': 3 }\n     */\n    function pickBy(object, predicate) {\n      if (object == null) {\n        return {};\n      }\n      var props = arrayMap(getAllKeysIn(object), function(prop) {\n        return [prop];\n      });\n      predicate = getIteratee(predicate);\n      return basePickBy(object, props, function(value, path) {\n        return predicate(value, path[0]);\n      });\n    }\n\n    /**\n     * This method is like `_.get` except that if the resolved value is a\n     * function it's invoked with the `this` binding of its parent object and\n     * its result is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to resolve.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };\n     *\n     * _.result(object, 'a[0].b.c1');\n     * // => 3\n     *\n     * _.result(object, 'a[0].b.c2');\n     * // => 4\n     *\n     * _.result(object, 'a[0].b.c3', 'default');\n     * // => 'default'\n     *\n     * _.result(object, 'a[0].b.c3', _.constant('default'));\n     * // => 'default'\n     */\n    function result(object, path, defaultValue) {\n      path = castPath(path, object);\n\n      var index = -1,\n          length = path.length;\n\n      // Ensure the loop is entered when path is empty.\n      if (!length) {\n        length = 1;\n        object = undefined;\n      }\n      while (++index < length) {\n        var value = object == null ? undefined : object[toKey(path[index])];\n        if (value === undefined) {\n          index = length;\n          value = defaultValue;\n        }\n        object = isFunction(value) ? value.call(object) : value;\n      }\n      return object;\n    }\n\n    /**\n     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,\n     * it's created. Arrays are created for missing index properties while objects\n     * are created for all other missing properties. Use `_.setWith` to customize\n     * `path` creation.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.set(object, 'a[0].b.c', 4);\n     * console.log(object.a[0].b.c);\n     * // => 4\n     *\n     * _.set(object, ['x', '0', 'y', 'z'], 5);\n     * console.log(object.x[0].y.z);\n     * // => 5\n     */\n    function set(object, path, value) {\n      return object == null ? object : baseSet(object, path, value);\n    }\n\n    /**\n     * This method is like `_.set` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {*} value The value to set.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.setWith(object, '[0][1]', 'a', Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function setWith(object, path, value, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseSet(object, path, value, customizer);\n    }\n\n    /**\n     * Creates an array of own enumerable string keyed-value pairs for `object`\n     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its\n     * entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entries\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairs(new Foo);\n     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)\n     */\n    var toPairs = createToPairs(keys);\n\n    /**\n     * Creates an array of own and inherited enumerable string keyed-value pairs\n     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map\n     * or set, its entries are returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @alias entriesIn\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the key-value pairs.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.toPairsIn(new Foo);\n     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)\n     */\n    var toPairsIn = createToPairs(keysIn);\n\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object),\n          isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n\n      iteratee = getIteratee(iteratee, 4);\n      if (accumulator == null) {\n        var Ctor = object && object.constructor;\n        if (isArrLike) {\n          accumulator = isArr ? new Ctor : [];\n        }\n        else if (isObject(object)) {\n          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n        }\n        else {\n          accumulator = {};\n        }\n      }\n      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n\n    /**\n     * Removes the property at `path` of `object`.\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to unset.\n     * @returns {boolean} Returns `true` if the property is deleted, else `false`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 7 } }] };\n     * _.unset(object, 'a[0].b.c');\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     *\n     * _.unset(object, ['a', '0', 'b', 'c']);\n     * // => true\n     *\n     * console.log(object);\n     * // => { 'a': [{ 'b': {} }] };\n     */\n    function unset(object, path) {\n      return object == null ? true : baseUnset(object, path);\n    }\n\n    /**\n     * This method is like `_.set` except that accepts `updater` to produce the\n     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`\n     * is invoked with one argument: (value).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.update(object, 'a[0].b.c', function(n) { return n * n; });\n     * console.log(object.a[0].b.c);\n     * // => 9\n     *\n     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });\n     * console.log(object.x[0].y.z);\n     * // => 0\n     */\n    function update(object, path, updater) {\n      return object == null ? object : baseUpdate(object, path, castFunction(updater));\n    }\n\n    /**\n     * This method is like `_.update` except that it accepts `customizer` which is\n     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`\n     * path creation is handled by the method instead. The `customizer` is invoked\n     * with three arguments: (nsValue, key, nsObject).\n     *\n     * **Note:** This method mutates `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.6.0\n     * @category Object\n     * @param {Object} object The object to modify.\n     * @param {Array|string} path The path of the property to set.\n     * @param {Function} updater The function to produce the updated value.\n     * @param {Function} [customizer] The function to customize assigned values.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var object = {};\n     *\n     * _.updateWith(object, '[0][1]', _.constant('a'), Object);\n     * // => { '0': { '1': 'a' } }\n     */\n    function updateWith(object, path, updater, customizer) {\n      customizer = typeof customizer == 'function' ? customizer : undefined;\n      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n    }\n\n    /**\n     * Creates an array of the own enumerable string keyed property values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.values(new Foo);\n     * // => [1, 2] (iteration order is not guaranteed)\n     *\n     * _.values('hi');\n     * // => ['h', 'i']\n     */\n    function values(object) {\n      return object == null ? [] : baseValues(object, keys(object));\n    }\n\n    /**\n     * Creates an array of the own and inherited enumerable string keyed property\n     * values of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property values.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.valuesIn(new Foo);\n     * // => [1, 2, 3] (iteration order is not guaranteed)\n     */\n    function valuesIn(object) {\n      return object == null ? [] : baseValues(object, keysIn(object));\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Clamps `number` within the inclusive `lower` and `upper` bounds.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Number\n     * @param {number} number The number to clamp.\n     * @param {number} [lower] The lower bound.\n     * @param {number} upper The upper bound.\n     * @returns {number} Returns the clamped number.\n     * @example\n     *\n     * _.clamp(-10, -5, 5);\n     * // => -5\n     *\n     * _.clamp(10, -5, 5);\n     * // => 5\n     */\n    function clamp(number, lower, upper) {\n      if (upper === undefined) {\n        upper = lower;\n        lower = undefined;\n      }\n      if (upper !== undefined) {\n        upper = toNumber(upper);\n        upper = upper === upper ? upper : 0;\n      }\n      if (lower !== undefined) {\n        lower = toNumber(lower);\n        lower = lower === lower ? lower : 0;\n      }\n      return baseClamp(toNumber(number), lower, upper);\n    }\n\n    /**\n     * Checks if `n` is between `start` and up to, but not including, `end`. If\n     * `end` is not specified, it's set to `start` with `start` then set to `0`.\n     * If `start` is greater than `end` the params are swapped to support\n     * negative ranges.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.3.0\n     * @category Number\n     * @param {number} number The number to check.\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.\n     * @see _.range, _.rangeRight\n     * @example\n     *\n     * _.inRange(3, 2, 4);\n     * // => true\n     *\n     * _.inRange(4, 8);\n     * // => true\n     *\n     * _.inRange(4, 2);\n     * // => false\n     *\n     * _.inRange(2, 2);\n     * // => false\n     *\n     * _.inRange(1.2, 2);\n     * // => true\n     *\n     * _.inRange(5.2, 4);\n     * // => false\n     *\n     * _.inRange(-3, -2, -6);\n     * // => true\n     */\n    function inRange(number, start, end) {\n      start = toFinite(start);\n      if (end === undefined) {\n        end = start;\n        start = 0;\n      } else {\n        end = toFinite(end);\n      }\n      number = toNumber(number);\n      return baseInRange(number, start, end);\n    }\n\n    /**\n     * Produces a random number between the inclusive `lower` and `upper` bounds.\n     * If only one argument is provided a number between `0` and the given number\n     * is returned. If `floating` is `true`, or either `lower` or `upper` are\n     * floats, a floating-point number is returned instead of an integer.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.7.0\n     * @category Number\n     * @param {number} [lower=0] The lower bound.\n     * @param {number} [upper=1] The upper bound.\n     * @param {boolean} [floating] Specify returning a floating-point number.\n     * @returns {number} Returns the random number.\n     * @example\n     *\n     * _.random(0, 5);\n     * // => an integer between 0 and 5\n     *\n     * _.random(5);\n     * // => also an integer between 0 and 5\n     *\n     * _.random(5, true);\n     * // => a floating-point number between 0 and 5\n     *\n     * _.random(1.2, 5.2);\n     * // => a floating-point number between 1.2 and 5.2\n     */\n    function random(lower, upper, floating) {\n      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {\n        upper = floating = undefined;\n      }\n      if (floating === undefined) {\n        if (typeof upper == 'boolean') {\n          floating = upper;\n          upper = undefined;\n        }\n        else if (typeof lower == 'boolean') {\n          floating = lower;\n          lower = undefined;\n        }\n      }\n      if (lower === undefined && upper === undefined) {\n        lower = 0;\n        upper = 1;\n      }\n      else {\n        lower = toFinite(lower);\n        if (upper === undefined) {\n          upper = lower;\n          lower = 0;\n        } else {\n          upper = toFinite(upper);\n        }\n      }\n      if (lower > upper) {\n        var temp = lower;\n        lower = upper;\n        upper = temp;\n      }\n      if (floating || lower % 1 || upper % 1) {\n        var rand = nativeRandom();\n        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);\n      }\n      return baseRandom(lower, upper);\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the camel cased string.\n     * @example\n     *\n     * _.camelCase('Foo Bar');\n     * // => 'fooBar'\n     *\n     * _.camelCase('--foo-bar--');\n     * // => 'fooBar'\n     *\n     * _.camelCase('__FOO_BAR__');\n     * // => 'fooBar'\n     */\n    var camelCase = createCompounder(function(result, word, index) {\n      word = word.toLowerCase();\n      return result + (index ? capitalize(word) : word);\n    });\n\n    /**\n     * Converts the first character of `string` to upper case and the remaining\n     * to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to capitalize.\n     * @returns {string} Returns the capitalized string.\n     * @example\n     *\n     * _.capitalize('FRED');\n     * // => 'Fred'\n     */\n    function capitalize(string) {\n      return upperFirst(toString(string).toLowerCase());\n    }\n\n    /**\n     * Deburrs `string` by converting\n     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)\n     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)\n     * letters to basic Latin letters and removing\n     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to deburr.\n     * @returns {string} Returns the deburred string.\n     * @example\n     *\n     * _.deburr('dj vu');\n     * // => 'deja vu'\n     */\n    function deburr(string) {\n      string = toString(string);\n      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\n    }\n\n    /**\n     * Checks if `string` ends with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=string.length] The position to search up to.\n     * @returns {boolean} Returns `true` if `string` ends with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.endsWith('abc', 'c');\n     * // => true\n     *\n     * _.endsWith('abc', 'b');\n     * // => false\n     *\n     * _.endsWith('abc', 'b', 2);\n     * // => true\n     */\n    function endsWith(string, target, position) {\n      string = toString(string);\n      target = baseToString(target);\n\n      var length = string.length;\n      position = position === undefined\n        ? length\n        : baseClamp(toInteger(position), 0, length);\n\n      var end = position;\n      position -= target.length;\n      return position >= 0 && string.slice(position, end) == target;\n    }\n\n    /**\n     * Converts the characters \"&\", \"<\", \">\", '\"', and \"'\" in `string` to their\n     * corresponding HTML entities.\n     *\n     * **Note:** No other characters are escaped. To escape additional\n     * characters use a third-party library like [_he_](https://mths.be/he).\n     *\n     * Though the \">\" character is escaped for symmetry, characters like\n     * \">\" and \"/\" don't need escaping in HTML and have no special meaning\n     * unless they're part of a tag or unquoted attribute value. See\n     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)\n     * (under \"semi-related fun fact\") for more details.\n     *\n     * When working with HTML you should always\n     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce\n     * XSS vectors.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escape('fred, barney, & pebbles');\n     * // => 'fred, barney, &amp; pebbles'\n     */\n    function escape(string) {\n      string = toString(string);\n      return (string && reHasUnescapedHtml.test(string))\n        ? string.replace(reUnescapedHtml, escapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n     * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to escape.\n     * @returns {string} Returns the escaped string.\n     * @example\n     *\n     * _.escapeRegExp('[lodash](https://lodash.com/)');\n     * // => '\\[lodash\\]\\(https://lodash\\.com/\\)'\n     */\n    function escapeRegExp(string) {\n      string = toString(string);\n      return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n    }\n\n    /**\n     * Converts `string` to\n     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the kebab cased string.\n     * @example\n     *\n     * _.kebabCase('Foo Bar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('fooBar');\n     * // => 'foo-bar'\n     *\n     * _.kebabCase('__FOO_BAR__');\n     * // => 'foo-bar'\n     */\n    var kebabCase = createCompounder(function(result, word, index) {\n      return result + (index ? '-' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts `string`, as space separated words, to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.lowerCase('--Foo-Bar--');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('fooBar');\n     * // => 'foo bar'\n     *\n     * _.lowerCase('__FOO_BAR__');\n     * // => 'foo bar'\n     */\n    var lowerCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Converts the first character of `string` to lower case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.lowerFirst('Fred');\n     * // => 'fred'\n     *\n     * _.lowerFirst('FRED');\n     * // => 'fRED'\n     */\n    var lowerFirst = createCaseFirst('toLowerCase');\n\n    /**\n     * Pads `string` on the left and right sides if it's shorter than `length`.\n     * Padding characters are truncated if they can't be evenly divided by `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.pad('abc', 8);\n     * // => '  abc   '\n     *\n     * _.pad('abc', 8, '_-');\n     * // => '_-abc_-_'\n     *\n     * _.pad('abc', 3);\n     * // => 'abc'\n     */\n    function pad(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      if (!length || strLength >= length) {\n        return string;\n      }\n      var mid = (length - strLength) / 2;\n      return (\n        createPadding(nativeFloor(mid), chars) +\n        string +\n        createPadding(nativeCeil(mid), chars)\n      );\n    }\n\n    /**\n     * Pads `string` on the right side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padEnd('abc', 6);\n     * // => 'abc   '\n     *\n     * _.padEnd('abc', 6, '_-');\n     * // => 'abc_-_'\n     *\n     * _.padEnd('abc', 3);\n     * // => 'abc'\n     */\n    function padEnd(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (string + createPadding(length - strLength, chars))\n        : string;\n    }\n\n    /**\n     * Pads `string` on the left side if it's shorter than `length`. Padding\n     * characters are truncated if they exceed `length`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to pad.\n     * @param {number} [length=0] The padding length.\n     * @param {string} [chars=' '] The string used as padding.\n     * @returns {string} Returns the padded string.\n     * @example\n     *\n     * _.padStart('abc', 6);\n     * // => '   abc'\n     *\n     * _.padStart('abc', 6, '_-');\n     * // => '_-_abc'\n     *\n     * _.padStart('abc', 3);\n     * // => 'abc'\n     */\n    function padStart(string, length, chars) {\n      string = toString(string);\n      length = toInteger(length);\n\n      var strLength = length ? stringSize(string) : 0;\n      return (length && strLength < length)\n        ? (createPadding(length - strLength, chars) + string)\n        : string;\n    }\n\n    /**\n     * Converts `string` to an integer of the specified radix. If `radix` is\n     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a\n     * hexadecimal, in which case a `radix` of `16` is used.\n     *\n     * **Note:** This method aligns with the\n     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.1.0\n     * @category String\n     * @param {string} string The string to convert.\n     * @param {number} [radix=10] The radix to interpret `value` by.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {number} Returns the converted integer.\n     * @example\n     *\n     * _.parseInt('08');\n     * // => 8\n     *\n     * _.map(['6', '08', '10'], _.parseInt);\n     * // => [6, 8, 10]\n     */\n    function parseInt(string, radix, guard) {\n      if (guard || radix == null) {\n        radix = 0;\n      } else if (radix) {\n        radix = +radix;\n      }\n      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);\n    }\n\n    /**\n     * Repeats the given string `n` times.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to repeat.\n     * @param {number} [n=1] The number of times to repeat the string.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the repeated string.\n     * @example\n     *\n     * _.repeat('*', 3);\n     * // => '***'\n     *\n     * _.repeat('abc', 2);\n     * // => 'abcabc'\n     *\n     * _.repeat('abc', 0);\n     * // => ''\n     */\n    function repeat(string, n, guard) {\n      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {\n        n = 1;\n      } else {\n        n = toInteger(n);\n      }\n      return baseRepeat(toString(string), n);\n    }\n\n    /**\n     * Replaces matches for `pattern` in `string` with `replacement`.\n     *\n     * **Note:** This method is based on\n     * [`String#replace`](https://mdn.io/String/replace).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to modify.\n     * @param {RegExp|string} pattern The pattern to replace.\n     * @param {Function|string} replacement The match replacement.\n     * @returns {string} Returns the modified string.\n     * @example\n     *\n     * _.replace('Hi Fred', 'Fred', 'Barney');\n     * // => 'Hi Barney'\n     */\n    function replace() {\n      var args = arguments,\n          string = toString(args[0]);\n\n      return args.length < 3 ? string : string.replace(args[1], args[2]);\n    }\n\n    /**\n     * Converts `string` to\n     * [snake case](https://en.wikipedia.org/wiki/Snake_case).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the snake cased string.\n     * @example\n     *\n     * _.snakeCase('Foo Bar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('fooBar');\n     * // => 'foo_bar'\n     *\n     * _.snakeCase('--FOO-BAR--');\n     * // => 'foo_bar'\n     */\n    var snakeCase = createCompounder(function(result, word, index) {\n      return result + (index ? '_' : '') + word.toLowerCase();\n    });\n\n    /**\n     * Splits `string` by `separator`.\n     *\n     * **Note:** This method is based on\n     * [`String#split`](https://mdn.io/String/split).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to split.\n     * @param {RegExp|string} separator The separator pattern to split by.\n     * @param {number} [limit] The length to truncate results to.\n     * @returns {Array} Returns the string segments.\n     * @example\n     *\n     * _.split('a-b-c', '-', 2);\n     * // => ['a', 'b']\n     */\n    function split(string, separator, limit) {\n      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {\n        separator = limit = undefined;\n      }\n      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;\n      if (!limit) {\n        return [];\n      }\n      string = toString(string);\n      if (string && (\n            typeof separator == 'string' ||\n            (separator != null && !isRegExp(separator))\n          )) {\n        separator = baseToString(separator);\n        if (!separator && hasUnicode(string)) {\n          return castSlice(stringToArray(string), 0, limit);\n        }\n      }\n      return string.split(separator, limit);\n    }\n\n    /**\n     * Converts `string` to\n     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).\n     *\n     * @static\n     * @memberOf _\n     * @since 3.1.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the start cased string.\n     * @example\n     *\n     * _.startCase('--foo-bar--');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('fooBar');\n     * // => 'Foo Bar'\n     *\n     * _.startCase('__FOO_BAR__');\n     * // => 'FOO BAR'\n     */\n    var startCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + upperFirst(word);\n    });\n\n    /**\n     * Checks if `string` starts with the given target string.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {string} [target] The string to search for.\n     * @param {number} [position=0] The position to search from.\n     * @returns {boolean} Returns `true` if `string` starts with `target`,\n     *  else `false`.\n     * @example\n     *\n     * _.startsWith('abc', 'a');\n     * // => true\n     *\n     * _.startsWith('abc', 'b');\n     * // => false\n     *\n     * _.startsWith('abc', 'b', 1);\n     * // => true\n     */\n    function startsWith(string, target, position) {\n      string = toString(string);\n      position = position == null\n        ? 0\n        : baseClamp(toInteger(position), 0, string.length);\n\n      target = baseToString(target);\n      return string.slice(position, position + target.length) == target;\n    }\n\n    /**\n     * Creates a compiled template function that can interpolate data properties\n     * in \"interpolate\" delimiters, HTML-escape interpolated data properties in\n     * \"escape\" delimiters, and execute JavaScript in \"evaluate\" delimiters. Data\n     * properties may be accessed as free variables in the template. If a setting\n     * object is given, it takes precedence over `_.templateSettings` values.\n     *\n     * **Note:** In the development build `_.template` utilizes\n     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)\n     * for easier debugging.\n     *\n     * For more information on precompiling templates see\n     * [lodash's custom builds documentation](https://lodash.com/custom-builds).\n     *\n     * For more information on Chrome extension sandboxes see\n     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category String\n     * @param {string} [string=''] The template string.\n     * @param {Object} [options={}] The options object.\n     * @param {RegExp} [options.escape=_.templateSettings.escape]\n     *  The HTML \"escape\" delimiter.\n     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]\n     *  The \"evaluate\" delimiter.\n     * @param {Object} [options.imports=_.templateSettings.imports]\n     *  An object to import into the template as free variables.\n     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]\n     *  The \"interpolate\" delimiter.\n     * @param {string} [options.sourceURL='lodash.templateSources[n]']\n     *  The sourceURL of the compiled template.\n     * @param {string} [options.variable='obj']\n     *  The data object variable name.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Function} Returns the compiled template function.\n     * @example\n     *\n     * // Use the \"interpolate\" delimiter to create a compiled template.\n     * var compiled = _.template('hello <%= user %>!');\n     * compiled({ 'user': 'fred' });\n     * // => 'hello fred!'\n     *\n     * // Use the HTML \"escape\" delimiter to escape data property values.\n     * var compiled = _.template('<b><%- value %></b>');\n     * compiled({ 'value': '<script>' });\n     * // => '<b>&lt;script&gt;</b>'\n     *\n     * // Use the \"evaluate\" delimiter to execute JavaScript and generate HTML.\n     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the internal `print` function in \"evaluate\" delimiters.\n     * var compiled = _.template('<% print(\"hello \" + user); %>!');\n     * compiled({ 'user': 'barney' });\n     * // => 'hello barney!'\n     *\n     * // Use the ES template literal delimiter as an \"interpolate\" delimiter.\n     * // Disable support by replacing the \"interpolate\" delimiter.\n     * var compiled = _.template('hello ${ user }!');\n     * compiled({ 'user': 'pebbles' });\n     * // => 'hello pebbles!'\n     *\n     * // Use backslashes to treat delimiters as plain text.\n     * var compiled = _.template('<%= \"\\\\<%- value %\\\\>\" %>');\n     * compiled({ 'value': 'ignored' });\n     * // => '<%- value %>'\n     *\n     * // Use the `imports` option to import `jQuery` as `jq`.\n     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';\n     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });\n     * compiled({ 'users': ['fred', 'barney'] });\n     * // => '<li>fred</li><li>barney</li>'\n     *\n     * // Use the `sourceURL` option to specify a custom sourceURL for the template.\n     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });\n     * compiled(data);\n     * // => Find the source of \"greeting.jst\" under the Sources tab or Resources panel of the web inspector.\n     *\n     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.\n     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });\n     * compiled.source;\n     * // => function(data) {\n     * //   var __t, __p = '';\n     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';\n     * //   return __p;\n     * // }\n     *\n     * // Use custom template delimiters.\n     * _.templateSettings.interpolate = /{{([\\s\\S]+?)}}/g;\n     * var compiled = _.template('hello {{ user }}!');\n     * compiled({ 'user': 'mustache' });\n     * // => 'hello mustache!'\n     *\n     * // Use the `source` property to inline compiled templates for meaningful\n     * // line numbers in error messages and stack traces.\n     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\\\n     *   var JST = {\\\n     *     \"main\": ' + _.template(mainText).source + '\\\n     *   };\\\n     * ');\n     */\n    function template(string, options, guard) {\n      // Based on John Resig's `tmpl` implementation\n      // (http://ejohn.org/blog/javascript-micro-templating/)\n      // and Laura Doktorova's doT.js (https://github.com/olado/doT).\n      var settings = lodash.templateSettings;\n\n      if (guard && isIterateeCall(string, options, guard)) {\n        options = undefined;\n      }\n      string = toString(string);\n      options = assignInWith({}, options, settings, customDefaultsAssignIn);\n\n      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),\n          importsKeys = keys(imports),\n          importsValues = baseValues(imports, importsKeys);\n\n      var isEscaping,\n          isEvaluating,\n          index = 0,\n          interpolate = options.interpolate || reNoMatch,\n          source = \"__p += '\";\n\n      // Compile the regexp to match each delimiter.\n      var reDelimiters = RegExp(\n        (options.escape || reNoMatch).source + '|' +\n        interpolate.source + '|' +\n        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +\n        (options.evaluate || reNoMatch).source + '|$'\n      , 'g');\n\n      // Use a sourceURL for easier debugging.\n      // The sourceURL gets injected into the source that's eval-ed, so be careful\n      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.\n      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.\n      var sourceURL = '//# sourceURL=' +\n        (hasOwnProperty.call(options, 'sourceURL')\n          ? (options.sourceURL + '').replace(/[\\r\\n]/g, ' ')\n          : ('lodash.templateSources[' + (++templateCounter) + ']')\n        ) + '\\n';\n\n      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n        interpolateValue || (interpolateValue = esTemplateValue);\n\n        // Escape characters that can't be included in string literals.\n        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n\n        // Replace delimiters with snippets.\n        if (escapeValue) {\n          isEscaping = true;\n          source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n        }\n        if (evaluateValue) {\n          isEvaluating = true;\n          source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n        }\n        if (interpolateValue) {\n          source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n        }\n        index = offset + match.length;\n\n        // The JS engine embedded in Adobe products needs `match` returned in\n        // order to produce the correct `offset` value.\n        return match;\n      });\n\n      source += \"';\\n\";\n\n      // If `variable` is not specified wrap a with-statement around the generated\n      // code to add the data object to the top of the scope chain.\n      // Like with sourceURL, we take care to not check the option's prototype,\n      // as this configuration is a code injection vector.\n      var variable = hasOwnProperty.call(options, 'variable') && options.variable;\n      if (!variable) {\n        source = 'with (obj) {\\n' + source + '\\n}\\n';\n      }\n      // Cleanup code by stripping empty strings.\n      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)\n        .replace(reEmptyStringMiddle, '$1')\n        .replace(reEmptyStringTrailing, '$1;');\n\n      // Frame code as the function body.\n      source = 'function(' + (variable || 'obj') + ') {\\n' +\n        (variable\n          ? ''\n          : 'obj || (obj = {});\\n'\n        ) +\n        \"var __t, __p = ''\" +\n        (isEscaping\n           ? ', __e = _.escape'\n           : ''\n        ) +\n        (isEvaluating\n          ? ', __j = Array.prototype.join;\\n' +\n            \"function print() { __p += __j.call(arguments, '') }\\n\"\n          : ';\\n'\n        ) +\n        source +\n        'return __p\\n}';\n\n      var result = attempt(function() {\n        return Function(importsKeys, sourceURL + 'return ' + source)\n          .apply(undefined, importsValues);\n      });\n\n      // Provide the compiled function's source by its `toString` method or\n      // the `source` property as a convenience for inlining compiled templates.\n      result.source = source;\n      if (isError(result)) {\n        throw result;\n      }\n      return result;\n    }\n\n    /**\n     * Converts `string`, as a whole, to lower case just like\n     * [String#toLowerCase](https://mdn.io/toLowerCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the lower cased string.\n     * @example\n     *\n     * _.toLower('--Foo-Bar--');\n     * // => '--foo-bar--'\n     *\n     * _.toLower('fooBar');\n     * // => 'foobar'\n     *\n     * _.toLower('__FOO_BAR__');\n     * // => '__foo_bar__'\n     */\n    function toLower(value) {\n      return toString(value).toLowerCase();\n    }\n\n    /**\n     * Converts `string`, as a whole, to upper case just like\n     * [String#toUpperCase](https://mdn.io/toUpperCase).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.toUpper('--foo-bar--');\n     * // => '--FOO-BAR--'\n     *\n     * _.toUpper('fooBar');\n     * // => 'FOOBAR'\n     *\n     * _.toUpper('__foo_bar__');\n     * // => '__FOO_BAR__'\n     */\n    function toUpper(value) {\n      return toString(value).toUpperCase();\n    }\n\n    /**\n     * Removes leading and trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trim('  abc  ');\n     * // => 'abc'\n     *\n     * _.trim('-_-abc-_-', '_-');\n     * // => 'abc'\n     *\n     * _.map(['  foo  ', '  bar  '], _.trim);\n     * // => ['foo', 'bar']\n     */\n    function trim(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrim, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          chrSymbols = stringToArray(chars),\n          start = charsStartIndex(strSymbols, chrSymbols),\n          end = charsEndIndex(strSymbols, chrSymbols) + 1;\n\n      return castSlice(strSymbols, start, end).join('');\n    }\n\n    /**\n     * Removes trailing whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimEnd('  abc  ');\n     * // => '  abc'\n     *\n     * _.trimEnd('-_-abc-_-', '_-');\n     * // => '-_-abc'\n     */\n    function trimEnd(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimEnd, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n\n      return castSlice(strSymbols, 0, end).join('');\n    }\n\n    /**\n     * Removes leading whitespace or specified characters from `string`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to trim.\n     * @param {string} [chars=whitespace] The characters to trim.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {string} Returns the trimmed string.\n     * @example\n     *\n     * _.trimStart('  abc  ');\n     * // => 'abc  '\n     *\n     * _.trimStart('-_-abc-_-', '_-');\n     * // => 'abc-_-'\n     */\n    function trimStart(string, chars, guard) {\n      string = toString(string);\n      if (string && (guard || chars === undefined)) {\n        return string.replace(reTrimStart, '');\n      }\n      if (!string || !(chars = baseToString(chars))) {\n        return string;\n      }\n      var strSymbols = stringToArray(string),\n          start = charsStartIndex(strSymbols, stringToArray(chars));\n\n      return castSlice(strSymbols, start).join('');\n    }\n\n    /**\n     * Truncates `string` if it's longer than the given maximum string length.\n     * The last characters of the truncated string are replaced with the omission\n     * string which defaults to \"...\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to truncate.\n     * @param {Object} [options={}] The options object.\n     * @param {number} [options.length=30] The maximum string length.\n     * @param {string} [options.omission='...'] The string to indicate text is omitted.\n     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.\n     * @returns {string} Returns the truncated string.\n     * @example\n     *\n     * _.truncate('hi-diddly-ho there, neighborino');\n     * // => 'hi-diddly-ho there, neighbo...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': ' '\n     * });\n     * // => 'hi-diddly-ho there,...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'length': 24,\n     *   'separator': /,? +/\n     * });\n     * // => 'hi-diddly-ho there...'\n     *\n     * _.truncate('hi-diddly-ho there, neighborino', {\n     *   'omission': ' [...]'\n     * });\n     * // => 'hi-diddly-ho there, neig [...]'\n     */\n    function truncate(string, options) {\n      var length = DEFAULT_TRUNC_LENGTH,\n          omission = DEFAULT_TRUNC_OMISSION;\n\n      if (isObject(options)) {\n        var separator = 'separator' in options ? options.separator : separator;\n        length = 'length' in options ? toInteger(options.length) : length;\n        omission = 'omission' in options ? baseToString(options.omission) : omission;\n      }\n      string = toString(string);\n\n      var strLength = string.length;\n      if (hasUnicode(string)) {\n        var strSymbols = stringToArray(string);\n        strLength = strSymbols.length;\n      }\n      if (length >= strLength) {\n        return string;\n      }\n      var end = length - stringSize(omission);\n      if (end < 1) {\n        return omission;\n      }\n      var result = strSymbols\n        ? castSlice(strSymbols, 0, end).join('')\n        : string.slice(0, end);\n\n      if (separator === undefined) {\n        return result + omission;\n      }\n      if (strSymbols) {\n        end += (result.length - end);\n      }\n      if (isRegExp(separator)) {\n        if (string.slice(end).search(separator)) {\n          var match,\n              substring = result;\n\n          if (!separator.global) {\n            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');\n          }\n          separator.lastIndex = 0;\n          while ((match = separator.exec(substring))) {\n            var newEnd = match.index;\n          }\n          result = result.slice(0, newEnd === undefined ? end : newEnd);\n        }\n      } else if (string.indexOf(baseToString(separator), end) != end) {\n        var index = result.lastIndexOf(separator);\n        if (index > -1) {\n          result = result.slice(0, index);\n        }\n      }\n      return result + omission;\n    }\n\n    /**\n     * The inverse of `_.escape`; this method converts the HTML entities\n     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to\n     * their corresponding characters.\n     *\n     * **Note:** No other HTML entities are unescaped. To unescape additional\n     * HTML entities use a third-party library like [_he_](https://mths.be/he).\n     *\n     * @static\n     * @memberOf _\n     * @since 0.6.0\n     * @category String\n     * @param {string} [string=''] The string to unescape.\n     * @returns {string} Returns the unescaped string.\n     * @example\n     *\n     * _.unescape('fred, barney, &amp; pebbles');\n     * // => 'fred, barney, & pebbles'\n     */\n    function unescape(string) {\n      string = toString(string);\n      return (string && reHasEscapedHtml.test(string))\n        ? string.replace(reEscapedHtml, unescapeHtmlChar)\n        : string;\n    }\n\n    /**\n     * Converts `string`, as space separated words, to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the upper cased string.\n     * @example\n     *\n     * _.upperCase('--foo-bar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('fooBar');\n     * // => 'FOO BAR'\n     *\n     * _.upperCase('__foo_bar__');\n     * // => 'FOO BAR'\n     */\n    var upperCase = createCompounder(function(result, word, index) {\n      return result + (index ? ' ' : '') + word.toUpperCase();\n    });\n\n    /**\n     * Converts the first character of `string` to upper case.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category String\n     * @param {string} [string=''] The string to convert.\n     * @returns {string} Returns the converted string.\n     * @example\n     *\n     * _.upperFirst('fred');\n     * // => 'Fred'\n     *\n     * _.upperFirst('FRED');\n     * // => 'FRED'\n     */\n    var upperFirst = createCaseFirst('toUpperCase');\n\n    /**\n     * Splits `string` into an array of its words.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category String\n     * @param {string} [string=''] The string to inspect.\n     * @param {RegExp|string} [pattern] The pattern to match words.\n     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\n     * @returns {Array} Returns the words of `string`.\n     * @example\n     *\n     * _.words('fred, barney, & pebbles');\n     * // => ['fred', 'barney', 'pebbles']\n     *\n     * _.words('fred, barney, & pebbles', /[^, ]+/g);\n     * // => ['fred', 'barney', '&', 'pebbles']\n     */\n    function words(string, pattern, guard) {\n      string = toString(string);\n      pattern = guard ? undefined : pattern;\n\n      if (pattern === undefined) {\n        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n      }\n      return string.match(pattern) || [];\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Attempts to invoke `func`, returning either the result or the caught error\n     * object. Any additional arguments are provided to `func` when it's invoked.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Function} func The function to attempt.\n     * @param {...*} [args] The arguments to invoke `func` with.\n     * @returns {*} Returns the `func` result or error object.\n     * @example\n     *\n     * // Avoid throwing errors for invalid selectors.\n     * var elements = _.attempt(function(selector) {\n     *   return document.querySelectorAll(selector);\n     * }, '>_>');\n     *\n     * if (_.isError(elements)) {\n     *   elements = [];\n     * }\n     */\n    var attempt = baseRest(function(func, args) {\n      try {\n        return apply(func, undefined, args);\n      } catch (e) {\n        return isError(e) ? e : new Error(e);\n      }\n    });\n\n    /**\n     * Binds methods of an object to the object itself, overwriting the existing\n     * method.\n     *\n     * **Note:** This method doesn't set the \"length\" property of bound functions.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Object} object The object to bind and assign the bound methods to.\n     * @param {...(string|string[])} methodNames The object method names to bind.\n     * @returns {Object} Returns `object`.\n     * @example\n     *\n     * var view = {\n     *   'label': 'docs',\n     *   'click': function() {\n     *     console.log('clicked ' + this.label);\n     *   }\n     * };\n     *\n     * _.bindAll(view, ['click']);\n     * jQuery(element).on('click', view.click);\n     * // => Logs 'clicked docs' when clicked.\n     */\n    var bindAll = flatRest(function(object, methodNames) {\n      arrayEach(methodNames, function(key) {\n        key = toKey(key);\n        baseAssignValue(object, key, bind(object[key], object));\n      });\n      return object;\n    });\n\n    /**\n     * Creates a function that iterates over `pairs` and invokes the corresponding\n     * function of the first predicate to return truthy. The predicate-function\n     * pairs are invoked with the `this` binding and arguments of the created\n     * function.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Array} pairs The predicate-function pairs.\n     * @returns {Function} Returns the new composite function.\n     * @example\n     *\n     * var func = _.cond([\n     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],\n     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],\n     *   [_.stubTrue,                      _.constant('no match')]\n     * ]);\n     *\n     * func({ 'a': 1, 'b': 2 });\n     * // => 'matches A'\n     *\n     * func({ 'a': 0, 'b': 1 });\n     * // => 'matches B'\n     *\n     * func({ 'a': '1', 'b': '2' });\n     * // => 'no match'\n     */\n    function cond(pairs) {\n      var length = pairs == null ? 0 : pairs.length,\n          toIteratee = getIteratee();\n\n      pairs = !length ? [] : arrayMap(pairs, function(pair) {\n        if (typeof pair[1] != 'function') {\n          throw new TypeError(FUNC_ERROR_TEXT);\n        }\n        return [toIteratee(pair[0]), pair[1]];\n      });\n\n      return baseRest(function(args) {\n        var index = -1;\n        while (++index < length) {\n          var pair = pairs[index];\n          if (apply(pair[0], this, args)) {\n            return apply(pair[1], this, args);\n          }\n        }\n      });\n    }\n\n    /**\n     * Creates a function that invokes the predicate properties of `source` with\n     * the corresponding property values of a given object, returning `true` if\n     * all predicates return truthy, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.conformsTo` with\n     * `source` partially applied.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {Object} source The object of property predicates to conform to.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 2, 'b': 1 },\n     *   { 'a': 1, 'b': 2 }\n     * ];\n     *\n     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));\n     * // => [{ 'a': 1, 'b': 2 }]\n     */\n    function conforms(source) {\n      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that returns `value`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {*} value The value to return from the new function.\n     * @returns {Function} Returns the new constant function.\n     * @example\n     *\n     * var objects = _.times(2, _.constant({ 'a': 1 }));\n     *\n     * console.log(objects);\n     * // => [{ 'a': 1 }, { 'a': 1 }]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => true\n     */\n    function constant(value) {\n      return function() {\n        return value;\n      };\n    }\n\n    /**\n     * Checks `value` to determine whether a default value should be returned in\n     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,\n     * or `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.14.0\n     * @category Util\n     * @param {*} value The value to check.\n     * @param {*} defaultValue The default value.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * _.defaultTo(1, 10);\n     * // => 1\n     *\n     * _.defaultTo(undefined, 10);\n     * // => 10\n     */\n    function defaultTo(value, defaultValue) {\n      return (value == null || value !== value) ? defaultValue : value;\n    }\n\n    /**\n     * Creates a function that returns the result of invoking the given functions\n     * with the `this` binding of the created function, where each successive\n     * invocation is supplied the return value of the previous.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flowRight\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flow([_.add, square]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flow = createFlow();\n\n    /**\n     * This method is like `_.flow` except that it creates a function that\n     * invokes the given functions from right to left.\n     *\n     * @static\n     * @since 3.0.0\n     * @memberOf _\n     * @category Util\n     * @param {...(Function|Function[])} [funcs] The functions to invoke.\n     * @returns {Function} Returns the new composite function.\n     * @see _.flow\n     * @example\n     *\n     * function square(n) {\n     *   return n * n;\n     * }\n     *\n     * var addSquare = _.flowRight([square, _.add]);\n     * addSquare(1, 2);\n     * // => 9\n     */\n    var flowRight = createFlow(true);\n\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n    function identity(value) {\n      return value;\n    }\n\n    /**\n     * Creates a function that invokes `func` with the arguments of the created\n     * function. If `func` is a property name, the created function returns the\n     * property value for a given element. If `func` is an array or object, the\n     * created function returns `true` for elements that contain the equivalent\n     * source properties, otherwise it returns `false`.\n     *\n     * @static\n     * @since 4.0.0\n     * @memberOf _\n     * @category Util\n     * @param {*} [func=_.identity] The value to convert to a callback.\n     * @returns {Function} Returns the callback.\n     * @example\n     *\n     * var users = [\n     *   { 'user': 'barney', 'age': 36, 'active': true },\n     *   { 'user': 'fred',   'age': 40, 'active': false }\n     * ];\n     *\n     * // The `_.matches` iteratee shorthand.\n     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));\n     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]\n     *\n     * // The `_.matchesProperty` iteratee shorthand.\n     * _.filter(users, _.iteratee(['user', 'fred']));\n     * // => [{ 'user': 'fred', 'age': 40 }]\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.map(users, _.iteratee('user'));\n     * // => ['barney', 'fred']\n     *\n     * // Create custom iteratee shorthands.\n     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {\n     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {\n     *     return func.test(string);\n     *   };\n     * });\n     *\n     * _.filter(['abc', 'def'], /ef/);\n     * // => ['def']\n     */\n    function iteratee(func) {\n      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between a given\n     * object and `source`, returning `true` if the given object has equivalent\n     * property values, else `false`.\n     *\n     * **Note:** The created function is equivalent to `_.isMatch` with `source`\n     * partially applied.\n     *\n     * Partial comparisons will match empty array and empty object `source`\n     * values against any array or object value, respectively. See `_.isEqual`\n     * for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));\n     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]\n     */\n    function matches(source) {\n      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that performs a partial deep comparison between the\n     * value at `path` of a given object to `srcValue`, returning `true` if the\n     * object value is equivalent, else `false`.\n     *\n     * **Note:** Partial comparisons will match empty array and empty object\n     * `srcValue` values against any array or object value, respectively. See\n     * `_.isEqual` for a list of supported value comparisons.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.2.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': 1, 'b': 2, 'c': 3 },\n     *   { 'a': 4, 'b': 5, 'c': 6 }\n     * ];\n     *\n     * _.find(objects, _.matchesProperty('a', 4));\n     * // => { 'a': 4, 'b': 5, 'c': 6 }\n     */\n    function matchesProperty(path, srcValue) {\n      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n    }\n\n    /**\n     * Creates a function that invokes the method at `path` of a given object.\n     * Any additional arguments are provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Array|string} path The path of the method to invoke.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': _.constant(2) } },\n     *   { 'a': { 'b': _.constant(1) } }\n     * ];\n     *\n     * _.map(objects, _.method('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(objects, _.method(['a', 'b']));\n     * // => [2, 1]\n     */\n    var method = baseRest(function(path, args) {\n      return function(object) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * The opposite of `_.method`; this method creates a function that invokes\n     * the method at a given path of `object`. Any additional arguments are\n     * provided to the invoked method.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @param {...*} [args] The arguments to invoke the method with.\n     * @returns {Function} Returns the new invoker function.\n     * @example\n     *\n     * var array = _.times(3, _.constant),\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.methodOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));\n     * // => [2, 0]\n     */\n    var methodOf = baseRest(function(object, args) {\n      return function(path) {\n        return baseInvoke(object, path, args);\n      };\n    });\n\n    /**\n     * Adds all own enumerable string keyed function properties of a source\n     * object to the destination object. If `object` is a function, then methods\n     * are added to its prototype as well.\n     *\n     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to\n     * avoid conflicts caused by modifying the original.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {Function|Object} [object=lodash] The destination object.\n     * @param {Object} source The object of functions to add.\n     * @param {Object} [options={}] The options object.\n     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.\n     * @returns {Function|Object} Returns `object`.\n     * @example\n     *\n     * function vowels(string) {\n     *   return _.filter(string, function(v) {\n     *     return /[aeiou]/i.test(v);\n     *   });\n     * }\n     *\n     * _.mixin({ 'vowels': vowels });\n     * _.vowels('fred');\n     * // => ['e']\n     *\n     * _('fred').vowels().value();\n     * // => ['e']\n     *\n     * _.mixin({ 'vowels': vowels }, { 'chain': false });\n     * _('fred').vowels();\n     * // => ['e']\n     */\n    function mixin(object, source, options) {\n      var props = keys(source),\n          methodNames = baseFunctions(source, props);\n\n      if (options == null &&\n          !(isObject(source) && (methodNames.length || !props.length))) {\n        options = source;\n        source = object;\n        object = this;\n        methodNames = baseFunctions(source, keys(source));\n      }\n      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,\n          isFunc = isFunction(object);\n\n      arrayEach(methodNames, function(methodName) {\n        var func = source[methodName];\n        object[methodName] = func;\n        if (isFunc) {\n          object.prototype[methodName] = function() {\n            var chainAll = this.__chain__;\n            if (chain || chainAll) {\n              var result = object(this.__wrapped__),\n                  actions = result.__actions__ = copyArray(this.__actions__);\n\n              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });\n              result.__chain__ = chainAll;\n              return result;\n            }\n            return func.apply(object, arrayPush([this.value()], arguments));\n          };\n        }\n      });\n\n      return object;\n    }\n\n    /**\n     * Reverts the `_` variable to its previous value and returns a reference to\n     * the `lodash` function.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @returns {Function} Returns the `lodash` function.\n     * @example\n     *\n     * var lodash = _.noConflict();\n     */\n    function noConflict() {\n      if (root._ === this) {\n        root._ = oldDash;\n      }\n      return this;\n    }\n\n    /**\n     * This method returns `undefined`.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.3.0\n     * @category Util\n     * @example\n     *\n     * _.times(2, _.noop);\n     * // => [undefined, undefined]\n     */\n    function noop() {\n      // No operation performed.\n    }\n\n    /**\n     * Creates a function that gets the argument at index `n`. If `n` is negative,\n     * the nth argument from the end is returned.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [n=0] The index of the argument to return.\n     * @returns {Function} Returns the new pass-thru function.\n     * @example\n     *\n     * var func = _.nthArg(1);\n     * func('a', 'b', 'c', 'd');\n     * // => 'b'\n     *\n     * var func = _.nthArg(-2);\n     * func('a', 'b', 'c', 'd');\n     * // => 'c'\n     */\n    function nthArg(n) {\n      n = toInteger(n);\n      return baseRest(function(args) {\n        return baseNth(args, n);\n      });\n    }\n\n    /**\n     * Creates a function that invokes `iteratees` with the arguments it receives\n     * and returns their results.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [iteratees=[_.identity]]\n     *  The iteratees to invoke.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.over([Math.max, Math.min]);\n     *\n     * func(1, 2, 3, 4);\n     * // => [4, 1]\n     */\n    var over = createOver(arrayMap);\n\n    /**\n     * Creates a function that checks if **all** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overEvery([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => false\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overEvery = createOver(arrayEvery);\n\n    /**\n     * Creates a function that checks if **any** of the `predicates` return\n     * truthy when invoked with the arguments it receives.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {...(Function|Function[])} [predicates=[_.identity]]\n     *  The predicates to check.\n     * @returns {Function} Returns the new function.\n     * @example\n     *\n     * var func = _.overSome([Boolean, isFinite]);\n     *\n     * func('1');\n     * // => true\n     *\n     * func(null);\n     * // => true\n     *\n     * func(NaN);\n     * // => false\n     */\n    var overSome = createOver(arraySome);\n\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    /**\n     * The opposite of `_.property`; this method creates a function that returns\n     * the value at a given path of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Util\n     * @param {Object} object The object to query.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var array = [0, 1, 2],\n     *     object = { 'a': array, 'b': array, 'c': array };\n     *\n     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));\n     * // => [2, 0]\n     *\n     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));\n     * // => [2, 0]\n     */\n    function propertyOf(object) {\n      return function(path) {\n        return object == null ? undefined : baseGet(object, path);\n      };\n    }\n\n    /**\n     * Creates an array of numbers (positive and/or negative) progressing from\n     * `start` up to, but not including, `end`. A step of `-1` is used if a negative\n     * `start` is specified without an `end` or `step`. If `end` is not specified,\n     * it's set to `start` with `start` then set to `0`.\n     *\n     * **Note:** JavaScript follows the IEEE-754 standard for resolving\n     * floating-point values which can produce unexpected results.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.rangeRight\n     * @example\n     *\n     * _.range(4);\n     * // => [0, 1, 2, 3]\n     *\n     * _.range(-4);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 5);\n     * // => [1, 2, 3, 4]\n     *\n     * _.range(0, 20, 5);\n     * // => [0, 5, 10, 15]\n     *\n     * _.range(0, -4, -1);\n     * // => [0, -1, -2, -3]\n     *\n     * _.range(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.range(0);\n     * // => []\n     */\n    var range = createRange();\n\n    /**\n     * This method is like `_.range` except that it populates values in\n     * descending order.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {number} [start=0] The start of the range.\n     * @param {number} end The end of the range.\n     * @param {number} [step=1] The value to increment or decrement by.\n     * @returns {Array} Returns the range of numbers.\n     * @see _.inRange, _.range\n     * @example\n     *\n     * _.rangeRight(4);\n     * // => [3, 2, 1, 0]\n     *\n     * _.rangeRight(-4);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 5);\n     * // => [4, 3, 2, 1]\n     *\n     * _.rangeRight(0, 20, 5);\n     * // => [15, 10, 5, 0]\n     *\n     * _.rangeRight(0, -4, -1);\n     * // => [-3, -2, -1, 0]\n     *\n     * _.rangeRight(1, 4, 0);\n     * // => [1, 1, 1]\n     *\n     * _.rangeRight(0);\n     * // => []\n     */\n    var rangeRight = createRange(true);\n\n    /**\n     * This method returns a new empty array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Array} Returns the new empty array.\n     * @example\n     *\n     * var arrays = _.times(2, _.stubArray);\n     *\n     * console.log(arrays);\n     * // => [[], []]\n     *\n     * console.log(arrays[0] === arrays[1]);\n     * // => false\n     */\n    function stubArray() {\n      return [];\n    }\n\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n    function stubFalse() {\n      return false;\n    }\n\n    /**\n     * This method returns a new empty object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {Object} Returns the new empty object.\n     * @example\n     *\n     * var objects = _.times(2, _.stubObject);\n     *\n     * console.log(objects);\n     * // => [{}, {}]\n     *\n     * console.log(objects[0] === objects[1]);\n     * // => false\n     */\n    function stubObject() {\n      return {};\n    }\n\n    /**\n     * This method returns an empty string.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {string} Returns the empty string.\n     * @example\n     *\n     * _.times(2, _.stubString);\n     * // => ['', '']\n     */\n    function stubString() {\n      return '';\n    }\n\n    /**\n     * This method returns `true`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `true`.\n     * @example\n     *\n     * _.times(2, _.stubTrue);\n     * // => [true, true]\n     */\n    function stubTrue() {\n      return true;\n    }\n\n    /**\n     * Invokes the iteratee `n` times, returning an array of the results of\n     * each invocation. The iteratee is invoked with one argument; (index).\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     * @example\n     *\n     * _.times(3, String);\n     * // => ['0', '1', '2']\n     *\n     *  _.times(4, _.constant(0));\n     * // => [0, 0, 0, 0]\n     */\n    function times(n, iteratee) {\n      n = toInteger(n);\n      if (n < 1 || n > MAX_SAFE_INTEGER) {\n        return [];\n      }\n      var index = MAX_ARRAY_LENGTH,\n          length = nativeMin(n, MAX_ARRAY_LENGTH);\n\n      iteratee = getIteratee(iteratee);\n      n -= MAX_ARRAY_LENGTH;\n\n      var result = baseTimes(length, iteratee);\n      while (++index < n) {\n        iteratee(index);\n      }\n      return result;\n    }\n\n    /**\n     * Converts `value` to a property path array.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Util\n     * @param {*} value The value to convert.\n     * @returns {Array} Returns the new property path array.\n     * @example\n     *\n     * _.toPath('a.b.c');\n     * // => ['a', 'b', 'c']\n     *\n     * _.toPath('a[0].b.c');\n     * // => ['a', '0', 'b', 'c']\n     */\n    function toPath(value) {\n      if (isArray(value)) {\n        return arrayMap(value, toKey);\n      }\n      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));\n    }\n\n    /**\n     * Generates a unique ID. If `prefix` is given, the ID is appended to it.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {string} [prefix=''] The value to prefix the ID with.\n     * @returns {string} Returns the unique ID.\n     * @example\n     *\n     * _.uniqueId('contact_');\n     * // => 'contact_104'\n     *\n     * _.uniqueId();\n     * // => '105'\n     */\n    function uniqueId(prefix) {\n      var id = ++idCounter;\n      return toString(prefix) + id;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * Adds two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {number} augend The first number in an addition.\n     * @param {number} addend The second number in an addition.\n     * @returns {number} Returns the total.\n     * @example\n     *\n     * _.add(6, 4);\n     * // => 10\n     */\n    var add = createMathOperation(function(augend, addend) {\n      return augend + addend;\n    }, 0);\n\n    /**\n     * Computes `number` rounded up to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round up.\n     * @param {number} [precision=0] The precision to round up to.\n     * @returns {number} Returns the rounded up number.\n     * @example\n     *\n     * _.ceil(4.006);\n     * // => 5\n     *\n     * _.ceil(6.004, 2);\n     * // => 6.01\n     *\n     * _.ceil(6040, -2);\n     * // => 6100\n     */\n    var ceil = createRound('ceil');\n\n    /**\n     * Divide two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} dividend The first number in a division.\n     * @param {number} divisor The second number in a division.\n     * @returns {number} Returns the quotient.\n     * @example\n     *\n     * _.divide(6, 4);\n     * // => 1.5\n     */\n    var divide = createMathOperation(function(dividend, divisor) {\n      return dividend / divisor;\n    }, 1);\n\n    /**\n     * Computes `number` rounded down to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round down.\n     * @param {number} [precision=0] The precision to round down to.\n     * @returns {number} Returns the rounded down number.\n     * @example\n     *\n     * _.floor(4.006);\n     * // => 4\n     *\n     * _.floor(0.046, 2);\n     * // => 0.04\n     *\n     * _.floor(4060, -2);\n     * // => 4000\n     */\n    var floor = createRound('floor');\n\n    /**\n     * Computes the maximum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * _.max([4, 2, 8, 6]);\n     * // => 8\n     *\n     * _.max([]);\n     * // => undefined\n     */\n    function max(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseGt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.max` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the maximum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.maxBy(objects, function(o) { return o.n; });\n     * // => { 'n': 2 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.maxBy(objects, 'n');\n     * // => { 'n': 2 }\n     */\n    function maxBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)\n        : undefined;\n    }\n\n    /**\n     * Computes the mean of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * _.mean([4, 2, 8, 6]);\n     * // => 5\n     */\n    function mean(array) {\n      return baseMean(array, identity);\n    }\n\n    /**\n     * This method is like `_.mean` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be averaged.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the mean.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.meanBy(objects, function(o) { return o.n; });\n     * // => 5\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.meanBy(objects, 'n');\n     * // => 5\n     */\n    function meanBy(array, iteratee) {\n      return baseMean(array, getIteratee(iteratee, 2));\n    }\n\n    /**\n     * Computes the minimum value of `array`. If `array` is empty or falsey,\n     * `undefined` is returned.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * _.min([4, 2, 8, 6]);\n     * // => 2\n     *\n     * _.min([]);\n     * // => undefined\n     */\n    function min(array) {\n      return (array && array.length)\n        ? baseExtremum(array, identity, baseLt)\n        : undefined;\n    }\n\n    /**\n     * This method is like `_.min` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the criterion by which\n     * the value is ranked. The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {*} Returns the minimum value.\n     * @example\n     *\n     * var objects = [{ 'n': 1 }, { 'n': 2 }];\n     *\n     * _.minBy(objects, function(o) { return o.n; });\n     * // => { 'n': 1 }\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.minBy(objects, 'n');\n     * // => { 'n': 1 }\n     */\n    function minBy(array, iteratee) {\n      return (array && array.length)\n        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)\n        : undefined;\n    }\n\n    /**\n     * Multiply two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.7.0\n     * @category Math\n     * @param {number} multiplier The first number in a multiplication.\n     * @param {number} multiplicand The second number in a multiplication.\n     * @returns {number} Returns the product.\n     * @example\n     *\n     * _.multiply(6, 4);\n     * // => 24\n     */\n    var multiply = createMathOperation(function(multiplier, multiplicand) {\n      return multiplier * multiplicand;\n    }, 1);\n\n    /**\n     * Computes `number` rounded to `precision`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.10.0\n     * @category Math\n     * @param {number} number The number to round.\n     * @param {number} [precision=0] The precision to round to.\n     * @returns {number} Returns the rounded number.\n     * @example\n     *\n     * _.round(4.006);\n     * // => 4\n     *\n     * _.round(4.006, 2);\n     * // => 4.01\n     *\n     * _.round(4060, -2);\n     * // => 4100\n     */\n    var round = createRound('round');\n\n    /**\n     * Subtract two numbers.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {number} minuend The first number in a subtraction.\n     * @param {number} subtrahend The second number in a subtraction.\n     * @returns {number} Returns the difference.\n     * @example\n     *\n     * _.subtract(6, 4);\n     * // => 2\n     */\n    var subtract = createMathOperation(function(minuend, subtrahend) {\n      return minuend - subtrahend;\n    }, 0);\n\n    /**\n     * Computes the sum of the values in `array`.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.4.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * _.sum([4, 2, 8, 6]);\n     * // => 20\n     */\n    function sum(array) {\n      return (array && array.length)\n        ? baseSum(array, identity)\n        : 0;\n    }\n\n    /**\n     * This method is like `_.sum` except that it accepts `iteratee` which is\n     * invoked for each element in `array` to generate the value to be summed.\n     * The iteratee is invoked with one argument: (value).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Math\n     * @param {Array} array The array to iterate over.\n     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\n     * @returns {number} Returns the sum.\n     * @example\n     *\n     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];\n     *\n     * _.sumBy(objects, function(o) { return o.n; });\n     * // => 20\n     *\n     * // The `_.property` iteratee shorthand.\n     * _.sumBy(objects, 'n');\n     * // => 20\n     */\n    function sumBy(array, iteratee) {\n      return (array && array.length)\n        ? baseSum(array, getIteratee(iteratee, 2))\n        : 0;\n    }\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return wrapped values in chain sequences.\n    lodash.after = after;\n    lodash.ary = ary;\n    lodash.assign = assign;\n    lodash.assignIn = assignIn;\n    lodash.assignInWith = assignInWith;\n    lodash.assignWith = assignWith;\n    lodash.at = at;\n    lodash.before = before;\n    lodash.bind = bind;\n    lodash.bindAll = bindAll;\n    lodash.bindKey = bindKey;\n    lodash.castArray = castArray;\n    lodash.chain = chain;\n    lodash.chunk = chunk;\n    lodash.compact = compact;\n    lodash.concat = concat;\n    lodash.cond = cond;\n    lodash.conforms = conforms;\n    lodash.constant = constant;\n    lodash.countBy = countBy;\n    lodash.create = create;\n    lodash.curry = curry;\n    lodash.curryRight = curryRight;\n    lodash.debounce = debounce;\n    lodash.defaults = defaults;\n    lodash.defaultsDeep = defaultsDeep;\n    lodash.defer = defer;\n    lodash.delay = delay;\n    lodash.difference = difference;\n    lodash.differenceBy = differenceBy;\n    lodash.differenceWith = differenceWith;\n    lodash.drop = drop;\n    lodash.dropRight = dropRight;\n    lodash.dropRightWhile = dropRightWhile;\n    lodash.dropWhile = dropWhile;\n    lodash.fill = fill;\n    lodash.filter = filter;\n    lodash.flatMap = flatMap;\n    lodash.flatMapDeep = flatMapDeep;\n    lodash.flatMapDepth = flatMapDepth;\n    lodash.flatten = flatten;\n    lodash.flattenDeep = flattenDeep;\n    lodash.flattenDepth = flattenDepth;\n    lodash.flip = flip;\n    lodash.flow = flow;\n    lodash.flowRight = flowRight;\n    lodash.fromPairs = fromPairs;\n    lodash.functions = functions;\n    lodash.functionsIn = functionsIn;\n    lodash.groupBy = groupBy;\n    lodash.initial = initial;\n    lodash.intersection = intersection;\n    lodash.intersectionBy = intersectionBy;\n    lodash.intersectionWith = intersectionWith;\n    lodash.invert = invert;\n    lodash.invertBy = invertBy;\n    lodash.invokeMap = invokeMap;\n    lodash.iteratee = iteratee;\n    lodash.keyBy = keyBy;\n    lodash.keys = keys;\n    lodash.keysIn = keysIn;\n    lodash.map = map;\n    lodash.mapKeys = mapKeys;\n    lodash.mapValues = mapValues;\n    lodash.matches = matches;\n    lodash.matchesProperty = matchesProperty;\n    lodash.memoize = memoize;\n    lodash.merge = merge;\n    lodash.mergeWith = mergeWith;\n    lodash.method = method;\n    lodash.methodOf = methodOf;\n    lodash.mixin = mixin;\n    lodash.negate = negate;\n    lodash.nthArg = nthArg;\n    lodash.omit = omit;\n    lodash.omitBy = omitBy;\n    lodash.once = once;\n    lodash.orderBy = orderBy;\n    lodash.over = over;\n    lodash.overArgs = overArgs;\n    lodash.overEvery = overEvery;\n    lodash.overSome = overSome;\n    lodash.partial = partial;\n    lodash.partialRight = partialRight;\n    lodash.partition = partition;\n    lodash.pick = pick;\n    lodash.pickBy = pickBy;\n    lodash.property = property;\n    lodash.propertyOf = propertyOf;\n    lodash.pull = pull;\n    lodash.pullAll = pullAll;\n    lodash.pullAllBy = pullAllBy;\n    lodash.pullAllWith = pullAllWith;\n    lodash.pullAt = pullAt;\n    lodash.range = range;\n    lodash.rangeRight = rangeRight;\n    lodash.rearg = rearg;\n    lodash.reject = reject;\n    lodash.remove = remove;\n    lodash.rest = rest;\n    lodash.reverse = reverse;\n    lodash.sampleSize = sampleSize;\n    lodash.set = set;\n    lodash.setWith = setWith;\n    lodash.shuffle = shuffle;\n    lodash.slice = slice;\n    lodash.sortBy = sortBy;\n    lodash.sortedUniq = sortedUniq;\n    lodash.sortedUniqBy = sortedUniqBy;\n    lodash.split = split;\n    lodash.spread = spread;\n    lodash.tail = tail;\n    lodash.take = take;\n    lodash.takeRight = takeRight;\n    lodash.takeRightWhile = takeRightWhile;\n    lodash.takeWhile = takeWhile;\n    lodash.tap = tap;\n    lodash.throttle = throttle;\n    lodash.thru = thru;\n    lodash.toArray = toArray;\n    lodash.toPairs = toPairs;\n    lodash.toPairsIn = toPairsIn;\n    lodash.toPath = toPath;\n    lodash.toPlainObject = toPlainObject;\n    lodash.transform = transform;\n    lodash.unary = unary;\n    lodash.union = union;\n    lodash.unionBy = unionBy;\n    lodash.unionWith = unionWith;\n    lodash.uniq = uniq;\n    lodash.uniqBy = uniqBy;\n    lodash.uniqWith = uniqWith;\n    lodash.unset = unset;\n    lodash.unzip = unzip;\n    lodash.unzipWith = unzipWith;\n    lodash.update = update;\n    lodash.updateWith = updateWith;\n    lodash.values = values;\n    lodash.valuesIn = valuesIn;\n    lodash.without = without;\n    lodash.words = words;\n    lodash.wrap = wrap;\n    lodash.xor = xor;\n    lodash.xorBy = xorBy;\n    lodash.xorWith = xorWith;\n    lodash.zip = zip;\n    lodash.zipObject = zipObject;\n    lodash.zipObjectDeep = zipObjectDeep;\n    lodash.zipWith = zipWith;\n\n    // Add aliases.\n    lodash.entries = toPairs;\n    lodash.entriesIn = toPairsIn;\n    lodash.extend = assignIn;\n    lodash.extendWith = assignInWith;\n\n    // Add methods to `lodash.prototype`.\n    mixin(lodash, lodash);\n\n    /*------------------------------------------------------------------------*/\n\n    // Add methods that return unwrapped values in chain sequences.\n    lodash.add = add;\n    lodash.attempt = attempt;\n    lodash.camelCase = camelCase;\n    lodash.capitalize = capitalize;\n    lodash.ceil = ceil;\n    lodash.clamp = clamp;\n    lodash.clone = clone;\n    lodash.cloneDeep = cloneDeep;\n    lodash.cloneDeepWith = cloneDeepWith;\n    lodash.cloneWith = cloneWith;\n    lodash.conformsTo = conformsTo;\n    lodash.deburr = deburr;\n    lodash.defaultTo = defaultTo;\n    lodash.divide = divide;\n    lodash.endsWith = endsWith;\n    lodash.eq = eq;\n    lodash.escape = escape;\n    lodash.escapeRegExp = escapeRegExp;\n    lodash.every = every;\n    lodash.find = find;\n    lodash.findIndex = findIndex;\n    lodash.findKey = findKey;\n    lodash.findLast = findLast;\n    lodash.findLastIndex = findLastIndex;\n    lodash.findLastKey = findLastKey;\n    lodash.floor = floor;\n    lodash.forEach = forEach;\n    lodash.forEachRight = forEachRight;\n    lodash.forIn = forIn;\n    lodash.forInRight = forInRight;\n    lodash.forOwn = forOwn;\n    lodash.forOwnRight = forOwnRight;\n    lodash.get = get;\n    lodash.gt = gt;\n    lodash.gte = gte;\n    lodash.has = has;\n    lodash.hasIn = hasIn;\n    lodash.head = head;\n    lodash.identity = identity;\n    lodash.includes = includes;\n    lodash.indexOf = indexOf;\n    lodash.inRange = inRange;\n    lodash.invoke = invoke;\n    lodash.isArguments = isArguments;\n    lodash.isArray = isArray;\n    lodash.isArrayBuffer = isArrayBuffer;\n    lodash.isArrayLike = isArrayLike;\n    lodash.isArrayLikeObject = isArrayLikeObject;\n    lodash.isBoolean = isBoolean;\n    lodash.isBuffer = isBuffer;\n    lodash.isDate = isDate;\n    lodash.isElement = isElement;\n    lodash.isEmpty = isEmpty;\n    lodash.isEqual = isEqual;\n    lodash.isEqualWith = isEqualWith;\n    lodash.isError = isError;\n    lodash.isFinite = isFinite;\n    lodash.isFunction = isFunction;\n    lodash.isInteger = isInteger;\n    lodash.isLength = isLength;\n    lodash.isMap = isMap;\n    lodash.isMatch = isMatch;\n    lodash.isMatchWith = isMatchWith;\n    lodash.isNaN = isNaN;\n    lodash.isNative = isNative;\n    lodash.isNil = isNil;\n    lodash.isNull = isNull;\n    lodash.isNumber = isNumber;\n    lodash.isObject = isObject;\n    lodash.isObjectLike = isObjectLike;\n    lodash.isPlainObject = isPlainObject;\n    lodash.isRegExp = isRegExp;\n    lodash.isSafeInteger = isSafeInteger;\n    lodash.isSet = isSet;\n    lodash.isString = isString;\n    lodash.isSymbol = isSymbol;\n    lodash.isTypedArray = isTypedArray;\n    lodash.isUndefined = isUndefined;\n    lodash.isWeakMap = isWeakMap;\n    lodash.isWeakSet = isWeakSet;\n    lodash.join = join;\n    lodash.kebabCase = kebabCase;\n    lodash.last = last;\n    lodash.lastIndexOf = lastIndexOf;\n    lodash.lowerCase = lowerCase;\n    lodash.lowerFirst = lowerFirst;\n    lodash.lt = lt;\n    lodash.lte = lte;\n    lodash.max = max;\n    lodash.maxBy = maxBy;\n    lodash.mean = mean;\n    lodash.meanBy = meanBy;\n    lodash.min = min;\n    lodash.minBy = minBy;\n    lodash.stubArray = stubArray;\n    lodash.stubFalse = stubFalse;\n    lodash.stubObject = stubObject;\n    lodash.stubString = stubString;\n    lodash.stubTrue = stubTrue;\n    lodash.multiply = multiply;\n    lodash.nth = nth;\n    lodash.noConflict = noConflict;\n    lodash.noop = noop;\n    lodash.now = now;\n    lodash.pad = pad;\n    lodash.padEnd = padEnd;\n    lodash.padStart = padStart;\n    lodash.parseInt = parseInt;\n    lodash.random = random;\n    lodash.reduce = reduce;\n    lodash.reduceRight = reduceRight;\n    lodash.repeat = repeat;\n    lodash.replace = replace;\n    lodash.result = result;\n    lodash.round = round;\n    lodash.runInContext = runInContext;\n    lodash.sample = sample;\n    lodash.size = size;\n    lodash.snakeCase = snakeCase;\n    lodash.some = some;\n    lodash.sortedIndex = sortedIndex;\n    lodash.sortedIndexBy = sortedIndexBy;\n    lodash.sortedIndexOf = sortedIndexOf;\n    lodash.sortedLastIndex = sortedLastIndex;\n    lodash.sortedLastIndexBy = sortedLastIndexBy;\n    lodash.sortedLastIndexOf = sortedLastIndexOf;\n    lodash.startCase = startCase;\n    lodash.startsWith = startsWith;\n    lodash.subtract = subtract;\n    lodash.sum = sum;\n    lodash.sumBy = sumBy;\n    lodash.template = template;\n    lodash.times = times;\n    lodash.toFinite = toFinite;\n    lodash.toInteger = toInteger;\n    lodash.toLength = toLength;\n    lodash.toLower = toLower;\n    lodash.toNumber = toNumber;\n    lodash.toSafeInteger = toSafeInteger;\n    lodash.toString = toString;\n    lodash.toUpper = toUpper;\n    lodash.trim = trim;\n    lodash.trimEnd = trimEnd;\n    lodash.trimStart = trimStart;\n    lodash.truncate = truncate;\n    lodash.unescape = unescape;\n    lodash.uniqueId = uniqueId;\n    lodash.upperCase = upperCase;\n    lodash.upperFirst = upperFirst;\n\n    // Add aliases.\n    lodash.each = forEach;\n    lodash.eachRight = forEachRight;\n    lodash.first = head;\n\n    mixin(lodash, (function() {\n      var source = {};\n      baseForOwn(lodash, function(func, methodName) {\n        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n          source[methodName] = func;\n        }\n      });\n      return source;\n    }()), { 'chain': false });\n\n    /*------------------------------------------------------------------------*/\n\n    /**\n     * The semantic version number.\n     *\n     * @static\n     * @memberOf _\n     * @type {string}\n     */\n    lodash.VERSION = VERSION;\n\n    // Assign default placeholders.\n    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {\n      lodash[methodName].placeholder = lodash;\n    });\n\n    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.\n    arrayEach(['drop', 'take'], function(methodName, index) {\n      LazyWrapper.prototype[methodName] = function(n) {\n        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);\n\n        var result = (this.__filtered__ && !index)\n          ? new LazyWrapper(this)\n          : this.clone();\n\n        if (result.__filtered__) {\n          result.__takeCount__ = nativeMin(n, result.__takeCount__);\n        } else {\n          result.__views__.push({\n            'size': nativeMin(n, MAX_ARRAY_LENGTH),\n            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')\n          });\n        }\n        return result;\n      };\n\n      LazyWrapper.prototype[methodName + 'Right'] = function(n) {\n        return this.reverse()[methodName](n).reverse();\n      };\n    });\n\n    // Add `LazyWrapper` methods that accept an `iteratee` value.\n    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {\n      var type = index + 1,\n          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n\n      LazyWrapper.prototype[methodName] = function(iteratee) {\n        var result = this.clone();\n        result.__iteratees__.push({\n          'iteratee': getIteratee(iteratee, 3),\n          'type': type\n        });\n        result.__filtered__ = result.__filtered__ || isFilter;\n        return result;\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.head` and `_.last`.\n    arrayEach(['head', 'last'], function(methodName, index) {\n      var takeName = 'take' + (index ? 'Right' : '');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this[takeName](1).value()[0];\n      };\n    });\n\n    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.\n    arrayEach(['initial', 'tail'], function(methodName, index) {\n      var dropName = 'drop' + (index ? '' : 'Right');\n\n      LazyWrapper.prototype[methodName] = function() {\n        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n      };\n    });\n\n    LazyWrapper.prototype.compact = function() {\n      return this.filter(identity);\n    };\n\n    LazyWrapper.prototype.find = function(predicate) {\n      return this.filter(predicate).head();\n    };\n\n    LazyWrapper.prototype.findLast = function(predicate) {\n      return this.reverse().find(predicate);\n    };\n\n    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n      if (typeof path == 'function') {\n        return new LazyWrapper(this);\n      }\n      return this.map(function(value) {\n        return baseInvoke(value, path, args);\n      });\n    });\n\n    LazyWrapper.prototype.reject = function(predicate) {\n      return this.filter(negate(getIteratee(predicate)));\n    };\n\n    LazyWrapper.prototype.slice = function(start, end) {\n      start = toInteger(start);\n\n      var result = this;\n      if (result.__filtered__ && (start > 0 || end < 0)) {\n        return new LazyWrapper(result);\n      }\n      if (start < 0) {\n        result = result.takeRight(-start);\n      } else if (start) {\n        result = result.drop(start);\n      }\n      if (end !== undefined) {\n        end = toInteger(end);\n        result = end < 0 ? result.dropRight(-end) : result.take(end - start);\n      }\n      return result;\n    };\n\n    LazyWrapper.prototype.takeRightWhile = function(predicate) {\n      return this.reverse().takeWhile(predicate).reverse();\n    };\n\n    LazyWrapper.prototype.toArray = function() {\n      return this.take(MAX_ARRAY_LENGTH);\n    };\n\n    // Add `LazyWrapper` methods to `lodash.prototype`.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),\n          isTaker = /^(?:head|last)$/.test(methodName),\n          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],\n          retUnwrapped = isTaker || /^find/.test(methodName);\n\n      if (!lodashFunc) {\n        return;\n      }\n      lodash.prototype[methodName] = function() {\n        var value = this.__wrapped__,\n            args = isTaker ? [1] : arguments,\n            isLazy = value instanceof LazyWrapper,\n            iteratee = args[0],\n            useLazy = isLazy || isArray(value);\n\n        var interceptor = function(value) {\n          var result = lodashFunc.apply(lodash, arrayPush([value], args));\n          return (isTaker && chainAll) ? result[0] : result;\n        };\n\n        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {\n          // Avoid lazy use if the iteratee has a \"length\" value other than `1`.\n          isLazy = useLazy = false;\n        }\n        var chainAll = this.__chain__,\n            isHybrid = !!this.__actions__.length,\n            isUnwrapped = retUnwrapped && !chainAll,\n            onlyLazy = isLazy && !isHybrid;\n\n        if (!retUnwrapped && useLazy) {\n          value = onlyLazy ? value : new LazyWrapper(this);\n          var result = func.apply(value, args);\n          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });\n          return new LodashWrapper(result, chainAll);\n        }\n        if (isUnwrapped && onlyLazy) {\n          return func.apply(this, args);\n        }\n        result = this.thru(interceptor);\n        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;\n      };\n    });\n\n    // Add `Array` methods to `lodash.prototype`.\n    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {\n      var func = arrayProto[methodName],\n          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',\n          retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n\n      lodash.prototype[methodName] = function() {\n        var args = arguments;\n        if (retUnwrapped && !this.__chain__) {\n          var value = this.value();\n          return func.apply(isArray(value) ? value : [], args);\n        }\n        return this[chainName](function(value) {\n          return func.apply(isArray(value) ? value : [], args);\n        });\n      };\n    });\n\n    // Map minified method names to their real names.\n    baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n      var lodashFunc = lodash[methodName];\n      if (lodashFunc) {\n        var key = lodashFunc.name + '';\n        if (!hasOwnProperty.call(realNames, key)) {\n          realNames[key] = [];\n        }\n        realNames[key].push({ 'name': methodName, 'func': lodashFunc });\n      }\n    });\n\n    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{\n      'name': 'wrapper',\n      'func': undefined\n    }];\n\n    // Add methods to `LazyWrapper`.\n    LazyWrapper.prototype.clone = lazyClone;\n    LazyWrapper.prototype.reverse = lazyReverse;\n    LazyWrapper.prototype.value = lazyValue;\n\n    // Add chain sequence methods to the `lodash` wrapper.\n    lodash.prototype.at = wrapperAt;\n    lodash.prototype.chain = wrapperChain;\n    lodash.prototype.commit = wrapperCommit;\n    lodash.prototype.next = wrapperNext;\n    lodash.prototype.plant = wrapperPlant;\n    lodash.prototype.reverse = wrapperReverse;\n    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n\n    // Add lazy aliases.\n    lodash.prototype.first = lodash.prototype.head;\n\n    if (symIterator) {\n      lodash.prototype[symIterator] = wrapperToIterator;\n    }\n    return lodash;\n  });\n\n  /*--------------------------------------------------------------------------*/\n\n  // Export lodash.\n  var _ = runInContext();\n\n  // Some AMD build optimizers, like r.js, check for condition patterns like:\n  if (true) {\n    // Expose Lodash on the global object to prevent errors when Lodash is\n    // loaded by a script tag in the presence of an AMD loader.\n    // See http://requirejs.org/docs/errors.html#mismatch for more details.\n    // Use `_.noConflict` to remove Lodash from the global object.\n    root._ = _;\n\n    // Define as an anonymous module so, through path mapping, it can be\n    // referenced as the \"underscore\" module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return _;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n  // Check for `exports` after `define` in case a build optimizer adds it.\n  else {}\n}.call(this));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../webpack/buildin/module.js */ \"../node_modules/webpack/buildin/module.js\")(module)))\n\n//# sourceURL=webpack://STK/../node_modules/lodash/lodash.js?");

/***/ }),

/***/ "../node_modules/lucene-query-parser/lib/lucene-query-parser.js":
/*!**********************************************************************!*\
  !*** ../node_modules/lucene-query-parser/lib/lucene-query-parser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { start: peg$parsestart },\n        peg$startRuleFunction  = peg$parsestart,\n\n        peg$c0 = function(node) {\n                return node[0];\n            },\n        peg$c1 = function() {\n                return {};\n            },\n        peg$c2 = function(operator) {\n                return {\n                    'operator': operator\n                    };\n            },\n        peg$c3 = function(operator, right) {\n                return right;\n            },\n        peg$c4 = function(left, operator, right) {\n                var node= {\n                    'left':left\n                    };\n\n                var right =\n                        right.length == 0\n                        ? null\n                        : right[0]['right'] == null\n                            ? right[0]['left']\n                            : right[0];\n\n                if (right != null)\n                {\n                    node['operator'] = operator=='' || operator==undefined ? '<implicit>' : operator[0];\n                    node['right'] = right;\n                }\n\n                return node;\n            },\n        peg$c5 = function(field_exp) {\n                return field_exp;\n            },\n        peg$c6 = \"(\",\n        peg$c7 = peg$literalExpectation(\"(\", false),\n        peg$c8 = \")\",\n        peg$c9 = peg$literalExpectation(\")\", false),\n        peg$c10 = function(fieldname, range) {\n                range['field'] =\n                    fieldname == '' || fieldname == undefined\n                        ? \"<implicit>\"\n                        : fieldname;\n\n                return range;\n            },\n        peg$c11 = function(fieldname, node) {\n                node['field']= fieldname;\n                return node;\n            },\n        peg$c12 = function(fieldname, term) {\n                var fieldexp = {\n                    'field':\n                        fieldname == '' || fieldname == undefined\n                            ? \"<implicit>\"\n                            : fieldname\n                    };\n\n                for(var key in term)\n                    fieldexp[key] = term[key];\n\n                return fieldexp;\n            },\n        peg$c13 = /^[:]/,\n        peg$c14 = peg$classExpectation([\":\"], false, false),\n        peg$c15 = function(fieldname) {\n                return fieldname;\n            },\n        peg$c16 = function(op, term, proximity, boost) {\n                var result = { 'term': term };\n\n                if('' != proximity)\n                {\n                    result['proximity'] = proximity;\n                }\n                if('' != boost)\n                {\n                    result['boost'] = boost;\n                }\n                if('' != op)\n                {\n                    result['prefix'] = op;\n                }\n\n                return result;\n            },\n        peg$c17 = function(op, term, similarity, boost) {\n                var result = { 'term': term };\n                if('' != similarity)\n                {\n                    result['similarity'] = similarity;\n                }\n                if('' != boost)\n                {\n                    result['boost'] = boost;\n                }\n                if('' != op)\n                {\n                    result['prefix'] = op;\n                }\n                return result;\n            },\n        peg$c18 = function(op, term, boost) {\n                  var result = { 'term': term, 'regexpr': true };\n                  if('' != boost)\n                  {\n                      result['boost'] = boost;\n                  }\n                  if('' != op)\n                  {\n                      result['prefix'] = op;\n                  }\n                  return result;\n              },\n        peg$c19 = function(term_start, term) {\n                var res = term_start + term.join('');\n                if (/^(?:AND|OR|NOT|\\|\\||&&)$/.test(res)) {\n                  var e = new Error('Term can not be AND, OR, NOT, ||, &&')\n                  e.name = 'SyntaxError'\n                  e.column = location\n                  throw e\n                }\n                return res\n            },\n        peg$c20 = \".\",\n        peg$c21 = peg$literalExpectation(\".\", false),\n        peg$c22 = /^[^: \\t\\r\\n\\f{}()\"+-\\/\\^~[\\]]/,\n        peg$c23 = peg$classExpectation([\":\", \" \", \"\\t\", \"\\r\", \"\\n\", \"\\f\", \"{\", \"}\", \"(\", \")\", \"\\\"\", [\"+\", \"/\"], \"^\", \"~\", \"[\", \"]\"], true, false),\n        peg$c24 = \"\\\\\",\n        peg$c25 = peg$literalExpectation(\"\\\\\", false),\n        peg$c26 = /^[: \\t\\r\\n\\f{}()\"\\/\\^~[\\]]/,\n        peg$c27 = peg$classExpectation([\":\", \" \", \"\\t\", \"\\r\", \"\\n\", \"\\f\", \"{\", \"}\", \"(\", \")\", \"\\\"\", \"/\", \"^\", \"~\", \"[\", \"]\"], false, false),\n        peg$c28 = function(escaping_char) {\n                return '\\\\' + escaping_char;\n            },\n        peg$c29 = \"+\",\n        peg$c30 = peg$literalExpectation(\"+\", false),\n        peg$c31 = \"-\",\n        peg$c32 = peg$literalExpectation(\"-\", false),\n        peg$c33 = \"/\",\n        peg$c34 = peg$literalExpectation(\"/\", false),\n        peg$c35 = function(term) {\n                return term.join('').replace('\\\\/', '/');\n            },\n        peg$c36 = \"\\\\/\",\n        peg$c37 = peg$literalExpectation(\"\\\\/\", false),\n        peg$c38 = /^[^\\/]/,\n        peg$c39 = peg$classExpectation([\"/\"], true, false),\n        peg$c40 = \"\\\"\",\n        peg$c41 = peg$literalExpectation(\"\\\"\", false),\n        peg$c42 = /^[^\"]/,\n        peg$c43 = peg$classExpectation([\"\\\"\"], true, false),\n        peg$c44 = function(term) {\n                return term.join('');\n            },\n        peg$c45 = \"~\",\n        peg$c46 = peg$literalExpectation(\"~\", false),\n        peg$c47 = function(proximity) {\n                return proximity;\n            },\n        peg$c48 = \"^\",\n        peg$c49 = peg$literalExpectation(\"^\", false),\n        peg$c50 = function(boost) {\n                return boost;\n            },\n        peg$c51 = function(fuzziness) {\n                return fuzziness == '' || fuzziness == undefined ? 0.5 : fuzziness;\n            },\n        peg$c52 = \"0.\",\n        peg$c53 = peg$literalExpectation(\"0.\", false),\n        peg$c54 = /^[0-9]/,\n        peg$c55 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n        peg$c56 = function(val) {\n                return parseFloat(\"0.\" + val.join(''));\n            },\n        peg$c57 = function(val) {\n                return parseInt(val.join(''));\n            },\n        peg$c58 = \"[\",\n        peg$c59 = peg$literalExpectation(\"[\", false),\n        peg$c60 = \"TO\",\n        peg$c61 = peg$literalExpectation(\"TO\", false),\n        peg$c62 = \"]\",\n        peg$c63 = peg$literalExpectation(\"]\", false),\n        peg$c64 = function(term_min, term_max) {\n                return {\n                    'term_min': term_min,\n                    'term_max': term_max,\n                    'inclusive': true,\n                    'inclusive_min': true,\n                    'inclusive_max': true\n                };\n            },\n        peg$c65 = \"{\",\n        peg$c66 = peg$literalExpectation(\"{\", false),\n        peg$c67 = \"}\",\n        peg$c68 = peg$literalExpectation(\"}\", false),\n        peg$c69 = function(term_min, term_max) {\n                return {\n                    'term_min': term_min,\n                    'term_max': term_max,\n                    'inclusive': false,\n                    'inclusive_min': false,\n                    'inclusive_max': false\n                };\n            },\n        peg$c70 = function(term_min, term_max) {\n                return {\n                    'term_min': term_min,\n                    'term_max': term_max,\n                    'inclusive': false,\n                    'inclusive_min': false,\n                    'inclusive_max': true\n                };\n            },\n        peg$c71 = function(term_min, term_max) {\n                return {\n                    'term_min': term_min,\n                    'term_max': term_max,\n                    'inclusive': false,\n                    'inclusive_min': true,\n                    'inclusive_max': false\n                };\n            },\n        peg$c72 = function(operator) {\n                return operator;\n            },\n        peg$c73 = \"OR\",\n        peg$c74 = peg$literalExpectation(\"OR\", false),\n        peg$c75 = \"AND\",\n        peg$c76 = peg$literalExpectation(\"AND\", false),\n        peg$c77 = \"NOT\",\n        peg$c78 = peg$literalExpectation(\"NOT\", false),\n        peg$c79 = \"||\",\n        peg$c80 = peg$literalExpectation(\"||\", false),\n        peg$c81 = function() { return 'OR'; },\n        peg$c82 = \"&&\",\n        peg$c83 = peg$literalExpectation(\"&&\", false),\n        peg$c84 = function() { return 'AND'; },\n        peg$c85 = \"!\",\n        peg$c86 = peg$literalExpectation(\"!\", false),\n        peg$c87 = function() { return 'NOT'},\n        peg$c88 = peg$otherExpectation(\"whitespace\"),\n        peg$c89 = /^[ \\t\\r\\n\\f]/,\n        peg$c90 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\", \"\\f\"], false, false),\n        peg$c91 = peg$anyExpectation(),\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parsestart() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsenode();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenode();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c1();\n        }\n        s0 = s1;\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseEOF();\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c1();\n          }\n          s0 = s1;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsenode() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$parseoperator_exp();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEOF();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseoperator_exp();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parsenode();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsegroup_exp();\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parseoperator_exp();\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parseoperator_exp();\n            }\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parsenode();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parsenode();\n              }\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c4(s1, s2, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsegroup_exp() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parsefield_exp();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parse_();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parse_();\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c5(s1);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseparen_exp();\n      }\n\n      return s0;\n    }\n\n    function peg$parseparen_exp() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s1 = peg$c6;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c7); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsenode();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parsenode();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s3 = peg$c8;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c9); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parse_();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parse_();\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c0(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsefield_exp() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$parsefieldname();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parserange_operator_exp();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsefieldname();\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseparen_exp();\n          if (s2 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11(s1, s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parsefieldname();\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseterm();\n            if (s2 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12(s1, s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsefieldname() {\n      var s0, s1, s2, s3, s4, s5;\n\n      s0 = peg$currPos;\n      s1 = peg$parseunquoted_term();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parse_();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parse_();\n        }\n        if (s2 !== peg$FAILED) {\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = [];\n            s5 = peg$parse_();\n            while (s5 !== peg$FAILED) {\n              s4.push(s5);\n              s5 = peg$parse_();\n            }\n            if (s4 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c15(s1);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterm() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseprefix_operator_exp();\n      if (s1 === peg$FAILED) {\n        s1 = null;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsequoted_term();\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseproximity_modifier();\n          if (s3 === peg$FAILED) {\n            s3 = null;\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseboost_modifier();\n            if (s4 === peg$FAILED) {\n              s4 = null;\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parse_();\n              while (s6 !== peg$FAILED) {\n                s5.push(s6);\n                s6 = peg$parse_();\n              }\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c16(s1, s2, s3, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parseprefix_operator_exp();\n        if (s1 === peg$FAILED) {\n          s1 = null;\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseunquoted_term();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parsefuzzy_modifier();\n            if (s3 === peg$FAILED) {\n              s3 = null;\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = peg$parseboost_modifier();\n              if (s4 === peg$FAILED) {\n                s4 = null;\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$parse_();\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parse_();\n                }\n                if (s5 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c17(s1, s2, s3, s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          s1 = peg$parseprefix_operator_exp();\n          if (s1 === peg$FAILED) {\n            s1 = null;\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseregexpr_term();\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseboost_modifier();\n              if (s3 === peg$FAILED) {\n                s3 = null;\n              }\n              if (s3 !== peg$FAILED) {\n                s4 = [];\n                s5 = peg$parse_();\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = peg$parse_();\n                }\n                if (s4 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c18(s1, s2, s3);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunquoted_term() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      s1 = peg$parseterm_start_char();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseterm_char();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseterm_char();\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c19(s1, s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterm_start_char() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s0 = peg$c20;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseterm_escaping_char();\n        if (s0 === peg$FAILED) {\n          if (peg$c22.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c23); }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseterm_escaping_char() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c24;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c25); }\n      }\n      if (s1 !== peg$FAILED) {\n        if (peg$c26.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c27); }\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c28(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseterm_char() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s0 = peg$c29;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s0 = peg$c31;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseterm_escaping_char();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseterm_start_char();\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseregexpr_term() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c33;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c34); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseregexpr_char();\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            s3 = peg$parseregexpr_char();\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 47) {\n            s3 = peg$c33;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c34); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c35(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseregexpr_char() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s0 = peg$c20;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c21); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 2) === peg$c36) {\n          s0 = peg$c36;\n          peg$currPos += 2;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c37); }\n        }\n        if (s0 === peg$FAILED) {\n          if (peg$c38.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c39); }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parsequoted_term() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s1 = peg$c40;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c41); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c42.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c43); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c42.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c43); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s3 = peg$c40;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c41); }\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c44(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseproximity_modifier() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 126) {\n        s1 = peg$c45;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c46); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseint_exp();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c47(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseboost_modifier() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s1 = peg$c48;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c49); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsedecimal_or_int_exp();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c50(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsefuzzy_modifier() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 126) {\n        s1 = peg$c45;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c46); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsedecimal_exp();\n        if (s2 === peg$FAILED) {\n          s2 = null;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c51(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parsedecimal_or_int_exp() {\n      var s0;\n\n      s0 = peg$parsedecimal_exp();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseint_exp();\n      }\n\n      return s0;\n    }\n\n    function peg$parsedecimal_exp() {\n      var s0, s1, s2, s3;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 2) === peg$c52) {\n        s1 = peg$c52;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c53); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        if (peg$c54.test(input.charAt(peg$currPos))) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c55); }\n        }\n        if (s3 !== peg$FAILED) {\n          while (s3 !== peg$FAILED) {\n            s2.push(s3);\n            if (peg$c54.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c55); }\n            }\n          }\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c56(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseint_exp() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      if (peg$c54.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c55); }\n      }\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          if (peg$c54.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c55); }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c57(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parserange_operator_exp() {\n      var s0, s1, s2, s3, s4, s5, s6, s7;\n\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 91) {\n        s1 = peg$c58;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c59); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseunquoted_term();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          while (s4 !== peg$FAILED) {\n            s3.push(s4);\n            s4 = peg$parse_();\n          }\n          if (s3 !== peg$FAILED) {\n            if (input.substr(peg$currPos, 2) === peg$c60) {\n              s4 = peg$c60;\n              peg$currPos += 2;\n            } else {\n              s4 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c61); }\n            }\n            if (s4 !== peg$FAILED) {\n              s5 = [];\n              s6 = peg$parse_();\n              if (s6 !== peg$FAILED) {\n                while (s6 !== peg$FAILED) {\n                  s5.push(s6);\n                  s6 = peg$parse_();\n                }\n              } else {\n                s5 = peg$FAILED;\n              }\n              if (s5 !== peg$FAILED) {\n                s6 = peg$parseunquoted_term();\n                if (s6 !== peg$FAILED) {\n                  if (input.charCodeAt(peg$currPos) === 93) {\n                    s7 = peg$c62;\n                    peg$currPos++;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c64(s2, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c65;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c66); }\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseunquoted_term();\n          if (s2 !== peg$FAILED) {\n            s3 = [];\n            s4 = peg$parse_();\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n            if (s3 !== peg$FAILED) {\n              if (input.substr(peg$currPos, 2) === peg$c60) {\n                s4 = peg$c60;\n                peg$currPos += 2;\n              } else {\n                s4 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c61); }\n              }\n              if (s4 !== peg$FAILED) {\n                s5 = [];\n                s6 = peg$parse_();\n                if (s6 !== peg$FAILED) {\n                  while (s6 !== peg$FAILED) {\n                    s5.push(s6);\n                    s6 = peg$parse_();\n                  }\n                } else {\n                  s5 = peg$FAILED;\n                }\n                if (s5 !== peg$FAILED) {\n                  s6 = peg$parseunquoted_term();\n                  if (s6 !== peg$FAILED) {\n                    if (input.charCodeAt(peg$currPos) === 125) {\n                      s7 = peg$c67;\n                      peg$currPos++;\n                    } else {\n                      s7 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                    }\n                    if (s7 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$c69(s2, s6);\n                      s0 = s1;\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 123) {\n            s1 = peg$c65;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c66); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseunquoted_term();\n            if (s2 !== peg$FAILED) {\n              s3 = [];\n              s4 = peg$parse_();\n              while (s4 !== peg$FAILED) {\n                s3.push(s4);\n                s4 = peg$parse_();\n              }\n              if (s3 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 2) === peg$c60) {\n                  s4 = peg$c60;\n                  peg$currPos += 2;\n                } else {\n                  s4 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c61); }\n                }\n                if (s4 !== peg$FAILED) {\n                  s5 = [];\n                  s6 = peg$parse_();\n                  if (s6 !== peg$FAILED) {\n                    while (s6 !== peg$FAILED) {\n                      s5.push(s6);\n                      s6 = peg$parse_();\n                    }\n                  } else {\n                    s5 = peg$FAILED;\n                  }\n                  if (s5 !== peg$FAILED) {\n                    s6 = peg$parseunquoted_term();\n                    if (s6 !== peg$FAILED) {\n                      if (input.charCodeAt(peg$currPos) === 93) {\n                        s7 = peg$c62;\n                        peg$currPos++;\n                      } else {\n                        s7 = peg$FAILED;\n                        if (peg$silentFails === 0) { peg$fail(peg$c63); }\n                      }\n                      if (s7 !== peg$FAILED) {\n                        peg$savedPos = s0;\n                        s1 = peg$c70(s2, s6);\n                        s0 = s1;\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 91) {\n              s1 = peg$c58;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c59); }\n            }\n            if (s1 !== peg$FAILED) {\n              s2 = peg$parseunquoted_term();\n              if (s2 !== peg$FAILED) {\n                s3 = [];\n                s4 = peg$parse_();\n                while (s4 !== peg$FAILED) {\n                  s3.push(s4);\n                  s4 = peg$parse_();\n                }\n                if (s3 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 2) === peg$c60) {\n                    s4 = peg$c60;\n                    peg$currPos += 2;\n                  } else {\n                    s4 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c61); }\n                  }\n                  if (s4 !== peg$FAILED) {\n                    s5 = [];\n                    s6 = peg$parse_();\n                    if (s6 !== peg$FAILED) {\n                      while (s6 !== peg$FAILED) {\n                        s5.push(s6);\n                        s6 = peg$parse_();\n                      }\n                    } else {\n                      s5 = peg$FAILED;\n                    }\n                    if (s5 !== peg$FAILED) {\n                      s6 = peg$parseunquoted_term();\n                      if (s6 !== peg$FAILED) {\n                        if (input.charCodeAt(peg$currPos) === 125) {\n                          s7 = peg$c67;\n                          peg$currPos++;\n                        } else {\n                          s7 = peg$FAILED;\n                          if (peg$silentFails === 0) { peg$fail(peg$c68); }\n                        }\n                        if (s7 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c71(s2, s6);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseoperator_exp() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseoperator();\n        if (s2 !== peg$FAILED) {\n          s3 = [];\n          s4 = peg$parse_();\n          if (s4 !== peg$FAILED) {\n            while (s4 !== peg$FAILED) {\n              s3.push(s4);\n              s4 = peg$parse_();\n            }\n          } else {\n            s3 = peg$FAILED;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c72(s2);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = [];\n        s2 = peg$parse_();\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n          s2 = peg$parse_();\n        }\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseoperator();\n          if (s2 !== peg$FAILED) {\n            s3 = peg$parseEOF();\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c72(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseoperator() {\n      var s0, s1;\n\n      if (input.substr(peg$currPos, 2) === peg$c73) {\n        s0 = peg$c73;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c74); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.substr(peg$currPos, 3) === peg$c75) {\n          s0 = peg$c75;\n          peg$currPos += 3;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c76); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c77) {\n            s0 = peg$c77;\n            peg$currPos += 3;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c78); }\n          }\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.substr(peg$currPos, 2) === peg$c79) {\n              s1 = peg$c79;\n              peg$currPos += 2;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c80); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c81();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.substr(peg$currPos, 2) === peg$c82) {\n                s1 = peg$c82;\n                peg$currPos += 2;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c83); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c84();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 33) {\n                  s1 = peg$c85;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c86); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c87();\n                }\n                s0 = s1;\n              }\n            }\n          }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseprefix_operator_exp() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = [];\n      s2 = peg$parse_();\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parse_();\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseprefix_operator();\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c72(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseprefix_operator() {\n      var s0;\n\n      if (input.charCodeAt(peg$currPos) === 43) {\n        s0 = peg$c29;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c30); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 45) {\n          s0 = peg$c31;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c32); }\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parse_() {\n      var s0, s1;\n\n      peg$silentFails++;\n      s0 = [];\n      if (peg$c89.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c90); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c89.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c90); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s0 === peg$FAILED) {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c88); }\n      }\n\n      return s0;\n    }\n\n    function peg$parseEOF() {\n      var s0, s1;\n\n      s0 = peg$currPos;\n      peg$silentFails++;\n      if (input.length > peg$currPos) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c91); }\n      }\n      peg$silentFails--;\n      if (s1 === peg$FAILED) {\n        s0 = void 0;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse:       peg$parse\n  };\n});\n\n\n//# sourceURL=webpack://STK/../node_modules/lucene-query-parser/lib/lucene-query-parser.js?");

/***/ }),

/***/ "../node_modules/md5/md5.js":
/*!**********************************!*\
  !*** ../node_modules/md5/md5.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("(function(){\r\n  var crypt = __webpack_require__(/*! crypt */ \"../node_modules/crypt/crypt.js\"),\r\n      utf8 = __webpack_require__(/*! charenc */ \"../node_modules/charenc/charenc.js\").utf8,\r\n      isBuffer = __webpack_require__(/*! is-buffer */ \"../node_modules/is-buffer/index.js\"),\r\n      bin = __webpack_require__(/*! charenc */ \"../node_modules/charenc/charenc.js\").bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message))\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n\n\n//# sourceURL=webpack://STK/../node_modules/md5/md5.js?");

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/buffer/index.js":
/*!**********************************************************************!*\
  !*** ../node_modules/node-libs-browser/node_modules/buffer/index.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"../node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"../node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"../node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://STK/../node_modules/node-libs-browser/node_modules/buffer/index.js?");

/***/ }),

/***/ "../node_modules/numeric/numeric-1.2.6.js":
/*!************************************************!*\
  !*** ../node_modules/numeric/numeric-1.2.6.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nvar numeric = ( false)?(undefined):(exports);\nif(typeof global !== \"undefined\") { global.numeric = numeric; }\n\nnumeric.version = \"1.2.6\";\n\n// 1. Utility functions\nnumeric.bench = function bench (f,interval) {\n    var t1,t2,n,i;\n    if(typeof interval === \"undefined\") { interval = 15; }\n    n = 0.5;\n    t1 = new Date();\n    while(1) {\n        n*=2;\n        for(i=n;i>3;i-=4) { f(); f(); f(); f(); }\n        while(i>0) { f(); i--; }\n        t2 = new Date();\n        if(t2-t1 > interval) break;\n    }\n    for(i=n;i>3;i-=4) { f(); f(); f(); f(); }\n    while(i>0) { f(); i--; }\n    t2 = new Date();\n    return 1000*(3*n-1)/(t2-t1);\n}\n\nnumeric._myIndexOf = (function _myIndexOf(w) {\n    var n = this.length,k;\n    for(k=0;k<n;++k) if(this[k]===w) return k;\n    return -1;\n});\nnumeric.myIndexOf = (Array.prototype.indexOf)?Array.prototype.indexOf:numeric._myIndexOf;\n\nnumeric.Function = Function;\nnumeric.precision = 4;\nnumeric.largeArray = 50;\n\nnumeric.prettyPrint = function prettyPrint(x) {\n    function fmtnum(x) {\n        if(x === 0) { return '0'; }\n        if(isNaN(x)) { return 'NaN'; }\n        if(x<0) { return '-'+fmtnum(-x); }\n        if(isFinite(x)) {\n            var scale = Math.floor(Math.log(x) / Math.log(10));\n            var normalized = x / Math.pow(10,scale);\n            var basic = normalized.toPrecision(numeric.precision);\n            if(parseFloat(basic) === 10) { scale++; normalized = 1; basic = normalized.toPrecision(numeric.precision); }\n            return parseFloat(basic).toString()+'e'+scale.toString();\n        }\n        return 'Infinity';\n    }\n    var ret = [];\n    function foo(x) {\n        var k;\n        if(typeof x === \"undefined\") { ret.push(Array(numeric.precision+8).join(' ')); return false; }\n        if(typeof x === \"string\") { ret.push('\"'+x+'\"'); return false; }\n        if(typeof x === \"boolean\") { ret.push(x.toString()); return false; }\n        if(typeof x === \"number\") {\n            var a = fmtnum(x);\n            var b = x.toPrecision(numeric.precision);\n            var c = parseFloat(x.toString()).toString();\n            var d = [a,b,c,parseFloat(b).toString(),parseFloat(c).toString()];\n            for(k=1;k<d.length;k++) { if(d[k].length < a.length) a = d[k]; }\n            ret.push(Array(numeric.precision+8-a.length).join(' ')+a);\n            return false;\n        }\n        if(x === null) { ret.push(\"null\"); return false; }\n        if(typeof x === \"function\") { \n            ret.push(x.toString());\n            var flag = false;\n            for(k in x) { if(x.hasOwnProperty(k)) { \n                if(flag) ret.push(',\\n');\n                else ret.push('\\n{');\n                flag = true; \n                ret.push(k); \n                ret.push(': \\n'); \n                foo(x[k]); \n            } }\n            if(flag) ret.push('}\\n');\n            return true;\n        }\n        if(x instanceof Array) {\n            if(x.length > numeric.largeArray) { ret.push('...Large Array...'); return true; }\n            var flag = false;\n            ret.push('[');\n            for(k=0;k<x.length;k++) { if(k>0) { ret.push(','); if(flag) ret.push('\\n '); } flag = foo(x[k]); }\n            ret.push(']');\n            return true;\n        }\n        ret.push('{');\n        var flag = false;\n        for(k in x) { if(x.hasOwnProperty(k)) { if(flag) ret.push(',\\n'); flag = true; ret.push(k); ret.push(': \\n'); foo(x[k]); } }\n        ret.push('}');\n        return true;\n    }\n    foo(x);\n    return ret.join('');\n}\n\nnumeric.parseDate = function parseDate(d) {\n    function foo(d) {\n        if(typeof d === 'string') { return Date.parse(d.replace(/-/g,'/')); }\n        if(!(d instanceof Array)) { throw new Error(\"parseDate: parameter must be arrays of strings\"); }\n        var ret = [],k;\n        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }\n        return ret;\n    }\n    return foo(d);\n}\n\nnumeric.parseFloat = function parseFloat_(d) {\n    function foo(d) {\n        if(typeof d === 'string') { return parseFloat(d); }\n        if(!(d instanceof Array)) { throw new Error(\"parseFloat: parameter must be arrays of strings\"); }\n        var ret = [],k;\n        for(k=0;k<d.length;k++) { ret[k] = foo(d[k]); }\n        return ret;\n    }\n    return foo(d);\n}\n\nnumeric.parseCSV = function parseCSV(t) {\n    var foo = t.split('\\n');\n    var j,k;\n    var ret = [];\n    var pat = /(([^'\",]*)|('[^']*')|(\"[^\"]*\")),/g;\n    var patnum = /^\\s*(([+-]?[0-9]+(\\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\\.[0-9]+)?(e[+-]?[0-9]+)?))\\s*$/;\n    var stripper = function(n) { return n.substr(0,n.length-1); }\n    var count = 0;\n    for(k=0;k<foo.length;k++) {\n      var bar = (foo[k]+\",\").match(pat),baz;\n      if(bar.length>0) {\n          ret[count] = [];\n          for(j=0;j<bar.length;j++) {\n              baz = stripper(bar[j]);\n              if(patnum.test(baz)) { ret[count][j] = parseFloat(baz); }\n              else ret[count][j] = baz;\n          }\n          count++;\n      }\n    }\n    return ret;\n}\n\nnumeric.toCSV = function toCSV(A) {\n    var s = numeric.dim(A);\n    var i,j,m,n,row,ret;\n    m = s[0];\n    n = s[1];\n    ret = [];\n    for(i=0;i<m;i++) {\n        row = [];\n        for(j=0;j<m;j++) { row[j] = A[i][j].toString(); }\n        ret[i] = row.join(', ');\n    }\n    return ret.join('\\n')+'\\n';\n}\n\nnumeric.getURL = function getURL(url) {\n    var client = new XMLHttpRequest();\n    client.open(\"GET\",url,false);\n    client.send();\n    return client;\n}\n\nnumeric.imageURL = function imageURL(img) {\n    function base64(A) {\n        var n = A.length, i,x,y,z,p,q,r,s;\n        var key = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n        var ret = \"\";\n        for(i=0;i<n;i+=3) {\n            x = A[i];\n            y = A[i+1];\n            z = A[i+2];\n            p = x >> 2;\n            q = ((x & 3) << 4) + (y >> 4);\n            r = ((y & 15) << 2) + (z >> 6);\n            s = z & 63;\n            if(i+1>=n) { r = s = 64; }\n            else if(i+2>=n) { s = 64; }\n            ret += key.charAt(p) + key.charAt(q) + key.charAt(r) + key.charAt(s);\n            }\n        return ret;\n    }\n    function crc32Array (a,from,to) {\n        if(typeof from === \"undefined\") { from = 0; }\n        if(typeof to === \"undefined\") { to = a.length; }\n        var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n                     0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, \n                     0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n                     0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, \n                     0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, \n                     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, \n                     0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n                     0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n                     0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n                     0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, \n                     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, \n                     0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, \n                     0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, \n                     0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, \n                     0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, \n                     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, \n                     0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, \n                     0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, \n                     0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, \n                     0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, \n                     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, \n                     0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, \n                     0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, \n                     0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, \n                     0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, \n                     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, \n                     0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, \n                     0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, \n                     0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, \n                     0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, \n                     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, \n                     0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];\n     \n        var crc = -1, y = 0, n = a.length,i;\n\n        for (i = from; i < to; i++) {\n            y = (crc ^ a[i]) & 0xFF;\n            crc = (crc >>> 8) ^ table[y];\n        }\n     \n        return crc ^ (-1);\n    }\n\n    var h = img[0].length, w = img[0][0].length, s1, s2, next,k,length,a,b,i,j,adler32,crc32;\n    var stream = [\n                  137, 80, 78, 71, 13, 10, 26, 10,                           //  0: PNG signature\n                  0,0,0,13,                                                  //  8: IHDR Chunk length\n                  73, 72, 68, 82,                                            // 12: \"IHDR\" \n                  (w >> 24) & 255, (w >> 16) & 255, (w >> 8) & 255, w&255,   // 16: Width\n                  (h >> 24) & 255, (h >> 16) & 255, (h >> 8) & 255, h&255,   // 20: Height\n                  8,                                                         // 24: bit depth\n                  2,                                                         // 25: RGB\n                  0,                                                         // 26: deflate\n                  0,                                                         // 27: no filter\n                  0,                                                         // 28: no interlace\n                  -1,-2,-3,-4,                                               // 29: CRC\n                  -5,-6,-7,-8,                                               // 33: IDAT Chunk length\n                  73, 68, 65, 84,                                            // 37: \"IDAT\"\n                  // RFC 1950 header starts here\n                  8,                                                         // 41: RFC1950 CMF\n                  29                                                         // 42: RFC1950 FLG\n                  ];\n    crc32 = crc32Array(stream,12,29);\n    stream[29] = (crc32>>24)&255;\n    stream[30] = (crc32>>16)&255;\n    stream[31] = (crc32>>8)&255;\n    stream[32] = (crc32)&255;\n    s1 = 1;\n    s2 = 0;\n    for(i=0;i<h;i++) {\n        if(i<h-1) { stream.push(0); }\n        else { stream.push(1); }\n        a = (3*w+1+(i===0))&255; b = ((3*w+1+(i===0))>>8)&255;\n        stream.push(a); stream.push(b);\n        stream.push((~a)&255); stream.push((~b)&255);\n        if(i===0) stream.push(0);\n        for(j=0;j<w;j++) {\n            for(k=0;k<3;k++) {\n                a = img[k][i][j];\n                if(a>255) a = 255;\n                else if(a<0) a=0;\n                else a = Math.round(a);\n                s1 = (s1 + a )%65521;\n                s2 = (s2 + s1)%65521;\n                stream.push(a);\n            }\n        }\n        stream.push(0);\n    }\n    adler32 = (s2<<16)+s1;\n    stream.push((adler32>>24)&255);\n    stream.push((adler32>>16)&255);\n    stream.push((adler32>>8)&255);\n    stream.push((adler32)&255);\n    length = stream.length - 41;\n    stream[33] = (length>>24)&255;\n    stream[34] = (length>>16)&255;\n    stream[35] = (length>>8)&255;\n    stream[36] = (length)&255;\n    crc32 = crc32Array(stream,37);\n    stream.push((crc32>>24)&255);\n    stream.push((crc32>>16)&255);\n    stream.push((crc32>>8)&255);\n    stream.push((crc32)&255);\n    stream.push(0);\n    stream.push(0);\n    stream.push(0);\n    stream.push(0);\n//    a = stream.length;\n    stream.push(73);  // I\n    stream.push(69);  // E\n    stream.push(78);  // N\n    stream.push(68);  // D\n    stream.push(174); // CRC1\n    stream.push(66);  // CRC2\n    stream.push(96);  // CRC3\n    stream.push(130); // CRC4\n    return 'data:image/png;base64,'+base64(stream);\n}\n\n// 2. Linear algebra with Arrays.\nnumeric._dim = function _dim(x) {\n    var ret = [];\n    while(typeof x === \"object\") { ret.push(x.length); x = x[0]; }\n    return ret;\n}\n\nnumeric.dim = function dim(x) {\n    var y,z;\n    if(typeof x === \"object\") {\n        y = x[0];\n        if(typeof y === \"object\") {\n            z = y[0];\n            if(typeof z === \"object\") {\n                return numeric._dim(x);\n            }\n            return [x.length,y.length];\n        }\n        return [x.length];\n    }\n    return [];\n}\n\nnumeric.mapreduce = function mapreduce(body,init) {\n    return Function('x','accum','_s','_k',\n            'if(typeof accum === \"undefined\") accum = '+init+';\\n'+\n            'if(typeof x === \"number\") { var xi = x; '+body+'; return accum; }\\n'+\n            'if(typeof _s === \"undefined\") _s = numeric.dim(x);\\n'+\n            'if(typeof _k === \"undefined\") _k = 0;\\n'+\n            'var _n = _s[_k];\\n'+\n            'var i,xi;\\n'+\n            'if(_k < _s.length-1) {\\n'+\n            '    for(i=_n-1;i>=0;i--) {\\n'+\n            '        accum = arguments.callee(x[i],accum,_s,_k+1);\\n'+\n            '    }'+\n            '    return accum;\\n'+\n            '}\\n'+\n            'for(i=_n-1;i>=1;i-=2) { \\n'+\n            '    xi = x[i];\\n'+\n            '    '+body+';\\n'+\n            '    xi = x[i-1];\\n'+\n            '    '+body+';\\n'+\n            '}\\n'+\n            'if(i === 0) {\\n'+\n            '    xi = x[i];\\n'+\n            '    '+body+'\\n'+\n            '}\\n'+\n            'return accum;'\n            );\n}\nnumeric.mapreduce2 = function mapreduce2(body,setup) {\n    return Function('x',\n            'var n = x.length;\\n'+\n            'var i,xi;\\n'+setup+';\\n'+\n            'for(i=n-1;i!==-1;--i) { \\n'+\n            '    xi = x[i];\\n'+\n            '    '+body+';\\n'+\n            '}\\n'+\n            'return accum;'\n            );\n}\n\n\nnumeric.same = function same(x,y) {\n    var i,n;\n    if(!(x instanceof Array) || !(y instanceof Array)) { return false; }\n    n = x.length;\n    if(n !== y.length) { return false; }\n    for(i=0;i<n;i++) {\n        if(x[i] === y[i]) { continue; }\n        if(typeof x[i] === \"object\") { if(!same(x[i],y[i])) return false; }\n        else { return false; }\n    }\n    return true;\n}\n\nnumeric.rep = function rep(s,v,k) {\n    if(typeof k === \"undefined\") { k=0; }\n    var n = s[k], ret = Array(n), i;\n    if(k === s.length-1) {\n        for(i=n-2;i>=0;i-=2) { ret[i+1] = v; ret[i] = v; }\n        if(i===-1) { ret[0] = v; }\n        return ret;\n    }\n    for(i=n-1;i>=0;i--) { ret[i] = numeric.rep(s,v,k+1); }\n    return ret;\n}\n\n\nnumeric.dotMMsmall = function dotMMsmall(x,y) {\n    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0;\n    p = x.length; q = y.length; r = y[0].length;\n    ret = Array(p);\n    for(i=p-1;i>=0;i--) {\n        foo = Array(r);\n        bar = x[i];\n        for(k=r-1;k>=0;k--) {\n            woo = bar[q-1]*y[q-1][k];\n            for(j=q-2;j>=1;j-=2) {\n                i0 = j-1;\n                woo += bar[j]*y[j][k] + bar[i0]*y[i0][k];\n            }\n            if(j===0) { woo += bar[0]*y[0][k]; }\n            foo[k] = woo;\n        }\n        ret[i] = foo;\n    }\n    return ret;\n}\nnumeric._getCol = function _getCol(A,j,x) {\n    var n = A.length, i;\n    for(i=n-1;i>0;--i) {\n        x[i] = A[i][j];\n        --i;\n        x[i] = A[i][j];\n    }\n    if(i===0) x[0] = A[0][j];\n}\nnumeric.dotMMbig = function dotMMbig(x,y){\n    var gc = numeric._getCol, p = y.length, v = Array(p);\n    var m = x.length, n = y[0].length, A = new Array(m), xj;\n    var VV = numeric.dotVV;\n    var i,j,k,z;\n    --p;\n    --m;\n    for(i=m;i!==-1;--i) A[i] = Array(n);\n    --n;\n    for(i=n;i!==-1;--i) {\n        gc(y,i,v);\n        for(j=m;j!==-1;--j) {\n            z=0;\n            xj = x[j];\n            A[j][i] = VV(xj,v);\n        }\n    }\n    return A;\n}\n\nnumeric.dotMV = function dotMV(x,y) {\n    var p = x.length, q = y.length,i;\n    var ret = Array(p), dotVV = numeric.dotVV;\n    for(i=p-1;i>=0;i--) { ret[i] = dotVV(x[i],y); }\n    return ret;\n}\n\nnumeric.dotVM = function dotVM(x,y) {\n    var i,j,k,p,q,r,ret,foo,bar,woo,i0,k0,p0,r0,s1,s2,s3,baz,accum;\n    p = x.length; q = y[0].length;\n    ret = Array(q);\n    for(k=q-1;k>=0;k--) {\n        woo = x[p-1]*y[p-1][k];\n        for(j=p-2;j>=1;j-=2) {\n            i0 = j-1;\n            woo += x[j]*y[j][k] + x[i0]*y[i0][k];\n        }\n        if(j===0) { woo += x[0]*y[0][k]; }\n        ret[k] = woo;\n    }\n    return ret;\n}\n\nnumeric.dotVV = function dotVV(x,y) {\n    var i,n=x.length,i1,ret = x[n-1]*y[n-1];\n    for(i=n-2;i>=1;i-=2) {\n        i1 = i-1;\n        ret += x[i]*y[i] + x[i1]*y[i1];\n    }\n    if(i===0) { ret += x[0]*y[0]; }\n    return ret;\n}\n\nnumeric.dot = function dot(x,y) {\n    var d = numeric.dim;\n    switch(d(x).length*1000+d(y).length) {\n    case 2002:\n        if(y.length < 10) return numeric.dotMMsmall(x,y);\n        else return numeric.dotMMbig(x,y);\n    case 2001: return numeric.dotMV(x,y);\n    case 1002: return numeric.dotVM(x,y);\n    case 1001: return numeric.dotVV(x,y);\n    case 1000: return numeric.mulVS(x,y);\n    case 1: return numeric.mulSV(x,y);\n    case 0: return x*y;\n    default: throw new Error('numeric.dot only works on vectors and matrices');\n    }\n}\n\nnumeric.diag = function diag(d) {\n    var i,i1,j,n = d.length, A = Array(n), Ai;\n    for(i=n-1;i>=0;i--) {\n        Ai = Array(n);\n        i1 = i+2;\n        for(j=n-1;j>=i1;j-=2) {\n            Ai[j] = 0;\n            Ai[j-1] = 0;\n        }\n        if(j>i) { Ai[j] = 0; }\n        Ai[i] = d[i];\n        for(j=i-1;j>=1;j-=2) {\n            Ai[j] = 0;\n            Ai[j-1] = 0;\n        }\n        if(j===0) { Ai[0] = 0; }\n        A[i] = Ai;\n    }\n    return A;\n}\nnumeric.getDiag = function(A) {\n    var n = Math.min(A.length,A[0].length),i,ret = Array(n);\n    for(i=n-1;i>=1;--i) {\n        ret[i] = A[i][i];\n        --i;\n        ret[i] = A[i][i];\n    }\n    if(i===0) {\n        ret[0] = A[0][0];\n    }\n    return ret;\n}\n\nnumeric.identity = function identity(n) { return numeric.diag(numeric.rep([n],1)); }\nnumeric.pointwise = function pointwise(params,body,setup) {\n    if(typeof setup === \"undefined\") { setup = \"\"; }\n    var fun = [];\n    var k;\n    var avec = /\\[i\\]$/,p,thevec = '';\n    var haveret = false;\n    for(k=0;k<params.length;k++) {\n        if(avec.test(params[k])) {\n            p = params[k].substring(0,params[k].length-3);\n            thevec = p;\n        } else { p = params[k]; }\n        if(p==='ret') haveret = true;\n        fun.push(p);\n    }\n    fun[params.length] = '_s';\n    fun[params.length+1] = '_k';\n    fun[params.length+2] = (\n            'if(typeof _s === \"undefined\") _s = numeric.dim('+thevec+');\\n'+\n            'if(typeof _k === \"undefined\") _k = 0;\\n'+\n            'var _n = _s[_k];\\n'+\n            'var i'+(haveret?'':', ret = Array(_n)')+';\\n'+\n            'if(_k < _s.length-1) {\\n'+\n            '    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee('+params.join(',')+',_s,_k+1);\\n'+\n            '    return ret;\\n'+\n            '}\\n'+\n            setup+'\\n'+\n            'for(i=_n-1;i!==-1;--i) {\\n'+\n            '    '+body+'\\n'+\n            '}\\n'+\n            'return ret;'\n            );\n    return Function.apply(null,fun);\n}\nnumeric.pointwise2 = function pointwise2(params,body,setup) {\n    if(typeof setup === \"undefined\") { setup = \"\"; }\n    var fun = [];\n    var k;\n    var avec = /\\[i\\]$/,p,thevec = '';\n    var haveret = false;\n    for(k=0;k<params.length;k++) {\n        if(avec.test(params[k])) {\n            p = params[k].substring(0,params[k].length-3);\n            thevec = p;\n        } else { p = params[k]; }\n        if(p==='ret') haveret = true;\n        fun.push(p);\n    }\n    fun[params.length] = (\n            'var _n = '+thevec+'.length;\\n'+\n            'var i'+(haveret?'':', ret = Array(_n)')+';\\n'+\n            setup+'\\n'+\n            'for(i=_n-1;i!==-1;--i) {\\n'+\n            body+'\\n'+\n            '}\\n'+\n            'return ret;'\n            );\n    return Function.apply(null,fun);\n}\nnumeric._biforeach = (function _biforeach(x,y,s,k,f) {\n    if(k === s.length-1) { f(x,y); return; }\n    var i,n=s[k];\n    for(i=n-1;i>=0;i--) { _biforeach(typeof x===\"object\"?x[i]:x,typeof y===\"object\"?y[i]:y,s,k+1,f); }\n});\nnumeric._biforeach2 = (function _biforeach2(x,y,s,k,f) {\n    if(k === s.length-1) { return f(x,y); }\n    var i,n=s[k],ret = Array(n);\n    for(i=n-1;i>=0;--i) { ret[i] = _biforeach2(typeof x===\"object\"?x[i]:x,typeof y===\"object\"?y[i]:y,s,k+1,f); }\n    return ret;\n});\nnumeric._foreach = (function _foreach(x,s,k,f) {\n    if(k === s.length-1) { f(x); return; }\n    var i,n=s[k];\n    for(i=n-1;i>=0;i--) { _foreach(x[i],s,k+1,f); }\n});\nnumeric._foreach2 = (function _foreach2(x,s,k,f) {\n    if(k === s.length-1) { return f(x); }\n    var i,n=s[k], ret = Array(n);\n    for(i=n-1;i>=0;i--) { ret[i] = _foreach2(x[i],s,k+1,f); }\n    return ret;\n});\n\n/*numeric.anyV = numeric.mapreduce('if(xi) return true;','false');\nnumeric.allV = numeric.mapreduce('if(!xi) return false;','true');\nnumeric.any = function(x) { if(typeof x.length === \"undefined\") return x; return numeric.anyV(x); }\nnumeric.all = function(x) { if(typeof x.length === \"undefined\") return x; return numeric.allV(x); }*/\n\nnumeric.ops2 = {\n        add: '+',\n        sub: '-',\n        mul: '*',\n        div: '/',\n        mod: '%',\n        and: '&&',\n        or:  '||',\n        eq:  '===',\n        neq: '!==',\n        lt:  '<',\n        gt:  '>',\n        leq: '<=',\n        geq: '>=',\n        band: '&',\n        bor: '|',\n        bxor: '^',\n        lshift: '<<',\n        rshift: '>>',\n        rrshift: '>>>'\n};\nnumeric.opseq = {\n        addeq: '+=',\n        subeq: '-=',\n        muleq: '*=',\n        diveq: '/=',\n        modeq: '%=',\n        lshifteq: '<<=',\n        rshifteq: '>>=',\n        rrshifteq: '>>>=',\n        bandeq: '&=',\n        boreq: '|=',\n        bxoreq: '^='\n};\nnumeric.mathfuns = ['abs','acos','asin','atan','ceil','cos',\n                    'exp','floor','log','round','sin','sqrt','tan',\n                    'isNaN','isFinite'];\nnumeric.mathfuns2 = ['atan2','pow','max','min'];\nnumeric.ops1 = {\n        neg: '-',\n        not: '!',\n        bnot: '~',\n        clone: ''\n};\nnumeric.mapreducers = {\n        any: ['if(xi) return true;','var accum = false;'],\n        all: ['if(!xi) return false;','var accum = true;'],\n        sum: ['accum += xi;','var accum = 0;'],\n        prod: ['accum *= xi;','var accum = 1;'],\n        norm2Squared: ['accum += xi*xi;','var accum = 0;'],\n        norminf: ['accum = max(accum,abs(xi));','var accum = 0, max = Math.max, abs = Math.abs;'],\n        norm1: ['accum += abs(xi)','var accum = 0, abs = Math.abs;'],\n        sup: ['accum = max(accum,xi);','var accum = -Infinity, max = Math.max;'],\n        inf: ['accum = min(accum,xi);','var accum = Infinity, min = Math.min;']\n};\n\n(function () {\n    var i,o;\n    for(i=0;i<numeric.mathfuns2.length;++i) {\n        o = numeric.mathfuns2[i];\n        numeric.ops2[o] = o;\n    }\n    for(i in numeric.ops2) {\n        if(numeric.ops2.hasOwnProperty(i)) {\n            o = numeric.ops2[i];\n            var code, codeeq, setup = '';\n            if(numeric.myIndexOf.call(numeric.mathfuns2,i)!==-1) {\n                setup = 'var '+o+' = Math.'+o+';\\n';\n                code = function(r,x,y) { return r+' = '+o+'('+x+','+y+')'; };\n                codeeq = function(x,y) { return x+' = '+o+'('+x+','+y+')'; };\n            } else {\n                code = function(r,x,y) { return r+' = '+x+' '+o+' '+y; };\n                if(numeric.opseq.hasOwnProperty(i+'eq')) {\n                    codeeq = function(x,y) { return x+' '+o+'= '+y; };\n                } else {\n                    codeeq = function(x,y) { return x+' = '+x+' '+o+' '+y; };                    \n                }\n            }\n            numeric[i+'VV'] = numeric.pointwise2(['x[i]','y[i]'],code('ret[i]','x[i]','y[i]'),setup);\n            numeric[i+'SV'] = numeric.pointwise2(['x','y[i]'],code('ret[i]','x','y[i]'),setup);\n            numeric[i+'VS'] = numeric.pointwise2(['x[i]','y'],code('ret[i]','x[i]','y'),setup);\n            numeric[i] = Function(\n                    'var n = arguments.length, i, x = arguments[0], y;\\n'+\n                    'var VV = numeric.'+i+'VV, VS = numeric.'+i+'VS, SV = numeric.'+i+'SV;\\n'+\n                    'var dim = numeric.dim;\\n'+\n                    'for(i=1;i!==n;++i) { \\n'+\n                    '  y = arguments[i];\\n'+\n                    '  if(typeof x === \"object\") {\\n'+\n                    '      if(typeof y === \"object\") x = numeric._biforeach2(x,y,dim(x),0,VV);\\n'+\n                    '      else x = numeric._biforeach2(x,y,dim(x),0,VS);\\n'+\n                    '  } else if(typeof y === \"object\") x = numeric._biforeach2(x,y,dim(y),0,SV);\\n'+\n                    '  else '+codeeq('x','y')+'\\n'+\n                    '}\\nreturn x;\\n');\n            numeric[o] = numeric[i];\n            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]','x[i]'], codeeq('ret[i]','x[i]'),setup);\n            numeric[i+'eqS'] = numeric.pointwise2(['ret[i]','x'], codeeq('ret[i]','x'),setup);\n            numeric[i+'eq'] = Function(\n                    'var n = arguments.length, i, x = arguments[0], y;\\n'+\n                    'var V = numeric.'+i+'eqV, S = numeric.'+i+'eqS\\n'+\n                    'var s = numeric.dim(x);\\n'+\n                    'for(i=1;i!==n;++i) { \\n'+\n                    '  y = arguments[i];\\n'+\n                    '  if(typeof y === \"object\") numeric._biforeach(x,y,s,0,V);\\n'+\n                    '  else numeric._biforeach(x,y,s,0,S);\\n'+\n                    '}\\nreturn x;\\n');\n        }\n    }\n    for(i=0;i<numeric.mathfuns2.length;++i) {\n        o = numeric.mathfuns2[i];\n        delete numeric.ops2[o];\n    }\n    for(i=0;i<numeric.mathfuns.length;++i) {\n        o = numeric.mathfuns[i];\n        numeric.ops1[o] = o;\n    }\n    for(i in numeric.ops1) {\n        if(numeric.ops1.hasOwnProperty(i)) {\n            setup = '';\n            o = numeric.ops1[i];\n            if(numeric.myIndexOf.call(numeric.mathfuns,i)!==-1) {\n                if(Math.hasOwnProperty(o)) setup = 'var '+o+' = Math.'+o+';\\n';\n            }\n            numeric[i+'eqV'] = numeric.pointwise2(['ret[i]'],'ret[i] = '+o+'(ret[i]);',setup);\n            numeric[i+'eq'] = Function('x',\n                    'if(typeof x !== \"object\") return '+o+'x\\n'+\n                    'var i;\\n'+\n                    'var V = numeric.'+i+'eqV;\\n'+\n                    'var s = numeric.dim(x);\\n'+\n                    'numeric._foreach(x,s,0,V);\\n'+\n                    'return x;\\n');\n            numeric[i+'V'] = numeric.pointwise2(['x[i]'],'ret[i] = '+o+'(x[i]);',setup);\n            numeric[i] = Function('x',\n                    'if(typeof x !== \"object\") return '+o+'(x)\\n'+\n                    'var i;\\n'+\n                    'var V = numeric.'+i+'V;\\n'+\n                    'var s = numeric.dim(x);\\n'+\n                    'return numeric._foreach2(x,s,0,V);\\n');\n        }\n    }\n    for(i=0;i<numeric.mathfuns.length;++i) {\n        o = numeric.mathfuns[i];\n        delete numeric.ops1[o];\n    }\n    for(i in numeric.mapreducers) {\n        if(numeric.mapreducers.hasOwnProperty(i)) {\n            o = numeric.mapreducers[i];\n            numeric[i+'V'] = numeric.mapreduce2(o[0],o[1]);\n            numeric[i] = Function('x','s','k',\n                    o[1]+\n                    'if(typeof x !== \"object\") {'+\n                    '    xi = x;\\n'+\n                    o[0]+';\\n'+\n                    '    return accum;\\n'+\n                    '}'+\n                    'if(typeof s === \"undefined\") s = numeric.dim(x);\\n'+\n                    'if(typeof k === \"undefined\") k = 0;\\n'+\n                    'if(k === s.length-1) return numeric.'+i+'V(x);\\n'+\n                    'var xi;\\n'+\n                    'var n = x.length, i;\\n'+\n                    'for(i=n-1;i!==-1;--i) {\\n'+\n                    '   xi = arguments.callee(x[i]);\\n'+\n                    o[0]+';\\n'+\n                    '}\\n'+\n                    'return accum;\\n');\n        }\n    }\n}());\n\nnumeric.truncVV = numeric.pointwise(['x[i]','y[i]'],'ret[i] = round(x[i]/y[i])*y[i];','var round = Math.round;');\nnumeric.truncVS = numeric.pointwise(['x[i]','y'],'ret[i] = round(x[i]/y)*y;','var round = Math.round;');\nnumeric.truncSV = numeric.pointwise(['x','y[i]'],'ret[i] = round(x/y[i])*y[i];','var round = Math.round;');\nnumeric.trunc = function trunc(x,y) {\n    if(typeof x === \"object\") {\n        if(typeof y === \"object\") return numeric.truncVV(x,y);\n        return numeric.truncVS(x,y);\n    }\n    if (typeof y === \"object\") return numeric.truncSV(x,y);\n    return Math.round(x/y)*y;\n}\n\nnumeric.inv = function inv(x) {\n    var s = numeric.dim(x), abs = Math.abs, m = s[0], n = s[1];\n    var A = numeric.clone(x), Ai, Aj;\n    var I = numeric.identity(m), Ii, Ij;\n    var i,j,k,x;\n    for(j=0;j<n;++j) {\n        var i0 = -1;\n        var v0 = -1;\n        for(i=j;i!==m;++i) { k = abs(A[i][j]); if(k>v0) { i0 = i; v0 = k; } }\n        Aj = A[i0]; A[i0] = A[j]; A[j] = Aj;\n        Ij = I[i0]; I[i0] = I[j]; I[j] = Ij;\n        x = Aj[j];\n        for(k=j;k!==n;++k)    Aj[k] /= x; \n        for(k=n-1;k!==-1;--k) Ij[k] /= x;\n        for(i=m-1;i!==-1;--i) {\n            if(i!==j) {\n                Ai = A[i];\n                Ii = I[i];\n                x = Ai[j];\n                for(k=j+1;k!==n;++k)  Ai[k] -= Aj[k]*x;\n                for(k=n-1;k>0;--k) { Ii[k] -= Ij[k]*x; --k; Ii[k] -= Ij[k]*x; }\n                if(k===0) Ii[0] -= Ij[0]*x;\n            }\n        }\n    }\n    return I;\n}\n\nnumeric.det = function det(x) {\n    var s = numeric.dim(x);\n    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: det() only works on square matrices'); }\n    var n = s[0], ret = 1,i,j,k,A = numeric.clone(x),Aj,Ai,alpha,temp,k1,k2,k3;\n    for(j=0;j<n-1;j++) {\n        k=j;\n        for(i=j+1;i<n;i++) { if(Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }\n        if(k !== j) {\n            temp = A[k]; A[k] = A[j]; A[j] = temp;\n            ret *= -1;\n        }\n        Aj = A[j];\n        for(i=j+1;i<n;i++) {\n            Ai = A[i];\n            alpha = Ai[j]/Aj[j];\n            for(k=j+1;k<n-1;k+=2) {\n                k1 = k+1;\n                Ai[k] -= Aj[k]*alpha;\n                Ai[k1] -= Aj[k1]*alpha;\n            }\n            if(k!==n) { Ai[k] -= Aj[k]*alpha; }\n        }\n        if(Aj[j] === 0) { return 0; }\n        ret *= Aj[j];\n    }\n    return ret*A[j][j];\n}\n\nnumeric.transpose = function transpose(x) {\n    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;\n    for(j=0;j<n;j++) ret[j] = Array(m);\n    for(i=m-1;i>=1;i-=2) {\n        A1 = x[i];\n        A0 = x[i-1];\n        for(j=n-1;j>=1;--j) {\n            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];\n            --j;\n            Bj = ret[j]; Bj[i] = A1[j]; Bj[i-1] = A0[j];\n        }\n        if(j===0) {\n            Bj = ret[0]; Bj[i] = A1[0]; Bj[i-1] = A0[0];\n        }\n    }\n    if(i===0) {\n        A0 = x[0];\n        for(j=n-1;j>=1;--j) {\n            ret[j][0] = A0[j];\n            --j;\n            ret[j][0] = A0[j];\n        }\n        if(j===0) { ret[0][0] = A0[0]; }\n    }\n    return ret;\n}\nnumeric.negtranspose = function negtranspose(x) {\n    var i,j,m = x.length,n = x[0].length, ret=Array(n),A0,A1,Bj;\n    for(j=0;j<n;j++) ret[j] = Array(m);\n    for(i=m-1;i>=1;i-=2) {\n        A1 = x[i];\n        A0 = x[i-1];\n        for(j=n-1;j>=1;--j) {\n            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];\n            --j;\n            Bj = ret[j]; Bj[i] = -A1[j]; Bj[i-1] = -A0[j];\n        }\n        if(j===0) {\n            Bj = ret[0]; Bj[i] = -A1[0]; Bj[i-1] = -A0[0];\n        }\n    }\n    if(i===0) {\n        A0 = x[0];\n        for(j=n-1;j>=1;--j) {\n            ret[j][0] = -A0[j];\n            --j;\n            ret[j][0] = -A0[j];\n        }\n        if(j===0) { ret[0][0] = -A0[0]; }\n    }\n    return ret;\n}\n\nnumeric._random = function _random(s,k) {\n    var i,n=s[k],ret=Array(n), rnd;\n    if(k === s.length-1) {\n        rnd = Math.random;\n        for(i=n-1;i>=1;i-=2) {\n            ret[i] = rnd();\n            ret[i-1] = rnd();\n        }\n        if(i===0) { ret[0] = rnd(); }\n        return ret;\n    }\n    for(i=n-1;i>=0;i--) ret[i] = _random(s,k+1);\n    return ret;\n}\nnumeric.random = function random(s) { return numeric._random(s,0); }\n\nnumeric.norm2 = function norm2(x) { return Math.sqrt(numeric.norm2Squared(x)); }\n\nnumeric.linspace = function linspace(a,b,n) {\n    if(typeof n === \"undefined\") n = Math.max(Math.round(b-a)+1,1);\n    if(n<2) { return n===1?[a]:[]; }\n    var i,ret = Array(n);\n    n--;\n    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }\n    return ret;\n}\n\nnumeric.getBlock = function getBlock(x,from,to) {\n    var s = numeric.dim(x);\n    function foo(x,k) {\n        var i,a = from[k], n = to[k]-a, ret = Array(n);\n        if(k === s.length-1) {\n            for(i=n;i>=0;i--) { ret[i] = x[i+a]; }\n            return ret;\n        }\n        for(i=n;i>=0;i--) { ret[i] = foo(x[i+a],k+1); }\n        return ret;\n    }\n    return foo(x,0);\n}\n\nnumeric.setBlock = function setBlock(x,from,to,B) {\n    var s = numeric.dim(x);\n    function foo(x,y,k) {\n        var i,a = from[k], n = to[k]-a;\n        if(k === s.length-1) { for(i=n;i>=0;i--) { x[i+a] = y[i]; } }\n        for(i=n;i>=0;i--) { foo(x[i+a],y[i],k+1); }\n    }\n    foo(x,B,0);\n    return x;\n}\n\nnumeric.getRange = function getRange(A,I,J) {\n    var m = I.length, n = J.length;\n    var i,j;\n    var B = Array(m), Bi, AI;\n    for(i=m-1;i!==-1;--i) {\n        B[i] = Array(n);\n        Bi = B[i];\n        AI = A[I[i]];\n        for(j=n-1;j!==-1;--j) Bi[j] = AI[J[j]];\n    }\n    return B;\n}\n\nnumeric.blockMatrix = function blockMatrix(X) {\n    var s = numeric.dim(X);\n    if(s.length<4) return numeric.blockMatrix([X]);\n    var m=s[0],n=s[1],M,N,i,j,Xij;\n    M = 0; N = 0;\n    for(i=0;i<m;++i) M+=X[i][0].length;\n    for(j=0;j<n;++j) N+=X[0][j][0].length;\n    var Z = Array(M);\n    for(i=0;i<M;++i) Z[i] = Array(N);\n    var I=0,J,ZI,k,l,Xijk;\n    for(i=0;i<m;++i) {\n        J=N;\n        for(j=n-1;j!==-1;--j) {\n            Xij = X[i][j];\n            J -= Xij[0].length;\n            for(k=Xij.length-1;k!==-1;--k) {\n                Xijk = Xij[k];\n                ZI = Z[I+k];\n                for(l = Xijk.length-1;l!==-1;--l) ZI[J+l] = Xijk[l];\n            }\n        }\n        I += X[i][0].length;\n    }\n    return Z;\n}\n\nnumeric.tensor = function tensor(x,y) {\n    if(typeof x === \"number\" || typeof y === \"number\") return numeric.mul(x,y);\n    var s1 = numeric.dim(x), s2 = numeric.dim(y);\n    if(s1.length !== 1 || s2.length !== 1) {\n        throw new Error('numeric: tensor product is only defined for vectors');\n    }\n    var m = s1[0], n = s2[0], A = Array(m), Ai, i,j,xi;\n    for(i=m-1;i>=0;i--) {\n        Ai = Array(n);\n        xi = x[i];\n        for(j=n-1;j>=3;--j) {\n            Ai[j] = xi * y[j];\n            --j;\n            Ai[j] = xi * y[j];\n            --j;\n            Ai[j] = xi * y[j];\n            --j;\n            Ai[j] = xi * y[j];\n        }\n        while(j>=0) { Ai[j] = xi * y[j]; --j; }\n        A[i] = Ai;\n    }\n    return A;\n}\n\n// 3. The Tensor type T\nnumeric.T = function T(x,y) { this.x = x; this.y = y; }\nnumeric.t = function t(x,y) { return new numeric.T(x,y); }\n\nnumeric.Tbinop = function Tbinop(rr,rc,cr,cc,setup) {\n    var io = numeric.indexOf;\n    if(typeof setup !== \"string\") {\n        var k;\n        setup = '';\n        for(k in numeric) {\n            if(numeric.hasOwnProperty(k) && (rr.indexOf(k)>=0 || rc.indexOf(k)>=0 || cr.indexOf(k)>=0 || cc.indexOf(k)>=0) && k.length>1) {\n                setup += 'var '+k+' = numeric.'+k+';\\n';\n            }\n        }\n    }\n    return Function(['y'],\n            'var x = this;\\n'+\n            'if(!(y instanceof numeric.T)) { y = new numeric.T(y); }\\n'+\n            setup+'\\n'+\n            'if(x.y) {'+\n            '  if(y.y) {'+\n            '    return new numeric.T('+cc+');\\n'+\n            '  }\\n'+\n            '  return new numeric.T('+cr+');\\n'+\n            '}\\n'+\n            'if(y.y) {\\n'+\n            '  return new numeric.T('+rc+');\\n'+\n            '}\\n'+\n            'return new numeric.T('+rr+');\\n'\n    );\n}\n\nnumeric.T.prototype.add = numeric.Tbinop(\n        'add(x.x,y.x)',\n        'add(x.x,y.x),y.y',\n        'add(x.x,y.x),x.y',\n        'add(x.x,y.x),add(x.y,y.y)');\nnumeric.T.prototype.sub = numeric.Tbinop(\n        'sub(x.x,y.x)',\n        'sub(x.x,y.x),neg(y.y)',\n        'sub(x.x,y.x),x.y',\n        'sub(x.x,y.x),sub(x.y,y.y)');\nnumeric.T.prototype.mul = numeric.Tbinop(\n        'mul(x.x,y.x)',\n        'mul(x.x,y.x),mul(x.x,y.y)',\n        'mul(x.x,y.x),mul(x.y,y.x)',\n        'sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))');\n\nnumeric.T.prototype.reciprocal = function reciprocal() {\n    var mul = numeric.mul, div = numeric.div;\n    if(this.y) {\n        var d = numeric.add(mul(this.x,this.x),mul(this.y,this.y));\n        return new numeric.T(div(this.x,d),div(numeric.neg(this.y),d));\n    }\n    return new T(div(1,this.x));\n}\nnumeric.T.prototype.div = function div(y) {\n    if(!(y instanceof numeric.T)) y = new numeric.T(y);\n    if(y.y) { return this.mul(y.reciprocal()); }\n    var div = numeric.div;\n    if(this.y) { return new numeric.T(div(this.x,y.x),div(this.y,y.x)); }\n    return new numeric.T(div(this.x,y.x));\n}\nnumeric.T.prototype.dot = numeric.Tbinop(\n        'dot(x.x,y.x)',\n        'dot(x.x,y.x),dot(x.x,y.y)',\n        'dot(x.x,y.x),dot(x.y,y.x)',\n        'sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))'\n        );\nnumeric.T.prototype.transpose = function transpose() {\n    var t = numeric.transpose, x = this.x, y = this.y;\n    if(y) { return new numeric.T(t(x),t(y)); }\n    return new numeric.T(t(x));\n}\nnumeric.T.prototype.transjugate = function transjugate() {\n    var t = numeric.transpose, x = this.x, y = this.y;\n    if(y) { return new numeric.T(t(x),numeric.negtranspose(y)); }\n    return new numeric.T(t(x));\n}\nnumeric.Tunop = function Tunop(r,c,s) {\n    if(typeof s !== \"string\") { s = ''; }\n    return Function(\n            'var x = this;\\n'+\n            s+'\\n'+\n            'if(x.y) {'+\n            '  '+c+';\\n'+\n            '}\\n'+\n            r+';\\n'\n    );\n}\n\nnumeric.T.prototype.exp = numeric.Tunop(\n        'return new numeric.T(ex)',\n        'return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))',\n        'var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;');\nnumeric.T.prototype.conj = numeric.Tunop(\n        'return new numeric.T(x.x);',\n        'return new numeric.T(x.x,numeric.neg(x.y));');\nnumeric.T.prototype.neg = numeric.Tunop(\n        'return new numeric.T(neg(x.x));',\n        'return new numeric.T(neg(x.x),neg(x.y));',\n        'var neg = numeric.neg;');\nnumeric.T.prototype.sin = numeric.Tunop(\n        'return new numeric.T(numeric.sin(x.x))',\n        'return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));');\nnumeric.T.prototype.cos = numeric.Tunop(\n        'return new numeric.T(numeric.cos(x.x))',\n        'return x.exp().add(x.neg().exp()).div(2);');\nnumeric.T.prototype.abs = numeric.Tunop(\n        'return new numeric.T(numeric.abs(x.x));',\n        'return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));',\n        'var mul = numeric.mul;');\nnumeric.T.prototype.log = numeric.Tunop(\n        'return new numeric.T(numeric.log(x.x));',\n        'var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\\n'+\n        'return new numeric.T(numeric.log(r.x),theta.x);');\nnumeric.T.prototype.norm2 = numeric.Tunop(\n        'return numeric.norm2(x.x);',\n        'var f = numeric.norm2Squared;\\n'+\n        'return Math.sqrt(f(x.x)+f(x.y));');\nnumeric.T.prototype.inv = function inv() {\n    var A = this;\n    if(typeof A.y === \"undefined\") { return new numeric.T(numeric.inv(A.x)); }\n    var n = A.x.length, i, j, k;\n    var Rx = numeric.identity(n),Ry = numeric.rep([n,n],0);\n    var Ax = numeric.clone(A.x), Ay = numeric.clone(A.y);\n    var Aix, Aiy, Ajx, Ajy, Rix, Riy, Rjx, Rjy;\n    var i,j,k,d,d1,ax,ay,bx,by,temp;\n    for(i=0;i<n;i++) {\n        ax = Ax[i][i]; ay = Ay[i][i];\n        d = ax*ax+ay*ay;\n        k = i;\n        for(j=i+1;j<n;j++) {\n            ax = Ax[j][i]; ay = Ay[j][i];\n            d1 = ax*ax+ay*ay;\n            if(d1 > d) { k=j; d = d1; }\n        }\n        if(k!==i) {\n            temp = Ax[i]; Ax[i] = Ax[k]; Ax[k] = temp;\n            temp = Ay[i]; Ay[i] = Ay[k]; Ay[k] = temp;\n            temp = Rx[i]; Rx[i] = Rx[k]; Rx[k] = temp;\n            temp = Ry[i]; Ry[i] = Ry[k]; Ry[k] = temp;\n        }\n        Aix = Ax[i]; Aiy = Ay[i];\n        Rix = Rx[i]; Riy = Ry[i];\n        ax = Aix[i]; ay = Aiy[i];\n        for(j=i+1;j<n;j++) {\n            bx = Aix[j]; by = Aiy[j];\n            Aix[j] = (bx*ax+by*ay)/d;\n            Aiy[j] = (by*ax-bx*ay)/d;\n        }\n        for(j=0;j<n;j++) {\n            bx = Rix[j]; by = Riy[j];\n            Rix[j] = (bx*ax+by*ay)/d;\n            Riy[j] = (by*ax-bx*ay)/d;\n        }\n        for(j=i+1;j<n;j++) {\n            Ajx = Ax[j]; Ajy = Ay[j];\n            Rjx = Rx[j]; Rjy = Ry[j];\n            ax = Ajx[i]; ay = Ajy[i];\n            for(k=i+1;k<n;k++) {\n                bx = Aix[k]; by = Aiy[k];\n                Ajx[k] -= bx*ax-by*ay;\n                Ajy[k] -= by*ax+bx*ay;\n            }\n            for(k=0;k<n;k++) {\n                bx = Rix[k]; by = Riy[k];\n                Rjx[k] -= bx*ax-by*ay;\n                Rjy[k] -= by*ax+bx*ay;\n            }\n        }\n    }\n    for(i=n-1;i>0;i--) {\n        Rix = Rx[i]; Riy = Ry[i];\n        for(j=i-1;j>=0;j--) {\n            Rjx = Rx[j]; Rjy = Ry[j];\n            ax = Ax[j][i]; ay = Ay[j][i];\n            for(k=n-1;k>=0;k--) {\n                bx = Rix[k]; by = Riy[k];\n                Rjx[k] -= ax*bx - ay*by;\n                Rjy[k] -= ax*by + ay*bx;\n            }\n        }\n    }\n    return new numeric.T(Rx,Ry);\n}\nnumeric.T.prototype.get = function get(i) {\n    var x = this.x, y = this.y, k = 0, ik, n = i.length;\n    if(y) {\n        while(k<n) {\n            ik = i[k];\n            x = x[ik];\n            y = y[ik];\n            k++;\n        }\n        return new numeric.T(x,y);\n    }\n    while(k<n) {\n        ik = i[k];\n        x = x[ik];\n        k++;\n    }\n    return new numeric.T(x);\n}\nnumeric.T.prototype.set = function set(i,v) {\n    var x = this.x, y = this.y, k = 0, ik, n = i.length, vx = v.x, vy = v.y;\n    if(n===0) {\n        if(vy) { this.y = vy; }\n        else if(y) { this.y = undefined; }\n        this.x = x;\n        return this;\n    }\n    if(vy) {\n        if(y) { /* ok */ }\n        else {\n            y = numeric.rep(numeric.dim(x),0);\n            this.y = y;\n        }\n        while(k<n-1) {\n            ik = i[k];\n            x = x[ik];\n            y = y[ik];\n            k++;\n        }\n        ik = i[k];\n        x[ik] = vx;\n        y[ik] = vy;\n        return this;\n    }\n    if(y) {\n        while(k<n-1) {\n            ik = i[k];\n            x = x[ik];\n            y = y[ik];\n            k++;\n        }\n        ik = i[k];\n        x[ik] = vx;\n        if(vx instanceof Array) y[ik] = numeric.rep(numeric.dim(vx),0);\n        else y[ik] = 0;\n        return this;\n    }\n    while(k<n-1) {\n        ik = i[k];\n        x = x[ik];\n        k++;\n    }\n    ik = i[k];\n    x[ik] = vx;\n    return this;\n}\nnumeric.T.prototype.getRows = function getRows(i0,i1) {\n    var n = i1-i0+1, j;\n    var rx = Array(n), ry, x = this.x, y = this.y;\n    for(j=i0;j<=i1;j++) { rx[j-i0] = x[j]; }\n    if(y) {\n        ry = Array(n);\n        for(j=i0;j<=i1;j++) { ry[j-i0] = y[j]; }\n        return new numeric.T(rx,ry);\n    }\n    return new numeric.T(rx);\n}\nnumeric.T.prototype.setRows = function setRows(i0,i1,A) {\n    var j;\n    var rx = this.x, ry = this.y, x = A.x, y = A.y;\n    for(j=i0;j<=i1;j++) { rx[j] = x[j-i0]; }\n    if(y) {\n        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }\n        for(j=i0;j<=i1;j++) { ry[j] = y[j-i0]; }\n    } else if(ry) {\n        for(j=i0;j<=i1;j++) { ry[j] = numeric.rep([x[j-i0].length],0); }\n    }\n    return this;\n}\nnumeric.T.prototype.getRow = function getRow(k) {\n    var x = this.x, y = this.y;\n    if(y) { return new numeric.T(x[k],y[k]); }\n    return new numeric.T(x[k]);\n}\nnumeric.T.prototype.setRow = function setRow(i,v) {\n    var rx = this.x, ry = this.y, x = v.x, y = v.y;\n    rx[i] = x;\n    if(y) {\n        if(!ry) { ry = numeric.rep(numeric.dim(rx),0); this.y = ry; }\n        ry[i] = y;\n    } else if(ry) {\n        ry = numeric.rep([x.length],0);\n    }\n    return this;\n}\n\nnumeric.T.prototype.getBlock = function getBlock(from,to) {\n    var x = this.x, y = this.y, b = numeric.getBlock;\n    if(y) { return new numeric.T(b(x,from,to),b(y,from,to)); }\n    return new numeric.T(b(x,from,to));\n}\nnumeric.T.prototype.setBlock = function setBlock(from,to,A) {\n    if(!(A instanceof numeric.T)) A = new numeric.T(A);\n    var x = this.x, y = this.y, b = numeric.setBlock, Ax = A.x, Ay = A.y;\n    if(Ay) {\n        if(!y) { this.y = numeric.rep(numeric.dim(this),0); y = this.y; }\n        b(x,from,to,Ax);\n        b(y,from,to,Ay);\n        return this;\n    }\n    b(x,from,to,Ax);\n    if(y) b(y,from,to,numeric.rep(numeric.dim(Ax),0));\n}\nnumeric.T.rep = function rep(s,v) {\n    var T = numeric.T;\n    if(!(v instanceof T)) v = new T(v);\n    var x = v.x, y = v.y, r = numeric.rep;\n    if(y) return new T(r(s,x),r(s,y));\n    return new T(r(s,x));\n}\nnumeric.T.diag = function diag(d) {\n    if(!(d instanceof numeric.T)) d = new numeric.T(d);\n    var x = d.x, y = d.y, diag = numeric.diag;\n    if(y) return new numeric.T(diag(x),diag(y));\n    return new numeric.T(diag(x));\n}\nnumeric.T.eig = function eig() {\n    if(this.y) { throw new Error('eig: not implemented for complex matrices.'); }\n    return numeric.eig(this.x);\n}\nnumeric.T.identity = function identity(n) { return new numeric.T(numeric.identity(n)); }\nnumeric.T.prototype.getDiag = function getDiag() {\n    var n = numeric;\n    var x = this.x, y = this.y;\n    if(y) { return new n.T(n.getDiag(x),n.getDiag(y)); }\n    return new n.T(n.getDiag(x));\n}\n\n// 4. Eigenvalues of real matrices\n\nnumeric.house = function house(x) {\n    var v = numeric.clone(x);\n    var s = x[0] >= 0 ? 1 : -1;\n    var alpha = s*numeric.norm2(x);\n    v[0] += alpha;\n    var foo = numeric.norm2(v);\n    if(foo === 0) { /* this should not happen */ throw new Error('eig: internal error'); }\n    return numeric.div(v,foo);\n}\n\nnumeric.toUpperHessenberg = function toUpperHessenberg(me) {\n    var s = numeric.dim(me);\n    if(s.length !== 2 || s[0] !== s[1]) { throw new Error('numeric: toUpperHessenberg() only works on square matrices'); }\n    var m = s[0], i,j,k,x,v,A = numeric.clone(me),B,C,Ai,Ci,Q = numeric.identity(m),Qi;\n    for(j=0;j<m-2;j++) {\n        x = Array(m-j-1);\n        for(i=j+1;i<m;i++) { x[i-j-1] = A[i][j]; }\n        if(numeric.norm2(x)>0) {\n            v = numeric.house(x);\n            B = numeric.getBlock(A,[j+1,j],[m-1,m-1]);\n            C = numeric.tensor(v,numeric.dot(v,B));\n            for(i=j+1;i<m;i++) { Ai = A[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Ai[k] -= 2*Ci[k-j]; }\n            B = numeric.getBlock(A,[0,j+1],[m-1,m-1]);\n            C = numeric.tensor(numeric.dot(B,v),v);\n            for(i=0;i<m;i++) { Ai = A[i]; Ci = C[i]; for(k=j+1;k<m;k++) Ai[k] -= 2*Ci[k-j-1]; }\n            B = Array(m-j-1);\n            for(i=j+1;i<m;i++) B[i-j-1] = Q[i];\n            C = numeric.tensor(v,numeric.dot(v,B));\n            for(i=j+1;i<m;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }\n        }\n    }\n    return {H:A, Q:Q};\n}\n\nnumeric.epsilon = 2.220446049250313e-16;\n\nnumeric.QRFrancis = function(H,maxiter) {\n    if(typeof maxiter === \"undefined\") { maxiter = 10000; }\n    H = numeric.clone(H);\n    var H0 = numeric.clone(H);\n    var s = numeric.dim(H),m=s[0],x,v,a,b,c,d,det,tr, Hloc, Q = numeric.identity(m), Qi, Hi, B, C, Ci,i,j,k,iter;\n    if(m<3) { return {Q:Q, B:[ [0,m-1] ]}; }\n    var epsilon = numeric.epsilon;\n    for(iter=0;iter<maxiter;iter++) {\n        for(j=0;j<m-1;j++) {\n            if(Math.abs(H[j+1][j]) < epsilon*(Math.abs(H[j][j])+Math.abs(H[j+1][j+1]))) {\n                var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[j,j]),maxiter);\n                var QH2 = numeric.QRFrancis(numeric.getBlock(H,[j+1,j+1],[m-1,m-1]),maxiter);\n                B = Array(j+1);\n                for(i=0;i<=j;i++) { B[i] = Q[i]; }\n                C = numeric.dot(QH1.Q,B);\n                for(i=0;i<=j;i++) { Q[i] = C[i]; }\n                B = Array(m-j-1);\n                for(i=j+1;i<m;i++) { B[i-j-1] = Q[i]; }\n                C = numeric.dot(QH2.Q,B);\n                for(i=j+1;i<m;i++) { Q[i] = C[i-j-1]; }\n                return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,j+1))};\n            }\n        }\n        a = H[m-2][m-2]; b = H[m-2][m-1];\n        c = H[m-1][m-2]; d = H[m-1][m-1];\n        tr = a+d;\n        det = (a*d-b*c);\n        Hloc = numeric.getBlock(H, [0,0], [2,2]);\n        if(tr*tr>=4*det) {\n            var s1,s2;\n            s1 = 0.5*(tr+Math.sqrt(tr*tr-4*det));\n            s2 = 0.5*(tr-Math.sqrt(tr*tr-4*det));\n            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),\n                                           numeric.mul(Hloc,s1+s2)),\n                               numeric.diag(numeric.rep([3],s1*s2)));\n        } else {\n            Hloc = numeric.add(numeric.sub(numeric.dot(Hloc,Hloc),\n                                           numeric.mul(Hloc,tr)),\n                               numeric.diag(numeric.rep([3],det)));\n        }\n        x = [Hloc[0][0],Hloc[1][0],Hloc[2][0]];\n        v = numeric.house(x);\n        B = [H[0],H[1],H[2]];\n        C = numeric.tensor(v,numeric.dot(v,B));\n        for(i=0;i<3;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<m;k++) Hi[k] -= 2*Ci[k]; }\n        B = numeric.getBlock(H, [0,0],[m-1,2]);\n        C = numeric.tensor(numeric.dot(B,v),v);\n        for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=0;k<3;k++) Hi[k] -= 2*Ci[k]; }\n        B = [Q[0],Q[1],Q[2]];\n        C = numeric.tensor(v,numeric.dot(v,B));\n        for(i=0;i<3;i++) { Qi = Q[i]; Ci = C[i]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }\n        var J;\n        for(j=0;j<m-2;j++) {\n            for(k=j;k<=j+1;k++) {\n                if(Math.abs(H[k+1][k]) < epsilon*(Math.abs(H[k][k])+Math.abs(H[k+1][k+1]))) {\n                    var QH1 = numeric.QRFrancis(numeric.getBlock(H,[0,0],[k,k]),maxiter);\n                    var QH2 = numeric.QRFrancis(numeric.getBlock(H,[k+1,k+1],[m-1,m-1]),maxiter);\n                    B = Array(k+1);\n                    for(i=0;i<=k;i++) { B[i] = Q[i]; }\n                    C = numeric.dot(QH1.Q,B);\n                    for(i=0;i<=k;i++) { Q[i] = C[i]; }\n                    B = Array(m-k-1);\n                    for(i=k+1;i<m;i++) { B[i-k-1] = Q[i]; }\n                    C = numeric.dot(QH2.Q,B);\n                    for(i=k+1;i<m;i++) { Q[i] = C[i-k-1]; }\n                    return {Q:Q,B:QH1.B.concat(numeric.add(QH2.B,k+1))};\n                }\n            }\n            J = Math.min(m-1,j+3);\n            x = Array(J-j);\n            for(i=j+1;i<=J;i++) { x[i-j-1] = H[i][j]; }\n            v = numeric.house(x);\n            B = numeric.getBlock(H, [j+1,j],[J,m-1]);\n            C = numeric.tensor(v,numeric.dot(v,B));\n            for(i=j+1;i<=J;i++) { Hi = H[i]; Ci = C[i-j-1]; for(k=j;k<m;k++) Hi[k] -= 2*Ci[k-j]; }\n            B = numeric.getBlock(H, [0,j+1],[m-1,J]);\n            C = numeric.tensor(numeric.dot(B,v),v);\n            for(i=0;i<m;i++) { Hi = H[i]; Ci = C[i]; for(k=j+1;k<=J;k++) Hi[k] -= 2*Ci[k-j-1]; }\n            B = Array(J-j);\n            for(i=j+1;i<=J;i++) B[i-j-1] = Q[i];\n            C = numeric.tensor(v,numeric.dot(v,B));\n            for(i=j+1;i<=J;i++) { Qi = Q[i]; Ci = C[i-j-1]; for(k=0;k<m;k++) Qi[k] -= 2*Ci[k]; }\n        }\n    }\n    throw new Error('numeric: eigenvalue iteration does not converge -- increase maxiter?');\n}\n\nnumeric.eig = function eig(A,maxiter) {\n    var QH = numeric.toUpperHessenberg(A);\n    var QB = numeric.QRFrancis(QH.H,maxiter);\n    var T = numeric.T;\n    var n = A.length,i,k,flag = false,B = QB.B,H = numeric.dot(QB.Q,numeric.dot(QH.H,numeric.transpose(QB.Q)));\n    var Q = new T(numeric.dot(QB.Q,QH.Q)),Q0;\n    var m = B.length,j;\n    var a,b,c,d,p1,p2,disc,x,y,p,q,n1,n2;\n    var sqrt = Math.sqrt;\n    for(k=0;k<m;k++) {\n        i = B[k][0];\n        if(i === B[k][1]) {\n            // nothing\n        } else {\n            j = i+1;\n            a = H[i][i];\n            b = H[i][j];\n            c = H[j][i];\n            d = H[j][j];\n            if(b === 0 && c === 0) continue;\n            p1 = -a-d;\n            p2 = a*d-b*c;\n            disc = p1*p1-4*p2;\n            if(disc>=0) {\n                if(p1<0) x = -0.5*(p1-sqrt(disc));\n                else     x = -0.5*(p1+sqrt(disc));\n                n1 = (a-x)*(a-x)+b*b;\n                n2 = c*c+(d-x)*(d-x);\n                if(n1>n2) {\n                    n1 = sqrt(n1);\n                    p = (a-x)/n1;\n                    q = b/n1;\n                } else {\n                    n2 = sqrt(n2);\n                    p = c/n2;\n                    q = (d-x)/n2;\n                }\n                Q0 = new T([[q,-p],[p,q]]);\n                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));\n            } else {\n                x = -0.5*p1;\n                y = 0.5*sqrt(-disc);\n                n1 = (a-x)*(a-x)+b*b;\n                n2 = c*c+(d-x)*(d-x);\n                if(n1>n2) {\n                    n1 = sqrt(n1+y*y);\n                    p = (a-x)/n1;\n                    q = b/n1;\n                    x = 0;\n                    y /= n1;\n                } else {\n                    n2 = sqrt(n2+y*y);\n                    p = c/n2;\n                    q = (d-x)/n2;\n                    x = y/n2;\n                    y = 0;\n                }\n                Q0 = new T([[q,-p],[p,q]],[[x,y],[y,-x]]);\n                Q.setRows(i,j,Q0.dot(Q.getRows(i,j)));\n            }\n        }\n    }\n    var R = Q.dot(A).dot(Q.transjugate()), n = A.length, E = numeric.T.identity(n);\n    for(j=0;j<n;j++) {\n        if(j>0) {\n            for(k=j-1;k>=0;k--) {\n                var Rk = R.get([k,k]), Rj = R.get([j,j]);\n                if(numeric.neq(Rk.x,Rj.x) || numeric.neq(Rk.y,Rj.y)) {\n                    x = R.getRow(k).getBlock([k],[j-1]);\n                    y = E.getRow(j).getBlock([k],[j-1]);\n                    E.set([j,k],(R.get([k,j]).neg().sub(x.dot(y))).div(Rk.sub(Rj)));\n                } else {\n                    E.setRow(j,E.getRow(k));\n                    continue;\n                }\n            }\n        }\n    }\n    for(j=0;j<n;j++) {\n        x = E.getRow(j);\n        E.setRow(j,x.div(x.norm2()));\n    }\n    E = E.transpose();\n    E = Q.transjugate().dot(E);\n    return { lambda:R.getDiag(), E:E };\n};\n\n// 5. Compressed Column Storage matrices\nnumeric.ccsSparse = function ccsSparse(A) {\n    var m = A.length,n,foo, i,j, counts = [];\n    for(i=m-1;i!==-1;--i) {\n        foo = A[i];\n        for(j in foo) {\n            j = parseInt(j);\n            while(j>=counts.length) counts[counts.length] = 0;\n            if(foo[j]!==0) counts[j]++;\n        }\n    }\n    var n = counts.length;\n    var Ai = Array(n+1);\n    Ai[0] = 0;\n    for(i=0;i<n;++i) Ai[i+1] = Ai[i] + counts[i];\n    var Aj = Array(Ai[n]), Av = Array(Ai[n]);\n    for(i=m-1;i!==-1;--i) {\n        foo = A[i];\n        for(j in foo) {\n            if(foo[j]!==0) {\n                counts[j]--;\n                Aj[Ai[j]+counts[j]] = i;\n                Av[Ai[j]+counts[j]] = foo[j];\n            }\n        }\n    }\n    return [Ai,Aj,Av];\n}\nnumeric.ccsFull = function ccsFull(A) {\n    var Ai = A[0], Aj = A[1], Av = A[2], s = numeric.ccsDim(A), m = s[0], n = s[1], i,j,j0,j1,k;\n    var B = numeric.rep([m,n],0);\n    for(i=0;i<n;i++) {\n        j0 = Ai[i];\n        j1 = Ai[i+1];\n        for(j=j0;j<j1;++j) { B[Aj[j]][i] = Av[j]; }\n    }\n    return B;\n}\nnumeric.ccsTSolve = function ccsTSolve(A,b,x,bj,xj) {\n    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, max = Math.max,n=0;\n    if(typeof bj === \"undefined\") x = numeric.rep([m],0);\n    if(typeof bj === \"undefined\") bj = numeric.linspace(0,x.length-1);\n    if(typeof xj === \"undefined\") xj = [];\n    function dfs(j) {\n        var k;\n        if(x[j] !== 0) return;\n        x[j] = 1;\n        for(k=Ai[j];k<Ai[j+1];++k) dfs(Aj[k]);\n        xj[n] = j;\n        ++n;\n    }\n    var i,j,j0,j1,k,l,l0,l1,a;\n    for(i=bj.length-1;i!==-1;--i) { dfs(bj[i]); }\n    xj.length = n;\n    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }\n    for(i=bj.length-1;i!==-1;--i) { j = bj[i]; x[j] = b[j]; }\n    for(i=xj.length-1;i!==-1;--i) {\n        j = xj[i];\n        j0 = Ai[j];\n        j1 = max(Ai[j+1],j0);\n        for(k=j0;k!==j1;++k) { if(Aj[k] === j) { x[j] /= Av[k]; break; } }\n        a = x[j];\n        for(k=j0;k!==j1;++k) {\n            l = Aj[k];\n            if(l !== j) x[l] -= a*Av[k];\n        }\n    }\n    return x;\n}\nnumeric.ccsDFS = function ccsDFS(n) {\n    this.k = Array(n);\n    this.k1 = Array(n);\n    this.j = Array(n);\n}\nnumeric.ccsDFS.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv) {\n    var m = 0,foo,n=xj.length;\n    var k = this.k, k1 = this.k1, j = this.j,km,k11;\n    if(x[J]!==0) return;\n    x[J] = 1;\n    j[0] = J;\n    k[0] = km = Ai[J];\n    k1[0] = k11 = Ai[J+1];\n    while(1) {\n        if(km >= k11) {\n            xj[n] = j[m];\n            if(m===0) return;\n            ++n;\n            --m;\n            km = k[m];\n            k11 = k1[m];\n        } else {\n            foo = Pinv[Aj[km]];\n            if(x[foo] === 0) {\n                x[foo] = 1;\n                k[m] = km;\n                ++m;\n                j[m] = foo;\n                km = Ai[foo];\n                k1[m] = k11 = Ai[foo+1];\n            } else ++km;\n        }\n    }\n}\nnumeric.ccsLPSolve = function ccsLPSolve(A,B,x,xj,I,Pinv,dfs) {\n    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;\n    var Bi = B[0], Bj = B[1], Bv = B[2];\n    \n    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;\n    i0 = Bi[I];\n    i1 = Bi[I+1];\n    xj.length = 0;\n    for(i=i0;i<i1;++i) { dfs.dfs(Pinv[Bj[i]],Ai,Aj,x,xj,Pinv); }\n    for(i=xj.length-1;i!==-1;--i) { x[xj[i]] = 0; }\n    for(i=i0;i!==i1;++i) { j = Pinv[Bj[i]]; x[j] = Bv[i]; }\n    for(i=xj.length-1;i!==-1;--i) {\n        j = xj[i];\n        j0 = Ai[j];\n        j1 = Ai[j+1];\n        for(k=j0;k<j1;++k) { if(Pinv[Aj[k]] === j) { x[j] /= Av[k]; break; } }\n        a = x[j];\n        for(k=j0;k<j1;++k) {\n            l = Pinv[Aj[k]];\n            if(l !== j) x[l] -= a*Av[k];\n        }\n    }\n    return x;\n}\nnumeric.ccsLUP1 = function ccsLUP1(A,threshold) {\n    var m = A[0].length-1;\n    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];\n    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];\n    var x = numeric.rep([m],0), xj = numeric.rep([m],0);\n    var i,j,k,j0,j1,a,e,c,d,K;\n    var sol = numeric.ccsLPSolve, max = Math.max, abs = Math.abs;\n    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);\n    var dfs = new numeric.ccsDFS(m);\n    if(typeof threshold === \"undefined\") { threshold = 1; }\n    for(i=0;i<m;++i) {\n        sol(L,A,x,xj,i,Pinv,dfs);\n        a = -1;\n        e = -1;\n        for(j=xj.length-1;j!==-1;--j) {\n            k = xj[j];\n            if(k <= i) continue;\n            c = abs(x[k]);\n            if(c > a) { e = k; a = c; }\n        }\n        if(abs(x[i])<threshold*a) {\n            j = P[i];\n            a = P[e];\n            P[i] = a; Pinv[a] = i;\n            P[e] = j; Pinv[j] = e;\n            a = x[i]; x[i] = x[e]; x[e] = a;\n        }\n        a = Li[i];\n        e = Ui[i];\n        d = x[i];\n        Lj[a] = P[i];\n        Lv[a] = 1;\n        ++a;\n        for(j=xj.length-1;j!==-1;--j) {\n            k = xj[j];\n            c = x[k];\n            xj[j] = 0;\n            x[k] = 0;\n            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }\n            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }\n        }\n        Li[i+1] = a;\n        Ui[i+1] = e;\n    }\n    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }\n    return {L:L, U:U, P:P, Pinv:Pinv};\n}\nnumeric.ccsDFS0 = function ccsDFS0(n) {\n    this.k = Array(n);\n    this.k1 = Array(n);\n    this.j = Array(n);\n}\nnumeric.ccsDFS0.prototype.dfs = function dfs(J,Ai,Aj,x,xj,Pinv,P) {\n    var m = 0,foo,n=xj.length;\n    var k = this.k, k1 = this.k1, j = this.j,km,k11;\n    if(x[J]!==0) return;\n    x[J] = 1;\n    j[0] = J;\n    k[0] = km = Ai[Pinv[J]];\n    k1[0] = k11 = Ai[Pinv[J]+1];\n    while(1) {\n        if(isNaN(km)) throw new Error(\"Ow!\");\n        if(km >= k11) {\n            xj[n] = Pinv[j[m]];\n            if(m===0) return;\n            ++n;\n            --m;\n            km = k[m];\n            k11 = k1[m];\n        } else {\n            foo = Aj[km];\n            if(x[foo] === 0) {\n                x[foo] = 1;\n                k[m] = km;\n                ++m;\n                j[m] = foo;\n                foo = Pinv[foo];\n                km = Ai[foo];\n                k1[m] = k11 = Ai[foo+1];\n            } else ++km;\n        }\n    }\n}\nnumeric.ccsLPSolve0 = function ccsLPSolve0(A,B,y,xj,I,Pinv,P,dfs) {\n    var Ai = A[0], Aj = A[1], Av = A[2],m = Ai.length-1, n=0;\n    var Bi = B[0], Bj = B[1], Bv = B[2];\n    \n    var i,i0,i1,j,J,j0,j1,k,l,l0,l1,a;\n    i0 = Bi[I];\n    i1 = Bi[I+1];\n    xj.length = 0;\n    for(i=i0;i<i1;++i) { dfs.dfs(Bj[i],Ai,Aj,y,xj,Pinv,P); }\n    for(i=xj.length-1;i!==-1;--i) { j = xj[i]; y[P[j]] = 0; }\n    for(i=i0;i!==i1;++i) { j = Bj[i]; y[j] = Bv[i]; }\n    for(i=xj.length-1;i!==-1;--i) {\n        j = xj[i];\n        l = P[j];\n        j0 = Ai[j];\n        j1 = Ai[j+1];\n        for(k=j0;k<j1;++k) { if(Aj[k] === l) { y[l] /= Av[k]; break; } }\n        a = y[l];\n        for(k=j0;k<j1;++k) y[Aj[k]] -= a*Av[k];\n        y[l] = a;\n    }\n}\nnumeric.ccsLUP0 = function ccsLUP0(A,threshold) {\n    var m = A[0].length-1;\n    var L = [numeric.rep([m+1],0),[],[]], U = [numeric.rep([m+1], 0),[],[]];\n    var Li = L[0], Lj = L[1], Lv = L[2], Ui = U[0], Uj = U[1], Uv = U[2];\n    var y = numeric.rep([m],0), xj = numeric.rep([m],0);\n    var i,j,k,j0,j1,a,e,c,d,K;\n    var sol = numeric.ccsLPSolve0, max = Math.max, abs = Math.abs;\n    var P = numeric.linspace(0,m-1),Pinv = numeric.linspace(0,m-1);\n    var dfs = new numeric.ccsDFS0(m);\n    if(typeof threshold === \"undefined\") { threshold = 1; }\n    for(i=0;i<m;++i) {\n        sol(L,A,y,xj,i,Pinv,P,dfs);\n        a = -1;\n        e = -1;\n        for(j=xj.length-1;j!==-1;--j) {\n            k = xj[j];\n            if(k <= i) continue;\n            c = abs(y[P[k]]);\n            if(c > a) { e = k; a = c; }\n        }\n        if(abs(y[P[i]])<threshold*a) {\n            j = P[i];\n            a = P[e];\n            P[i] = a; Pinv[a] = i;\n            P[e] = j; Pinv[j] = e;\n        }\n        a = Li[i];\n        e = Ui[i];\n        d = y[P[i]];\n        Lj[a] = P[i];\n        Lv[a] = 1;\n        ++a;\n        for(j=xj.length-1;j!==-1;--j) {\n            k = xj[j];\n            c = y[P[k]];\n            xj[j] = 0;\n            y[P[k]] = 0;\n            if(k<=i) { Uj[e] = k; Uv[e] = c;   ++e; }\n            else     { Lj[a] = P[k]; Lv[a] = c/d; ++a; }\n        }\n        Li[i+1] = a;\n        Ui[i+1] = e;\n    }\n    for(j=Lj.length-1;j!==-1;--j) { Lj[j] = Pinv[Lj[j]]; }\n    return {L:L, U:U, P:P, Pinv:Pinv};\n}\nnumeric.ccsLUP = numeric.ccsLUP0;\n\nnumeric.ccsDim = function ccsDim(A) { return [numeric.sup(A[1])+1,A[0].length-1]; }\nnumeric.ccsGetBlock = function ccsGetBlock(A,i,j) {\n    var s = numeric.ccsDim(A),m=s[0],n=s[1];\n    if(typeof i === \"undefined\") { i = numeric.linspace(0,m-1); }\n    else if(typeof i === \"number\") { i = [i]; }\n    if(typeof j === \"undefined\") { j = numeric.linspace(0,n-1); }\n    else if(typeof j === \"number\") { j = [j]; }\n    var p,p0,p1,P = i.length,q,Q = j.length,r,jq,ip;\n    var Bi = numeric.rep([n],0), Bj=[], Bv=[], B = [Bi,Bj,Bv];\n    var Ai = A[0], Aj = A[1], Av = A[2];\n    var x = numeric.rep([m],0),count=0,flags = numeric.rep([m],0);\n    for(q=0;q<Q;++q) {\n        jq = j[q];\n        var q0 = Ai[jq];\n        var q1 = Ai[jq+1];\n        for(p=q0;p<q1;++p) {\n            r = Aj[p];\n            flags[r] = 1;\n            x[r] = Av[p];\n        }\n        for(p=0;p<P;++p) {\n            ip = i[p];\n            if(flags[ip]) {\n                Bj[count] = p;\n                Bv[count] = x[i[p]];\n                ++count;\n            }\n        }\n        for(p=q0;p<q1;++p) {\n            r = Aj[p];\n            flags[r] = 0;\n        }\n        Bi[q+1] = count;\n    }\n    return B;\n}\n\nnumeric.ccsDot = function ccsDot(A,B) {\n    var Ai = A[0], Aj = A[1], Av = A[2];\n    var Bi = B[0], Bj = B[1], Bv = B[2];\n    var sA = numeric.ccsDim(A), sB = numeric.ccsDim(B);\n    var m = sA[0], n = sA[1], o = sB[1];\n    var x = numeric.rep([m],0), flags = numeric.rep([m],0), xj = Array(m);\n    var Ci = numeric.rep([o],0), Cj = [], Cv = [], C = [Ci,Cj,Cv];\n    var i,j,k,j0,j1,i0,i1,l,p,a,b;\n    for(k=0;k!==o;++k) {\n        j0 = Bi[k];\n        j1 = Bi[k+1];\n        p = 0;\n        for(j=j0;j<j1;++j) {\n            a = Bj[j];\n            b = Bv[j];\n            i0 = Ai[a];\n            i1 = Ai[a+1];\n            for(i=i0;i<i1;++i) {\n                l = Aj[i];\n                if(flags[l]===0) {\n                    xj[p] = l;\n                    flags[l] = 1;\n                    p = p+1;\n                }\n                x[l] = x[l] + Av[i]*b;\n            }\n        }\n        j0 = Ci[k];\n        j1 = j0+p;\n        Ci[k+1] = j1;\n        for(j=p-1;j!==-1;--j) {\n            b = j0+j;\n            i = xj[j];\n            Cj[b] = i;\n            Cv[b] = x[i];\n            flags[i] = 0;\n            x[i] = 0;\n        }\n        Ci[k+1] = Ci[k]+p;\n    }\n    return C;\n}\n\nnumeric.ccsLUPSolve = function ccsLUPSolve(LUP,B) {\n    var L = LUP.L, U = LUP.U, P = LUP.P;\n    var Bi = B[0];\n    var flag = false;\n    if(typeof Bi !== \"object\") { B = [[0,B.length],numeric.linspace(0,B.length-1),B]; Bi = B[0]; flag = true; }\n    var Bj = B[1], Bv = B[2];\n    var n = L[0].length-1, m = Bi.length-1;\n    var x = numeric.rep([n],0), xj = Array(n);\n    var b = numeric.rep([n],0), bj = Array(n);\n    var Xi = numeric.rep([m+1],0), Xj = [], Xv = [];\n    var sol = numeric.ccsTSolve;\n    var i,j,j0,j1,k,J,N=0;\n    for(i=0;i<m;++i) {\n        k = 0;\n        j0 = Bi[i];\n        j1 = Bi[i+1];\n        for(j=j0;j<j1;++j) { \n            J = LUP.Pinv[Bj[j]];\n            bj[k] = J;\n            b[J] = Bv[j];\n            ++k;\n        }\n        bj.length = k;\n        sol(L,b,x,bj,xj);\n        for(j=bj.length-1;j!==-1;--j) b[bj[j]] = 0;\n        sol(U,x,b,xj,bj);\n        if(flag) return b;\n        for(j=xj.length-1;j!==-1;--j) x[xj[j]] = 0;\n        for(j=bj.length-1;j!==-1;--j) {\n            J = bj[j];\n            Xj[N] = J;\n            Xv[N] = b[J];\n            b[J] = 0;\n            ++N;\n        }\n        Xi[i+1] = N;\n    }\n    return [Xi,Xj,Xv];\n}\n\nnumeric.ccsbinop = function ccsbinop(body,setup) {\n    if(typeof setup === \"undefined\") setup='';\n    return Function('X','Y',\n            'var Xi = X[0], Xj = X[1], Xv = X[2];\\n'+\n            'var Yi = Y[0], Yj = Y[1], Yv = Y[2];\\n'+\n            'var n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\\n'+\n            'var Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\\n'+\n            'var x = numeric.rep([m],0),y = numeric.rep([m],0);\\n'+\n            'var xk,yk,zk;\\n'+\n            'var i,j,j0,j1,k,p=0;\\n'+\n            setup+\n            'for(i=0;i<n;++i) {\\n'+\n            '  j0 = Xi[i]; j1 = Xi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) {\\n'+\n            '    k = Xj[j];\\n'+\n            '    x[k] = 1;\\n'+\n            '    Zj[p] = k;\\n'+\n            '    ++p;\\n'+\n            '  }\\n'+\n            '  j0 = Yi[i]; j1 = Yi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) {\\n'+\n            '    k = Yj[j];\\n'+\n            '    y[k] = Yv[j];\\n'+\n            '    if(x[k] === 0) {\\n'+\n            '      Zj[p] = k;\\n'+\n            '      ++p;\\n'+\n            '    }\\n'+\n            '  }\\n'+\n            '  Zi[i+1] = p;\\n'+\n            '  j0 = Xi[i]; j1 = Xi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\\n'+\n            '  j0 = Zi[i]; j1 = Zi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) {\\n'+\n            '    k = Zj[j];\\n'+\n            '    xk = x[k];\\n'+\n            '    yk = y[k];\\n'+\n            body+'\\n'+\n            '    Zv[j] = zk;\\n'+\n            '  }\\n'+\n            '  j0 = Xi[i]; j1 = Xi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\\n'+\n            '  j0 = Yi[i]; j1 = Yi[i+1];\\n'+\n            '  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\\n'+\n            '}\\n'+\n            'return [Zi,Zj,Zv];'\n            );\n};\n\n(function() {\n    var k,A,B,C;\n    for(k in numeric.ops2) {\n        if(isFinite(eval('1'+numeric.ops2[k]+'0'))) A = '[Y[0],Y[1],numeric.'+k+'(X,Y[2])]';\n        else A = 'NaN';\n        if(isFinite(eval('0'+numeric.ops2[k]+'1'))) B = '[X[0],X[1],numeric.'+k+'(X[2],Y)]';\n        else B = 'NaN';\n        if(isFinite(eval('1'+numeric.ops2[k]+'0')) && isFinite(eval('0'+numeric.ops2[k]+'1'))) C = 'numeric.ccs'+k+'MM(X,Y)';\n        else C = 'NaN';\n        numeric['ccs'+k+'MM'] = numeric.ccsbinop('zk = xk '+numeric.ops2[k]+'yk;');\n        numeric['ccs'+k] = Function('X','Y',\n                'if(typeof X === \"number\") return '+A+';\\n'+\n                'if(typeof Y === \"number\") return '+B+';\\n'+\n                'return '+C+';\\n'\n                );\n    }\n}());\n\nnumeric.ccsScatter = function ccsScatter(A) {\n    var Ai = A[0], Aj = A[1], Av = A[2];\n    var n = numeric.sup(Aj)+1,m=Ai.length;\n    var Ri = numeric.rep([n],0),Rj=Array(m), Rv = Array(m);\n    var counts = numeric.rep([n],0),i;\n    for(i=0;i<m;++i) counts[Aj[i]]++;\n    for(i=0;i<n;++i) Ri[i+1] = Ri[i] + counts[i];\n    var ptr = Ri.slice(0),k,Aii;\n    for(i=0;i<m;++i) {\n        Aii = Aj[i];\n        k = ptr[Aii];\n        Rj[k] = Ai[i];\n        Rv[k] = Av[i];\n        ptr[Aii]=ptr[Aii]+1;\n    }\n    return [Ri,Rj,Rv];\n}\n\nnumeric.ccsGather = function ccsGather(A) {\n    var Ai = A[0], Aj = A[1], Av = A[2];\n    var n = Ai.length-1,m = Aj.length;\n    var Ri = Array(m), Rj = Array(m), Rv = Array(m);\n    var i,j,j0,j1,p;\n    p=0;\n    for(i=0;i<n;++i) {\n        j0 = Ai[i];\n        j1 = Ai[i+1];\n        for(j=j0;j!==j1;++j) {\n            Rj[p] = i;\n            Ri[p] = Aj[j];\n            Rv[p] = Av[j];\n            ++p;\n        }\n    }\n    return [Ri,Rj,Rv];\n}\n\n// The following sparse linear algebra routines are deprecated.\n\nnumeric.sdim = function dim(A,ret,k) {\n    if(typeof ret === \"undefined\") { ret = []; }\n    if(typeof A !== \"object\") return ret;\n    if(typeof k === \"undefined\") { k=0; }\n    if(!(k in ret)) { ret[k] = 0; }\n    if(A.length > ret[k]) ret[k] = A.length;\n    var i;\n    for(i in A) {\n        if(A.hasOwnProperty(i)) dim(A[i],ret,k+1);\n    }\n    return ret;\n};\n\nnumeric.sclone = function clone(A,k,n) {\n    if(typeof k === \"undefined\") { k=0; }\n    if(typeof n === \"undefined\") { n = numeric.sdim(A).length; }\n    var i,ret = Array(A.length);\n    if(k === n-1) {\n        for(i in A) { if(A.hasOwnProperty(i)) ret[i] = A[i]; }\n        return ret;\n    }\n    for(i in A) {\n        if(A.hasOwnProperty(i)) ret[i] = clone(A[i],k+1,n);\n    }\n    return ret;\n}\n\nnumeric.sdiag = function diag(d) {\n    var n = d.length,i,ret = Array(n),i1,i2,i3;\n    for(i=n-1;i>=1;i-=2) {\n        i1 = i-1;\n        ret[i] = []; ret[i][i] = d[i];\n        ret[i1] = []; ret[i1][i1] = d[i1];\n    }\n    if(i===0) { ret[0] = []; ret[0][0] = d[i]; }\n    return ret;\n}\n\nnumeric.sidentity = function identity(n) { return numeric.sdiag(numeric.rep([n],1)); }\n\nnumeric.stranspose = function transpose(A) {\n    var ret = [], n = A.length, i,j,Ai;\n    for(i in A) {\n        if(!(A.hasOwnProperty(i))) continue;\n        Ai = A[i];\n        for(j in Ai) {\n            if(!(Ai.hasOwnProperty(j))) continue;\n            if(typeof ret[j] !== \"object\") { ret[j] = []; }\n            ret[j][i] = Ai[j];\n        }\n    }\n    return ret;\n}\n\nnumeric.sLUP = function LUP(A,tol) {\n    throw new Error(\"The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.\");\n};\n\nnumeric.sdotMM = function dotMM(A,B) {\n    var p = A.length, q = B.length, BT = numeric.stranspose(B), r = BT.length, Ai, BTk;\n    var i,j,k,accum;\n    var ret = Array(p),reti;\n    for(i=p-1;i>=0;i--) {\n        reti = [];\n        Ai = A[i];\n        for(k=r-1;k>=0;k--) {\n            accum = 0;\n            BTk = BT[k];\n            for(j in Ai) {\n                if(!(Ai.hasOwnProperty(j))) continue;\n                if(j in BTk) { accum += Ai[j]*BTk[j]; }\n            }\n            if(accum) reti[k] = accum;\n        }\n        ret[i] = reti;\n    }\n    return ret;\n}\n\nnumeric.sdotMV = function dotMV(A,x) {\n    var p = A.length, Ai, i,j;\n    var ret = Array(p), accum;\n    for(i=p-1;i>=0;i--) {\n        Ai = A[i];\n        accum = 0;\n        for(j in Ai) {\n            if(!(Ai.hasOwnProperty(j))) continue;\n            if(x[j]) accum += Ai[j]*x[j];\n        }\n        if(accum) ret[i] = accum;\n    }\n    return ret;\n}\n\nnumeric.sdotVM = function dotMV(x,A) {\n    var i,j,Ai,alpha;\n    var ret = [], accum;\n    for(i in x) {\n        if(!x.hasOwnProperty(i)) continue;\n        Ai = A[i];\n        alpha = x[i];\n        for(j in Ai) {\n            if(!Ai.hasOwnProperty(j)) continue;\n            if(!ret[j]) { ret[j] = 0; }\n            ret[j] += alpha*Ai[j];\n        }\n    }\n    return ret;\n}\n\nnumeric.sdotVV = function dotVV(x,y) {\n    var i,ret=0;\n    for(i in x) { if(x[i] && y[i]) ret+= x[i]*y[i]; }\n    return ret;\n}\n\nnumeric.sdot = function dot(A,B) {\n    var m = numeric.sdim(A).length, n = numeric.sdim(B).length;\n    var k = m*1000+n;\n    switch(k) {\n    case 0: return A*B;\n    case 1001: return numeric.sdotVV(A,B);\n    case 2001: return numeric.sdotMV(A,B);\n    case 1002: return numeric.sdotVM(A,B);\n    case 2002: return numeric.sdotMM(A,B);\n    default: throw new Error('numeric.sdot not implemented for tensors of order '+m+' and '+n);\n    }\n}\n\nnumeric.sscatter = function scatter(V) {\n    var n = V[0].length, Vij, i, j, m = V.length, A = [], Aj;\n    for(i=n-1;i>=0;--i) {\n        if(!V[m-1][i]) continue;\n        Aj = A;\n        for(j=0;j<m-2;j++) {\n            Vij = V[j][i];\n            if(!Aj[Vij]) Aj[Vij] = [];\n            Aj = Aj[Vij];\n        }\n        Aj[V[j][i]] = V[j+1][i];\n    }\n    return A;\n}\n\nnumeric.sgather = function gather(A,ret,k) {\n    if(typeof ret === \"undefined\") ret = [];\n    if(typeof k === \"undefined\") k = [];\n    var n,i,Ai;\n    n = k.length;\n    for(i in A) {\n        if(A.hasOwnProperty(i)) {\n            k[n] = parseInt(i);\n            Ai = A[i];\n            if(typeof Ai === \"number\") {\n                if(Ai) {\n                    if(ret.length === 0) {\n                        for(i=n+1;i>=0;--i) ret[i] = [];\n                    }\n                    for(i=n;i>=0;--i) ret[i].push(k[i]);\n                    ret[n+1].push(Ai);\n                }\n            } else gather(Ai,ret,k);\n        }\n    }\n    if(k.length>n) k.pop();\n    return ret;\n}\n\n// 6. Coordinate matrices\nnumeric.cLU = function LU(A) {\n    var I = A[0], J = A[1], V = A[2];\n    var p = I.length, m=0, i,j,k,a,b,c;\n    for(i=0;i<p;i++) if(I[i]>m) m=I[i];\n    m++;\n    var L = Array(m), U = Array(m), left = numeric.rep([m],Infinity), right = numeric.rep([m],-Infinity);\n    var Ui, Uj,alpha;\n    for(k=0;k<p;k++) {\n        i = I[k];\n        j = J[k];\n        if(j<left[i]) left[i] = j;\n        if(j>right[i]) right[i] = j;\n    }\n    for(i=0;i<m-1;i++) { if(right[i] > right[i+1]) right[i+1] = right[i]; }\n    for(i=m-1;i>=1;i--) { if(left[i]<left[i-1]) left[i-1] = left[i]; }\n    var countL = 0, countU = 0;\n    for(i=0;i<m;i++) {\n        U[i] = numeric.rep([right[i]-left[i]+1],0);\n        L[i] = numeric.rep([i-left[i]],0);\n        countL += i-left[i]+1;\n        countU += right[i]-i+1;\n    }\n    for(k=0;k<p;k++) { i = I[k]; U[i][J[k]-left[i]] = V[k]; }\n    for(i=0;i<m-1;i++) {\n        a = i-left[i];\n        Ui = U[i];\n        for(j=i+1;left[j]<=i && j<m;j++) {\n            b = i-left[j];\n            c = right[i]-i;\n            Uj = U[j];\n            alpha = Uj[b]/Ui[a];\n            if(alpha) {\n                for(k=1;k<=c;k++) { Uj[k+b] -= alpha*Ui[k+a]; }\n                L[j][i-left[j]] = alpha;\n            }\n        }\n    }\n    var Ui = [], Uj = [], Uv = [], Li = [], Lj = [], Lv = [];\n    var p,q,foo;\n    p=0; q=0;\n    for(i=0;i<m;i++) {\n        a = left[i];\n        b = right[i];\n        foo = U[i];\n        for(j=i;j<=b;j++) {\n            if(foo[j-a]) {\n                Ui[p] = i;\n                Uj[p] = j;\n                Uv[p] = foo[j-a];\n                p++;\n            }\n        }\n        foo = L[i];\n        for(j=a;j<i;j++) {\n            if(foo[j-a]) {\n                Li[q] = i;\n                Lj[q] = j;\n                Lv[q] = foo[j-a];\n                q++;\n            }\n        }\n        Li[q] = i;\n        Lj[q] = i;\n        Lv[q] = 1;\n        q++;\n    }\n    return {U:[Ui,Uj,Uv], L:[Li,Lj,Lv]};\n};\n\nnumeric.cLUsolve = function LUsolve(lu,b) {\n    var L = lu.L, U = lu.U, ret = numeric.clone(b);\n    var Li = L[0], Lj = L[1], Lv = L[2];\n    var Ui = U[0], Uj = U[1], Uv = U[2];\n    var p = Ui.length, q = Li.length;\n    var m = ret.length,i,j,k;\n    k = 0;\n    for(i=0;i<m;i++) {\n        while(Lj[k] < i) {\n            ret[i] -= Lv[k]*ret[Lj[k]];\n            k++;\n        }\n        k++;\n    }\n    k = p-1;\n    for(i=m-1;i>=0;i--) {\n        while(Uj[k] > i) {\n            ret[i] -= Uv[k]*ret[Uj[k]];\n            k--;\n        }\n        ret[i] /= Uv[k];\n        k--;\n    }\n    return ret;\n};\n\nnumeric.cgrid = function grid(n,shape) {\n    if(typeof n === \"number\") n = [n,n];\n    var ret = numeric.rep(n,-1);\n    var i,j,count;\n    if(typeof shape !== \"function\") {\n        switch(shape) {\n        case 'L':\n            shape = function(i,j) { return (i>=n[0]/2 || j<n[1]/2); }\n            break;\n        default:\n            shape = function(i,j) { return true; };\n            break;\n        }\n    }\n    count=0;\n    for(i=1;i<n[0]-1;i++) for(j=1;j<n[1]-1;j++) \n        if(shape(i,j)) {\n            ret[i][j] = count;\n            count++;\n        }\n    return ret;\n}\n\nnumeric.cdelsq = function delsq(g) {\n    var dir = [[-1,0],[0,-1],[0,1],[1,0]];\n    var s = numeric.dim(g), m = s[0], n = s[1], i,j,k,p,q;\n    var Li = [], Lj = [], Lv = [];\n    for(i=1;i<m-1;i++) for(j=1;j<n-1;j++) {\n        if(g[i][j]<0) continue;\n        for(k=0;k<4;k++) {\n            p = i+dir[k][0];\n            q = j+dir[k][1];\n            if(g[p][q]<0) continue;\n            Li.push(g[i][j]);\n            Lj.push(g[p][q]);\n            Lv.push(-1);\n        }\n        Li.push(g[i][j]);\n        Lj.push(g[i][j]);\n        Lv.push(4);\n    }\n    return [Li,Lj,Lv];\n}\n\nnumeric.cdotMV = function dotMV(A,x) {\n    var ret, Ai = A[0], Aj = A[1], Av = A[2],k,p=Ai.length,N;\n    N=0;\n    for(k=0;k<p;k++) { if(Ai[k]>N) N = Ai[k]; }\n    N++;\n    ret = numeric.rep([N],0);\n    for(k=0;k<p;k++) { ret[Ai[k]]+=Av[k]*x[Aj[k]]; }\n    return ret;\n}\n\n// 7. Splines\n\nnumeric.Spline = function Spline(x,yl,yr,kl,kr) { this.x = x; this.yl = yl; this.yr = yr; this.kl = kl; this.kr = kr; }\nnumeric.Spline.prototype._at = function _at(x1,p) {\n    var x = this.x;\n    var yl = this.yl;\n    var yr = this.yr;\n    var kl = this.kl;\n    var kr = this.kr;\n    var x1,a,b,t;\n    var add = numeric.add, sub = numeric.sub, mul = numeric.mul;\n    a = sub(mul(kl[p],x[p+1]-x[p]),sub(yr[p+1],yl[p]));\n    b = add(mul(kr[p+1],x[p]-x[p+1]),sub(yr[p+1],yl[p]));\n    t = (x1-x[p])/(x[p+1]-x[p]);\n    var s = t*(1-t);\n    return add(add(add(mul(1-t,yl[p]),mul(t,yr[p+1])),mul(a,s*(1-t))),mul(b,s*t));\n}\nnumeric.Spline.prototype.at = function at(x0) {\n    if(typeof x0 === \"number\") {\n        var x = this.x;\n        var n = x.length;\n        var p,q,mid,floor = Math.floor,a,b,t;\n        p = 0;\n        q = n-1;\n        while(q-p>1) {\n            mid = floor((p+q)/2);\n            if(x[mid] <= x0) p = mid;\n            else q = mid;\n        }\n        return this._at(x0,p);\n    }\n    var n = x0.length, i, ret = Array(n);\n    for(i=n-1;i!==-1;--i) ret[i] = this.at(x0[i]);\n    return ret;\n}\nnumeric.Spline.prototype.diff = function diff() {\n    var x = this.x;\n    var yl = this.yl;\n    var yr = this.yr;\n    var kl = this.kl;\n    var kr = this.kr;\n    var n = yl.length;\n    var i,dx,dy;\n    var zl = kl, zr = kr, pl = Array(n), pr = Array(n);\n    var add = numeric.add, mul = numeric.mul, div = numeric.div, sub = numeric.sub;\n    for(i=n-1;i!==-1;--i) {\n        dx = x[i+1]-x[i];\n        dy = sub(yr[i+1],yl[i]);\n        pl[i] = div(add(mul(dy, 6),mul(kl[i],-4*dx),mul(kr[i+1],-2*dx)),dx*dx);\n        pr[i+1] = div(add(mul(dy,-6),mul(kl[i], 2*dx),mul(kr[i+1], 4*dx)),dx*dx);\n    }\n    return new numeric.Spline(x,zl,zr,pl,pr);\n}\nnumeric.Spline.prototype.roots = function roots() {\n    function sqr(x) { return x*x; }\n    function heval(y0,y1,k0,k1,x) {\n        var A = k0*2-(y1-y0);\n        var B = -k1*2+(y1-y0);\n        var t = (x+1)*0.5;\n        var s = t*(1-t);\n        return (1-t)*y0+t*y1+A*s*(1-t)+B*s*t;\n    }\n    var ret = [];\n    var x = this.x, yl = this.yl, yr = this.yr, kl = this.kl, kr = this.kr;\n    if(typeof yl[0] === \"number\") {\n        yl = [yl];\n        yr = [yr];\n        kl = [kl];\n        kr = [kr];\n    }\n    var m = yl.length,n=x.length-1,i,j,k,y,s,t;\n    var ai,bi,ci,di, ret = Array(m),ri,k0,k1,y0,y1,A,B,D,dx,cx,stops,z0,z1,zm,t0,t1,tm;\n    var sqrt = Math.sqrt;\n    for(i=0;i!==m;++i) {\n        ai = yl[i];\n        bi = yr[i];\n        ci = kl[i];\n        di = kr[i];\n        ri = [];\n        for(j=0;j!==n;j++) {\n            if(j>0 && bi[j]*ai[j]<0) ri.push(x[j]);\n            dx = (x[j+1]-x[j]);\n            cx = x[j];\n            y0 = ai[j];\n            y1 = bi[j+1];\n            k0 = ci[j]/dx;\n            k1 = di[j+1]/dx;\n            D = sqr(k0-k1+3*(y0-y1)) + 12*k1*y0;\n            A = k1+3*y0+2*k0-3*y1;\n            B = 3*(k1+k0+2*(y0-y1));\n            if(D<=0) {\n                z0 = A/B;\n                if(z0>x[j] && z0<x[j+1]) stops = [x[j],z0,x[j+1]];\n                else stops = [x[j],x[j+1]];\n            } else {\n                z0 = (A-sqrt(D))/B;\n                z1 = (A+sqrt(D))/B;\n                stops = [x[j]];\n                if(z0>x[j] && z0<x[j+1]) stops.push(z0);\n                if(z1>x[j] && z1<x[j+1]) stops.push(z1);\n                stops.push(x[j+1]);\n            }\n            t0 = stops[0];\n            z0 = this._at(t0,j);\n            for(k=0;k<stops.length-1;k++) {\n                t1 = stops[k+1];\n                z1 = this._at(t1,j);\n                if(z0 === 0) {\n                    ri.push(t0); \n                    t0 = t1;\n                    z0 = z1;\n                    continue;\n                }\n                if(z1 === 0 || z0*z1>0) {\n                    t0 = t1;\n                    z0 = z1;\n                    continue;\n                }\n                var side = 0;\n                while(1) {\n                    tm = (z0*t1-z1*t0)/(z0-z1);\n                    if(tm <= t0 || tm >= t1) { break; }\n                    zm = this._at(tm,j);\n                    if(zm*z1>0) {\n                        t1 = tm;\n                        z1 = zm;\n                        if(side === -1) z0*=0.5;\n                        side = -1;\n                    } else if(zm*z0>0) {\n                        t0 = tm;\n                        z0 = zm;\n                        if(side === 1) z1*=0.5;\n                        side = 1;\n                    } else break;\n                }\n                ri.push(tm);\n                t0 = stops[k+1];\n                z0 = this._at(t0, j);\n            }\n            if(z1 === 0) ri.push(t1);\n        }\n        ret[i] = ri;\n    }\n    if(typeof this.yl[0] === \"number\") return ret[0];\n    return ret;\n}\nnumeric.spline = function spline(x,y,k1,kn) {\n    var n = x.length, b = [], dx = [], dy = [];\n    var i;\n    var sub = numeric.sub,mul = numeric.mul,add = numeric.add;\n    for(i=n-2;i>=0;i--) { dx[i] = x[i+1]-x[i]; dy[i] = sub(y[i+1],y[i]); }\n    if(typeof k1 === \"string\" || typeof kn === \"string\") { \n        k1 = kn = \"periodic\";\n    }\n    // Build sparse tridiagonal system\n    var T = [[],[],[]];\n    switch(typeof k1) {\n    case \"undefined\":\n        b[0] = mul(3/(dx[0]*dx[0]),dy[0]);\n        T[0].push(0,0);\n        T[1].push(0,1);\n        T[2].push(2/dx[0],1/dx[0]);\n        break;\n    case \"string\":\n        b[0] = add(mul(3/(dx[n-2]*dx[n-2]),dy[n-2]),mul(3/(dx[0]*dx[0]),dy[0]));\n        T[0].push(0,0,0);\n        T[1].push(n-2,0,1);\n        T[2].push(1/dx[n-2],2/dx[n-2]+2/dx[0],1/dx[0]);\n        break;\n    default:\n        b[0] = k1;\n        T[0].push(0);\n        T[1].push(0);\n        T[2].push(1);\n        break;\n    }\n    for(i=1;i<n-1;i++) {\n        b[i] = add(mul(3/(dx[i-1]*dx[i-1]),dy[i-1]),mul(3/(dx[i]*dx[i]),dy[i]));\n        T[0].push(i,i,i);\n        T[1].push(i-1,i,i+1);\n        T[2].push(1/dx[i-1],2/dx[i-1]+2/dx[i],1/dx[i]);\n    }\n    switch(typeof kn) {\n    case \"undefined\":\n        b[n-1] = mul(3/(dx[n-2]*dx[n-2]),dy[n-2]);\n        T[0].push(n-1,n-1);\n        T[1].push(n-2,n-1);\n        T[2].push(1/dx[n-2],2/dx[n-2]);\n        break;\n    case \"string\":\n        T[1][T[1].length-1] = 0;\n        break;\n    default:\n        b[n-1] = kn;\n        T[0].push(n-1);\n        T[1].push(n-1);\n        T[2].push(1);\n        break;\n    }\n    if(typeof b[0] !== \"number\") b = numeric.transpose(b);\n    else b = [b];\n    var k = Array(b.length);\n    if(typeof k1 === \"string\") {\n        for(i=k.length-1;i!==-1;--i) {\n            k[i] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(T)),b[i]);\n            k[i][n-1] = k[i][0];\n        }\n    } else {\n        for(i=k.length-1;i!==-1;--i) {\n            k[i] = numeric.cLUsolve(numeric.cLU(T),b[i]);\n        }\n    }\n    if(typeof y[0] === \"number\") k = k[0];\n    else k = numeric.transpose(k);\n    return new numeric.Spline(x,y,y,k,k);\n}\n\n// 8. FFT\nnumeric.fftpow2 = function fftpow2(x,y) {\n    var n = x.length;\n    if(n === 1) return;\n    var cos = Math.cos, sin = Math.sin, i,j;\n    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);\n    j = n/2;\n    for(i=n-1;i!==-1;--i) {\n        --j;\n        xo[j] = x[i];\n        yo[j] = y[i];\n        --i;\n        xe[j] = x[i];\n        ye[j] = y[i];\n    }\n    fftpow2(xe,ye);\n    fftpow2(xo,yo);\n    j = n/2;\n    var t,k = (-6.2831853071795864769252867665590057683943387987502116419/n),ci,si;\n    for(i=n-1;i!==-1;--i) {\n        --j;\n        if(j === -1) j = n/2-1;\n        t = k*i;\n        ci = cos(t);\n        si = sin(t);\n        x[i] = xe[j] + ci*xo[j] - si*yo[j];\n        y[i] = ye[j] + ci*yo[j] + si*xo[j];\n    }\n}\nnumeric._ifftpow2 = function _ifftpow2(x,y) {\n    var n = x.length;\n    if(n === 1) return;\n    var cos = Math.cos, sin = Math.sin, i,j;\n    var xe = Array(n/2), ye = Array(n/2), xo = Array(n/2), yo = Array(n/2);\n    j = n/2;\n    for(i=n-1;i!==-1;--i) {\n        --j;\n        xo[j] = x[i];\n        yo[j] = y[i];\n        --i;\n        xe[j] = x[i];\n        ye[j] = y[i];\n    }\n    _ifftpow2(xe,ye);\n    _ifftpow2(xo,yo);\n    j = n/2;\n    var t,k = (6.2831853071795864769252867665590057683943387987502116419/n),ci,si;\n    for(i=n-1;i!==-1;--i) {\n        --j;\n        if(j === -1) j = n/2-1;\n        t = k*i;\n        ci = cos(t);\n        si = sin(t);\n        x[i] = xe[j] + ci*xo[j] - si*yo[j];\n        y[i] = ye[j] + ci*yo[j] + si*xo[j];\n    }\n}\nnumeric.ifftpow2 = function ifftpow2(x,y) {\n    numeric._ifftpow2(x,y);\n    numeric.diveq(x,x.length);\n    numeric.diveq(y,y.length);\n}\nnumeric.convpow2 = function convpow2(ax,ay,bx,by) {\n    numeric.fftpow2(ax,ay);\n    numeric.fftpow2(bx,by);\n    var i,n = ax.length,axi,bxi,ayi,byi;\n    for(i=n-1;i!==-1;--i) {\n        axi = ax[i]; ayi = ay[i]; bxi = bx[i]; byi = by[i];\n        ax[i] = axi*bxi-ayi*byi;\n        ay[i] = axi*byi+ayi*bxi;\n    }\n    numeric.ifftpow2(ax,ay);\n}\nnumeric.T.prototype.fft = function fft() {\n    var x = this.x, y = this.y;\n    var n = x.length, log = Math.log, log2 = log(2),\n        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);\n    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;\n    var k, c = (-3.141592653589793238462643383279502884197169399375105820/n),t;\n    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);\n    for(k=0;k<n;k++) a[k] = x[k];\n    if(typeof y !== \"undefined\") for(k=0;k<n;k++) b[k] = y[k];\n    cx[0] = 1;\n    for(k=1;k<=m/2;k++) {\n        t = c*k*k;\n        cx[k] = cos(t);\n        cy[k] = sin(t);\n        cx[m-k] = cos(t);\n        cy[m-k] = sin(t)\n    }\n    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);\n    X = X.mul(Y);\n    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));\n    X = X.mul(Y);\n    X.x.length = n;\n    X.y.length = n;\n    return X;\n}\nnumeric.T.prototype.ifft = function ifft() {\n    var x = this.x, y = this.y;\n    var n = x.length, log = Math.log, log2 = log(2),\n        p = Math.ceil(log(2*n-1)/log2), m = Math.pow(2,p);\n    var cx = numeric.rep([m],0), cy = numeric.rep([m],0), cos = Math.cos, sin = Math.sin;\n    var k, c = (3.141592653589793238462643383279502884197169399375105820/n),t;\n    var a = numeric.rep([m],0), b = numeric.rep([m],0),nhalf = Math.floor(n/2);\n    for(k=0;k<n;k++) a[k] = x[k];\n    if(typeof y !== \"undefined\") for(k=0;k<n;k++) b[k] = y[k];\n    cx[0] = 1;\n    for(k=1;k<=m/2;k++) {\n        t = c*k*k;\n        cx[k] = cos(t);\n        cy[k] = sin(t);\n        cx[m-k] = cos(t);\n        cy[m-k] = sin(t)\n    }\n    var X = new numeric.T(a,b), Y = new numeric.T(cx,cy);\n    X = X.mul(Y);\n    numeric.convpow2(X.x,X.y,numeric.clone(Y.x),numeric.neg(Y.y));\n    X = X.mul(Y);\n    X.x.length = n;\n    X.y.length = n;\n    return X.div(n);\n}\n\n//9. Unconstrained optimization\nnumeric.gradient = function gradient(f,x) {\n    var n = x.length;\n    var f0 = f(x);\n    if(isNaN(f0)) throw new Error('gradient: f(x) is a NaN!');\n    var max = Math.max;\n    var i,x0 = numeric.clone(x),f1,f2, J = Array(n);\n    var div = numeric.div, sub = numeric.sub,errest,roundoff,max = Math.max,eps = 1e-3,abs = Math.abs, min = Math.min;\n    var t0,t1,t2,it=0,d1,d2,N;\n    for(i=0;i<n;i++) {\n        var h = max(1e-6*f0,1e-8);\n        while(1) {\n            ++it;\n            if(it>20) { throw new Error(\"Numerical gradient fails\"); }\n            x0[i] = x[i]+h;\n            f1 = f(x0);\n            x0[i] = x[i]-h;\n            f2 = f(x0);\n            x0[i] = x[i];\n            if(isNaN(f1) || isNaN(f2)) { h/=16; continue; }\n            J[i] = (f1-f2)/(2*h);\n            t0 = x[i]-h;\n            t1 = x[i];\n            t2 = x[i]+h;\n            d1 = (f1-f0)/h;\n            d2 = (f0-f2)/h;\n            N = max(abs(J[i]),abs(f0),abs(f1),abs(f2),abs(t0),abs(t1),abs(t2),1e-8);\n            errest = min(max(abs(d1-J[i]),abs(d2-J[i]),abs(d1-d2))/N,h/N);\n            if(errest>eps) { h/=16; }\n            else break;\n            }\n    }\n    return J;\n}\n\nnumeric.uncmin = function uncmin(f,x0,tol,gradient,maxit,callback,options) {\n    var grad = numeric.gradient;\n    if(typeof options === \"undefined\") { options = {}; }\n    if(typeof tol === \"undefined\") { tol = 1e-8; }\n    if(typeof gradient === \"undefined\") { gradient = function(x) { return grad(f,x); }; }\n    if(typeof maxit === \"undefined\") maxit = 1000;\n    x0 = numeric.clone(x0);\n    var n = x0.length;\n    var f0 = f(x0),f1,df0;\n    if(isNaN(f0)) throw new Error('uncmin: f(x0) is a NaN!');\n    var max = Math.max, norm2 = numeric.norm2;\n    tol = max(tol,numeric.epsilon);\n    var step,g0,g1,H1 = options.Hinv || numeric.identity(n);\n    var dot = numeric.dot, inv = numeric.inv, sub = numeric.sub, add = numeric.add, ten = numeric.tensor, div = numeric.div, mul = numeric.mul;\n    var all = numeric.all, isfinite = numeric.isFinite, neg = numeric.neg;\n    var it=0,i,s,x1,y,Hy,Hs,ys,i0,t,nstep,t1,t2;\n    var msg = \"\";\n    g0 = gradient(x0);\n    while(it<maxit) {\n        if(typeof callback === \"function\") { if(callback(it,x0,f0,g0,H1)) { msg = \"Callback returned true\"; break; } }\n        if(!all(isfinite(g0))) { msg = \"Gradient has Infinity or NaN\"; break; }\n        step = neg(dot(H1,g0));\n        if(!all(isfinite(step))) { msg = \"Search direction has Infinity or NaN\"; break; }\n        nstep = norm2(step);\n        if(nstep < tol) { msg=\"Newton step smaller than tol\"; break; }\n        t = 1;\n        df0 = dot(g0,step);\n        // line search\n        x1 = x0;\n        while(it < maxit) {\n            if(t*nstep < tol) { break; }\n            s = mul(step,t);\n            x1 = add(x0,s);\n            f1 = f(x1);\n            if(f1-f0 >= 0.1*t*df0 || isNaN(f1)) {\n                t *= 0.5;\n                ++it;\n                continue;\n            }\n            break;\n        }\n        if(t*nstep < tol) { msg = \"Line search step size smaller than tol\"; break; }\n        if(it === maxit) { msg = \"maxit reached during line search\"; break; }\n        g1 = gradient(x1);\n        y = sub(g1,g0);\n        ys = dot(y,s);\n        Hy = dot(H1,y);\n        H1 = sub(add(H1,\n                mul(\n                        (ys+dot(y,Hy))/(ys*ys),\n                        ten(s,s)    )),\n                div(add(ten(Hy,s),ten(s,Hy)),ys));\n        x0 = x1;\n        f0 = f1;\n        g0 = g1;\n        ++it;\n    }\n    return {solution: x0, f: f0, gradient: g0, invHessian: H1, iterations:it, message: msg};\n}\n\n// 10. Ode solver (Dormand-Prince)\nnumeric.Dopri = function Dopri(x,y,f,ymid,iterations,msg,events) {\n    this.x = x;\n    this.y = y;\n    this.f = f;\n    this.ymid = ymid;\n    this.iterations = iterations;\n    this.events = events;\n    this.message = msg;\n}\nnumeric.Dopri.prototype._at = function _at(xi,j) {\n    function sqr(x) { return x*x; }\n    var sol = this;\n    var xs = sol.x;\n    var ys = sol.y;\n    var k1 = sol.f;\n    var ymid = sol.ymid;\n    var n = xs.length;\n    var x0,x1,xh,y0,y1,yh,xi;\n    var floor = Math.floor,h;\n    var c = 0.5;\n    var add = numeric.add, mul = numeric.mul,sub = numeric.sub, p,q,w;\n    x0 = xs[j];\n    x1 = xs[j+1];\n    y0 = ys[j];\n    y1 = ys[j+1];\n    h  = x1-x0;\n    xh = x0+c*h;\n    yh = ymid[j];\n    p = sub(k1[j  ],mul(y0,1/(x0-xh)+2/(x0-x1)));\n    q = sub(k1[j+1],mul(y1,1/(x1-xh)+2/(x1-x0)));\n    w = [sqr(xi - x1) * (xi - xh) / sqr(x0 - x1) / (x0 - xh),\n         sqr(xi - x0) * sqr(xi - x1) / sqr(x0 - xh) / sqr(x1 - xh),\n         sqr(xi - x0) * (xi - xh) / sqr(x1 - x0) / (x1 - xh),\n         (xi - x0) * sqr(xi - x1) * (xi - xh) / sqr(x0-x1) / (x0 - xh),\n         (xi - x1) * sqr(xi - x0) * (xi - xh) / sqr(x0-x1) / (x1 - xh)];\n    return add(add(add(add(mul(y0,w[0]),\n                           mul(yh,w[1])),\n                           mul(y1,w[2])),\n                           mul( p,w[3])),\n                           mul( q,w[4]));\n}\nnumeric.Dopri.prototype.at = function at(x) {\n    var i,j,k,floor = Math.floor;\n    if(typeof x !== \"number\") {\n        var n = x.length, ret = Array(n);\n        for(i=n-1;i!==-1;--i) {\n            ret[i] = this.at(x[i]);\n        }\n        return ret;\n    }\n    var x0 = this.x;\n    i = 0; j = x0.length-1;\n    while(j-i>1) {\n        k = floor(0.5*(i+j));\n        if(x0[k] <= x) i = k;\n        else j = k;\n    }\n    return this._at(x,i);\n}\n\nnumeric.dopri = function dopri(x0,x1,y0,f,tol,maxit,event) {\n    if(typeof tol === \"undefined\") { tol = 1e-6; }\n    if(typeof maxit === \"undefined\") { maxit = 1000; }\n    var xs = [x0], ys = [y0], k1 = [f(x0,y0)], k2,k3,k4,k5,k6,k7, ymid = [];\n    var A2 = 1/5;\n    var A3 = [3/40,9/40];\n    var A4 = [44/45,-56/15,32/9];\n    var A5 = [19372/6561,-25360/2187,64448/6561,-212/729];\n    var A6 = [9017/3168,-355/33,46732/5247,49/176,-5103/18656];\n    var b = [35/384,0,500/1113,125/192,-2187/6784,11/84];\n    var bm = [0.5*6025192743/30085553152,\n              0,\n              0.5*51252292925/65400821598,\n              0.5*-2691868925/45128329728,\n              0.5*187940372067/1594534317056,\n              0.5*-1776094331/19743644256,\n              0.5*11237099/235043384];\n    var c = [1/5,3/10,4/5,8/9,1,1];\n    var e = [-71/57600,0,71/16695,-71/1920,17253/339200,-22/525,1/40];\n    var i = 0,er,j;\n    var h = (x1-x0)/10;\n    var it = 0;\n    var add = numeric.add, mul = numeric.mul, y1,erinf;\n    var max = Math.max, min = Math.min, abs = Math.abs, norminf = numeric.norminf,pow = Math.pow;\n    var any = numeric.any, lt = numeric.lt, and = numeric.and, sub = numeric.sub;\n    var e0, e1, ev;\n    var ret = new numeric.Dopri(xs,ys,k1,ymid,-1,\"\");\n    if(typeof event === \"function\") e0 = event(x0,y0);\n    while(x0<x1 && it<maxit) {\n        ++it;\n        if(x0+h>x1) h = x1-x0;\n        k2 = f(x0+c[0]*h,                add(y0,mul(   A2*h,k1[i])));\n        k3 = f(x0+c[1]*h,            add(add(y0,mul(A3[0]*h,k1[i])),mul(A3[1]*h,k2)));\n        k4 = f(x0+c[2]*h,        add(add(add(y0,mul(A4[0]*h,k1[i])),mul(A4[1]*h,k2)),mul(A4[2]*h,k3)));\n        k5 = f(x0+c[3]*h,    add(add(add(add(y0,mul(A5[0]*h,k1[i])),mul(A5[1]*h,k2)),mul(A5[2]*h,k3)),mul(A5[3]*h,k4)));\n        k6 = f(x0+c[4]*h,add(add(add(add(add(y0,mul(A6[0]*h,k1[i])),mul(A6[1]*h,k2)),mul(A6[2]*h,k3)),mul(A6[3]*h,k4)),mul(A6[4]*h,k5)));\n        y1 = add(add(add(add(add(y0,mul(k1[i],h*b[0])),mul(k3,h*b[2])),mul(k4,h*b[3])),mul(k5,h*b[4])),mul(k6,h*b[5]));\n        k7 = f(x0+h,y1);\n        er = add(add(add(add(add(mul(k1[i],h*e[0]),mul(k3,h*e[2])),mul(k4,h*e[3])),mul(k5,h*e[4])),mul(k6,h*e[5])),mul(k7,h*e[6]));\n        if(typeof er === \"number\") erinf = abs(er);\n        else erinf = norminf(er);\n        if(erinf > tol) { // reject\n            h = 0.2*h*pow(tol/erinf,0.25);\n            if(x0+h === x0) {\n                ret.msg = \"Step size became too small\";\n                break;\n            }\n            continue;\n        }\n        ymid[i] = add(add(add(add(add(add(y0,\n                mul(k1[i],h*bm[0])),\n                mul(k3   ,h*bm[2])),\n                mul(k4   ,h*bm[3])),\n                mul(k5   ,h*bm[4])),\n                mul(k6   ,h*bm[5])),\n                mul(k7   ,h*bm[6]));\n        ++i;\n        xs[i] = x0+h;\n        ys[i] = y1;\n        k1[i] = k7;\n        if(typeof event === \"function\") {\n            var yi,xl = x0,xr = x0+0.5*h,xi;\n            e1 = event(xr,ymid[i-1]);\n            ev = and(lt(e0,0),lt(0,e1));\n            if(!any(ev)) { xl = xr; xr = x0+h; e0 = e1; e1 = event(xr,y1); ev = and(lt(e0,0),lt(0,e1)); }\n            if(any(ev)) {\n                var xc, yc, en,ei;\n                var side=0, sl = 1.0, sr = 1.0;\n                while(1) {\n                    if(typeof e0 === \"number\") xi = (sr*e1*xl-sl*e0*xr)/(sr*e1-sl*e0);\n                    else {\n                        xi = xr;\n                        for(j=e0.length-1;j!==-1;--j) {\n                            if(e0[j]<0 && e1[j]>0) xi = min(xi,(sr*e1[j]*xl-sl*e0[j]*xr)/(sr*e1[j]-sl*e0[j]));\n                        }\n                    }\n                    if(xi <= xl || xi >= xr) break;\n                    yi = ret._at(xi, i-1);\n                    ei = event(xi,yi);\n                    en = and(lt(e0,0),lt(0,ei));\n                    if(any(en)) {\n                        xr = xi;\n                        e1 = ei;\n                        ev = en;\n                        sr = 1.0;\n                        if(side === -1) sl *= 0.5;\n                        else sl = 1.0;\n                        side = -1;\n                    } else {\n                        xl = xi;\n                        e0 = ei;\n                        sl = 1.0;\n                        if(side === 1) sr *= 0.5;\n                        else sr = 1.0;\n                        side = 1;\n                    }\n                }\n                y1 = ret._at(0.5*(x0+xi),i-1);\n                ret.f[i] = f(xi,yi);\n                ret.x[i] = xi;\n                ret.y[i] = yi;\n                ret.ymid[i-1] = y1;\n                ret.events = ev;\n                ret.iterations = it;\n                return ret;\n            }\n        }\n        x0 += h;\n        y0 = y1;\n        e0 = e1;\n        h = min(0.8*h*pow(tol/erinf,0.25),4*h);\n    }\n    ret.iterations = it;\n    return ret;\n}\n\n// 11. Ax = b\nnumeric.LU = function(A, fast) {\n  fast = fast || false;\n\n  var abs = Math.abs;\n  var i, j, k, absAjk, Akk, Ak, Pk, Ai;\n  var max;\n  var n = A.length, n1 = n-1;\n  var P = new Array(n);\n  if(!fast) A = numeric.clone(A);\n\n  for (k = 0; k < n; ++k) {\n    Pk = k;\n    Ak = A[k];\n    max = abs(Ak[k]);\n    for (j = k + 1; j < n; ++j) {\n      absAjk = abs(A[j][k]);\n      if (max < absAjk) {\n        max = absAjk;\n        Pk = j;\n      }\n    }\n    P[k] = Pk;\n\n    if (Pk != k) {\n      A[k] = A[Pk];\n      A[Pk] = Ak;\n      Ak = A[k];\n    }\n\n    Akk = Ak[k];\n\n    for (i = k + 1; i < n; ++i) {\n      A[i][k] /= Akk;\n    }\n\n    for (i = k + 1; i < n; ++i) {\n      Ai = A[i];\n      for (j = k + 1; j < n1; ++j) {\n        Ai[j] -= Ai[k] * Ak[j];\n        ++j;\n        Ai[j] -= Ai[k] * Ak[j];\n      }\n      if(j===n1) Ai[j] -= Ai[k] * Ak[j];\n    }\n  }\n\n  return {\n    LU: A,\n    P:  P\n  };\n}\n\nnumeric.LUsolve = function LUsolve(LUP, b) {\n  var i, j;\n  var LU = LUP.LU;\n  var n   = LU.length;\n  var x = numeric.clone(b);\n  var P   = LUP.P;\n  var Pi, LUi, LUii, tmp;\n\n  for (i=n-1;i!==-1;--i) x[i] = b[i];\n  for (i = 0; i < n; ++i) {\n    Pi = P[i];\n    if (P[i] !== i) {\n      tmp = x[i];\n      x[i] = x[Pi];\n      x[Pi] = tmp;\n    }\n\n    LUi = LU[i];\n    for (j = 0; j < i; ++j) {\n      x[i] -= x[j] * LUi[j];\n    }\n  }\n\n  for (i = n - 1; i >= 0; --i) {\n    LUi = LU[i];\n    for (j = i + 1; j < n; ++j) {\n      x[i] -= x[j] * LUi[j];\n    }\n\n    x[i] /= LUi[i];\n  }\n\n  return x;\n}\n\nnumeric.solve = function solve(A,b,fast) { return numeric.LUsolve(numeric.LU(A,fast), b); }\n\n// 12. Linear programming\nnumeric.echelonize = function echelonize(A) {\n    var s = numeric.dim(A), m = s[0], n = s[1];\n    var I = numeric.identity(m);\n    var P = Array(m);\n    var i,j,k,l,Ai,Ii,Z,a;\n    var abs = Math.abs;\n    var diveq = numeric.diveq;\n    A = numeric.clone(A);\n    for(i=0;i<m;++i) {\n        k = 0;\n        Ai = A[i];\n        Ii = I[i];\n        for(j=1;j<n;++j) if(abs(Ai[k])<abs(Ai[j])) k=j;\n        P[i] = k;\n        diveq(Ii,Ai[k]);\n        diveq(Ai,Ai[k]);\n        for(j=0;j<m;++j) if(j!==i) {\n            Z = A[j]; a = Z[k];\n            for(l=n-1;l!==-1;--l) Z[l] -= Ai[l]*a;\n            Z = I[j];\n            for(l=m-1;l!==-1;--l) Z[l] -= Ii[l]*a;\n        }\n    }\n    return {I:I, A:A, P:P};\n}\n\nnumeric.__solveLP = function __solveLP(c,A,b,tol,maxit,x,flag) {\n    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;\n    var m = c.length, n = b.length,y;\n    var unbounded = false, cb,i0=0;\n    var alpha = 1.0;\n    var f0,df0,AT = numeric.transpose(A), svd = numeric.svd,transpose = numeric.transpose,leq = numeric.leq, sqrt = Math.sqrt, abs = Math.abs;\n    var muleq = numeric.muleq;\n    var norm = numeric.norminf, any = numeric.any,min = Math.min;\n    var all = numeric.all, gt = numeric.gt;\n    var p = Array(m), A0 = Array(n),e=numeric.rep([n],1), H;\n    var solve = numeric.solve, z = sub(b,dot(A,x)),count;\n    var dotcc = dot(c,c);\n    var g;\n    for(count=i0;count<maxit;++count) {\n        var i,j,d;\n        for(i=n-1;i!==-1;--i) A0[i] = div(A[i],z[i]);\n        var A1 = transpose(A0);\n        for(i=m-1;i!==-1;--i) p[i] = (/*x[i]+*/sum(A1[i]));\n        alpha = 0.25*abs(dotcc/dot(c,p));\n        var a1 = 100*sqrt(dotcc/dot(p,p));\n        if(!isFinite(alpha) || alpha>a1) alpha = a1;\n        g = add(c,mul(alpha,p));\n        H = dot(A1,A0);\n        for(i=m-1;i!==-1;--i) H[i][i] += 1;\n        d = solve(H,div(g,alpha),true);\n        var t0 = div(z,dot(A,d));\n        var t = 1.0;\n        for(i=n-1;i!==-1;--i) if(t0[i]<0) t = min(t,-0.999*t0[i]);\n        y = sub(x,mul(d,t));\n        z = sub(b,dot(A,y));\n        if(!all(gt(z,0))) return { solution: x, message: \"\", iterations: count };\n        x = y;\n        if(alpha<tol) return { solution: y, message: \"\", iterations: count };\n        if(flag) {\n            var s = dot(c,g), Ag = dot(A,g);\n            unbounded = true;\n            for(i=n-1;i!==-1;--i) if(s*Ag[i]<0) { unbounded = false; break; }\n        } else {\n            if(x[m-1]>=0) unbounded = false;\n            else unbounded = true;\n        }\n        if(unbounded) return { solution: y, message: \"Unbounded\", iterations: count };\n    }\n    return { solution: x, message: \"maximum iteration count exceeded\", iterations:count };\n}\n\nnumeric._solveLP = function _solveLP(c,A,b,tol,maxit) {\n    var m = c.length, n = b.length,y;\n    var sum = numeric.sum, log = numeric.log, mul = numeric.mul, sub = numeric.sub, dot = numeric.dot, div = numeric.div, add = numeric.add;\n    var c0 = numeric.rep([m],0).concat([1]);\n    var J = numeric.rep([n,1],-1);\n    var A0 = numeric.blockMatrix([[A                   ,   J  ]]);\n    var b0 = b;\n    var y = numeric.rep([m],0).concat(Math.max(0,numeric.sup(numeric.neg(b)))+1);\n    var x0 = numeric.__solveLP(c0,A0,b0,tol,maxit,y,false);\n    var x = numeric.clone(x0.solution);\n    x.length = m;\n    var foo = numeric.inf(sub(b,dot(A,x)));\n    if(foo<0) { return { solution: NaN, message: \"Infeasible\", iterations: x0.iterations }; }\n    var ret = numeric.__solveLP(c, A, b, tol, maxit-x0.iterations, x, true);\n    ret.iterations += x0.iterations;\n    return ret;\n};\n\nnumeric.solveLP = function solveLP(c,A,b,Aeq,beq,tol,maxit) {\n    if(typeof maxit === \"undefined\") maxit = 1000;\n    if(typeof tol === \"undefined\") tol = numeric.epsilon;\n    if(typeof Aeq === \"undefined\") return numeric._solveLP(c,A,b,tol,maxit);\n    var m = Aeq.length, n = Aeq[0].length, o = A.length;\n    var B = numeric.echelonize(Aeq);\n    var flags = numeric.rep([n],0);\n    var P = B.P;\n    var Q = [];\n    var i;\n    for(i=P.length-1;i!==-1;--i) flags[P[i]] = 1;\n    for(i=n-1;i!==-1;--i) if(flags[i]===0) Q.push(i);\n    var g = numeric.getRange;\n    var I = numeric.linspace(0,m-1), J = numeric.linspace(0,o-1);\n    var Aeq2 = g(Aeq,I,Q), A1 = g(A,J,P), A2 = g(A,J,Q), dot = numeric.dot, sub = numeric.sub;\n    var A3 = dot(A1,B.I);\n    var A4 = sub(A2,dot(A3,Aeq2)), b4 = sub(b,dot(A3,beq));\n    var c1 = Array(P.length), c2 = Array(Q.length);\n    for(i=P.length-1;i!==-1;--i) c1[i] = c[P[i]];\n    for(i=Q.length-1;i!==-1;--i) c2[i] = c[Q[i]];\n    var c4 = sub(c2,dot(c1,dot(B.I,Aeq2)));\n    var S = numeric._solveLP(c4,A4,b4,tol,maxit);\n    var x2 = S.solution;\n    if(x2!==x2) return S;\n    var x1 = dot(B.I,sub(beq,dot(Aeq2,x2)));\n    var x = Array(c.length);\n    for(i=P.length-1;i!==-1;--i) x[P[i]] = x1[i];\n    for(i=Q.length-1;i!==-1;--i) x[Q[i]] = x2[i];\n    return { solution: x, message:S.message, iterations: S.iterations };\n}\n\nnumeric.MPStoLP = function MPStoLP(MPS) {\n    if(MPS instanceof String) { MPS.split('\\n'); }\n    var state = 0;\n    var states = ['Initial state','NAME','ROWS','COLUMNS','RHS','BOUNDS','ENDATA'];\n    var n = MPS.length;\n    var i,j,z,N=0,rows = {}, sign = [], rl = 0, vars = {}, nv = 0;\n    var name;\n    var c = [], A = [], b = [];\n    function err(e) { throw new Error('MPStoLP: '+e+'\\nLine '+i+': '+MPS[i]+'\\nCurrent state: '+states[state]+'\\n'); }\n    for(i=0;i<n;++i) {\n        z = MPS[i];\n        var w0 = z.match(/\\S*/g);\n        var w = [];\n        for(j=0;j<w0.length;++j) if(w0[j]!==\"\") w.push(w0[j]);\n        if(w.length === 0) continue;\n        for(j=0;j<states.length;++j) if(z.substr(0,states[j].length) === states[j]) break;\n        if(j<states.length) {\n            state = j;\n            if(j===1) { name = w[1]; }\n            if(j===6) return { name:name, c:c, A:numeric.transpose(A), b:b, rows:rows, vars:vars };\n            continue;\n        }\n        switch(state) {\n        case 0: case 1: err('Unexpected line');\n        case 2: \n            switch(w[0]) {\n            case 'N': if(N===0) N = w[1]; else err('Two or more N rows'); break;\n            case 'L': rows[w[1]] = rl; sign[rl] = 1; b[rl] = 0; ++rl; break;\n            case 'G': rows[w[1]] = rl; sign[rl] = -1;b[rl] = 0; ++rl; break;\n            case 'E': rows[w[1]] = rl; sign[rl] = 0;b[rl] = 0; ++rl; break;\n            default: err('Parse error '+numeric.prettyPrint(w));\n            }\n            break;\n        case 3:\n            if(!vars.hasOwnProperty(w[0])) { vars[w[0]] = nv; c[nv] = 0; A[nv] = numeric.rep([rl],0); ++nv; }\n            var p = vars[w[0]];\n            for(j=1;j<w.length;j+=2) {\n                if(w[j] === N) { c[p] = parseFloat(w[j+1]); continue; }\n                var q = rows[w[j]];\n                A[p][q] = (sign[q]<0?-1:1)*parseFloat(w[j+1]);\n            }\n            break;\n        case 4:\n            for(j=1;j<w.length;j+=2) b[rows[w[j]]] = (sign[rows[w[j]]]<0?-1:1)*parseFloat(w[j+1]);\n            break;\n        case 5: /*FIXME*/ break;\n        case 6: err('Internal error');\n        }\n    }\n    err('Reached end of file without ENDATA');\n}\n// seedrandom.js version 2.0.\n// Author: David Bau 4/2/2011\n//\n// Defines a method Math.seedrandom() that, when called, substitutes\n// an explicitly seeded RC4-based algorithm for Math.random().  Also\n// supports automatic seeding from local or network sources of entropy.\n//\n// Usage:\n//\n//   <script src=http://davidbau.com/encode/seedrandom-min.js></script>\n//\n//   Math.seedrandom('yipee'); Sets Math.random to a function that is\n//                             initialized using the given explicit seed.\n//\n//   Math.seedrandom();        Sets Math.random to a function that is\n//                             seeded using the current time, dom state,\n//                             and other accumulated local entropy.\n//                             The generated seed string is returned.\n//\n//   Math.seedrandom('yowza', true);\n//                             Seeds using the given explicit seed mixed\n//                             together with accumulated entropy.\n//\n//   <script src=\"http://bit.ly/srandom-512\"></script>\n//                             Seeds using physical random bits downloaded\n//                             from random.org.\n//\n//   <script src=\"https://jsonlib.appspot.com/urandom?callback=Math.seedrandom\">\n//   </script>                 Seeds using urandom bits from call.jsonlib.com,\n//                             which is faster than random.org.\n//\n// Examples:\n//\n//   Math.seedrandom(\"hello\");            // Use \"hello\" as the seed.\n//   document.write(Math.random());       // Always 0.5463663768140734\n//   document.write(Math.random());       // Always 0.43973793770592234\n//   var rng1 = Math.random;              // Remember the current prng.\n//\n//   var autoseed = Math.seedrandom();    // New prng with an automatic seed.\n//   document.write(Math.random());       // Pretty much unpredictable.\n//\n//   Math.random = rng1;                  // Continue \"hello\" prng sequence.\n//   document.write(Math.random());       // Always 0.554769432473455\n//\n//   Math.seedrandom(autoseed);           // Restart at the previous seed.\n//   document.write(Math.random());       // Repeat the 'unpredictable' value.\n//\n// Notes:\n//\n// Each time seedrandom('arg') is called, entropy from the passed seed\n// is accumulated in a pool to help generate future seeds for the\n// zero-argument form of Math.seedrandom, so entropy can be injected over\n// time by calling seedrandom with explicit data repeatedly.\n//\n// On speed - This javascript implementation of Math.random() is about\n// 3-10x slower than the built-in Math.random() because it is not native\n// code, but this is typically fast enough anyway.  Seeding is more expensive,\n// especially if you use auto-seeding.  Some details (timings on Chrome 4):\n//\n// Our Math.random()            - avg less than 0.002 milliseconds per call\n// seedrandom('explicit')       - avg less than 0.5 milliseconds per call\n// seedrandom('explicit', true) - avg less than 2 milliseconds per call\n// seedrandom()                 - avg about 38 milliseconds per call\n//\n// LICENSE (BSD):\n//\n// Copyright 2010 David Bau, all rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n// \n//   1. Redistributions of source code must retain the above copyright\n//      notice, this list of conditions and the following disclaimer.\n//\n//   2. Redistributions in binary form must reproduce the above copyright\n//      notice, this list of conditions and the following disclaimer in the\n//      documentation and/or other materials provided with the distribution.\n// \n//   3. Neither the name of this module nor the names of its contributors may\n//      be used to endorse or promote products derived from this software\n//      without specific prior written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n/**\n * All code is in an anonymous closure to keep the global namespace clean.\n *\n * @param {number=} overflow \n * @param {number=} startdenom\n */\n\n// Patched by Seb so that seedrandom.js does not pollute the Math object.\n// My tests suggest that doing Math.trouble = 1 makes Math lookups about 5%\n// slower.\nnumeric.seedrandom = { pow:Math.pow, random:Math.random };\n\n(function (pool, math, width, chunks, significance, overflow, startdenom) {\n\n\n//\n// seedrandom()\n// This is the seedrandom function described above.\n//\nmath['seedrandom'] = function seedrandom(seed, use_entropy) {\n  var key = [];\n  var arc4;\n\n  // Flatten the seed string or build one from local entropy if needed.\n  seed = mixkey(flatten(\n    use_entropy ? [seed, pool] :\n    arguments.length ? seed :\n    [new Date().getTime(), pool, window], 3), key);\n\n  // Use the seed to initialize an ARC4 generator.\n  arc4 = new ARC4(key);\n\n  // Mix the randomness into accumulated entropy.\n  mixkey(arc4.S, pool);\n\n  // Override Math.random\n\n  // This function returns a random double in [0, 1) that contains\n  // randomness in every bit of the mantissa of the IEEE 754 value.\n\n  math['random'] = function random() {  // Closure to return a random double:\n    var n = arc4.g(chunks);             // Start with a numerator n < 2 ^ 48\n    var d = startdenom;                 //   and denominator d = 2 ^ 48.\n    var x = 0;                          //   and no 'extra last byte'.\n    while (n < significance) {          // Fill up all significant digits by\n      n = (n + x) * width;              //   shifting numerator and\n      d *= width;                       //   denominator and generating a\n      x = arc4.g(1);                    //   new least-significant-byte.\n    }\n    while (n >= overflow) {             // To avoid rounding up, before adding\n      n /= 2;                           //   last byte, shift everything\n      d /= 2;                           //   right using integer math until\n      x >>>= 1;                         //   we have exactly the desired bits.\n    }\n    return (n + x) / d;                 // Form the number within [0, 1).\n  };\n\n  // Return the seed that was used\n  return seed;\n};\n\n//\n// ARC4\n//\n// An ARC4 implementation.  The constructor takes a key in the form of\n// an array of at most (width) integers that should be 0 <= x < (width).\n//\n// The g(count) method returns a pseudorandom integer that concatenates\n// the next (count) outputs from ARC4.  Its return value is a number x\n// that is in the range 0 <= x < (width ^ count).\n//\n/** @constructor */\nfunction ARC4(key) {\n  var t, u, me = this, keylen = key.length;\n  var i = 0, j = me.i = me.j = me.m = 0;\n  me.S = [];\n  me.c = [];\n\n  // The empty key [] is treated as [0].\n  if (!keylen) { key = [keylen++]; }\n\n  // Set up S using the standard key scheduling algorithm.\n  while (i < width) { me.S[i] = i++; }\n  for (i = 0; i < width; i++) {\n    t = me.S[i];\n    j = lowbits(j + t + key[i % keylen]);\n    u = me.S[j];\n    me.S[i] = u;\n    me.S[j] = t;\n  }\n\n  // The \"g\" method returns the next (count) outputs as one number.\n  me.g = function getnext(count) {\n    var s = me.S;\n    var i = lowbits(me.i + 1); var t = s[i];\n    var j = lowbits(me.j + t); var u = s[j];\n    s[i] = u;\n    s[j] = t;\n    var r = s[lowbits(t + u)];\n    while (--count) {\n      i = lowbits(i + 1); t = s[i];\n      j = lowbits(j + t); u = s[j];\n      s[i] = u;\n      s[j] = t;\n      r = r * width + s[lowbits(t + u)];\n    }\n    me.i = i;\n    me.j = j;\n    return r;\n  };\n  // For robust unpredictability discard an initial batch of values.\n  // See http://www.rsa.com/rsalabs/node.asp?id=2009\n  me.g(width);\n}\n\n//\n// flatten()\n// Converts an object tree to nested arrays of strings.\n//\n/** @param {Object=} result \n  * @param {string=} prop\n  * @param {string=} typ */\nfunction flatten(obj, depth, result, prop, typ) {\n  result = [];\n  typ = typeof(obj);\n  if (depth && typ == 'object') {\n    for (prop in obj) {\n      if (prop.indexOf('S') < 5) {    // Avoid FF3 bug (local/sessionStorage)\n        try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}\n      }\n    }\n  }\n  return (result.length ? result : obj + (typ != 'string' ? '\\0' : ''));\n}\n\n//\n// mixkey()\n// Mixes a string seed into a key that is an array of integers, and\n// returns a shortened string seed that is equivalent to the result key.\n//\n/** @param {number=} smear \n  * @param {number=} j */\nfunction mixkey(seed, key, smear, j) {\n  seed += '';                         // Ensure the seed is a string\n  smear = 0;\n  for (j = 0; j < seed.length; j++) {\n    key[lowbits(j)] =\n      lowbits((smear ^= key[lowbits(j)] * 19) + seed.charCodeAt(j));\n  }\n  seed = '';\n  for (j in key) { seed += String.fromCharCode(key[j]); }\n  return seed;\n}\n\n//\n// lowbits()\n// A quick \"n mod width\" for width a power of 2.\n//\nfunction lowbits(n) { return n & (width - 1); }\n\n//\n// The following constants are related to IEEE 754 limits.\n//\nstartdenom = math.pow(width, chunks);\nsignificance = math.pow(2, significance);\noverflow = significance * 2;\n\n//\n// When seedrandom.js is loaded, we immediately mix a few bits\n// from the built-in RNG into the entropy pool.  Because we do\n// not want to intefere with determinstic PRNG state later,\n// seedrandom will not call math.random on its own again after\n// initialization.\n//\nmixkey(math.random(), pool);\n\n// End anonymous scope, and pass initial values.\n}(\n  [],   // pool: entropy pool starts empty\n  numeric.seedrandom, // math: package containing random, pow, and seedrandom\n  256,  // width: each RC4 output is 0 <= x < 256\n  6,    // chunks: at least six RC4 outputs for each double\n  52    // significance: there are 52 significant digits in a double\n  ));\n/* This file is a slightly modified version of quadprog.js from Alberto Santini.\n * It has been slightly modified by Sbastien Loisel to make sure that it handles\n * 0-based Arrays instead of 1-based Arrays.\n * License is in resources/LICENSE.quadprog */\n(function(exports) {\n\nfunction base0to1(A) {\n    if(typeof A !== \"object\") { return A; }\n    var ret = [], i,n=A.length;\n    for(i=0;i<n;i++) ret[i+1] = base0to1(A[i]);\n    return ret;\n}\nfunction base1to0(A) {\n    if(typeof A !== \"object\") { return A; }\n    var ret = [], i,n=A.length;\n    for(i=1;i<n;i++) ret[i-1] = base1to0(A[i]);\n    return ret;\n}\n\nfunction dpori(a, lda, n) {\n    var i, j, k, kp1, t;\n\n    for (k = 1; k <= n; k = k + 1) {\n        a[k][k] = 1 / a[k][k];\n        t = -a[k][k];\n        //~ dscal(k - 1, t, a[1][k], 1);\n        for (i = 1; i < k; i = i + 1) {\n            a[i][k] = t * a[i][k];\n        }\n\n        kp1 = k + 1;\n        if (n < kp1) {\n            break;\n        }\n        for (j = kp1; j <= n; j = j + 1) {\n            t = a[k][j];\n            a[k][j] = 0;\n            //~ daxpy(k, t, a[1][k], 1, a[1][j], 1);\n            for (i = 1; i <= k; i = i + 1) {\n                a[i][j] = a[i][j] + (t * a[i][k]);\n            }\n        }\n    }\n\n}\n\nfunction dposl(a, lda, n, b) {\n    var i, k, kb, t;\n\n    for (k = 1; k <= n; k = k + 1) {\n        //~ t = ddot(k - 1, a[1][k], 1, b[1], 1);\n        t = 0;\n        for (i = 1; i < k; i = i + 1) {\n            t = t + (a[i][k] * b[i]);\n        }\n\n        b[k] = (b[k] - t) / a[k][k];\n    }\n\n    for (kb = 1; kb <= n; kb = kb + 1) {\n        k = n + 1 - kb;\n        b[k] = b[k] / a[k][k];\n        t = -b[k];\n        //~ daxpy(k - 1, t, a[1][k], 1, b[1], 1);\n        for (i = 1; i < k; i = i + 1) {\n            b[i] = b[i] + (t * a[i][k]);\n        }\n    }\n}\n\nfunction dpofa(a, lda, n, info) {\n    var i, j, jm1, k, t, s;\n\n    for (j = 1; j <= n; j = j + 1) {\n        info[1] = j;\n        s = 0;\n        jm1 = j - 1;\n        if (jm1 < 1) {\n            s = a[j][j] - s;\n            if (s <= 0) {\n                break;\n            }\n            a[j][j] = Math.sqrt(s);\n        } else {\n            for (k = 1; k <= jm1; k = k + 1) {\n                //~ t = a[k][j] - ddot(k - 1, a[1][k], 1, a[1][j], 1);\n                t = a[k][j];\n                for (i = 1; i < k; i = i + 1) {\n                    t = t - (a[i][j] * a[i][k]);\n                }\n                t = t / a[k][k];\n                a[k][j] = t;\n                s = s + t * t;\n            }\n            s = a[j][j] - s;\n            if (s <= 0) {\n                break;\n            }\n            a[j][j] = Math.sqrt(s);\n        }\n        info[1] = 0;\n    }\n}\n\nfunction qpgen2(dmat, dvec, fddmat, n, sol, crval, amat,\n    bvec, fdamat, q, meq, iact, nact, iter, work, ierr) {\n\n    var i, j, l, l1, info, it1, iwzv, iwrv, iwrm, iwsv, iwuv, nvl, r, iwnbv,\n        temp, sum, t1, tt, gc, gs, nu,\n        t1inf, t2min,\n        vsmall, tmpa, tmpb,\n        go;\n\n    r = Math.min(n, q);\n    l = 2 * n + (r * (r + 5)) / 2 + 2 * q + 1;\n\n    vsmall = 1.0e-60;\n    do {\n        vsmall = vsmall + vsmall;\n        tmpa = 1 + 0.1 * vsmall;\n        tmpb = 1 + 0.2 * vsmall;\n    } while (tmpa <= 1 || tmpb <= 1);\n\n    for (i = 1; i <= n; i = i + 1) {\n        work[i] = dvec[i];\n    }\n    for (i = n + 1; i <= l; i = i + 1) {\n        work[i] = 0;\n    }\n    for (i = 1; i <= q; i = i + 1) {\n        iact[i] = 0;\n    }\n\n    info = [];\n\n    if (ierr[1] === 0) {\n        dpofa(dmat, fddmat, n, info);\n        if (info[1] !== 0) {\n            ierr[1] = 2;\n            return;\n        }\n        dposl(dmat, fddmat, n, dvec);\n        dpori(dmat, fddmat, n);\n    } else {\n        for (j = 1; j <= n; j = j + 1) {\n            sol[j] = 0;\n            for (i = 1; i <= j; i = i + 1) {\n                sol[j] = sol[j] + dmat[i][j] * dvec[i];\n            }\n        }\n        for (j = 1; j <= n; j = j + 1) {\n            dvec[j] = 0;\n            for (i = j; i <= n; i = i + 1) {\n                dvec[j] = dvec[j] + dmat[j][i] * sol[i];\n            }\n        }\n    }\n\n    crval[1] = 0;\n    for (j = 1; j <= n; j = j + 1) {\n        sol[j] = dvec[j];\n        crval[1] = crval[1] + work[j] * sol[j];\n        work[j] = 0;\n        for (i = j + 1; i <= n; i = i + 1) {\n            dmat[i][j] = 0;\n        }\n    }\n    crval[1] = -crval[1] / 2;\n    ierr[1] = 0;\n\n    iwzv = n;\n    iwrv = iwzv + n;\n    iwuv = iwrv + r;\n    iwrm = iwuv + r + 1;\n    iwsv = iwrm + (r * (r + 1)) / 2;\n    iwnbv = iwsv + q;\n\n    for (i = 1; i <= q; i = i + 1) {\n        sum = 0;\n        for (j = 1; j <= n; j = j + 1) {\n            sum = sum + amat[j][i] * amat[j][i];\n        }\n        work[iwnbv + i] = Math.sqrt(sum);\n    }\n    nact = 0;\n    iter[1] = 0;\n    iter[2] = 0;\n\n    function fn_goto_50() {\n        iter[1] = iter[1] + 1;\n\n        l = iwsv;\n        for (i = 1; i <= q; i = i + 1) {\n            l = l + 1;\n            sum = -bvec[i];\n            for (j = 1; j <= n; j = j + 1) {\n                sum = sum + amat[j][i] * sol[j];\n            }\n            if (Math.abs(sum) < vsmall) {\n                sum = 0;\n            }\n            if (i > meq) {\n                work[l] = sum;\n            } else {\n                work[l] = -Math.abs(sum);\n                if (sum > 0) {\n                    for (j = 1; j <= n; j = j + 1) {\n                        amat[j][i] = -amat[j][i];\n                    }\n                    bvec[i] = -bvec[i];\n                }\n            }\n        }\n\n        for (i = 1; i <= nact; i = i + 1) {\n            work[iwsv + iact[i]] = 0;\n        }\n\n        nvl = 0;\n        temp = 0;\n        for (i = 1; i <= q; i = i + 1) {\n            if (work[iwsv + i] < temp * work[iwnbv + i]) {\n                nvl = i;\n                temp = work[iwsv + i] / work[iwnbv + i];\n            }\n        }\n        if (nvl === 0) {\n            return 999;\n        }\n\n        return 0;\n    }\n\n    function fn_goto_55() {\n        for (i = 1; i <= n; i = i + 1) {\n            sum = 0;\n            for (j = 1; j <= n; j = j + 1) {\n                sum = sum + dmat[j][i] * amat[j][nvl];\n            }\n            work[i] = sum;\n        }\n\n        l1 = iwzv;\n        for (i = 1; i <= n; i = i + 1) {\n            work[l1 + i] = 0;\n        }\n        for (j = nact + 1; j <= n; j = j + 1) {\n            for (i = 1; i <= n; i = i + 1) {\n                work[l1 + i] = work[l1 + i] + dmat[i][j] * work[j];\n            }\n        }\n\n        t1inf = true;\n        for (i = nact; i >= 1; i = i - 1) {\n            sum = work[i];\n            l = iwrm + (i * (i + 3)) / 2;\n            l1 = l - i;\n            for (j = i + 1; j <= nact; j = j + 1) {\n                sum = sum - work[l] * work[iwrv + j];\n                l = l + j;\n            }\n            sum = sum / work[l1];\n            work[iwrv + i] = sum;\n            if (iact[i] < meq) {\n                // continue;\n                break;\n            }\n            if (sum < 0) {\n                // continue;\n                break;\n            }\n            t1inf = false;\n            it1 = i;\n        }\n\n        if (!t1inf) {\n            t1 = work[iwuv + it1] / work[iwrv + it1];\n            for (i = 1; i <= nact; i = i + 1) {\n                if (iact[i] < meq) {\n                    // continue;\n                    break;\n                }\n                if (work[iwrv + i] < 0) {\n                    // continue;\n                    break;\n                }\n                temp = work[iwuv + i] / work[iwrv + i];\n                if (temp < t1) {\n                    t1 = temp;\n                    it1 = i;\n                }\n            }\n        }\n\n        sum = 0;\n        for (i = iwzv + 1; i <= iwzv + n; i = i + 1) {\n            sum = sum + work[i] * work[i];\n        }\n        if (Math.abs(sum) <= vsmall) {\n            if (t1inf) {\n                ierr[1] = 1;\n                // GOTO 999\n                return 999;\n            } else {\n                for (i = 1; i <= nact; i = i + 1) {\n                    work[iwuv + i] = work[iwuv + i] - t1 * work[iwrv + i];\n                }\n                work[iwuv + nact + 1] = work[iwuv + nact + 1] + t1;\n                // GOTO 700\n                return 700;\n            }\n        } else {\n            sum = 0;\n            for (i = 1; i <= n; i = i + 1) {\n                sum = sum + work[iwzv + i] * amat[i][nvl];\n            }\n            tt = -work[iwsv + nvl] / sum;\n            t2min = true;\n            if (!t1inf) {\n                if (t1 < tt) {\n                    tt = t1;\n                    t2min = false;\n                }\n            }\n\n            for (i = 1; i <= n; i = i + 1) {\n                sol[i] = sol[i] + tt * work[iwzv + i];\n                if (Math.abs(sol[i]) < vsmall) {\n                    sol[i] = 0;\n                }\n            }\n\n            crval[1] = crval[1] + tt * sum * (tt / 2 + work[iwuv + nact + 1]);\n            for (i = 1; i <= nact; i = i + 1) {\n                work[iwuv + i] = work[iwuv + i] - tt * work[iwrv + i];\n            }\n            work[iwuv + nact + 1] = work[iwuv + nact + 1] + tt;\n\n            if (t2min) {\n                nact = nact + 1;\n                iact[nact] = nvl;\n\n                l = iwrm + ((nact - 1) * nact) / 2 + 1;\n                for (i = 1; i <= nact - 1; i = i + 1) {\n                    work[l] = work[i];\n                    l = l + 1;\n                }\n\n                if (nact === n) {\n                    work[l] = work[n];\n                } else {\n                    for (i = n; i >= nact + 1; i = i - 1) {\n                        if (work[i] === 0) {\n                            // continue;\n                            break;\n                        }\n                        gc = Math.max(Math.abs(work[i - 1]), Math.abs(work[i]));\n                        gs = Math.min(Math.abs(work[i - 1]), Math.abs(work[i]));\n                        if (work[i - 1] >= 0) {\n                            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n                        } else {\n                            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n                        }\n                        gc = work[i - 1] / temp;\n                        gs = work[i] / temp;\n\n                        if (gc === 1) {\n                            // continue;\n                            break;\n                        }\n                        if (gc === 0) {\n                            work[i - 1] = gs * temp;\n                            for (j = 1; j <= n; j = j + 1) {\n                                temp = dmat[j][i - 1];\n                                dmat[j][i - 1] = dmat[j][i];\n                                dmat[j][i] = temp;\n                            }\n                        } else {\n                            work[i - 1] = temp;\n                            nu = gs / (1 + gc);\n                            for (j = 1; j <= n; j = j + 1) {\n                                temp = gc * dmat[j][i - 1] + gs * dmat[j][i];\n                                dmat[j][i] = nu * (dmat[j][i - 1] + temp) - dmat[j][i];\n                                dmat[j][i - 1] = temp;\n\n                            }\n                        }\n                    }\n                    work[l] = work[nact];\n                }\n            } else {\n                sum = -bvec[nvl];\n                for (j = 1; j <= n; j = j + 1) {\n                    sum = sum + sol[j] * amat[j][nvl];\n                }\n                if (nvl > meq) {\n                    work[iwsv + nvl] = sum;\n                } else {\n                    work[iwsv + nvl] = -Math.abs(sum);\n                    if (sum > 0) {\n                        for (j = 1; j <= n; j = j + 1) {\n                            amat[j][nvl] = -amat[j][nvl];\n                        }\n                        bvec[nvl] = -bvec[nvl];\n                    }\n                }\n                // GOTO 700\n                return 700;\n            }\n        }\n\n        return 0;\n    }\n\n    function fn_goto_797() {\n        l = iwrm + (it1 * (it1 + 1)) / 2 + 1;\n        l1 = l + it1;\n        if (work[l1] === 0) {\n            // GOTO 798\n            return 798;\n        }\n        gc = Math.max(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n        gs = Math.min(Math.abs(work[l1 - 1]), Math.abs(work[l1]));\n        if (work[l1 - 1] >= 0) {\n            temp = Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n        } else {\n            temp = -Math.abs(gc * Math.sqrt(1 + gs * gs / (gc * gc)));\n        }\n        gc = work[l1 - 1] / temp;\n        gs = work[l1] / temp;\n\n        if (gc === 1) {\n            // GOTO 798\n            return 798;\n        }\n        if (gc === 0) {\n            for (i = it1 + 1; i <= nact; i = i + 1) {\n                temp = work[l1 - 1];\n                work[l1 - 1] = work[l1];\n                work[l1] = temp;\n                l1 = l1 + i;\n            }\n            for (i = 1; i <= n; i = i + 1) {\n                temp = dmat[i][it1];\n                dmat[i][it1] = dmat[i][it1 + 1];\n                dmat[i][it1 + 1] = temp;\n            }\n        } else {\n            nu = gs / (1 + gc);\n            for (i = it1 + 1; i <= nact; i = i + 1) {\n                temp = gc * work[l1 - 1] + gs * work[l1];\n                work[l1] = nu * (work[l1 - 1] + temp) - work[l1];\n                work[l1 - 1] = temp;\n                l1 = l1 + i;\n            }\n            for (i = 1; i <= n; i = i + 1) {\n                temp = gc * dmat[i][it1] + gs * dmat[i][it1 + 1];\n                dmat[i][it1 + 1] = nu * (dmat[i][it1] + temp) - dmat[i][it1 + 1];\n                dmat[i][it1] = temp;\n            }\n        }\n\n        return 0;\n    }\n\n    function fn_goto_798() {\n        l1 = l - it1;\n        for (i = 1; i <= it1; i = i + 1) {\n            work[l1] = work[l];\n            l = l + 1;\n            l1 = l1 + 1;\n        }\n\n        work[iwuv + it1] = work[iwuv + it1 + 1];\n        iact[it1] = iact[it1 + 1];\n        it1 = it1 + 1;\n        if (it1 < nact) {\n            // GOTO 797\n            return 797;\n        }\n\n        return 0;\n    }\n\n    function fn_goto_799() {\n        work[iwuv + nact] = work[iwuv + nact + 1];\n        work[iwuv + nact + 1] = 0;\n        iact[nact] = 0;\n        nact = nact - 1;\n        iter[2] = iter[2] + 1;\n\n        return 0;\n    }\n\n    go = 0;\n    while (true) {\n        go = fn_goto_50();\n        if (go === 999) {\n            return;\n        }\n        while (true) {\n            go = fn_goto_55();\n            if (go === 0) {\n                break;\n            }\n            if (go === 999) {\n                return;\n            }\n            if (go === 700) {\n                if (it1 === nact) {\n                    fn_goto_799();\n                } else {\n                    while (true) {\n                        fn_goto_797();\n                        go = fn_goto_798();\n                        if (go !== 797) {\n                            break;\n                        }\n                    }\n                    fn_goto_799();\n                }\n            }\n        }\n    }\n\n}\n\nfunction solveQP(Dmat, dvec, Amat, bvec, meq, factorized) {\n    Dmat = base0to1(Dmat);\n    dvec = base0to1(dvec);\n    Amat = base0to1(Amat);\n    var i, n, q,\n        nact, r,\n        crval = [], iact = [], sol = [], work = [], iter = [],\n        message;\n\n    meq = meq || 0;\n    factorized = factorized ? base0to1(factorized) : [undefined, 0];\n    bvec = bvec ? base0to1(bvec) : [];\n\n    // In Fortran the array index starts from 1\n    n = Dmat.length - 1;\n    q = Amat[1].length - 1;\n\n    if (!bvec) {\n        for (i = 1; i <= q; i = i + 1) {\n            bvec[i] = 0;\n        }\n    }\n    for (i = 1; i <= q; i = i + 1) {\n        iact[i] = 0;\n    }\n    nact = 0;\n    r = Math.min(n, q);\n    for (i = 1; i <= n; i = i + 1) {\n        sol[i] = 0;\n    }\n    crval[1] = 0;\n    for (i = 1; i <= (2 * n + (r * (r + 5)) / 2 + 2 * q + 1); i = i + 1) {\n        work[i] = 0;\n    }\n    for (i = 1; i <= 2; i = i + 1) {\n        iter[i] = 0;\n    }\n\n    qpgen2(Dmat, dvec, n, n, sol, crval, Amat,\n        bvec, n, q, meq, iact, nact, iter, work, factorized);\n\n    message = \"\";\n    if (factorized[1] === 1) {\n        message = \"constraints are inconsistent, no solution!\";\n    }\n    if (factorized[1] === 2) {\n        message = \"matrix D in quadratic function is not positive definite!\";\n    }\n\n    return {\n        solution: base1to0(sol),\n        value: base1to0(crval),\n        unconstrained_solution: base1to0(dvec),\n        iterations: base1to0(iter),\n        iact: base1to0(iact),\n        message: message\n    };\n}\nexports.solveQP = solveQP;\n}(numeric));\n/*\r\nShanti Rao sent me this routine by private email. I had to modify it\r\nslightly to work on Arrays instead of using a Matrix object.\r\nIt is apparently translated from http://stitchpanorama.sourceforge.net/Python/svd.py\r\n*/\r\n\r\nnumeric.svd= function svd(A) {\r\n    var temp;\r\n//Compute the thin SVD from G. H. Golub and C. Reinsch, Numer. Math. 14, 403-420 (1970)\r\n\tvar prec= numeric.epsilon; //Math.pow(2,-52) // assumes double prec\r\n\tvar tolerance= 1.e-64/prec;\r\n\tvar itmax= 50;\r\n\tvar c=0;\r\n\tvar i=0;\r\n\tvar j=0;\r\n\tvar k=0;\r\n\tvar l=0;\r\n\t\r\n\tvar u= numeric.clone(A);\r\n\tvar m= u.length;\r\n\t\r\n\tvar n= u[0].length;\r\n\t\r\n\tif (m < n) throw \"Need more rows than columns\"\r\n\t\r\n\tvar e = new Array(n);\r\n\tvar q = new Array(n);\r\n\tfor (i=0; i<n; i++) e[i] = q[i] = 0.0;\r\n\tvar v = numeric.rep([n,n],0);\r\n//\tv.zero();\r\n\t\r\n \tfunction pythag(a,b)\r\n \t{\r\n\t\ta = Math.abs(a)\r\n\t\tb = Math.abs(b)\r\n\t\tif (a > b)\r\n\t\t\treturn a*Math.sqrt(1.0+(b*b/a/a))\r\n\t\telse if (b == 0.0) \r\n\t\t\treturn a\r\n\t\treturn b*Math.sqrt(1.0+(a*a/b/b))\r\n\t}\r\n\r\n\t//Householder's reduction to bidiagonal form\r\n\r\n\tvar f= 0.0;\r\n\tvar g= 0.0;\r\n\tvar h= 0.0;\r\n\tvar x= 0.0;\r\n\tvar y= 0.0;\r\n\tvar z= 0.0;\r\n\tvar s= 0.0;\r\n\t\r\n\tfor (i=0; i < n; i++)\r\n\t{\t\r\n\t\te[i]= g;\r\n\t\ts= 0.0;\r\n\t\tl= i+1;\r\n\t\tfor (j=i; j < m; j++) \r\n\t\t\ts += (u[j][i]*u[j][i]);\r\n\t\tif (s <= tolerance)\r\n\t\t\tg= 0.0;\r\n\t\telse\r\n\t\t{\t\r\n\t\t\tf= u[i][i];\r\n\t\t\tg= Math.sqrt(s);\r\n\t\t\tif (f >= 0.0) g= -g;\r\n\t\t\th= f*g-s\r\n\t\t\tu[i][i]=f-g;\r\n\t\t\tfor (j=l; j < n; j++)\r\n\t\t\t{\r\n\t\t\t\ts= 0.0\r\n\t\t\t\tfor (k=i; k < m; k++) \r\n\t\t\t\t\ts += u[k][i]*u[k][j]\r\n\t\t\t\tf= s/h\r\n\t\t\t\tfor (k=i; k < m; k++) \r\n\t\t\t\t\tu[k][j]+=f*u[k][i]\r\n\t\t\t}\r\n\t\t}\r\n\t\tq[i]= g\r\n\t\ts= 0.0\r\n\t\tfor (j=l; j < n; j++) \r\n\t\t\ts= s + u[i][j]*u[i][j]\r\n\t\tif (s <= tolerance)\r\n\t\t\tg= 0.0\r\n\t\telse\r\n\t\t{\t\r\n\t\t\tf= u[i][i+1]\r\n\t\t\tg= Math.sqrt(s)\r\n\t\t\tif (f >= 0.0) g= -g\r\n\t\t\th= f*g - s\r\n\t\t\tu[i][i+1] = f-g;\r\n\t\t\tfor (j=l; j < n; j++) e[j]= u[i][j]/h\r\n\t\t\tfor (j=l; j < m; j++)\r\n\t\t\t{\t\r\n\t\t\t\ts=0.0\r\n\t\t\t\tfor (k=l; k < n; k++) \r\n\t\t\t\t\ts += (u[j][k]*u[i][k])\r\n\t\t\t\tfor (k=l; k < n; k++) \r\n\t\t\t\t\tu[j][k]+=s*e[k]\r\n\t\t\t}\t\r\n\t\t}\r\n\t\ty= Math.abs(q[i])+Math.abs(e[i])\r\n\t\tif (y>x) \r\n\t\t\tx=y\r\n\t}\r\n\t\r\n\t// accumulation of right hand gtransformations\r\n\tfor (i=n-1; i != -1; i+= -1)\r\n\t{\t\r\n\t\tif (g != 0.0)\r\n\t\t{\r\n\t\t \th= g*u[i][i+1]\r\n\t\t\tfor (j=l; j < n; j++) \r\n\t\t\t\tv[j][i]=u[i][j]/h\r\n\t\t\tfor (j=l; j < n; j++)\r\n\t\t\t{\t\r\n\t\t\t\ts=0.0\r\n\t\t\t\tfor (k=l; k < n; k++) \r\n\t\t\t\t\ts += u[i][k]*v[k][j]\r\n\t\t\t\tfor (k=l; k < n; k++) \r\n\t\t\t\t\tv[k][j]+=(s*v[k][i])\r\n\t\t\t}\t\r\n\t\t}\r\n\t\tfor (j=l; j < n; j++)\r\n\t\t{\r\n\t\t\tv[i][j] = 0;\r\n\t\t\tv[j][i] = 0;\r\n\t\t}\r\n\t\tv[i][i] = 1;\r\n\t\tg= e[i]\r\n\t\tl= i\r\n\t}\r\n\t\r\n\t// accumulation of left hand transformations\r\n\tfor (i=n-1; i != -1; i+= -1)\r\n\t{\t\r\n\t\tl= i+1\r\n\t\tg= q[i]\r\n\t\tfor (j=l; j < n; j++) \r\n\t\t\tu[i][j] = 0;\r\n\t\tif (g != 0.0)\r\n\t\t{\r\n\t\t\th= u[i][i]*g\r\n\t\t\tfor (j=l; j < n; j++)\r\n\t\t\t{\r\n\t\t\t\ts=0.0\r\n\t\t\t\tfor (k=l; k < m; k++) s += u[k][i]*u[k][j];\r\n\t\t\t\tf= s/h\r\n\t\t\t\tfor (k=i; k < m; k++) u[k][j]+=f*u[k][i];\r\n\t\t\t}\r\n\t\t\tfor (j=i; j < m; j++) u[j][i] = u[j][i]/g;\r\n\t\t}\r\n\t\telse\r\n\t\t\tfor (j=i; j < m; j++) u[j][i] = 0;\r\n\t\tu[i][i] += 1;\r\n\t}\r\n\t\r\n\t// diagonalization of the bidiagonal form\r\n\tprec= prec*x\r\n\tfor (k=n-1; k != -1; k+= -1)\r\n\t{\r\n\t\tfor (var iteration=0; iteration < itmax; iteration++)\r\n\t\t{\t// test f splitting\r\n\t\t\tvar test_convergence = false\r\n\t\t\tfor (l=k; l != -1; l+= -1)\r\n\t\t\t{\t\r\n\t\t\t\tif (Math.abs(e[l]) <= prec)\r\n\t\t\t\t{\ttest_convergence= true\r\n\t\t\t\t\tbreak \r\n\t\t\t\t}\r\n\t\t\t\tif (Math.abs(q[l-1]) <= prec)\r\n\t\t\t\t\tbreak \r\n\t\t\t}\r\n\t\t\tif (!test_convergence)\r\n\t\t\t{\t// cancellation of e[l] if l>0\r\n\t\t\t\tc= 0.0\r\n\t\t\t\ts= 1.0\r\n\t\t\t\tvar l1= l-1\r\n\t\t\t\tfor (i =l; i<k+1; i++)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tf= s*e[i]\r\n\t\t\t\t\te[i]= c*e[i]\r\n\t\t\t\t\tif (Math.abs(f) <= prec)\r\n\t\t\t\t\t\tbreak\r\n\t\t\t\t\tg= q[i]\r\n\t\t\t\t\th= pythag(f,g)\r\n\t\t\t\t\tq[i]= h\r\n\t\t\t\t\tc= g/h\r\n\t\t\t\t\ts= -f/h\r\n\t\t\t\t\tfor (j=0; j < m; j++)\r\n\t\t\t\t\t{\t\r\n\t\t\t\t\t\ty= u[j][l1]\r\n\t\t\t\t\t\tz= u[j][i]\r\n\t\t\t\t\t\tu[j][l1] =  y*c+(z*s)\r\n\t\t\t\t\t\tu[j][i] = -y*s+(z*c)\r\n\t\t\t\t\t} \r\n\t\t\t\t}\t\r\n\t\t\t}\r\n\t\t\t// test f convergence\r\n\t\t\tz= q[k]\r\n\t\t\tif (l== k)\r\n\t\t\t{\t//convergence\r\n\t\t\t\tif (z<0.0)\r\n\t\t\t\t{\t//q[k] is made non-negative\r\n\t\t\t\t\tq[k]= -z\r\n\t\t\t\t\tfor (j=0; j < n; j++)\r\n\t\t\t\t\t\tv[j][k] = -v[j][k]\r\n\t\t\t\t}\r\n\t\t\t\tbreak  //break out of iteration loop and move on to next k value\r\n\t\t\t}\r\n\t\t\tif (iteration >= itmax-1)\r\n\t\t\t\tthrow 'Error: no convergence.'\r\n\t\t\t// shift from bottom 2x2 minor\r\n\t\t\tx= q[l]\r\n\t\t\ty= q[k-1]\r\n\t\t\tg= e[k-1]\r\n\t\t\th= e[k]\r\n\t\t\tf= ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y)\r\n\t\t\tg= pythag(f,1.0)\r\n\t\t\tif (f < 0.0)\r\n\t\t\t\tf= ((x-z)*(x+z)+h*(y/(f-g)-h))/x\r\n\t\t\telse\r\n\t\t\t\tf= ((x-z)*(x+z)+h*(y/(f+g)-h))/x\r\n\t\t\t// next QR transformation\r\n\t\t\tc= 1.0\r\n\t\t\ts= 1.0\r\n\t\t\tfor (i=l+1; i< k+1; i++)\r\n\t\t\t{\t\r\n\t\t\t\tg= e[i]\r\n\t\t\t\ty= q[i]\r\n\t\t\t\th= s*g\r\n\t\t\t\tg= c*g\r\n\t\t\t\tz= pythag(f,h)\r\n\t\t\t\te[i-1]= z\r\n\t\t\t\tc= f/z\r\n\t\t\t\ts= h/z\r\n\t\t\t\tf= x*c+g*s\r\n\t\t\t\tg= -x*s+g*c\r\n\t\t\t\th= y*s\r\n\t\t\t\ty= y*c\r\n\t\t\t\tfor (j=0; j < n; j++)\r\n\t\t\t\t{\t\r\n\t\t\t\t\tx= v[j][i-1]\r\n\t\t\t\t\tz= v[j][i]\r\n\t\t\t\t\tv[j][i-1] = x*c+z*s\r\n\t\t\t\t\tv[j][i] = -x*s+z*c\r\n\t\t\t\t}\r\n\t\t\t\tz= pythag(f,h)\r\n\t\t\t\tq[i-1]= z\r\n\t\t\t\tc= f/z\r\n\t\t\t\ts= h/z\r\n\t\t\t\tf= c*g+s*y\r\n\t\t\t\tx= -s*g+c*y\r\n\t\t\t\tfor (j=0; j < m; j++)\r\n\t\t\t\t{\r\n\t\t\t\t\ty= u[j][i-1]\r\n\t\t\t\t\tz= u[j][i]\r\n\t\t\t\t\tu[j][i-1] = y*c+z*s\r\n\t\t\t\t\tu[j][i] = -y*s+z*c\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\te[l]= 0.0\r\n\t\t\te[k]= f\r\n\t\t\tq[k]= x\r\n\t\t} \r\n\t}\r\n\t\t\r\n\t//vt= transpose(v)\r\n\t//return (u,q,vt)\r\n\tfor (i=0;i<q.length; i++) \r\n\t  if (q[i] < prec) q[i] = 0\r\n\t  \r\n\t//sort eigenvalues\t\r\n\tfor (i=0; i< n; i++)\r\n\t{\t \r\n\t//writeln(q)\r\n\t for (j=i-1; j >= 0; j--)\r\n\t {\r\n\t  if (q[j] < q[i])\r\n\t  {\r\n\t//  writeln(i,'-',j)\r\n\t   c = q[j]\r\n\t   q[j] = q[i]\r\n\t   q[i] = c\r\n\t   for(k=0;k<u.length;k++) { temp = u[k][i]; u[k][i] = u[k][j]; u[k][j] = temp; }\r\n\t   for(k=0;k<v.length;k++) { temp = v[k][i]; v[k][i] = v[k][j]; v[k][j] = temp; }\r\n//\t   u.swapCols(i,j)\r\n//\t   v.swapCols(i,j)\r\n\t   i = j\t   \r\n\t  }\r\n\t }\t\r\n\t}\r\n\t\r\n\treturn {U:u,S:q,V:v}\r\n};\r\n\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"../node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://STK/../node_modules/numeric/numeric-1.2.6.js?");

/***/ }),

/***/ "../node_modules/pako/index.js":
/*!*************************************!*\
  !*** ../node_modules/pako/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"../node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"../node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"../node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"../node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/index.js?");

/***/ }),

/***/ "../node_modules/pako/lib/deflate.js":
/*!*******************************************!*\
  !*** ../node_modules/pako/lib/deflate.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"../node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"../node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"../node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"../node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"../node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/deflate.js?");

/***/ }),

/***/ "../node_modules/pako/lib/inflate.js":
/*!*******************************************!*\
  !*** ../node_modules/pako/lib/inflate.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"../node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"../node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"../node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"../node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"../node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"../node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"../node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/inflate.js?");

/***/ }),

/***/ "../node_modules/pako/lib/utils/common.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/utils/common.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/utils/common.js?");

/***/ }),

/***/ "../node_modules/pako/lib/utils/strings.js":
/*!*************************************************!*\
  !*** ../node_modules/pako/lib/utils/strings.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"../node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/utils/strings.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/adler32.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/zlib/adler32.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/adler32.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/constants.js":
/*!**************************************************!*\
  !*** ../node_modules/pako/lib/zlib/constants.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/constants.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/crc32.js":
/*!**********************************************!*\
  !*** ../node_modules/pako/lib/zlib/crc32.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/crc32.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/deflate.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/zlib/deflate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"../node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"../node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"../node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"../node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"../node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/deflate.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/gzheader.js":
/*!*************************************************!*\
  !*** ../node_modules/pako/lib/zlib/gzheader.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/gzheader.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inffast.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/zlib/inffast.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/inffast.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inflate.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/zlib/inflate.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"../node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"../node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"../node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"../node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"../node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/inflate.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inftrees.js":
/*!*************************************************!*\
  !*** ../node_modules/pako/lib/zlib/inftrees.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"../node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/inftrees.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/messages.js":
/*!*************************************************!*\
  !*** ../node_modules/pako/lib/zlib/messages.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/messages.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/trees.js":
/*!**********************************************!*\
  !*** ../node_modules/pako/lib/zlib/trees.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"../node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/trees.js?");

/***/ }),

/***/ "../node_modules/pako/lib/zlib/zstream.js":
/*!************************************************!*\
  !*** ../node_modules/pako/lib/zlib/zstream.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n//# sourceURL=webpack://STK/../node_modules/pako/lib/zlib/zstream.js?");

/***/ }),

/***/ "../node_modules/papaparse/papaparse.min.js":
/*!**************************************************!*\
  !*** ../node_modules/papaparse/papaparse.min.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* @license\nPapa Parse\nv4.6.3\nhttps://github.com/mholt/PapaParse\nLicense: MIT\n*/\nArray.isArray||(Array.isArray=function(e){return\"[object Array]\"===Object.prototype.toString.call(e)}),function(e,t){\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof module&&\"undefined\"!=typeof exports?module.exports=t():e.Papa=t()}(this,function(){\"use strict\";var s,e,f=\"undefined\"!=typeof self?self:\"undefined\"!=typeof window?window:void 0!==f?f:{},n=!f.document&&!!f.postMessage,o=n&&/(\\?|&)papaworker(=|&|$)/.test(f.location.search),a=!1,h={},u=0,k={parse:function(e,t){var r=(t=t||{}).dynamicTyping||!1;z(r)&&(t.dynamicTypingFunction=r,r={});if(t.dynamicTyping=r,t.transform=!!z(t.transform)&&t.transform,t.worker&&k.WORKERS_SUPPORTED){var i=function(){if(!k.WORKERS_SUPPORTED)return!1;if(!a&&null===k.SCRIPT_PATH)throw new Error(\"Script path cannot be determined automatically when Papa Parse is loaded asynchronously. You need to set Papa.SCRIPT_PATH manually.\");var e=k.SCRIPT_PATH||s;e+=(-1!==e.indexOf(\"?\")?\"&\":\"?\")+\"papaworker\";var t=new f.Worker(e);return t.onmessage=m,t.id=u++,h[t.id]=t}();return i.userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=z(t.step),t.chunk=z(t.chunk),t.complete=z(t.complete),t.error=z(t.error),delete t.worker,void i.postMessage({input:e,config:t,workerId:i.id})}var n=null;k.NODE_STREAM_INPUT,\"string\"==typeof e?n=t.download?new c(t):new _(t):!0===e.readable&&z(e.read)&&z(e.on)?n=new g(t):(f.File&&e instanceof File||e instanceof Object)&&(n=new p(t));return n.stream(e)},unparse:function(e,t){var i=!1,g=!0,m=\",\",y=\"\\r\\n\",n='\"',r=!1;!function(){if(\"object\"!=typeof t)return;\"string\"!=typeof t.delimiter||k.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter);(\"boolean\"==typeof t.quotes||Array.isArray(t.quotes))&&(i=t.quotes);\"boolean\"!=typeof t.skipEmptyLines&&\"string\"!=typeof t.skipEmptyLines||(r=t.skipEmptyLines);\"string\"==typeof t.newline&&(y=t.newline);\"string\"==typeof t.quoteChar&&(n=t.quoteChar);\"boolean\"==typeof t.header&&(g=t.header)}();var s=new RegExp(M(n),\"g\");\"string\"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return o(null,e,r);if(\"object\"==typeof e[0])return o(a(e[0]),e,r)}else if(\"object\"==typeof e)return\"string\"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:a(e.data[0])),Array.isArray(e.data[0])||\"object\"==typeof e.data[0]||(e.data=[e.data])),o(e.fields||[],e.data||[],r);throw\"exception: Unable to serialize unrecognized input\";function a(e){if(\"object\"!=typeof e)return[];var t=[];for(var r in e)t.push(r);return t}function o(e,t,r){var i=\"\";\"string\"==typeof e&&(e=JSON.parse(e)),\"string\"==typeof t&&(t=JSON.parse(t));var n=Array.isArray(e)&&0<e.length,s=!Array.isArray(t[0]);if(n&&g){for(var a=0;a<e.length;a++)0<a&&(i+=m),i+=v(e[a],a);0<t.length&&(i+=y)}for(var o=0;o<t.length;o++){var h=n?e.length:t[o].length,u=!1,f=n?0===Object.keys(t[o]).length:0===t[o].length;if(r&&!n&&(u=\"greedy\"===r?\"\"===t[o].join(\"\").trim():1===t[o].length&&0===t[o][0].length),\"greedy\"===r&&n){for(var d=[],l=0;l<h;l++){var c=s?e[l]:l;d.push(t[o][c])}u=\"\"===d.join(\"\").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!f&&(i+=m);var _=n&&s?e[p]:p;i+=v(t[o][_],p)}o<t.length-1&&(!r||0<h&&!f)&&(i+=y)}}return i}function v(e,t){if(null==e)return\"\";if(e.constructor===Date)return JSON.stringify(e).slice(1,25);e=e.toString().replace(s,n+n);var r=\"boolean\"==typeof i&&i||Array.isArray(i)&&i[t]||function(e,t){for(var r=0;r<t.length;r++)if(-1<e.indexOf(t[r]))return!0;return!1}(e,k.BAD_DELIMITERS)||-1<e.indexOf(m)||\" \"===e.charAt(0)||\" \"===e.charAt(e.length-1);return r?n+e+n:e}}};if(k.RECORD_SEP=String.fromCharCode(30),k.UNIT_SEP=String.fromCharCode(31),k.BYTE_ORDER_MARK=\"\\ufeff\",k.BAD_DELIMITERS=[\"\\r\",\"\\n\",'\"',k.BYTE_ORDER_MARK],k.WORKERS_SUPPORTED=!n&&!!f.Worker,k.SCRIPT_PATH=null,k.NODE_STREAM_INPUT=1,k.LocalChunkSize=10485760,k.RemoteChunkSize=5242880,k.DefaultDelimiter=\",\",k.Parser=v,k.ParserHandle=r,k.NetworkStreamer=c,k.FileStreamer=p,k.StringStreamer=_,k.ReadableStreamStreamer=g,f.jQuery){var d=f.jQuery;d.fn.parse=function(o){var r=o.config||{},h=[];return this.each(function(e){if(!(\"INPUT\"===d(this).prop(\"tagName\").toUpperCase()&&\"file\"===d(this).attr(\"type\").toLowerCase()&&f.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},r)})}),e(),this;function e(){if(0!==h.length){var e,t,r,i,n=h[0];if(z(o.before)){var s=o.before(n.file,n.inputElem);if(\"object\"==typeof s){if(\"abort\"===s.action)return e=\"AbortError\",t=n.file,r=n.inputElem,i=s.reason,void(z(o.error)&&o.error({name:e},t,r,i));if(\"skip\"===s.action)return void u();\"object\"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if(\"skip\"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){z(a)&&a(e,n.file,n.inputElem),u()},k.parse(n.file,n.instanceConfig)}else z(o.complete)&&o.complete()}function u(){h.splice(0,1),e()}}}function l(e){this._handle=null,this._finished=!1,this._completed=!1,this._input=null,this._baseIndex=0,this._partialLine=\"\",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=E(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new r(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(e,t){if(this.isFirstChunk&&z(this._config.beforeFirstChunk)){var r=this._config.beforeFirstChunk(e);void 0!==r&&(e=r)}this.isFirstChunk=!1;var i=this._partialLine+e;this._partialLine=\"\";var n=this._handle.parse(i,this._baseIndex,!this._finished);if(!this._handle.paused()&&!this._handle.aborted()){var s=n.meta.cursor;this._finished||(this._partialLine=i.substring(s-this._baseIndex),this._baseIndex=s),n&&n.data&&(this._rowCount+=n.data.length);var a=this._finished||this._config.preview&&this._rowCount>=this._config.preview;if(o)f.postMessage({results:n,workerId:k.WORKER_ID,finished:a});else if(z(this._config.chunk)&&!t){if(this._config.chunk(n,this._handle),this._handle.paused()||this._handle.aborted())return;n=void 0,this._completeResults=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(n.data),this._completeResults.errors=this._completeResults.errors.concat(n.errors),this._completeResults.meta=n.meta),this._completed||!a||!z(this._config.complete)||n&&n.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),a||n&&n.meta.paused||this._nextChunk(),n}},this._sendError=function(e){z(this._config.error)?this._config.error(e):o&&this._config.error&&f.postMessage({workerId:k.WORKER_ID,error:e,finished:!1})}}function c(e){var i;(e=e||{}).chunkSize||(e.chunkSize=k.RemoteChunkSize),l.call(this,e),this._nextChunk=n?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(i=new XMLHttpRequest,this._config.withCredentials&&(i.withCredentials=this._config.withCredentials),n||(i.onload=w(this._chunkLoaded,this),i.onerror=w(this._chunkError,this)),i.open(\"GET\",this._input,!n),this._config.downloadRequestHeaders){var e=this._config.downloadRequestHeaders;for(var t in e)i.setRequestHeader(t,e[t])}if(this._config.chunkSize){var r=this._start+this._config.chunkSize-1;i.setRequestHeader(\"Range\",\"bytes=\"+this._start+\"-\"+r),i.setRequestHeader(\"If-None-Match\",\"webkit-no-cache\")}try{i.send()}catch(e){this._chunkError(e.message)}n&&0===i.status?this._chunkError():this._start+=this._config.chunkSize}},this._chunkLoaded=function(){4===i.readyState&&(i.status<200||400<=i.status?this._chunkError():(this._finished=!this._config.chunkSize||this._start>function(e){var t=e.getResponseHeader(\"Content-Range\");if(null===t)return-1;return parseInt(t.substr(t.lastIndexOf(\"/\")+1))}(i),this.parseChunk(i.responseText)))},this._chunkError=function(e){var t=i.statusText||e;this._sendError(new Error(t))}}function p(e){var i,n;(e=e||{}).chunkSize||(e.chunkSize=k.LocalChunkSize),l.call(this,e);var s=\"undefined\"!=typeof FileReader;this.stream=function(e){this._input=e,n=e.slice||e.webkitSlice||e.mozSlice,s?((i=new FileReader).onload=w(this._chunkLoaded,this),i.onerror=w(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input;if(this._config.chunkSize){var t=Math.min(this._start+this._config.chunkSize,this._input.size);e=n.call(e,this._start,t)}var r=i.readAsText(e,this._config.encoding);s||this._chunkLoaded({target:{result:r}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function _(e){var r;l.call(this,e=e||{}),this.stream=function(e){return r=e,this._nextChunk()},this._nextChunk=function(){if(!this._finished){var e=this._config.chunkSize,t=e?r.substr(0,e):r;return r=e?r.substr(e):\"\",this._finished=!r,this.parseChunk(t)}}}function g(e){l.call(this,e=e||{});var t=[],r=!0,i=!1;this.pause=function(){l.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){l.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on(\"data\",this._streamData),this._input.on(\"end\",this._streamEnd),this._input.on(\"error\",this._streamError)},this._checkIsFinished=function(){i&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):r=!0},this._streamData=w(function(e){try{t.push(\"string\"==typeof e?e:e.toString(this._config.encoding)),r&&(r=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=w(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=w(function(){this._streamCleanUp(),i=!0,this._streamData(\"\")},this),this._streamCleanUp=w(function(){this._input.removeListener(\"data\",this._streamData),this._input.removeListener(\"end\",this._streamEnd),this._input.removeListener(\"error\",this._streamError)},this)}function r(g){var a,o,h,i=/^\\s*-?(\\d*\\.?\\d+|\\d+\\.?\\d*)(e[-+]?\\d+)?\\s*$/i,n=/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/,t=this,r=0,s=0,u=!1,e=!1,f=[],d={data:[],errors:[],meta:{}};if(z(g.step)){var l=g.step;g.step=function(e){if(d=e,p())c();else{if(c(),0===d.data.length)return;r+=e.data.length,g.preview&&r>g.preview?o.abort():l(d,t)}}}function m(e){return\"greedy\"===g.skipEmptyLines?\"\"===e.join(\"\").trim():1===e.length&&0===e[0].length}function c(){if(d&&h&&(y(\"Delimiter\",\"UndetectableDelimiter\",\"Unable to auto-detect delimiting character; defaulted to '\"+k.DefaultDelimiter+\"'\"),h=!1),g.skipEmptyLines)for(var e=0;e<d.data.length;e++)m(d.data[e])&&d.data.splice(e--,1);return p()&&function(){if(!d)return;for(var e=0;p()&&e<d.data.length;e++)for(var t=0;t<d.data[e].length;t++){var r=d.data[e][t];g.trimHeaders&&(r=r.trim()),f.push(r)}d.data.splice(0,1)}(),function(){if(!d||!g.header&&!g.dynamicTyping&&!g.transform)return d;for(var e=0;e<d.data.length;e++){var t,r=g.header?{}:[];for(t=0;t<d.data[e].length;t++){var i=t,n=d.data[e][t];g.header&&(i=t>=f.length?\"__parsed_extra\":f[t]),g.transform&&(n=g.transform(n,i)),n=_(i,n),\"__parsed_extra\"===i?(r[i]=r[i]||[],r[i].push(n)):r[i]=n}d.data[e]=r,g.header&&(t>f.length?y(\"FieldMismatch\",\"TooManyFields\",\"Too many fields: expected \"+f.length+\" fields but parsed \"+t,s+e):t<f.length&&y(\"FieldMismatch\",\"TooFewFields\",\"Too few fields: expected \"+f.length+\" fields but parsed \"+t,s+e))}g.header&&d.meta&&(d.meta.fields=f);return s+=d.data.length,d}()}function p(){return g.header&&0===f.length}function _(e,t){return r=e,g.dynamicTypingFunction&&void 0===g.dynamicTyping[r]&&(g.dynamicTyping[r]=g.dynamicTypingFunction(r)),!0===(g.dynamicTyping[r]||g.dynamicTyping)?\"true\"===t||\"TRUE\"===t||\"false\"!==t&&\"FALSE\"!==t&&(i.test(t)?parseFloat(t):n.test(t)?new Date(t):\"\"===t?null:t):t;var r}function y(e,t,r,i){d.errors.push({type:e,code:t,message:r,row:i})}this.parse=function(e,t,r){var i=g.quoteChar||'\"';if(g.newline||(g.newline=function(e,t){e=e.substr(0,1048576);var r=new RegExp(M(t)+\"([^]*?)\"+M(t),\"gm\"),i=(e=e.replace(r,\"\")).split(\"\\r\"),n=e.split(\"\\n\"),s=1<n.length&&n[0].length<i[0].length;if(1===i.length||s)return\"\\n\";for(var a=0,o=0;o<i.length;o++)\"\\n\"===i[o][0]&&a++;return a>=i.length/2?\"\\r\\n\":\"\\r\"}(e,i)),h=!1,g.delimiter)z(g.delimiter)&&(g.delimiter=g.delimiter(e),d.meta.delimiter=g.delimiter);else{var n=function(e,t,r,i){for(var n,s,a,o=[\",\",\"\\t\",\"|\",\";\",k.RECORD_SEP,k.UNIT_SEP],h=0;h<o.length;h++){var u=o[h],f=0,d=0,l=0;a=void 0;for(var c=new v({comments:i,delimiter:u,newline:t,preview:10}).parse(e),p=0;p<c.data.length;p++)if(r&&m(c.data[p]))l++;else{var _=c.data[p].length;d+=_,void 0!==a?1<_&&(f+=Math.abs(_-a),a=_):a=0}0<c.data.length&&(d/=c.data.length-l),(void 0===s||s<f)&&1.99<d&&(s=f,n=u)}return{successful:!!(g.delimiter=n),bestDelimiter:n}}(e,g.newline,g.skipEmptyLines,g.comments);n.successful?g.delimiter=n.bestDelimiter:(h=!0,g.delimiter=k.DefaultDelimiter),d.meta.delimiter=g.delimiter}var s=E(g);return g.preview&&g.header&&s.preview++,a=e,o=new v(s),d=o.parse(a,t,r),c(),u?{meta:{paused:!0}}:d||{meta:{paused:!1}}},this.paused=function(){return u},this.pause=function(){u=!0,o.abort(),a=a.substr(o.getCharIndex())},this.resume=function(){u=!1,t.streamer.parseChunk(a,!0)},this.aborted=function(){return e},this.abort=function(){e=!0,o.abort(),d.meta.aborted=!0,z(g.complete)&&g.complete(d),a=\"\"}}function M(e){return e.replace(/[.*+?^${}()|[\\]\\\\]/g,\"\\\\$&\")}function v(e){var S,O=(e=e||{}).delimiter,x=e.newline,T=e.comments,I=e.step,A=e.preview,D=e.fastMode,L=S=void 0===e.quoteChar?'\"':e.quoteChar;if(void 0!==e.escapeChar&&(L=e.escapeChar),(\"string\"!=typeof O||-1<k.BAD_DELIMITERS.indexOf(O))&&(O=\",\"),T===O)throw\"Comment character same as delimiter\";!0===T?T=\"#\":(\"string\"!=typeof T||-1<k.BAD_DELIMITERS.indexOf(T))&&(T=!1),\"\\n\"!==x&&\"\\r\"!==x&&\"\\r\\n\"!==x&&(x=\"\\n\");var P=0,F=!1;this.parse=function(i,t,r){if(\"string\"!=typeof i)throw\"Input must be a string\";var n=i.length,e=O.length,s=x.length,a=T.length,o=z(I),h=[],u=[],f=[],d=P=0;if(!i)return C();if(D||!1!==D&&-1===i.indexOf(S)){for(var l=i.split(x),c=0;c<l.length;c++){if(f=l[c],P+=f.length,c!==l.length-1)P+=x.length;else if(r)return C();if(!T||f.substr(0,a)!==T){if(o){if(h=[],k(f.split(O)),R(),F)return C()}else k(f.split(O));if(A&&A<=c)return h=h.slice(0,A),C(!0)}}return C()}for(var p,_=i.indexOf(O,P),g=i.indexOf(x,P),m=new RegExp(M(L)+M(S),\"g\");;)if(i[P]!==S)if(T&&0===f.length&&i.substr(P,a)===T){if(-1===g)return C();P=g+s,g=i.indexOf(x,P),_=i.indexOf(O,P)}else if(-1!==_&&(_<g||-1===g))f.push(i.substring(P,_)),P=_+e,_=i.indexOf(O,P);else{if(-1===g)break;if(f.push(i.substring(P,g)),w(g+s),o&&(R(),F))return C();if(A&&h.length>=A)return C(!0)}else for(p=P,P++;;){if(-1===(p=i.indexOf(S,p+1)))return r||u.push({type:\"Quotes\",code:\"MissingQuotes\",message:\"Quoted field unterminated\",row:h.length,index:P}),E();if(p===n-1)return E(i.substring(P,p).replace(m,S));if(S!==L||i[p+1]!==L){if(S===L||0===p||i[p-1]!==L){var y=b(-1===g?_:Math.min(_,g));if(i[p+1+y]===O){f.push(i.substring(P,p).replace(m,S)),P=p+1+y+e,_=i.indexOf(O,P),g=i.indexOf(x,P);break}var v=b(g);if(i.substr(p+1+v,s)===x){if(f.push(i.substring(P,p).replace(m,S)),w(p+1+v+s),_=i.indexOf(O,P),o&&(R(),F))return C();if(A&&h.length>=A)return C(!0);break}u.push({type:\"Quotes\",code:\"InvalidQuotes\",message:\"Trailing quote on quoted field is malformed\",row:h.length,index:P}),p++}}else p++}return E();function k(e){h.push(e),d=P}function b(e){var t=0;if(-1!==e){var r=i.substring(p+1,e);r&&\"\"===r.trim()&&(t=r.length)}return t}function E(e){return r||(void 0===e&&(e=i.substr(P)),f.push(e),P=n,k(f),o&&R()),C()}function w(e){P=e,k(f),f=[],g=i.indexOf(x,P)}function C(e){return{data:h,errors:u,meta:{delimiter:O,linebreak:x,aborted:F,truncated:!!e,cursor:d+(t||0)}}}function R(){I(C()),h=[],u=[]}},this.abort=function(){F=!0},this.getCharIndex=function(){return P}}function m(e){var t=e.data,r=h[t.workerId],i=!1;if(t.error)r.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){i=!0,y(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:b,resume:b};if(z(r.userStep)){for(var s=0;s<t.results.data.length&&(r.userStep({data:[t.results.data[s]],errors:t.results.errors,meta:t.results.meta},n),!i);s++);delete t.results}else z(r.userChunk)&&(r.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!i&&y(t.workerId,t.results)}function y(e,t){var r=h[e];z(r.userComplete)&&r.userComplete(t),r.terminate(),delete h[e]}function b(){throw\"Not implemented.\"}function E(e){if(\"object\"!=typeof e||null===e)return e;var t=Array.isArray(e)?[]:{};for(var r in e)t[r]=E(e[r]);return t}function w(e,t){return function(){e.apply(t,arguments)}}function z(e){return\"function\"==typeof e}return o?f.onmessage=function(e){var t=e.data;void 0===k.WORKER_ID&&t&&(k.WORKER_ID=t.workerId);if(\"string\"==typeof t.input)f.postMessage({workerId:k.WORKER_ID,results:k.parse(t.input,t.config),finished:!0});else if(f.File&&t.input instanceof File||t.input instanceof Object){var r=k.parse(t.input,t.config);r&&f.postMessage({workerId:k.WORKER_ID,results:r,finished:!0})}}:k.WORKERS_SUPPORTED&&(e=document.getElementsByTagName(\"script\"),s=e.length?e[e.length-1].src:\"\",document.body?document.addEventListener(\"DOMContentLoaded\",function(){a=!0},!0):a=!0),(c.prototype=Object.create(l.prototype)).constructor=c,(p.prototype=Object.create(l.prototype)).constructor=p,(_.prototype=Object.create(_.prototype)).constructor=_,(g.prototype=Object.create(l.prototype)).constructor=g,k});\n\n//# sourceURL=webpack://STK/../node_modules/papaparse/papaparse.min.js?");

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://STK/../node_modules/process/browser.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/amd-define.js":
/*!*****************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-define.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function() {\n\tthrow new Error(\"define cannot be used indirect\");\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/webpack/buildin/amd-define.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/amd-options.js":
/*!******************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-options.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\nmodule.exports = __webpack_amd_options__;\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))\n\n//# sourceURL=webpack://STK/../node_modules/webpack/buildin/amd-options.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://STK/../node_modules/webpack/buildin/global.js?");

/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack://STK/../node_modules/webpack/buildin/module.js?");

/***/ }),

/***/ "../node_modules/well-rng/rng.js":
/*!***************************************!*\
  !*** ../node_modules/well-rng/rng.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * well-rng\n * A fast, pure javascript implementation of the WELL-1024a PRNG. Suitable for\n * use with Node.js or inside a browser with browserify. The output is limited\n * to 31 bits rather than 32, because javascript does not support unsigned ints\n *\n * Available under the terms of the MIT License. See LICENSE.\n * Copyright (c) 2013, Greg Malysa <gmalysa@stanford.edu>\n */\n\n// WELL1024a has parameters:\n// k=1024,w=32,r=32,p=0\n// m1=3,m2=24,m3=10\n// T0=M1, T1=M3(8), T2 = M3(-19), T3 = M3(-14)\n// T4=M3(-11), T5=M3(-7), T6 = M3(-13), T7 = M0\n\n/**\n * Constructor accepts an optional initial state vector. If this is not\n * supplied, then one will be generated automatically. The choice of state\n * vector is not particularly important (this is a strength of WELL) for\n * result quality, but specifying a vector is useful for obtaining repeatable\n * results\n * @param state 32-entry initial state vector\n */\nfunction WELL(state) {\n\tif (!state)\n\t\tstate = this.genstate();\n\tthis.set_state(state, 0);\n\tthis.next_bit = 32;\n}\n\n/**\n * Some constants used to produce various random numbers\n */\nWELL.prototype.scale = 1 / (Math.pow(2, 31)-1);\nWELL.prototype.positive_mask = Math.pow(2, 31)-1;\nWELL.prototype.log2 = Math.log(2);\n\n/**\n * Generate a random state vector using Math.random().\n * @return 32-entry initial state vector\n */\nWELL.prototype.genstate = function() {\n\tvar state = new Array(32);\n\tfor (var i = 0; i < 32; ++i) {\n\t\tstate[i] = 0 | (Math.random()*Math.pow(2, 32));\n\t}\n\treturn state;\n}\n\n/**\n * Retrieve a copy of the internal state vector (you can modify this\n * without breaking the generator internals). You should retrieve the\n * state pointer separately if you intend to copy that as well.\n * @return 32-entry current state vector\n */\nWELL.prototype.get_state = function() {\n\treturn this._state.slice(0);\n}\n\n/**\n * Set the current state and state pointer to obtain a specific series of\n * values\n * @param state The 32-entry state vector to use, which should consist only of 32-bit ints\n * @param sp (optiona) The state pointer to use, which determines where we are in the state vector during PRNG operation\n */\nWELL.prototype.set_state = function(state, sp) {\n\tif (state.length != 32)\n\t\tthrow new TypeError('State vector is not 32 entries long!');\n\n\tthis._n = sp || 0;\n\tthis._state = state.slice(0);\n}\n\n/**\n * Retrieve a random integer from either 0 to 2^31-1 or -2^31 to 2^31-1, depending\n * on the argument given (none implies positive only)\n * @param incNeg (optional) If a truthy value, includes negative values in the output\n * @return int\n */\nWELL.prototype.rand = function(incNeg) {\n\tvar _state = this._state;\n\tvar _n = this._n;\n\n\t// Algorithm pseudo-code from the paper\n\t// z0 = rot_p (v_r-2, v_r-1)\n\t// z1 = T0v_0 ^ T1V_m1\n\t// z2 = T2v_m2 ^ T3V_m3\n\t// z3 = z1 ^ z2\n\t// z4 = T4z0 ^ T5z1 ^ T6z2 ^ T7z3\n\t// vnext_r-1 = v_r-2 & m_p\n\t// for j = r-2 downto 2\n\t// \tvnext_j = v_j-1\n\t// vnext_1 = z3\n\t// vnext_0 = z4\n\t// output y = v_1 or v_0 (pick for convenience of implementation)\n\n\tvar z0 = _state[(_n+31)&31];\n\tvar v_m1 = _state[(_n+3)&31];\n\tvar v_m2 = _state[(_n+24)&31];\n\tvar v_m3 = _state[(_n+10)&31];\n\tvar z1 = z0 ^ (v_m1 ^ (v_m1 >> 8));\n\tvar z2 = v_m2 ^ (v_m2 << 19) ^ v_m3 ^ (v_m3 << 14);\n\n\t_state[_n] = (z1 ^ z2);\n\tthis._n = _n = (_n + 31) & 31;\n\t_state[_n] = (z0 ^ (z0 << 11) ^ z1 ^ (z1 << 7) ^ z2 ^ (z2 << 13));\n\n\treturn (incNeg ? _state[_n] : (_state[_n] & WELL.prototype.positive_mask));\n}\n\n/**\n * Retrieve a random float on the interval [0, 1) or (-1, 1) if the argument is\n * given\n * @param incNeg (optional) If a truthy value, includes negative values in output\n * @return float\n */\nWELL.prototype.random = function(incNeg) {\n\treturn WELL.prototype.rand.call(this, incNeg) * WELL.prototype.scale;\n}\n\n/**\n * Retrieve a random integer on the interval [a, b]\n * @return int\n */\nWELL.prototype.randInt = function(a, b) {\n\tvar dist = 1 + b - a;\n\treturn (WELL.prototype.rand.call(this) % dist) + a;\n}\n\n/**\n * Obtains a small number of random bits (<32) amortizing the cost of running\n * the generator, where possible. This is must faster for generating powers of 2\n * than using randInt().\n * @param bits Number of bits to obtain\n * @return Random integer consisting of only the given number of bits\n */\nWELL.prototype.randBits = function(bits) {\n\tvar mask = (1 << bits) - 1;\n\tvar unshift = 0;\n\t\n\tif (bits + this.next_bit <= 32) {\n\t\tunshift = this.next_bit;\n\t\tthis.next_bit += bits;\n\t}\n\telse {\n\t\tthis.bit_state = WELL.prototype.rand.call(this, true);\n\t\tthis.next_bit = bits;\n\t}\n\t\n\treturn (this.bit_state >> unshift) & mask;\n}\n\nmodule.exports = WELL;\n\n\n//# sourceURL=webpack://STK/../node_modules/well-rng/rng.js?");

/***/ }),

/***/ "./js/apps/MultiModelView/MultiModelView.js":
/*!**************************************************!*\
  !*** ./js/apps/MultiModelView/MultiModelView.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst AssetManager = __webpack_require__(/*! assets/AssetManager */ \"./js/lib/assets/AssetManager.js\");\nconst BasicSearchController = __webpack_require__(/*! search/BasicSearchController */ \"./js/lib/search/BasicSearchController.js\");\nconst ArticulationsRenderHelper = __webpack_require__(/*! articulations/ArticulationsRenderHelper */ \"./js/lib/articulations/ArticulationsRenderHelper.js\")\nconst ViewTile = __webpack_require__(/*! ./ViewTile */ \"./js/apps/MultiModelView/ViewTile.js\")\nvar PubSub = __webpack_require__(/*! PubSub */ \"./js/lib/PubSub.js\");\n\nconst template = '<div class=\"scene\"></div>\\n<div class=\"description\">Scene $</div>';\n\nclass MultiModelView extends PubSub {\n    constructor(canvas, content) {\n        super();\n\n        // Init the parameters\n        this.viewTiles = [];\n        this.autoRotate = false;\n        this.staticMode = false;\n        // this.__cachedModelInstances = {};\n        // this.__loadingModels = {};\n        this.__articulations = {};\n        this.__datasetRegistered = false;\n        // Html stuff\n        this.__canvas = canvas;\n        this.__content = content\n        // Helper function to create the asset Manager\n        this.__assetManager = this.__createAssetManager();\n        this.__renderHelper = this.__createRenderHelper();\n        this.__renderer = this.__createRender();\n\n        this.__showPoint = {};\n        this.__showXYZ = {};\n        this.__showArrow = {};\n        this.__showPlane = {};\n\n        this.assetSources = ['shape2motion', 'partnetsim', 'rpmnet'];\n\n        // Register the dataset\n        this.__registerDataset();\n\n        this.animate();\n    }\n\n    __createRender() {\n        const renderer = new THREE.WebGLRenderer({ canvas: this.__canvas, antialias: true, alpha: true });\n        renderer.setClearColor(0xffffff, 0);\n        renderer.setPixelRatio(window.devicePixelRatio);\n        return renderer;\n    }\n\n    __createAssetManager() {\n        //const useSearchController = cmd.use_search_controller;\n        const useSearchController = true;\n        const assetManager = new AssetManager({\n            autoAlignModels: false,\n            autoScaleModels: false,\n            assetCacheSize: 100,\n            enableLights: false,\n            defaultLightState: false,\n            supportArticulated: true, mergeFixedParts: false,\n            searchController: useSearchController ? new BasicSearchController() : null\n        });\n        return assetManager;\n    }\n\n    __createRenderHelper() {\n        const static_color = 'neutral';\n        const moving_part_color = 'highlight';\n        const attached_moving_part_color = 'faded_highlight';\n        const base_part_color = '#9467BD';\n        const static_opacity = 0.3;\n        const base_opacity = 0.5;\n        const renderHelper = new ArticulationsRenderHelper({\n            staticColor: static_color,\n            movingPartColor: moving_part_color,\n            attachedMovingPartColor: attached_moving_part_color,\n            staticOpacity: static_opacity,\n            basePartColor: base_part_color,\n            baseOpacity: base_opacity\n        });\n        return renderHelper;\n    }\n\n    __registerDataset() {\n        this.__assetManager.registerCustomAssetGroups({\n            assetFiles: Constants.extraAssetsFile,\n            filterBySource: this.assetSources,\n            callback: (err, res) => {\n                console.log('Registered models');\n                this.__assetManager.clearCache();\n                this.__datasetRegistered = true;\n                this.Publish('RegisterDataset');\n            }\n        });\n    }\n\n    // Used to add Model Joint\n    // If without movingPartId and basePartId, it will render all articulations that satisfy the limits\n    // The format of modelInfo should be {'fullId': , 'movingPartId': , 'basePartId': , 'element':}\n    addModelJoint(modelInfo, callback) {\n        if (modelInfo instanceof Array) {\n            // Add a list of modelInfo into dic\n            for (let info of modelInfo) {\n                this.__createViewTile(info, callback);\n            }\n        }\n        else {\n            // Add one model info into the dic\n            this.__createViewTile(modelInfo, callback);\n        }\n    }\n\n    // Used to remove Model Joint\n    // If without movingPartId, it will remove all tiles loading this model; if without modelId, it will delete the relevant element; \n    // If modelInfo == null, then clear all tiles\n    // The modelInfo is the same to that in addModelJoint\n    removeModelJoint(modelInfo) {\n        if (modelInfo == null) {\n            // clear all tiles\n            this.viewTiles = [];\n        }\n        // Remove a list of modelInfo from dic\n        else if (modelInfo instanceof Array) {\n            for (let info of modelInfo) {\n                this.filterModelJoint(info, true);\n            }\n        }\n        // Remove on modelInfo from the dic\n        else {\n            this.filterModelJoint(modelInfo, true);\n        }\n    }\n\n    filterModelJoint(info, removeFlag = false) {\n        const fullId = info.modelId;\n        const movingPartId = info.movingPartId;\n        const basePartId = info.basePartId;\n        const element = info.element;\n\n        const filterViewTiles = [];\n\n        for (let i = this.viewTiles.length - 1; i >= 0; --i) {\n            let filterFlag = true;\n\n            const viewTile = this.viewTiles[i];\n            if (fullId != null && fullId != viewTile.getFullId()) {\n                filterFlag = false;\n            }\n\n            const jointInfo = viewTile.getJointInfo();\n            if (movingPartId != null && movingPartId != jointInfo['movingPartId']) {\n                filterFlag = false;\n            }\n            if (basePartId != null && basePartId != jointInfo['basePartId']) {\n                filterFlag = false;\n            }\n\n            if (element != null && element != viewTile.getElement()) {\n                filterFlag = false;\n            }\n\n            if (filterFlag == true) {\n                if (removeFlag == true) {\n                    this.__removeListeners(i);\n\n                    // Remove the element if created not by UI\n                    const elements = this.__content.querySelectorAll('.list-item');\n                    for (let j = elements.length - 1; j >= 0; --j) {\n                        if (elements[j].querySelector('.scene') == viewTile.getElement()) {\n                            console.log('Remove Element');\n                            this.__content.removeChild(elements[j]);\n                        }\n                    }\n\n                    this.viewTiles.splice(i, 1);\n                }\n                filterViewTiles.push(viewTile);\n            }\n        }\n        return filterViewTiles;\n    }\n\n    setArticulations(modelInfo) {\n        // All informations are necessary, or I cannot judge if this viewtile is loading\n        const fullId = modelInfo.modelId;\n        const movingPartId = modelInfo.movingPartId;\n        const basePartId = modelInfo.basePartId;\n        const articulations = modelInfo.articulations;\n\n        var filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n\n        if (filterViewTiles.length != 0) {\n            filterViewTiles[0].setArticulations(articulations);\n        }\n        else {\n            if (this.__articulations[fullId + movingPartId + basePartId] == null) {\n                // Update to the latest requirement\n                this.__articulations[fullId + movingPartId + basePartId] = articulations;\n\n                this.SubscribeOnce(fullId + movingPartId + basePartId, this, () => {\n                    filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n                    filterViewTiles[0].setArticulations(this.__articulations[fullId + movingPartId + basePartId]);\n                    this.__articulations[fullId + movingPartId + basePartId] = null;\n                });\n            }\n            else {\n                // Update to the latest requirement\n                this.__articulations[fullId + movingPartId + basePartId] = articulations;\n            }\n        }\n\n    }\n\n    showXYZ(modelInfo, display) {\n        // All informations are necessary, or I cannot judge if this viewtile is loading\n        const fullId = modelInfo.modelId;\n        const movingPartId = modelInfo.movingPartId;\n        const basePartId = modelInfo.basePartId;\n\n        var filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n\n        if (filterViewTiles.length != 0) {\n            filterViewTiles[0].showXYZ(display);\n        }\n        else {\n            if (this.__showXYZ[fullId + movingPartId + basePartId] == null) {\n                // Update to the latest requirement\n                this.__showXYZ[fullId + movingPartId + basePartId] = display;\n\n                this.SubscribeOnce(fullId + movingPartId + basePartId, this, () => {\n                    filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n                    filterViewTiles[0].showXYZ(this.__showXYZ[fullId + movingPartId + basePartId]);\n                    this.__showXYZ[fullId + movingPartId + basePartId] = null;\n                });\n            }\n            else {\n                // Update to the latest requirement\n                this.__showXYZ[fullId + movingPartId + basePartId] = display;\n            }\n        }\n    }\n\n    // Display: show or not\n    // id: id to index the point\n    // parameter: {location: [0, 0, 0], color: 0x000000, opacity: 1, size: 1}\n    showPoint(modelInfo, display, id, parameter) {\n        // All informations are necessary, or I cannot judge if this viewtile is loading\n        const fullId = modelInfo.modelId;\n        const movingPartId = modelInfo.movingPartId;\n        const basePartId = modelInfo.basePartId;\n\n        var filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n\n        if (filterViewTiles.length != 0) {\n            filterViewTiles[0].showPoint(display, id, parameter);\n        }\n        else {\n            if (this.__showPoint[fullId + movingPartId + basePartId + id] == null) {\n                // Update to the latest requirement\n                this.__showPoint[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n\n                this.SubscribeOnce(fullId + movingPartId + basePartId, this, () => {\n                    filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n                    let info = this.__showPoint[fullId + movingPartId + basePartId + id];\n                    filterViewTiles[0].showPoint(info['display'], info['id'], info['parameter']);\n                    this.__showPoint[fullId + movingPartId + basePartId + id] = null;\n                });\n            }\n            else {\n                // Update to the latest requirement\n                this.__showPoint[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n            }\n        }\n    }\n\n    // Display: show or not\n    // id: id to index the arrow\n    // parameter: {location: [0, 0, 0], direction: [1, 1, 1], color: 0x000000, opacity: 1, length: 1, arrowSize: 0.2}\n    showArrow(modelInfo, display, id, parameter) {\n        // All informations are necessary, or I cannot judge if this viewtile is loading\n        const fullId = modelInfo.modelId;\n        const movingPartId = modelInfo.movingPartId;\n        const basePartId = modelInfo.basePartId;\n\n        var filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n\n        if (filterViewTiles.length != 0) {\n            filterViewTiles[0].showArrow(display, id, parameter);\n        }\n        else {\n            if (this.__showArrow[fullId + movingPartId + basePartId + id] == null) {\n                // Update to the latest requirement\n                this.__showArrow[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n\n                this.SubscribeOnce(fullId + movingPartId + basePartId, this, () => {\n                    filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n                    let info = this.__showArrow[fullId + movingPartId + basePartId + id];\n                    filterViewTiles[0].showArrow(info['display'], info['id'], info['parameter']);\n                    this.__showArrow[fullId + movingPartId + basePartId + id] = null;\n                });\n            }\n            else {\n                // Update to the latest requirement\n                this.__showArrow[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n            }\n        }\n    }\n\n    // Display: show or not\n    // id: id to index the plane\n    // parameter: {location: [1, 1, 1], normal: [1, 1, 1], size: 1, color: 0x000000, opacity: 1}\n    showPlane(modelInfo, display, id, parameter) {\n        // All informations are necessary, or I cannot judge if this viewtile is loading\n        const fullId = modelInfo.modelId;\n        const movingPartId = modelInfo.movingPartId;\n        const basePartId = modelInfo.basePartId;\n\n        var filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n\n        if (filterViewTiles.length != 0) {\n            filterViewTiles[0].showPlane(display, id, parameter);\n        }\n        else {\n            if (this.__showPlane[fullId + movingPartId + basePartId + id] == null) {\n                // Update to the latest requirement\n                this.__showPlane[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n\n                this.SubscribeOnce(fullId + movingPartId + basePartId, this, () => {\n                    filterViewTiles = this.filterModelJoint({ 'modelId': fullId, 'movingPartId': movingPartId, 'basePartId': basePartId });\n                    let info = this.__showPlane[fullId + movingPartId + basePartId + id];\n                    filterViewTiles[0].showPlane(info['display'], info['id'], info['parameter']);\n                    this.__showPlane[fullId + movingPartId + basePartId + id] = null;\n                });\n            }\n            else {\n                // Update to the latest requirement\n                this.__showPlane[fullId + movingPartId + basePartId + id] = { 'display': display, 'id': id, 'parameter': parameter };\n            }\n        }\n    }\n\n\n\n    __createViewTile(info, callback) {\n        const fullId = info.modelId;\n        const movingPartId = info.movingPartId;\n        const basePartId = info.basePartId;\n        const jointInfo = { 'movingPartId': movingPartId, 'basePartId': basePartId };\n        const articulations = info.articulations;\n\n        let tileElement;\n\n        if (info['element'] == null) {\n            const element = document.createElement(\"div\");\n            element.className = \"list-item\";\n            element.innerHTML = template.replace('$', 'Wonderful!');\n            this.__content.appendChild(element);\n            tileElement = element.querySelector(\".scene\");\n        }\n        else {\n            tileElement = info['element'];\n        }\n\n        // Directly build the scene\n        this.__loadModel(fullId, jointInfo, tileElement, articulations, callback);\n        // if (this.__cachedModelInstances.hasOwnProperty(fullId)) {\n        //     const viewTile = new ViewTile(this.__cachedModelInstances[fullId].clone(), fullId, jointInfo, tileElement, this.autoRotate);\n        //     this.viewTiles.push(viewTile);\n        //     this.__updateViewTiles();\n        // }\n        // else {\n        //     // If the model has been loading\n        //     if (this.__loadingModels.hasOwnProperty(fullId)) {\n        //         this.SubscribeOnce(fullId, this, () => {\n        //             const viewTile = new ViewTile(this.__cachedModelInstances[fullId].clone(), fullId, jointInfo, tileElement, this.autoRotate);\n        //             this.viewTiles.push(viewTile);\n        //             this.__updateViewTiles();\n        //         });\n        //     }\n        //     else {\n        //         this.__loadingModels[fullId] = true;\n        //         // Load the obj\n        //         this.__loadModel(fullId, jointInfo, tileElement);\n        //     }\n        // }\n    }\n\n    __loadModel(fullId, jointInfo, tileElement, articulations, callback) {\n        // const dataset_name = fullId.split('.')[0];\n\n        const addViewTile = (err, modelInstance) => {\n            //            this.__cachedModelInstances[fullId] = modelInstance;\n            // tileElement.innerHTML = name;\n            if(callback != null) {\n                callback();\n            }\n            const viewTileOpts = { 'modelInstance': modelInstance, 'fullId': fullId, 'jointInfo': jointInfo, 'element': tileElement, 'autoRotate': this.autoRotate, 'articulations': articulations }\n            const viewTile = new ViewTile(viewTileOpts);\n            viewTile.setStaticMode(this.staticMode);\n            this.viewTiles.push(viewTile);\n            this.__updateViewTiles();\n            console.log('Finish Loading Model ' + fullId);\n            //this.Publish(fullId);\n            this.Publish(\"AddTile\", viewTile);\n            this.Publish(fullId + jointInfo.movingPartId + jointInfo.basePartId);\n        };\n\n        const info = { 'fullId': fullId, 'format': 'gltf' }\n\n        // const name = tileElement.innerHTML;\n        // tileElement.innerHTML = 'Loading...';\n\n        if (this.__datasetRegistered == true) {\n            this.__assetManager.loadModel(info, addViewTile);\n        }\n        else {\n            this.SubscribeOnce('RegisterDataset', this, () => {\n                this.__assetManager.loadModel(info, addViewTile);\n            })\n        }\n    }\n\n    __updateViewTiles() {\n        const numViewTiles = this.viewTiles.length;\n        const newViewTile = this.viewTiles[numViewTiles - 1];\n        for (let i = 0; i < numViewTiles - 1; ++i) {\n            this.viewTiles[i].addListenElement(newViewTile.getElement());\n            newViewTile.addListenElement(this.viewTiles[i].getElement());\n        }\n\n        const controlInfo = this.viewTiles[0].getControls().getState();\n        newViewTile.getControls().setState(controlInfo);\n    }\n\n    __removeListeners(index) {\n        // Used to clean the eventlisten hook up\n        const numViewTiles = this.viewTiles.length;\n        const deletedViewTile = this.viewTiles[index];\n        for (let i = 0; i < numViewTiles; ++i) {\n            if (i == index) continue;\n            this.viewTiles[i].removeListenElement(deletedViewTile.getElement());\n            deletedViewTile.removeListenElement(this.viewTiles[i].getElement());\n        }\n    }\n\n    setAutoRotate(autoRotate) {\n        this.autoRotate = autoRotate;\n\n        for (let viewTile of this.viewTiles) {\n            viewTile.setAutoRotate(autoRotate);\n        }\n    }\n\n    setStaticMode(staticMode) {\n        this.staticMode = staticMode;\n        for (let viewTile of this.viewTiles) {\n            viewTile.setStaticMode(staticMode);\n        }\n    }\n\n    updateSize() {\n        const width = this.__canvas.clientWidth;\n        const height = this.__canvas.clientHeight;\n\n        if (this.__canvas.width !== width || this.__canvas.height !== height) {\n            this.__renderer.setSize(width, height, false);\n        }\n    }\n\n    animate() {\n        this.render();\n        requestAnimationFrame(() => { this.animate(); });\n    }\n\n    render() {\n        this.updateSize();\n        this.__renderer.setScissorTest(false);\n        this.__renderer.clear();\n        this.__renderer.setScissorTest(true);\n\n        this.viewTiles.forEach((viewTile) => {\n            viewTile.updateTileState(this.__renderHelper);\n            viewTile.updateViewport(this.__renderer);\n        });\n    }\n}\n\nmodule.exports = MultiModelView;\n\n//# sourceURL=webpack://STK/./js/apps/MultiModelView/MultiModelView.js?");

/***/ }),

/***/ "./js/apps/MultiModelView/ViewTile.js":
/*!********************************************!*\
  !*** ./js/apps/MultiModelView/ViewTile.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst Camera = __webpack_require__(/*! gfx/Camera */ \"./js/lib/gfx/Camera.js\");\nconst SceneSetupHelper = __webpack_require__(/*! gfx/SceneSetupHelper */ \"./js/lib/gfx/SceneSetupHelper.js\");\nconst DisplayAxis = __webpack_require__(/*! articulations/DisplayAxis */ \"./js/lib/articulations/DisplayAxis.js\");\nconst DisplayRadar = __webpack_require__(/*! articulations/DisplayRadar */ \"./js/lib/articulations/DisplayRadar.js\");\nconst MatrixUtil = __webpack_require__(/*! math/MatrixUtil */ \"./js/lib/math/MatrixUtil.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\nclass ViewTile {\n    // viewTileOpts should include modelInstance, fullId, jointInfo, element, autoRotates\n    constructor(viewTileOpts) {\n        const modelInstance = viewTileOpts.modelInstance;\n        const fullId = viewTileOpts.fullId;\n        const jointInfo = viewTileOpts.jointInfo;\n        const element = viewTileOpts.element;\n        const autoRotate = viewTileOpts.autoRotate || false;\n        const articulations = viewTileOpts.articulations;\n\n        this.__points = {};\n        this.__arrows = {};\n        this.__planes = {};\n\n        // this.scene = new THREE.Scene();\n        this.fullId = fullId;\n        this.jointInfo = jointInfo;\n        this.element = element;\n\n        this.staticMode = false;\n\n        // Create the  camera\n        this.camera = this.__createCamera();\n\n        // Create a new scene\n        this.scene = SceneSetupHelper.createScene(this.camera, {\n            // backgroundColor: 'lightgrey',\n            useLights: true,\n            useDirectionalLights: false\n        });\n\n        // Add the light\n        this.__addLight();\n\n        // Create the control\n        this.controls = this.__createControls(autoRotate);\n\n        this.articulatedObject = null;\n\n        if (modelInstance !== null) {\n            this.setModelInst(modelInstance, articulations);\n        }\n    }\n\n    setModelInst(modelInstance, articulations) {\n        this.modelInstance = modelInstance;\n        this.articulations = articulations || this.modelInstance.getObject3D('Model').userData.articulations;\n\n        this.articulatedObject = this.modelInstance.clone().toArticulatedObject(this.articulations);\n\n        // align and rescale\n        this.group = new THREE.Group();\n        this.modelInstance.alignAndScaleObject3D(this.group, Constants.worldUp, Constants.worldFront);\n        this.group.add(this.articulatedObject);\n\n        this.scene.add(this.group);\n\n        this.axisRadarGroup = new THREE.Group();\n        this.scene.add(this.axisRadarGroup);\n        this.modelInstance.alignAndScaleObject3D(this.axisRadarGroup, Constants.worldUp, Constants.worldFront);\n\n        if (this.xyzGroup == null) {\n            this.xyzGroup = new THREE.Group();\n            this.scene.add(this.xyzGroup);\n            this.modelInstance.alignAndScaleObject3D(this.xyzGroup, Constants.worldUp, Constants.worldFront);\n        }\n\n        if (this.pointGroup == null) {\n            this.pointGroup = new THREE.Group();\n            this.scene.add(this.pointGroup);\n            this.modelInstance.alignAndScaleObject3D(this.pointGroup, Constants.worldUp, Constants.worldFront);\n        }\n\n        if (this.arrowGroup == null) {\n            this.arrowGroup = new THREE.Group();\n            this.scene.add(this.arrowGroup);\n            this.modelInstance.alignAndScaleObject3D(this.arrowGroup, Constants.worldUp, Constants.worldFront);\n        }\n\n        if (this.planeGroup == null) {\n            this.planeGroup = new THREE.Group();\n            this.scene.add(this.planeGroup);\n            this.modelInstance.alignAndScaleObject3D(this.planeGroup, Constants.worldUp, Constants.worldFront);\n        }\n    }\n\n    setArticulations(articulations) {\n        this.scene.remove(this.group);\n        this.scene.remove(this.axisRadarGroup);\n        this.setModelInst(this.modelInstance, articulations);\n    }\n\n    getScene() {\n        return this.scene;\n    }\n\n    getModelInstance() {\n        return this.modelInstance;\n    }\n\n    getFullId() {\n        return this.fullId;\n    }\n\n    getJointInfo() {\n        return this.jointInfo;\n    }\n\n    getElement() {\n        return this.element;\n    }\n\n    getCamera() {\n        return this.camera;\n    }\n\n    getControls() {\n        return this.controls;\n    }\n\n    updateViewport(renderer) {\n        // get the element that is a place holder for where we want to\n        // draw the viewTile\n        const element = this.element;\n\n        // get its position relative to the page's viewport\n        const rect = element.getBoundingClientRect();\n\n        // set the viewport\n        const width = rect.right - rect.left;\n        const height = rect.bottom - rect.top;\n        const left = rect.left - renderer.domElement.getBoundingClientRect().left;\n        const bottom = renderer.domElement.clientHeight - rect.bottom + renderer.domElement.getBoundingClientRect().top;\n\n        if (bottom > renderer.domElement.clientHeight || bottom + height < 0 || left > renderer.domElement.clientWidth || left + width < 0) {\n            return;\n        }\n\n        renderer.setViewport(left, bottom, width, height);\n        renderer.setScissor(left, bottom, width, height);\n\n        this.controls.update();\n\n        renderer.render(this.scene, this.camera);\n    }\n\n    setStaticMode(staticMode) {\n        this.staticMode = staticMode;\n    }\n\n    updateTileState(renderHelper) {\n\n        if (this.articulatedObject) {\n            // const articulationStates = this.articulatedObject.articulationStates;\n            // const articulationStatesByPart = _.groupBy(articulationStates, 'pid');\n\n            const movingPartId = this.jointInfo['movingPartId'];\n            const basePartId = this.jointInfo['basePartId'];\n\n            const articulationStates = _.filter(this.articulatedObject.articulationStates, (articulationState) => {\n                const pid = articulationState.part.pid;\n                if (!(movingPartId == null) && pid != movingPartId) {\n                    return false;\n                }\n\n                const parentId = articulationState.part.baseIds[0];\n                if (!(basePartId == null) && parentId != basePartId) {\n                    return false;\n                }\n\n                return true;\n            });\n\n            let resetFlag = true;\n            for (let articulationState of articulationStates) {\n                renderHelper.applyMultiplePartColorings(this.articulatedObject, articulationState, resetFlag);\n\n                if (articulationState.type.toLowerCase() == 'fixed') {\n                    // Deal with the default highlight\n                    continue;\n                }\n                if (resetFlag == true) resetFlag = false;\n\n                if (articulationState.refNow == null && articulationState.articulation.rangeMin != null && articulationState.articulation.rangeMax != null) {\n                    articulationState.apply(articulationState.articulation.rangeMin - articulationState.articulation.defaultValue);\n                    if (articulationState.articulation.defaultValue < articulationState.articulation.rangeMin || articulationState.articulation.defaultValue > articulationState.articulation.rangeMax) {\n                        console.log(\"Warning: Current Pose is not in the Range!\", this.fullId);\n                    }\n                    articulationState.refNow = true;\n                }\n\n                let delta;\n                // const maxIterations = 100;\n                // const rangeAmount = _.isFinite(articulationState.rangeAmount) ? articulationState.rangeAmount : articulationState.defaultRangeAmount;\n                // const delta = 2 * rangeAmount / (maxIterations - 1);\n                if (articulationState.type.toLowerCase() != 'translation') {\n                    delta = 0.04;\n                }\n                else {\n                    delta = 0.01;\n                }\n\n                // Deal with the case that display the rule\n                if (articulationState.articulation.rangeMin == null || articulationState.articulation.rangeMax == null) {\n                    if (articulationState.fakeValue == null) {\n                        articulationState.fakeValue = 0;\n                    }\n                    // Deal with axis/rader\n                    this.__showAxisRadar(articulationState, articulationState.direction * delta);\n                    if (this.staticMode) continue;\n                    articulationState.fakeValue += articulationState.direction * delta;\n                    if (articulationState.fakeValue > 0.5) {\n                        articulationState.direction = -articulationState.direction;\n                    }\n                    if (articulationState.fakeValue < -0.5) {\n                        articulationState.direction = -articulationState.direction;\n                    }\n                    continue;\n                }\n\n                // Deal with axis/rader\n                this.__showAxisRadar(articulationState);\n                if (this.staticMode) continue;\n\n                // console.log(delta)\n\n                articulationState.apply(articulationState.direction * delta);\n\n                // Check if we need to reverse\n                if (articulationState.atMax) {\n                    articulationState.direction = -articulationState.direction;\n                }\n                if (articulationState.atMin) {\n                    articulationState.direction = -articulationState.direction;\n                }\n            }\n        }\n        else {\n            console.log(`No articulated object for ${this.modelInstance.model.getFullID()}`);\n            return;\n        }\n    }\n\n    showPoint(display, id, parameter) {\n        if (display == false) {\n            if (this.__points[id] != null) {\n                this.pointGroup.remove(this.__points[id]);\n                delete this.__points[id];\n            }\n            return;\n        }\n        if (this.__points[id] == null) {\n            const location = parameter['location'];\n            const size = parameter['size'] || 1;\n            const color = parameter['color'] || 0x000000;\n            const opacity = parameter['opacity'] || 1;\n\n            let widgetsNode = new THREE.Group();\n\n            const geometry = new THREE.SphereBufferGeometry(size);\n            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity, depthTest: false });\n            const sphere = new THREE.Mesh(geometry, material);\n            widgetsNode.add(sphere);\n\n            const new_location = { x: location[0], y: location[1], z: location[2] };\n\n            widgetsNode.position.copy(new_location);\n\n            this.pointGroup.add(widgetsNode);\n            this.__points[id] = widgetsNode;\n\n        }\n\n    }\n\n    showArrow(display, id, parameter) {\n        if (display == false) {\n            if (this.__arrows[id] != null) {\n                this.arrowGroup.remove(this.__arrows[id]);\n                delete this.__arrows[id];\n            }\n            return;\n        }\n        if (this.__arrows[id] == null) {\n            const location = parameter['location'];\n            const direction = parameter['direction'];\n            const arrowSize = parameter['arrowSize'] || 0.3;\n            const length = parameter['length'] || 1;\n            const color = parameter['color'] || 0x000000;\n            const opacity = parameter['opacity'] || 1;\n\n            let widgetsNode = new THREE.Group();\n\n            const dir = new THREE.Vector3(direction[0], direction[1], direction[2]);\n            dir.normalize();\n\n            const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), length, color, arrowSize);\n            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity, depthTest: false });\n            arrow.line.material = material;\n            Object3DUtil.setMaterial(arrow, material, Object3DUtil.MaterialsAll, true);\n\n            widgetsNode.add(arrow);\n\n            const new_location = { x: location[0], y: location[1], z: location[2] };\n\n            widgetsNode.position.copy(new_location);\n\n            this.arrowGroup.add(widgetsNode);\n            this.__arrows[id] = widgetsNode;\n\n        }\n\n    }\n\n    showPlane(display, id, parameter) {\n        if (display == false) {\n            if (this.__planes[id] != null) {\n                this.planeGroup.remove(this.__planes[id]);\n                delete this.__planes[id];\n            }\n            return;\n        }\n        if (this.__planes[id] == null) {\n            const normal = parameter['normal'];\n            const location = parameter['location'];\n            const size = parameter['size'] || 1;\n            const color = parameter['color'] || 0x000000;\n            const opacity = parameter['opacity'] || 1;\n\n            let widgetsNode = new THREE.Group();\n\n            const norm_pos = new THREE.Vector3(normal[0], normal[1], normal[2]);\n            norm_pos.normalize();\n\n            const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: opacity, depthTest: false, side: THREE.DoubleSide });\n            const geometryPlane = new THREE.PlaneBufferGeometry(size, size, 1, 1);\n            const meshPlane = new THREE.Mesh(geometryPlane, material);\n            widgetsNode.add(meshPlane);\n\n            // const m = MatrixUtil.getAlignmentMatrix(new THREE.Vector3(0,0,1), new THREE.Vector3(1,0,0),\n            //   norm_pos, MatrixUtil.getOrthogonal(norm_pos));\n            const m = MatrixUtil.getAlignmentMatrix(new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0),\n                norm_pos, new THREE.Vector3(1, 0, 0));\n            widgetsNode.setRotationFromMatrix(m);\n\n            widgetsNode.position.set(location[0], location[1], location[2]);\n            //widgetsNode.position.set(...location);  // Less readable but equivalent to above\n\n            this.planeGroup.add(widgetsNode);\n            this.__planes[id] = widgetsNode;\n\n        }\n    }\n\n\n    showXYZ(display) {\n        if (display == false) {\n            if (this.xyzGroup.children[0] != null) {\n                this.xyzGroup.remove(this.xyzGroup.children[0]);\n            }\n            return;\n        }\n\n        if (this.xyzGroup.children[0] == null) {\n\n            let widgetsNode = new THREE.Group();\n\n            const xDir = new THREE.Vector3(1, 0, 0),\n                yDir = new THREE.Vector3(0, 1, 0),\n                zDir = new THREE.Vector3(0, 0, 1);\n\n            const xColor = 0xFF0000,\n                yColor = 0x00FF00,\n                zColor = 0x0000FF;\n\n            const length = 1.5;\n\n            const arrowX = new THREE.ArrowHelper(xDir, new THREE.Vector3(0, 0, 0), length, 0x000000, 0.3);\n            const arrowY = new THREE.ArrowHelper(yDir, new THREE.Vector3(0, 0, 0), length, 0x000000, 0.3);\n            const arrowZ = new THREE.ArrowHelper(zDir, new THREE.Vector3(0, 0, 0), length, 0x000000, 0.3);\n\n            const materialX = new THREE.MeshBasicMaterial({ color: xColor, depthTest: false }),\n                materialY = new THREE.MeshBasicMaterial({ color: yColor, depthTest: false }),\n                materialZ = new THREE.MeshBasicMaterial({ color: zColor, depthTest: false });\n\n            arrowX.line.material = materialX;\n            arrowY.line.material = materialY;\n            arrowZ.line.material = materialZ;\n            Object3DUtil.setMaterial(arrowX, materialX, Object3DUtil.MaterialsAll, true);\n            Object3DUtil.setMaterial(arrowY, materialY, Object3DUtil.MaterialsAll, true);\n            Object3DUtil.setMaterial(arrowZ, materialZ, Object3DUtil.MaterialsAll, true);\n\n            widgetsNode.add(arrowX);\n            widgetsNode.add(arrowY);\n            widgetsNode.add(arrowZ);\n\n            this.xyzGroup.add(widgetsNode);\n        }\n    }\n\n    __showAxisRadar(articulationState, delta) {\n        if (articulationState.displayAxis == null) {\n            articulationState.articulation.value = articulationState.articulation.value || articulationState.articulation.defaultValue;\n\n            let widgetsNode = new THREE.Group();\n\n            const displayAxis = new DisplayAxis({ articulation: articulationState });\n            if (articulationState.type.toLowerCase() != 'translation') {\n                const displayRadar = new DisplayRadar({ articulation: articulationState });\n                displayRadar.update();\n                displayRadar.attach(widgetsNode);\n                articulationState.displayRadar = displayRadar;\n                displayAxis.update();\n            }\n            else {\n                displayAxis.update(true);\n            }\n            displayAxis.attach(widgetsNode);\n            this.axisRadarGroup.add(widgetsNode);\n\n            articulationState.displayAxis = displayAxis;\n        }\n\n        if (this.staticMode) return;\n\n        if (delta == null) {\n            if (articulationState.type.toLowerCase() == 'translation') {\n                articulationState.displayAxis.updateValue();\n            } else {\n                articulationState.displayRadar.updateValue();\n            }\n        }\n        else {\n            if (articulationState.type.toLowerCase() == 'translation') {\n                articulationState.displayAxis.updateAxisPoint(delta);\n            } else {\n                articulationState.displayRadar.rotate(delta);\n            }\n        }\n    }\n\n    __createCamera() {\n        const cameraConfig = _.defaults(Object.create(null), {}, {\n            type: 'perspective',\n            fov: 50,\n            near: 0.1 * Constants.metersToVirtualUnit,\n            far: 400 * Constants.metersToVirtualUnit\n        });\n        const camera = Camera.fromJson(cameraConfig, 1024, 1024);\n\n        camera.position.z = -150;\n        camera.position.x = -150;\n        camera.position.y = 100;\n\n        return camera;\n    }\n\n    __createControls(autoRotate) {\n        const controls = new THREE.OrbitControls(this.camera, this.element);\n        controls.minDistance = 0.1 * Constants.metersToVirtualUnit;\n        controls.maxDistance = 400 * Constants.metersToVirtualUnit;\n        controls.enablePan = true;\n        controls.enableZoom = true;\n        controls.autoRotate = autoRotate;\n        // Remove the focus\n        this.element.removeEventListener('mousedown', controls.onMouseDown, false);\n        this.element.addEventListener('mousedown', controls.onMouseDownNoFocus, false);\n        return controls;\n    }\n\n    setAutoRotate(autoRotate) {\n        this.controls.autoRotate = autoRotate;\n    }\n\n    addListenElement(element) {\n        const scope = this.controls;\n\n        element.addEventListener('contextmenu', scope.onContextMenu, false);\n\n        element.addEventListener('mousedown', scope.onMouseDownNoFocus, false);\n        element.addEventListener('wheel', scope.onMouseWheel, false);\n\n        element.addEventListener('touchstart', scope.onTouchStart, false);\n        element.addEventListener('touchend', scope.onTouchEnd, false);\n        element.addEventListener('touchmove', scope.onTouchMove, false);\n\n        element.addEventListener('keydown', scope.onKeyDown, false);\n\n        scope.update();\n    }\n\n    removeListenElement(element) {\n        const scope = this.controls;\n\n        element.removeEventListener('contextmenu', scope.onContextMenu, false);\n\n        element.removeEventListener('mousedown', scope.onMouseDownNoFocus, false);\n        element.removeEventListener('wheel', scope.onMouseWheel, false);\n\n        element.removeEventListener('touchstart', scope.onTouchStart, false);\n        element.removeEventListener('touchend', scope.onTouchEnd, false);\n        element.removeEventListener('touchmove', scope.onTouchMove, false);\n\n        element.removeEventListener('keydown', scope.onKeyDown, false);\n\n        scope.update();\n    }\n\n    __addLight() {\n        this.scene.add(new THREE.HemisphereLight(0xaaaaaa, 0x444444));\n        const light = new THREE.DirectionalLight(0xffffff, 0.5);\n        light.position.set(1, 1, 1);\n        this.scene.add(light);\n    }\n}\n\nmodule.exports = ViewTile;\n\n//# sourceURL=webpack://STK/./js/apps/MultiModelView/ViewTile.js?");

/***/ }),

/***/ "./js/apps/MultiModelView/index.js":
/*!*****************************************!*\
  !*** ./js/apps/MultiModelView/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var webapp = __webpack_require__(/*! ../webapp */ \"./js/apps/webapp.js\");\n\nmodule.exports = webapp.util.merge(webapp, {\n  MultiModelView: __webpack_require__(/*! ./MultiModelView.js */ \"./js/apps/MultiModelView/MultiModelView.js\")\n});\n\n\n//# sourceURL=webpack://STK/./js/apps/MultiModelView/index.js?");

/***/ }),

/***/ "./js/apps/webapp.js":
/*!***************************!*\
  !*** ./js/apps/webapp.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(Buffer) {var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nConstants.sys = {\n  fs: __webpack_require__(/*! io/FileUtil */ \"./js/lib/io/FileUtil.js\"),\n  Buffer: Buffer\n};\n\nmodule.exports = {\n  Constants: Constants,\n  util: __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\")\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/node-libs-browser/node_modules/buffer/index.js */ \"../node_modules/node-libs-browser/node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://STK/./js/apps/webapp.js?");

/***/ }),

/***/ "./js/lib/Constants.js":
/*!*****************************!*\
  !*** ./js/lib/Constants.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n  var Constants = {};\n\n  Constants.VERSION = \"0.8.0\";\n  Constants.BUILD = \"Wed, 20 May 2020 00:20:48 GMT\";\n  Constants.assets = [{\"name\":\"psb\",\"metadata\":{\"source\":\"psb\",\"description\":\"Princeton Shape Benchmark\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/psb/\",\"screenShotPath\":\"${rootPath}/jpg/m${id}_thumb.jpg\",\"formats\":[{\"format\":\"utf8v2\",\"path\":\"${rootPath}/utf8/m${id}.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"options\":{\"useBuffers\":false,\"defaultMaterial\":true}}]}},{\"name\":\"tsb\",\"metadata\":{\"source\":\"tsb\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/tsb/\",\"screenShotPath\":\"${rootPath}/jpg/m${id}.jpg\",\"formats\":[{\"format\":\"utf8v2\",\"path\":\"${rootPath}/utf8/m${id}.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"options\":{\"useBuffers\":false,\"defaultMaterial\":true}}]}},{\"name\":\"shrec2012\",\"metadata\":{\"source\":\"shrec2012\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/shrec2012/\",\"screenShotPath\":\"${rootPath}/jpg/${id}.jpg\",\"formats\":[{\"format\":\"utf8v2\",\"path\":\"${rootPath}/utf8/${id}.json\",\"defaultUp\":[0,0,1],\"defaultFront\":[0,-1,0],\"options\":{\"useBuffers\":false,\"defaultMaterial\":true}}]}},{\"name\":\"archive3d\",\"metadata\":{\"name\":\"archive3d\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/archive3d/\",\"screenShotDir\":\"${baseUrl}/data/models3d/screenshots/archive3d\",\"hasThumbnails\":true,\"defaultImageCount\":14,\"defaultImageIndex\":13,\"defaultUp\":[0,0,1],\"defaultFront\":[0,-1,0],\"defaultUnit\":0.0254,\"defaultFilter\":\"+hasModel:true\",\"assetFields\":{\"originalSourceUrl\":\"http://archive3d.net/?a=download&id=${id}\"},\"dataTypes\":{\"mesh\":{\"defaultOptions\":{\"materialSidedness\":\"Double\",\"ignoreZerorRGBs\":true,\"defaultColor\":[0,0,0]},\"data\":[{\"name\":\"utf8\",\"format\":\"utf8v2\",\"path\":\"${rootPath}/models/${id}/${id}.json\"},{\"name\":\"obj\",\"format\":\"obj\",\"path\":\"${rootPath}/models/${id}/${id}.obj\",\"mtl\":\"${rootPath}/models/${id}/${id}.mtl\"}]},\"segment\":[{\"name\":\"surfaces\",\"format\":\"trimesh\",\"path\":\"${baseUrl}/text2scene/surfaces.${format}/archive3d/${id}/${id}-surfaces.json\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"${format}\"}}],\"voxel\":[{\"name\":\"voxels-surface\",\"format\":\"binvox\",\"path\":\"${rootPath}/models/${id}/${id}.binvox\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}}],\"image\":[{\"name\":\"screenshot\",\"path\":\"${screenShotDir}/${id}/${id}-${index}.png\"},{\"name\":\"originalImage\",\"path\":\"${rootPath}/images/${id}.jpg\"},{\"name\":\"rotatingImage\",\"path\":\"${screenShotDir}/${id}/${id}.gif\"}]}},\"metadataFilename\":\"../server/static//data/wss/archive3d.models.metadata.json\"},{\"name\":\"a3dTexture\",\"metadata\":{\"name\":\"a3dTexture\",\"source\":\"a3dTexture\",\"assetType\":\"texture\",\"rootPath\":\"${baseUrl}/data/textures/archivetextures/\",\"assetFields\":{\"originalSourceUrl\":\"http://archivetextures.net/?a=download&id=${id}\"},\"dataTypes\":{\"image\":[{\"name\":\"originalImage\",\"path\":\"${rootPath}/images/${id}.jpg\"},{\"name\":\"texture\",\"path\":\"${rootPath}/images/${id}.jpg\"}]}},\"metadataFilename\":\"../server/static//data/wss/archive3d.textures.metadata.json\"},{\"name\":\"wss\",\"metadata\":{\"name\":\"wss\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/wss/\",\"g3dwPath\":\"${baseUrl}/data/models3d/g3dw/\",\"screenShotDir\":\"${baseUrl}/data/models3d/screenshots/wss\",\"texturePath\":\"${rootPath}/texture\",\"hasThumbnails\":true,\"useThumbnails\":true,\"defaultImageCount\":14,\"defaultImageIndex\":13,\"defaultUp\":[0,0,1],\"defaultFront\":[0,-1,0],\"defaultUnit\":0.0254,\"defaultFilter\":\"+hasModel:true\",\"assetFields\":{\"originalSourceUrl\":\"https://3dwarehouse.sketchup.com/model.html?id=${id}\",\"categoryOrdering\":\"coarse-to-fine\"},\"dataTypes\":{\"mesh\":{\"defaultOptions\":{\"invertTransparency\":true,\"ignoreZeroRGBs\":true,\"defaultColor\":[0,0,0],\"geometryBase\":\"${rootPath}/geometry\",\"materialBase\":\"${rootPath}/texture\"},\"data\":[{\"format\":\"obj\",\"path\":\"${g3dwPath}/models/${id}.obj\",\"mtl\":\"${g3dwPath}/models/${id}.mtl\"},{\"format\":\"utf8v2\",\"path\":\"${rootPath}/model/${id}.json\"}]},\"segment\":[{\"name\":\"surfaces\",\"format\":\"trimesh\",\"path\":\"${baseUrl}/text2scene/surfaces.${format}/wss/${id}/${id}-surfaces.json\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"${format}\"}}],\"voxel\":[{\"name\":\"voxels-surface\",\"path\":\"${g3dwPath}/models-binvox/${id}.binvox\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}},{\"name\":\"voxels-solid\",\"path\":\"${g3dwPath}/models-binvox-solid/${id}.binvox\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}}],\"image\":[{\"name\":\"screenshot\",\"path\":\"${screenShotDir}/${id}/${id}-${index}.png\"},{\"name\":\"originalImage\",\"path\":\"${rootPath}/image/${id}.jpg\"},{\"name\":\"rotatingImage\",\"path\":\"${screenShotDir}/${id}/${id}.gif\"}]}},\"metadataFilename\":\"../server/static//data/wss/wss.models.metadata.json\"},{\"name\":\"wssScenes\",\"metadata\":{\"name\":\"wssScenes\",\"assetType\":\"scene\",\"rootPath\":\"${baseUrl}/data/scenes/wss/\",\"screenShotDir\":\"${baseUrl}/data/scenes/screenshots/wssScenes\",\"defaultImageIndex\":0,\"defaultUp\":[0,0,1],\"defaultFront\":[0,-1,0],\"defaultUnit\":0.0254,\"dataTypes\":{\"image\":[{\"name\":\"screenshot\",\"path\":\"${screenShotDir}/${id}.png\"},{\"name\":\"originalImage\",\"path\":\"${rootPath}/<%= vars.id.replace('-', '/') %>.png\"}]}},\"metadataFilename\":\"../server/static//data/wss/wss.scenes.metadata.json\"},{\"name\":\"3dw\",\"metadata\":{\"name\":\"3dw\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/shapenet\",\"shapenetDataDir\":\"${rootPath}/data\",\"shapenetScreenshotDir\":\"${rootPath}/screenshots\",\"shapenetCoreV1Dir\":\"${rootPath}/obj-zip/ShapeNetCore.v1\",\"shapenetCoreV2Dir\":\"${rootPath}/obj-zip/ShapeNetCore.v2\",\"shapenetCoreV2KmzDir\":\"${rootPath}/ShapeNetCore.v3/kmzmod\",\"shapenetNewModelsDir\":\"${rootPath}/ShapeNetCore.v3/shapenetNewModels\",\"colorVoxelsDir\":\"${rootPath}/color_voxelizations\",\"hasThumbnails\":true,\"defaultImageCount\":14,\"defaultImageIndex\":13,\"defaultUp\":[0,0,1],\"defaultFront\":[0,-1,0],\"defaultUnit\":0.0254,\"defaultFilter\":\"+hasModel:true\",\"assetFields\":{\"inShapeNetNew\":\"<%= vars.datatags && (vars.datatags.indexOf('ShapeNetNewModel') >= 0 || vars.datatags.indexOf('ShapeNetUpdatedModel') >= 0) %>\",\"inShapeNetCore\":\"<%= !!vars.datasets && vars.datasets.indexOf('ShapeNetCore') >= 0 %>\",\"imageCount\":\"<%= (vars.inShapeNetCore || vars.inShapeNetNew)? 14 : 0 %>\",\"hasThumbnail\":\"${inShapeNetCore}\",\"assetDataPathOrig\":\"${shapenetDataDir}/<%= _.splitPrefixId(5, '/', vars.id) %>/${id}/\",\"assetDataPathNew\":\"${shapenetNewModelsDir}/<%= _.splitPrefixId(5, '/', vars.id) %>/${id}/\",\"assetDataPath\":\"<%= vars.inShapeNetNew? vars.assetDataPathNew : vars.assetDataPathOrig %>\",\"assetScreenshotPath\":\"${shapenetScreenshotDir}/models/3dw.v4/<%= _.splitPrefixId(5, '/', vars.id) %>/${id}/\",\"synsetv1Path\":\"${shapenetCoreV1Dir}/${shapenetCoreSynset}/\",\"synsetv2Path\":\"${shapenetCoreV2Dir}/${shapenetCoreSynset}/\",\"originalSourceUrl\":\"https://3dwarehouse.sketchup.com/model.html?id=${id}\",\"isObjv1\":\"<%= vars.name === 'objv1' %>\"},\"dataTypes\":{\"mesh\":[{\"name\":\"kmz\",\"format\":\"kmz\",\"path\":\"${assetDataPath}/Collada/${id}.kmz\",\"up\":[0,0,1],\"front\":[0,-1,0],\"unit\":0.0254,\"voxelsNormalizedAligned\":true,\"voxelsCentered\":true,\"voxelsUp\":[0,1,0],\"voxelsFront\":[0,0,-1],\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"handleExtractTypes\":[\"simple\"]},\"shapenetCorev2ModelSpaceMetadataFile\":\"${synsetv2Path}/${id}/models/model_normalized.json\",\"modelSpaceMetadataFile\":\"<%= vars.inShapeNetCore? vars.shapenetCorev2ModelSpaceMetadataFile : '' %>\"},{\"name\":\"kmzv2\",\"format\":\"kmz\",\"path\":\"${shapenetCoreV2KmzDir}/<%= _.getPrefix(2, '/', vars.id) %>/${id}.kmz\",\"up\":[0,0,1],\"front\":[0,-1,0],\"unit\":0.0254,\"voxelsNormalizedAligned\":true,\"voxelsCentered\":true,\"voxelsUp\":[0,1,0],\"voxelsFront\":[0,0,-1],\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"handleExtractTypes\":[\"simple\"]},\"shapenetCorev2ModelSpaceMetadataFile\":\"${synsetv2Path}/${id}/models/model_normalized.json\",\"modelSpaceMetadataFile\":\"<%= vars.inShapeNetCore? vars.shapenetCorev2ModelSpaceMetadataFile : '' %>\"},{\"name\":\"obj\",\"format\":\"obj\",\"isSupported\":\"${inShapeNetCore}\",\"path\":\"${synsetv2Path}/${id}/models/model_normalized.obj\",\"aligned\":true,\"normalized\":\"diagonal\",\"up\":[0,1,0],\"front\":[0,0,-1],\"unit\":1,\"overrideFields\":{\"up\":1,\"front\":1,\"unit\":1},\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"materialSidedness\":\"front\"}},{\"name\":\"objv2\",\"format\":\"obj\",\"isSupported\":\"${inShapeNetCore}\",\"path\":\"${synsetv2Path}/${id}/models/model_normalized.obj\",\"aligned\":true,\"normalized\":\"diagonal\",\"up\":[0,1,0],\"front\":[0,0,-1],\"unit\":1,\"overrideFields\":{\"up\":1,\"front\":1,\"unit\":1},\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"materialSidedness\":\"front\"}},{\"name\":\"objv3\",\"format\":\"obj\",\"isSupported\":\"${inShapeNetCore}\",\"path\":\"${synsetv21Path}/export-meshes/meshes/${id}/${id}.obj\",\"aligned\":true,\"normalized\":\"diagonal\",\"up\":[0,1,0],\"front\":[0,0,-1],\"unit\":1,\"overrideFields\":{\"up\":1,\"front\":1,\"unit\":1},\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"materialSidedness\":\"front\"}},{\"name\":\"objv1\",\"format\":\"obj\",\"isSupported\":\"${inShapeNetCore}\",\"path\":\"${synsetv1Path}/${id}/model.obj\",\"aligned\":true,\"normalized\":\"diagonal\",\"up\":[0,1,0],\"front\":[1,0,0],\"unit\":1,\"overrideFields\":{\"up\":1,\"front\":1,\"unit\":1},\"options\":{\"preserveMeshes\":true,\"skipLines\":true,\"materialSidedness\":\"front\"}}],\"voxel\":[{\"name\":\"voxels-surface\",\"pathv1\":\"${synsetv1Path}/${id}/model.binvox\",\"pathv2\":\"${synsetv2Path}/${id}/models/model_normalized.surface.binvox\",\"path\":\"<%= (vars.isObjv1)? vars.pathv1 : vars.pathv2 %>\",\"isSupported\":\"${inShapeNetCore}\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"<%= (vars.isObjv1)? 'objv1' : 'obj' %>\"}},{\"name\":\"voxels-solid\",\"pathv1\":\"${synsetv1Path}/${id}/model.presolid.binvox\",\"pathv2\":\"${synsetv2Path}/${id}/models/model_normalized.solid.binvox\",\"path\":\"<%= (vars.isObjv1)? vars.pathv1 : vars.pathv2 %>\",\"isSupported\":\"${inShapeNetCore}\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"<%= (vars.isObjv1)? 'objv1' : 'obj' %>\"}},{\"name\":\"voxels-solid-256\",\"pathv1\":\"${rootPath}/ShapeNetCore.v1/${shapenetCoreSynset}/${id}/model.binvox\",\"pathv2\":\"${synsetv2Path}/${id}/models/model_normalized.binvox\",\"path\":\"<%= (vars.isObjv1)? vars.pathv1 : vars.pathv2 %>\",\"isSupported\":\"<%= vars.inShapeNetCore && (vars.shapenetCoreSynset.indexOf('03001627') >= 0 || vars.shapenetCoreSynset.indexOf('04379243') >= 0) %>\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"<%= (vars.isObjv1)? 'objv1' : 'obj' %>\"}},{\"name\":\"voxels-color\",\"variants\":{\"varying\":[\"resolution\",\"solidity\"],\"resolution\":[32,64,128,256],\"solidity\":[\"surface\",\"solid\"],\"name\":\"voxels-color-${resolution}-${solidity}\",\"path\":\"${colorVoxelsDir}/${resolution}/${solidity}/${id}/${id}.nrrd\",\"image\":\"${colorVoxelsDir}/${resolution}/${solidity}/${id}/${id}.png\"},\"isSupported\":\"<%= vars.inShapeNetCore && (vars.shapenetCoreSynset.indexOf('03001627') >= 0 || vars.shapenetCoreSynset.indexOf('04379243') >= 0) %>\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}},{\"name\":\"voxels-color-filtered\",\"variants\":{\"varying\":[\"resolution\",\"solidity\"],\"resolution\":[32,64,128],\"solidity\":[\"surface\",\"solid\"],\"name\":\"voxels-color-${resolution}-${solidity}-filtered\",\"path\":\"${colorVoxelsDir}/filtered/${resolution}/${solidity}/${id}/${id}.nrrd\",\"image\":\"${colorVoxelsDir}/filtered/${resolution}/${solidity}/${id}/${id}.png\"},\"isSupported\":\"<%= vars.inShapeNetCore && (vars.shapenetCoreSynset.indexOf('03001627') >= 0 || vars.shapenetCoreSynset.indexOf('04379243') >= 0) %>\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}}],\"image\":[{\"name\":\"screenshot\",\"path\":\"${assetScreenshotPath}/${id}-${index}.png\"},{\"name\":\"originalImage\",\"path\":\"${assetDataPath}/Image/${id}\"},{\"name\":\"rotatingImage\",\"path\":\"${assetScreenshotPath}/${id}.gif\",\"isSupported\":\"${inShapeNetCore}\"}]}},\"metadataFilename\":\"../server/static//data/shapenet/shapenet.3dw.metadata.json\"},{\"name\":\"yobi3d\",\"metadata\":{\"name\":\"yobi3d\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/data/models3d/yobi3d/\",\"screenShotDir\":\"${baseUrl}/data/models3d/screenshots/yobi3d\",\"shapenetCoreV1Dir\":\"${baseUrl}/shapenet/obj-zip/ShapeNetCore.v1/\",\"hasThumbnails\":false,\"defaultImageCount\":14,\"defaultImageIndex\":13,\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":0.0254,\"defaultFilter\":\"+hasModel:true\",\"assetFields\":{\"assetPath\":\"${rootPath}/<%= _.getPrefix(3, '/', vars.id).toLowerCase() %>\",\"shapenetCoreSynset\":\"02834778\",\"synsetPath\":\"${shapenetCoreV1Dir}/${shapenetCoreSynset}\",\"originalSourceUrl\":\"https://www.yobi3d.com/v/${id}\"},\"dataTypes\":{\"mesh\":[{\"name\":\"obj\",\"format\":\"obj\",\"path\":\"${synsetPath}/${id}/model.obj\",\"aligned\":true,\"normalized\":\"diagonal\",\"up\":[0,1,0],\"front\":[1,0,0],\"unit\":1,\"overrideFields\":{\"up\":1,\"front\":1,\"unit\":1}},{\"name\":\"three.js\",\"format\":\"three.js\",\"path\":\"${assetPath}/${id}.js.zip\",\"voxelsNormalizedAligned\":true,\"voxelsUp\":[0,1,0],\"voxelsFront\":[1,0,0]}],\"voxel\":[{\"name\":\"voxels-surface\",\"path\":\"${synsetPath}/${id}/model.binvox\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}},{\"name\":\"voxels-solid\",\"path\":\"${synsetPath}/${id}/model.presolid.binvox\",\"createdFrom\":{\"dataType\":\"mesh\",\"name\":\"obj\"}}],\"image\":[{\"name\":\"screenshot\",\"path\":\"${screenShotDir}/${id}/${id}-${index}.png\"},{\"name\":\"originalImage\",\"path\":\"${assetPath}/${id}.jpg\"}]}},\"metadataFilename\":\"../server/static//data/shapenet/shapenet.yobi3d.metadata.json\"},{\"name\":\"vf\",\"metadata\":{\"source\":\"vf\",\"assetType\":\"scan\",\"rootPath\":\"${baseUrl}/data/models3d/vf/\",\"screenShotPath\":\"${baseUrl}/data/models3d/screenshots/vf/${id}/${id}-${index}.png\",\"defaultImageCount\":14,\"defaultImageIndex\":13,\"voxels-surface\":\"${rootPath}/${id}.surface.binvox\",\"voxels-solid\":\"${rootPath}/${id}.solid.binvox\",\"voxels-labeled\":\"${rootPath}/${id}.vox\",\"formats\":[{\"format\":\"ply\",\"path\":\"${rootPath}/${id}d.ply\",\"options\":{\"ignoreZeroRGBs\":true,\"preserveMeshes\":false},\"defaultUp\":[0,0,1],\"defaultFront\":[-1,0,0],\"defaultUnit\":1,\"useVertexColors\":true,\"computeNormals\":true}],\"surfaces\":{\"format\":\"segmentGroups\",\"field\":null,\"obbMatrixIsRowMajor\":true,\"file\":\"${rootPath}/${id}d.segs.json\"}},\"metadataFilename\":\"../server/static//data/pigraphs/vf.metadata.json\"},{\"name\":\"p5dTexture\",\"metadata\":{\"name\":\"p5dTexture\",\"source\":\"p5dTexture\",\"assetType\":\"texture\",\"rootPath\":\"${baseUrl}/suncg/\",\"texturePath\":\"${rootPath}/texture/\",\"dataTypes\":{\"image\":[{\"name\":\"originalImage\",\"path\":\"${texturePath}/${name}\"},{\"name\":\"texture\",\"path\":\"${texturePath}/${name}\"}]}},\"assetIdField\":\"name\",\"ids\":\"${assetsDir}/data/suncg/suncg.planner5d.textures.csv\",\"metadataFilename\":\"../server/static//data/suncg/suncg.planner5d.textures.json\"},{\"name\":\"p5d\",\"metadata\":{\"source\":\"p5d\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/suncg/\",\"defaultImageCount\":14,\"screenShotPath\":\"${rootPath}/object_screenshots/p5d.js/${id}/${id}-${index}.png\",\"hasThumbnails\":true,\"originalScreenShotPath\":\"${rootPath}/objects/${baseVariantId}/${id}.png\",\"texturePath\":\"${rootPath}/texture/\",\"lightSpecsFile\":\"${assetsDir}/data/suncg/suncg.lights.json\",\"soundsFile\":\"${assetsDir}/data/suncg/sounds.json\",\"prefetchModelInfo\":{\"source\":\"p5d\",\"query\":\"*:*\",\"limit\":4000},\"voxels-solid\":\"${rootPath}/object_vox/object_vox_data/${baseVariantId}/${id}.binvox\",\"assetFields\":[\"parts\",\"defaultCenter\",\"connectivity_graph\",\"articulations\",\"articulation-parts\"],\"defaultCenter\":[0.5,0,0.5],\"surfaces\":{\"file\":\"${rootPath}/object_segmentations/${id}/${id}-segments.json\",\"format\":\"indexedSegmentation\"},\"parts\":{\"file\":\"${rootPath}/object_part_annotations/${id}/${id}.json\",\"format\":\"indexedSegmentation\"},\"connectivity_graph\":{\"file\":\"${rootPath}/articulations/precomputed/${id}.artpre.json\",\"image\":\"${rootPath}/articulations/connectivity_graph_viz/${id}.png\"},\"articulation-parts\":{\"partType\":\"indexedSegmentation\",\"files\":{\"mesh\":\"${rootPath}/object_mesh/object_mesh_r2.1_v6/${id}/${id}.obj\",\"parts\":\"${rootPath}/suncg/object_parts/object_part_annotations_r2.1_v6/${id}/${id}.parts.json\",\"connectivity_graph\":\"${rootPath}/articulations/precomputed_v1.5/${id}.artpre.json\",\"connectivity_graph_viz\":\"${rootPath}/articulations/connectivity_graph_viz_v1.5/${id}.png\"}},\"articulations\":{\"files\":{\"mesh\":\"${rootPath}/object_mesh/object_mesh_r2.1_v5/${id}/${id}.obj\",\"parts\":\"${rootPath}/suncg/object_parts/object_part_annotations_r2.1_v5/${id}/${id}.parts.json\",\"connectivity_graph\":\"${rootPath}/articulations/annotations_v1.4b/${id}.artpost.json\",\"articulations\":\"${rootPath}/articulations/annotations_v1.4b/${id}.articulations.json\"}},\"articulation-annotations\":{\"name\":\"articulations\",\"files\":{\"annIds\":\"${baseUrl}/articulation-annotations/list?format=json\",\"annotation\":\"${baseUrl}/articulation-annotations/load-annotations?modelId=${fullId}\"}},\"part-annotations\":{\"name\":\"parts\",\"format\":\"indexedSegmentation\",\"files\":{\"annIds\":\"${baseUrl}/part-annotations/list?itemId=${fullId}&$columns=id,workerId,data&format=json\",\"annotation\":\"${baseUrl}/part-annotations/get?annId=${annId}&modelId=${fullId}\",\"parts\":\"${baseUrl}/query?qt=parts&annId=${annId}&modelId=${fullId}\",\"segmentation\":\"${rootPath}/object_segmentations/${id}/${id}-segments.json\"}},\"formats\":[{\"format\":\"p5d\",\"path\":\"${rootPath}/objects/${baseVariantId}/${id}.js\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"voxelsAligned\":true,\"voxelsToModelTransform\":[1,0,0,0,0,1,0,1,0],\"materialSidedness\":\"double\"},{\"name\":\"obj-modified\",\"format\":\"p5d\",\"path\":\"${rootPath}/object_mesh/object_mesh_r2.1_v6/${id}/${id}.obj\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"voxelsAligned\":true,\"voxelsToModelTransform\":[1,0,0,0,0,1,0,1,0],\"materialSidedness\":\"double\",\"options\":{\"useRelativeTexturePath\":true}},{\"name\":\"obj\",\"format\":\"p5d\",\"path\":\"${rootPath}/object/${baseVariantId}/${id}.obj\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"voxelsAligned\":true,\"voxelsToModelTransform\":[1,0,0,0,0,1,0,1,0],\"materialSidedness\":\"double\",\"options\":{\"useRelativeTexturePath\":true}},{\"name\":\"obj-light\",\"format\":\"p5d\",\"path\":\"${rootPath}/object_light/${baseVariantId}/${id}.obj\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"voxelsAligned\":true,\"voxelsToModelTransform\":[1,0,0,0,0,1,0,1,0],\"materialSidedness\":\"double\"},{\"name\":\"obj-zup\",\"format\":\"p5d\",\"path\":\"${rootPath}/objects/${baseVariantId}/${id}.obj\",\"defaultUp\":[0,0,1],\"defaultFront\":[0,1,0],\"defaultUnit\":1,\"materialSidedness\":\"double\"}]},\"requires\":[\"p5dTexture\"],\"metadataFilename\":\"../server/static//data/suncg/suncg.planner5d.models.json\"},{\"name\":\"p5dScene\",\"metadata\":{\"source\":\"p5dScene\",\"assetType\":\"scene\",\"rootPath\":\"${baseUrl}/suncg/\",\"originalScreenShotPath\":\"${rootPath}/scenes_rendered/${id}/${id}.png\",\"screenShotPath\":\"${rootPath}/levels_rendered/${id}/${id}_${index}.png\",\"roomFilesPath\":\"${rootPath}/room/\",\"texturePath\":\"${rootPath}/texture/\",\"prefetchModelInfo\":{\"source\":\"p5d\",\"query\":\"*:*\",\"limit\":4000},\"voxelsField\":\"voxels-solid\",\"assetFields\":[\"navmap\",\"wall\",\"arch\"],\"navmap\":{\"assetType\":\"navmap\",\"encoding\":\"json\",\"format\":\"navgrid\",\"path\":\"${rootPath}/navgrid_10/${id}/${id}.${archType}.grid.json\"},\"house-relations\":{\"encoding\":\"json\",\"format\":\"house-relations\",\"path\":\"${rootPath}/house_stats/${id}/${id}.stats.json\"},\"wall\":{\"assetType\":\"wall\",\"encoding\":\"utf8\",\"path\":\"${rootPath}/wall/${id}/${id}.wall\"},\"arch\":{\"assetType\":\"arch\",\"encoding\":\"json\",\"path\":\"${rootPath}/wall/${id}/${id}.arch.json\"},\"roomTypes\":{\"assetType\":\"labelMapping\",\"encoding\":\"csv\",\"path\":\"${assetsDir}/data/suncg/roomTypes.csv\",\"fields\":{\"label\":\"roomType\",\"index\":\"index\"}},\"objectTypes\":{\"assetType\":\"labelMapping\",\"encoding\":\"csv\",\"path\":\"${assetsDir}/data/suncg/objectTypes.csv\",\"fields\":{\"label\":\"objectType\",\"index\":\"index\"}},\"formats\":[{\"name\":\"suncg\",\"format\":\"suncg\",\"path\":\"${rootPath}/house/${id}/house.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"createArch\":true},{\"name\":\"suncg-v1\",\"format\":\"suncg\",\"path\":\"${rootPath}/house.v1/${id}/house.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"createArch\":true},{\"name\":\"suncg-v2\",\"format\":\"suncg\",\"path\":\"${rootPath}/house.v2/${id}/house.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"createArch\":true},{\"name\":\"suncg-v3\",\"format\":\"suncg\",\"path\":\"${rootPath}/house.v3/${id}/house.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1,\"createArch\":true},{\"name\":\"full\",\"format\":\"p5d\",\"path\":\"${rootPath}/projects_full/${id}/project.json\",\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":0.01}]},\"requires\":[\"p5d\"],\"metadataFilename\":\"../server/static//data/suncg/suncg.planner5d.scenes.json\"},{\"name\":\"p5dRoom\",\"metadata\":{\"source\":\"p5dRoom\",\"assetType\":\"room\",\"rootPath\":\"${baseUrl}/suncg/\",\"screenShotPath\":\"${rootPath}/rooms_rendered/${sceneId}/${id}.png\",\"prefetchModelInfo\":{\"source\":\"p5d\",\"query\":\"*:*\",\"limit\":4000},\"texturePath\":\"${rootPath}/texture/\",\"formats\":[{\"name\":\"obj-yup\",\"format\":\"obj\",\"path\":[\"${rootPath}/room/${sceneId}/fr_${floor}rm_${roomIndex}w.obj\",\"${rootPath}/room/${sceneId}/fr_${floor}rm_${roomIndex}f.obj\",\"${rootPath}/room/${sceneId}/fr_${floor}rm_${roomIndex}c.obj\"],\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":1},{\"name\":\"obj-zup\",\"format\":\"obj\",\"path\":\"${rootPath}/roomfiles/${sceneId}/fr_${floor}rm_${roomIndex}.obj\",\"defaultUp\":[0,0,1],\"defaultFront\":[0,1,0],\"defaultUnit\":1}]},\"requires\":[\"p5d\"],\"metadataFilename\":\"../server/static//data/suncg/suncg.planner5d.rooms.json\"},{\"name\":\"suncgPoses\",\"metadata\":{\"source\":\"poses\",\"assetType\":\"model\",\"rootPath\":\"${baseUrl}/suncg/poses\",\"screenShotPath\":\"${rootPath}/${id}/${id}-${index}.png\",\"defaultImageCount\":14,\"defaultImageIndex\":13,\"texturePath\":\"${rootPath}/\",\"prefetchModelInfo\":{\"source\":\"poses\",\"query\":\"*:*\",\"limit\":4000},\"formats\":[{\"format\":\"obj\",\"path\":\"${rootPath}/${id}/${id}.obj\",\"options\":{\"ignoreZeroRGBs\":true},\"defaultUp\":[0,1,0],\"defaultFront\":[0,0,1],\"defaultUnit\":0.01}]},\"metadataFilename\":\"../server/static//data/suncg/suncg.poses.models.json\"}];\n  Constants.config = {\"scene\":{\"ikea_demo\":{\"assetInfo\":{\"source\":\"p5dScene\",\"format\":\"suncg\",\"assetType\":\"scene\",\"useDefaultMaterials\":true,\"adjustReplacementTransforms\":true,\"includeCeiling\":true,\"useArchModelId\":true,\"ignoreOriginalArchHoles\":false,\"attachWallsToRoom\":false,\"createArch\":true,\"archOptions\":{\"defaults\":{\"Wall\":{\"materials\":[{\"name\":\"inside\",\"texture\":\"wallp_1_1\",\"diffuse\":\"#ffffff\"},{\"name\":\"outside\",\"texture\":\"wallp_1_1\",\"diffuse\":\"#ffffff\"}]},\"Floor\":{\"materials\":[{\"name\":\"surface\",\"texture\":\"wood_14_2\",\"diffuse\":\"#ffffff\"}]}}}},\"replaceModels\":{\"104\":\"ikea.10203610\",\"109\":\"ikea.20404203\",\"130\":\"ikea.50358817\",\"140\":\"ikea.70311305\",\"146\":\"ikea.00103343\",\"205\":\"wss.93f92261cd41e39a5eead856a4605937\",\"235\":\"ikea.20366296\",\"236\":\"ikea.60378457\",\"397\":\"ikea.80178607\",\"480\":\"ikea.60401896\",\"506\":\"ikea.10203610\",\"560\":\"ikea.80215308\",\"679\":\"ikea.30378454\",\"680\":\"ikea.50268874\",\"693\":\"ikea.30361043\",\"s__804\":\"ikea.00360002\",\"s__785\":\"ikea.60178613\",\"s__1074\":\"ikea.30162133\",\"s__834\":\"ikea.30344505\",\"s__1007\":\"ikea.30381183\",\"s__2099\":\"ikea.30401893\",\"s__1281\":\"ikea.50214555\",\"s__1004\":\"ikea.40404198\",\"s__807\":\"ikea.50162212\",\"s__563\":\"ikea.70103349\",\"s__2367\":\"ikea.80154550\"}}},\"sim\":{\"sensors\":{\"default\":[{\"name\":\"group\",\"type\":\"group\",\"modes\":[{\"name\":\"color\",\"type\":\"color\",\"renderer\":\"main\",\"encoding\":\"gray\"},{\"name\":\"objectId\",\"type\":\"semantic\",\"encoding\":\"objectId\",\"countPixels\":true},{\"name\":\"objectType\",\"type\":\"semantic\",\"encoding\":\"objectType\"},{\"name\":\"roomId\",\"type\":\"semantic\",\"encoding\":\"roomId\"},{\"name\":\"roomType\",\"type\":\"semantic\",\"encoding\":\"roomType\"},{\"name\":\"normal\",\"type\":\"normal\",\"encoding\":\"xyza\"}],\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"active\":true},{\"name\":\"depth\",\"type\":\"depth\",\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"encoding\":\"depth\",\"datatype\":\"float32\",\"near\":0.1,\"far\":20,\"metersToUnit\":1,\"noise_model\":{\"name\":\"kinect\",\"type\":\"simple\",\"clip\":[0.5,4],\"noise\":[\"gaussian\",0,0.01]},\"noise\":false,\"active\":true},{\"name\":\"audio\",\"type\":\"audio\",\"configuration\":\"radial\",\"position\":[[0.15,0.6,1.57],[0.15,0.6,4.71]],\"orientation\":[[1,0,0],[-1,0,0]],\"resolution\":[1],\"encoding\":\"pcm\",\"active\":true},{\"name\":\"force\",\"type\":\"force\",\"configuration\":\"radial-group\",\"position\":[[0,-0.25,0]],\"orientation\":[[0,0,1]],\"radial\":[0.25,4,0,6.28],\"resolution\":[1,1,1],\"encoding\":\"raw_contact\",\"active\":true}],\"default_mp3d\":[{\"name\":\"group\",\"type\":\"group\",\"modes\":[{\"name\":\"color\",\"type\":\"color\",\"renderer\":\"main\",\"encoding\":\"gray\"},{\"name\":\"objectId\",\"type\":\"semantic_texture\",\"encoding\":\"objectId\"},{\"name\":\"normal\",\"type\":\"normal\",\"encoding\":\"xyza\"}],\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"active\":true},{\"name\":\"depth\",\"type\":\"depth\",\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"encoding\":\"depth\",\"datatype\":\"float32\",\"near\":0.1,\"far\":20,\"metersToUnit\":1,\"noise_model\":{\"name\":\"kinect\",\"type\":\"simple\",\"clip\":[0.5,4],\"noise\":[\"gaussian\",0,0.01]},\"noise\":false,\"active\":true},{\"name\":\"audio\",\"type\":\"audio\",\"configuration\":\"radial\",\"position\":[[0.15,0.6,1.57],[0.15,0.6,4.71]],\"orientation\":[[1,0,0],[-1,0,0]],\"resolution\":[1],\"encoding\":\"pcm\",\"active\":true},{\"name\":\"force\",\"type\":\"force\",\"configuration\":\"radial-group\",\"position\":[[0,-0.25,0]],\"orientation\":[[0,0,1]],\"radial\":[0.25,4,0,6.28],\"resolution\":[1,1,1],\"encoding\":\"raw_contact\",\"active\":true}],\"equirectangular\":[{\"name\":\"group\",\"type\":\"group\",\"modes\":[{\"name\":\"color\",\"type\":\"color\",\"renderer\":\"main\",\"encoding\":\"gray\"},{\"name\":\"objectId\",\"type\":\"semantic\",\"encoding\":\"objectId\",\"countPixels\":true},{\"name\":\"objectType\",\"type\":\"semantic\",\"encoding\":\"objectType\"},{\"name\":\"roomId\",\"type\":\"semantic\",\"encoding\":\"roomId\"},{\"name\":\"roomType\",\"type\":\"semantic\",\"encoding\":\"roomType\"},{\"name\":\"normal\",\"type\":\"normal\",\"encoding\":\"xyza\"}],\"isEquirectangular\":true,\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"active\":true},{\"name\":\"depth\",\"type\":\"depth\",\"isEquirectangular\":true,\"configuration\":\"positional\",\"position\":[[0,0.6,0]],\"orientation\":[[0,0,-1]],\"resolution\":[84,84],\"resize\":true,\"encoding\":\"depth\",\"datatype\":\"float32\",\"near\":0.1,\"far\":20,\"metersToUnit\":1,\"noise_model\":{\"name\":\"kinect\",\"type\":\"simple\",\"clip\":[0.5,4],\"noise\":[\"gaussian\",0,0.01]},\"noise\":false,\"active\":true},{\"name\":\"audio\",\"type\":\"audio\",\"configuration\":\"radial\",\"position\":[[0.15,0.6,1.57],[0.15,0.6,4.71]],\"orientation\":[[1,0,0],[-1,0,0]],\"resolution\":[1],\"encoding\":\"pcm\",\"active\":true},{\"name\":\"force\",\"type\":\"force\",\"configuration\":\"radial-group\",\"position\":[[0,-0.25,0]],\"orientation\":[[0,0,1]],\"radial\":[0.25,4,0,6.28],\"resolution\":[1,1,1],\"encoding\":\"raw_contact\",\"active\":true}],\"im2pano3d\":[{\"name\":\"group\",\"type\":\"group\",\"modes\":[{\"name\":\"color\",\"type\":\"color\",\"renderer\":\"main\",\"encoding\":\"gray\"},{\"name\":\"objectId\",\"type\":\"semantic\",\"encoding\":\"objectId\",\"countPixels\":true},{\"name\":\"objectType\",\"type\":\"semantic\",\"encoding\":\"objectType\"},{\"name\":\"roomId\",\"type\":\"semantic\",\"encoding\":\"roomId\"},{\"name\":\"roomType\",\"type\":\"semantic\",\"encoding\":\"roomType\"},{\"name\":\"normal\",\"type\":\"normal\",\"encoding\":\"xyza\"}],\"configuration\":\"radial-group\",\"position\":[[0,1,0]],\"orientation\":[[0,0,-1]],\"radial\":[0,4,0,-6.28],\"resolution\":[160,256],\"fov\":116,\"resize\":false,\"active\":true},{\"name\":\"depth\",\"type\":\"depth\",\"configuration\":\"radial-group\",\"position\":[[0,1,0]],\"orientation\":[[0,0,-1]],\"radial\":[0,4,0,-6.28],\"resolution\":[160,256],\"fov\":116,\"resize\":false,\"encoding\":\"depth\",\"datatype\":\"float32\",\"near\":0.1,\"far\":20,\"metersToUnit\":1,\"noise_model\":{\"name\":\"kinect\",\"type\":\"simple\",\"clip\":[0.5,4],\"noise\":[\"gaussian\",0,0.01]},\"noise\":false,\"active\":true},{\"name\":\"audio\",\"type\":\"audio\",\"configuration\":\"radial\",\"position\":[[0.15,0.6,1.57],[0.15,0.6,4.71]],\"orientation\":[[1,0,0],[-1,0,0]],\"resolution\":[1],\"encoding\":\"pcm\",\"active\":true},{\"name\":\"force\",\"type\":\"force\",\"configuration\":\"radial-group\",\"position\":[[0,-0.25,0]],\"orientation\":[[0,0,1]],\"radial\":[0.25,4,0,6.28],\"resolution\":[1,1,1],\"encoding\":\"raw_contact\",\"active\":true}]},\"agents\":{\"agent_continuous\":{\"eyeHeight\":1.09,\"radius\":0.1,\"radialClearance\":0.2,\"mass\":32,\"coeffRestitution\":0,\"stepAcceleration\":20,\"maxSpeed\":2,\"linearFriction\":0.5,\"turnAcceleration\":12.5663706144,\"maxAngularSpeed\":12.5663706144,\"angularFriction\":1},\"agent_gridworld\":{\"eyeHeight\":1.09,\"radius\":0.1,\"radialClearance\":0.2,\"mass\":32,\"coeffRestitution\":0,\"stepAcceleration\":40,\"maxSpeed\":4,\"linearFriction\":1,\"turnAcceleration\":157.079632679,\"maxAngularSpeed\":15.7079632679,\"angularFriction\":1,\"angularResolution\":1.57079632679},\"agent_firstperson\":{\"eyeHeight\":1.5,\"radius\":0.1,\"radialClearance\":0.2,\"mass\":50,\"coeffRestitution\":0.1,\"stepAcceleration\":1,\"maxSpeed\":1,\"linearFriction\":0.3,\"turnAcceleration\":1,\"maxAngularSpeed\":1,\"angularFriction\":0.3}},\"replaceModels\":{\"73\":\"73_2\",\"122\":\"122_2\",\"133\":\"133_2\",\"214\":\"214_2\",\"246\":\"246_2\",\"247\":\"247_2\",\"326\":\"327\",\"331\":\"327\",\"502\":\"502_2\",\"622\":\"625\",\"756\":\"756_2\",\"757\":\"757_2\",\"758\":\"758_2\",\"759\":\"759_2\",\"760\":\"760_2\",\"761\":\"761_2\",\"762\":\"762_2\",\"763\":\"763_2\",\"764\":\"764_2\",\"768\":\"768_2\",\"769\":\"769_2\",\"770\":\"770_2\",\"s__1762\":\"s__1762_2\",\"s__1763\":\"s__1763_2\",\"s__1764\":\"s__1764_2\",\"s__1765\":\"s__1765_2\",\"s__1766\":\"s__1766_2\",\"s__1767\":\"s__1767_2\",\"s__1768\":\"s__1768_2\",\"s__1769\":\"s__1769_2\",\"s__1770\":\"s__1770_2\",\"s__1771\":\"s__1771_2\",\"s__1772\":\"s__1772_2\",\"s__1773\":\"s__1773_2\"}}};\n  Constants.pkgname = \"SSTK version \" + Constants.VERSION;\n  Constants.buildname = Constants.pkgname + \" (build \"  +  Constants.BUILD + \")\";\n\n  // Where global vars are stored\n  Constants.isBrowser = typeof window !== 'undefined';\n  Constants.globals = (Constants.isBrowser && window.globals) ? window.globals : {};\n\n  // Returns whether global var with given name is available\n  Constants.hasGlobal = function (name) {\n    return Constants.globals && (Constants.globals[name] != undefined);\n  };\n\n  // Returns value of global var with given name or undefined if unavailable\n  Constants.getGlobal = function (name) {\n    return Constants.hasGlobal(name) ? Constants.globals[name] : undefined;\n  };\n\n  // Returns value of global var with given name or given value if unavailable\n  Constants.getGlobalOrDefault = function (name, def, opts) {\n    var value = Constants.hasGlobal(name) ? Constants.globals[name] : def;\n    if (Array.isArray(def) && typeof value === 'string') {\n      // Try to convert value to array\n      value = value.split(',');\n      if (opts && opts.dropEmpty) {\n        value = value.filter( function(x) { return x.length > 0; });\n      }\n    } else {\n      if (opts && opts.dropEmpty) {\n        if (value === '' && def !== '') {\n          value = def;\n        }\n      }\n    }\n    return value;\n  };\n\n  Constants.setVirtualUnit = function(virtualUnitToMeters) {\n    Constants.virtualUnitToMeters = virtualUnitToMeters;\n    Constants.metersToVirtualUnit = 1/virtualUnitToMeters;\n  };\n\n  Constants.setWorldUpFront = function(worldUp, worldFront) {\n    if (worldUp) {\n      Constants.worldUp.copy(worldUp);\n    }\n    if (worldFront) {\n      Constants.worldFront.copy(worldFront);\n    }\n    Constants.worldDown.copy(Constants.worldUp).negate();\n  };\n\n  Constants.defaultPalette = null;\n\n  // Mouse buttons (event.which)\n  Constants.LEFT_MOUSE_BTN = 1;\n  Constants.RIGHT_MOUSE_BTN = 3;\n\n  //    Constants.worldUp = new THREE.Vector3(0,0,1);\n  //    Constants.worldFront = new THREE.Vector3(0,1,0);\n  Constants.worldUp = new THREE.Vector3(0,1,0);\n  Constants.worldDown = new THREE.Vector3(0,-1,0);\n  Constants.worldFront = new THREE.Vector3(0,0,-1);\n  Constants.shapenetUp = new THREE.Vector3(0,1,0);\n  Constants.shapenetFront = new THREE.Vector3(1,0,0);\n  Constants.defaultModelUp = new THREE.Vector3(0,0,1);\n  Constants.defaultModelFront = new THREE.Vector3(0,-1,0);\n  Constants.defaultSceneUp = new THREE.Vector3(0,0,1);\n  Constants.defaultSceneFront = new THREE.Vector3(0,-1,0);\n\n  Constants.defaultCamera = {\n    position: new THREE.Vector3(-50, 20, -100),\n    near: 10,\n    far: 10000,\n    nearFarMultiplier: 1000  // used to divide near and multiply far when setting wrt view target bbox\n  };\n\n  Constants.ControlTypes = ['orbit', 'firstPerson'];\n\n  // We will work assuming 1 virtual unit = 1 cm\n  //  (most of the objects we are concerned with are best measured in cms)\n\n  // How much to multiply stored units (in meters) by to get virtual units (cms)\n  //  and vice versa\n  Constants.metersToVirtualUnit = 100;\n  Constants.virtualUnitToMeters = 1 / Constants.metersToVirtualUnit;\n  Constants.modelUnitInches = 0.0254;\n  Constants.modelUnitCentimeters = 0.01;\n  Constants.modelUnitMeters = 1.0;\n\n  // Assume input model data is modeled in inches (WSS COLLADA mostly declares this)\n  // Assume units are always stored in meters\n  Constants.defaultModelUnit = Constants.modelUnitMeters;\n  Constants.defaultSceneUnit = Constants.defaultModelUnit;\n\n  // TODO: Populate with stuff!\n  Constants.assetTypes = {\n    'model': { defaults: { defaultDataType: \"mesh\", defaultUp: Constants.defaultModelUp, defaultFront: Constants.defaultModelFront, defaultUnit: Constants.defaultModelUnit },\n               arrayFields: ['datasets', 'category', 'variantIds', 'componentIds', 'setIds', 'wnsynset','wnsynsetkey'] },\n    'scan':  { defaults: { defaultDataType: \"mesh\", defaultUp: Constants.defaultModelUp, defaultFront: Constants.defaultModelFront, defaultUnit: Constants.defaultModelUnit } },\n    'room':  { defaults: { defaultDataType: \"mesh\", defaultUp: Constants.defaultSceneUp, defaultFront: Constants.defaultSceneFront, defaultUnit: Constants.defaultSceneUnit } },\n    'scene': { defaults: { defaultDataType: \"mesh\", defaultUp: Constants.defaultSceneUp, defaultFront: Constants.defaultSceneFront, defaultUnit: Constants.defaultSceneUnit },\n               arrayFields: ['datasets', 'modelIds', 'modelCats', 'modelNames', 'modelTags', 'roomIds', 'roomTypes', 'origRoomTypes'] },\n    'texture': { defaults: { defaultDataType: \"image\" } }\n  };\n  Constants.assetTypeModel = 'model';\n  Constants.assetTypeScan = 'scan';\n  Constants.assetTypeRoom = 'room';\n  Constants.assetTypeScene = 'scene';\n  Constants.assetTypeTexture = 'texture';\n  Constants.assetTypeArch = 'arch';\n\n  Constants.assetSources = {\n    'scan': [/*'scans'*/],\n    'model': ['models3d'],\n    'scene': ['scenes'],\n    'texture': ['textures']\n  };\n\n  Constants.maxModelSize = 10000000;\n  Constants.defaultModelSource = 'models3d';\n\n  // Preview constants\n  Constants.previewMaxWidth = 500;\n  Constants.previewMaxHeight = 500;\n\n  // Base URL\n  Constants.baseUrl = Constants.getGlobalOrDefault('base_url', process.env.NODE_BASE_URL || '');\n  // TODO: Consolidate assets/resources\n  Constants.assetsDir = Constants.getGlobalOrDefault('assets_url', Constants.baseUrl + '/resources/');\n  Constants.screenShotDir = Constants.baseUrl + '/text2scene/screenshots/';\n  Constants.defaultVideo = 'videos/sintel.ogv';\n\n  Constants.assetsFile = Constants.assetsDir + '/data/assets.json';\n  Constants.extraAssetsFile = Constants.assetsDir + '/data/assets-extra.json';\n  Constants.scanAssetsFile = Constants.extraAssetsFile; // Scans are in the extra assets files\n\n  //Rails asset urls\n  //Constants.imageDir = Constants.baseUrl + '/data/image/';\n\n  // Combined models 3D database\n  Constants.models3dSearchUrl = Constants.baseUrl + '/solr/models3d/select';\n  Constants.models3dFieldsUrl = Constants.baseUrl + '/solr/models3d/schema/fields';\n  Constants.models3dSimilaritySearchUrl = Constants.baseUrl + '/ws/models3d/search';\n  Constants.models3dTextSearchUrl = Constants.baseUrl + '/ws/models3d/search';\n\n  Constants.texturesDataDir = Constants.baseUrl + '/data/textures/';\n  Constants.texturesSearchUrl = Constants.baseUrl + '/solr/textures/select';\n\n  Constants.wordnetSearchUrl = Constants.baseUrl + '/solr/wordnet/select';\n  Constants.shapenetSearchUrl = Constants.baseUrl + '/solr/shapenet-synsets/select';\n  Constants.taxonomyUrl = Constants.baseUrl + '/taxonomy'; // shows shapenet taxonomy\n  Constants.imagenetUrl = Constants.baseUrl + '/imagenet';\n\n  // Data\n  Constants.dataDir = Constants.getGlobalOrDefault('data_url', Constants.assetsDir + '/data/');\n  // Images\n  Constants.imagesDir = Constants.getGlobalOrDefault('images_url', Constants.assetsDir + '/images/');\n  // Loading icon\n  Constants.manipulatorImagesDir = Constants.imagesDir + '/manipulator/';\n  Constants.cameraControlIconsDir = Constants.imagesDir + '/camera_icons/';\n  Constants.toolbarIconsDir = Constants.imagesDir + '/toolbar_icons/';\n  Constants.scaleLineImageDir = Constants.imagesDir + '/scaleline/';\n  Constants.defaultLoadingIconUrl = Constants.imagesDir + '/loading.gif';\n\n  // Scenes searching\n  Constants.scenesSearchUrl = Constants.baseUrl + '/solr/scenes/select';\n  Constants.scenesFieldsUrl = Constants.baseUrl + '/solr/scenes/schema/fields';\n\n  // Rooms searching\n  Constants.roomsSearchUrl = Constants.baseUrl + '/solr/rooms/select';\n  Constants.roomsFieldsUrl = Constants.baseUrl + '/solr/rooms/schema/fields';\n\n  Constants.autoRotateSpeed = 0.001;\n\n  // PartAnnotator\n  Constants.meshPrefix = 'SGPath-';\n  // Annotations\n  Constants.submitUpdateMain = true;\n  Constants.submitPartAnnotationsURL = Constants.baseUrl + '/part-annotations/submit';\n  Constants.retrievePartAnnotationsURL = Constants.baseUrl + '/query?qt=parts';\n  Constants.retrieveSegmentsAnnotationsURL = Constants.baseUrl + '/query?qt=segments';\n  Constants.retrieveAnnotationsURL = Constants.baseUrl + '/annotations/list';\n  Constants.submitAnnotationsURL = Constants.baseUrl + '/annotations/submit';\n  Constants.submitSegmentsAnnotationsStatusURL = Constants.baseUrl + '/scans/segment-annotations/edit';\n  Constants.submitSegmentAnnotationsURL = Constants.baseUrl + '/scans/segment-annotations/submit';\n\n  // TODO: Reorganize these under shapenet\n  // ShapeNet MySQL query URL\n  Constants.shapenetQueryUrl = Constants.baseUrl + '/queryShapeNet';\n\n  // Scene generation\n  Constants.text2sceneDataUrl = Constants.baseUrl + '/text2scene/';\n  Constants.sceneGenerationUrl = Constants.baseUrl + '/ws/scenes/interact';\n\n  // Visualizing parts\n  Constants.getPartsUrl = Constants.baseUrl + '/ws/scenes/getParts';\n\n  // Get scene priors\n  Constants.getScenePriorsUrl = Constants.baseUrl + '/ws/scenes/getScenePriors';\n\n  // Similarity layout\n  Constants.simLayoutUrl = Constants.baseUrl + '/ws/sim/layout';\n  Constants.similaritiesUrl = Constants.baseUrl + '/ws/sim/similarities';\n\n  // Camera widget settings\n  Constants.cameraWidgetSettings = {\n    orbitLeftAmt: Math.PI / 8,\n    orbitUpAmt: Math.PI / 12,\n    dollyAmt: 20,\n    zoomAmt: 30,\n    orbitDuration: 250,\n    dollyDuration: 250,\n    zoomDuration: 250,\n    resetDuration: 750\n  };\n\n  // Undo stack settings\n  Constants.undoStackMaxSize = 100;\n\n  // Edit event operation status\n  Constants.EDIT_OPSTATE = Object.freeze({\n    INIT: 'EDIT_INIT',\n    PROGRESS: 'EDIT_PROGRESS',\n    DONE: 'EDIT_DONE'\n  });\n\n  // Command Type enum for UndoStack\n  Constants.CMDTYPE = Object.freeze({\n      INSERT: 'INSERT',\n      DELETE: 'DELETE',\n      MOVE: 'MOVE',\n      ROTATE: 'ROTATE',\n      SCALE: 'SCALE',\n      SWITCHFACE: 'SWITCHFACE',\n      INIT: 'INIT',\n      TEXT2SCENE: 'TEXT2SCENE',\n      TUTORIAL_START: 'TUTORIAL_START',\n      NULL: 'NULL'\n    });\n\n  // Query events\n  Constants.QUERY_OP = Object.freeze({\n    START: 'QUERY_START',\n    SELECT: 'QUERY_SELECT',\n    SELECT_GROUP: 'QUERY_SELECT_GROUP',\n    GO_BACK: 'QUERY_GO_BACK',\n    DONE: 'QUERY_DONE'\n  });\n\n  Constants.BBoxFaces = Object.freeze({\n    LEFT:    0,\n    RIGHT:   1,\n    BOTTOM:  2,\n    TOP:     3,\n    FRONT:   4,\n    BACK:    5\n  });\n\n  Constants.BBoxFaceCenters = Constants.BBoxFaces;\n\n  Constants.BBoxFacesThetaPhi = [\n    [0, -Math.PI/2],\n    [0, Math.PI/2],\n    [-Math.PI/2, 0],\n    [+Math.PI/2, 0],\n    [0, 0],\n    [0, Math.PI]\n  ];\n\n  Constants.EmptyArray = Object.freeze([]);\n\n  Constants.EditStrategy = Object.freeze({\n    // Strategy for getting attachment point\n    //DragDrop.ATTACH_BBCENTER = 1;\n    //DragDrop.ATTACH_BBCENTER_PRIORS = 2;\n\n    // Strategy for dealing with support surface change\n    SupportSurfaceChange: {\n      NONE: 0,\n      SWITCH_ATTACHMENT: 1,\n      REORIENT_CHILD: 2\n    }\n  });\n\n  Constants.tutorialModelId = 'wss.f6bcb75ed0132a2bd99fe055da4bc66c';\n  Constants.tutorialCameraPosition = [-145, 240, -72];\n\n  // Experimental features\n  Constants.enableThumbnail = true;\n  Constants.thumbnailPostfix = '_thumb.png';\n  Constants.AssetGroup = Object.freeze({\n      'ROTATING_IMAGE_INDEX': -10\n    });\n\n  Constants.defaultTexturedObjects = ['WallInside', 'WallOutside', 'Floor', 'Ceiling'];\n\n  Constants.MAX_ASYNC_REQS = 10;\n\n  // Exports\n  return Constants;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/process/browser.js */ \"../node_modules/process/browser.js\")))\n\n//# sourceURL=webpack://STK/./js/lib/Constants.js?");

/***/ }),

/***/ "./js/lib/PubSub.js":
/*!**************************!*\
  !*** ./js/lib/PubSub.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * PubSub defines a publisher/subscriber model. An object that extends PubSub can\n * register subscribers (functions) that will be called whenever the object 'publishes'\n * an event with a particular name. Published events can also come with an arbitrary\n * list of arguments which are passed to the subscriber functions.\n * @constructor\n **/\nfunction PubSub() {\n  this.subscribers = {};\n}\n\nPubSub.ALL = '*'; // All events\n\n/**\n * Subscribes to all events\n * @param contextObj {Object} Context object (used for this when callback is called)\n * @param callback {function(string, args)} Callback when event is published\n * @param [opts.limit] {int} Limit on number of times to subscribe to these events\n * @constructor\n */\nPubSub.prototype.SubscribeAll = function(contextObj, callback, opts) {\n  this.Subscribe(PubSub.ALL, contextObj, callback, opts);\n};\n\n/**\n * Subscribes to event just once\n * @param eventname {string} Name of event to subscribe to\n * @param contextObj {Object} Context object (used for this when callback is called)\n * @param callback\n * @constructor\n */\nPubSub.prototype.SubscribeOnce = function(eventname, contextObj, callback) {\n  // Wait for event just once\n  this.Subscribe(eventname, contextObj, callback, { limit: 1 });\n};\n\n/**\n * Subscribes to event\n * @param eventname {string} Name of event to subscribe to\n * @param contextObj {Object} Context object (used for this when callback is called)\n * @param callback {function(args)} Callback when event is published\n * @param [opts.limit] {int} Limit on number of times to subscribe to these events\n * @constructor\n */\nPubSub.prototype.Subscribe = function (eventname, contextObj, callback, opts) {\n  opts = opts || {};\n  var subs = this.subscribers;\n  if (!subs[eventname]) {\n    subs[eventname] = [];\n  }\n  var esubs = subs[eventname];\n\n  // Only add the callback if it hasn't already been added\n  var found = false;\n  for (var i = 0; i < esubs.length; i++) {\n    var entry = esubs[i];\n    if (entry.ctx === contextObj && entry.func === callback) {\n      found = true;\n      break;\n    }\n  }\n  if (!found) {\n    esubs.push({ ctx: contextObj, func: callback, count: 0, limit: opts.limit || 0 });\n  }\n};\n\n/**\n * Unsubscribe from events\n * @param eventname {string} Name of event to unsubscribe from\n * @param contextObj {Object} Context object to match\n * @param [optCallback] {function} Optional callback (if specified, unsubscribe specific callback.  Otherwise, unsubscribes all callbacks associated with contextObj)\n * @constructor\n */\nPubSub.prototype.Unsubscribe = function (eventname, contextObj, optCallback) {\n  var subs = this.subscribers;\n  var esubs = subs[eventname];\n  if (!esubs) {\n    return;\n  }\n\n  // Make list of subscribers we are keeping\n  var newsubs = [];\n  for (var i = 0; i < esubs.length; i++) {\n    var entry = esubs[i];\n    // This is the negation of (entry.ctx === contextObject) && (!optCallback || entry.func === optCallback)\n    if (entry.ctx !== contextObj || (optCallback && (entry.func !== optCallback))) {\n      newsubs.push(entry);\n    }\n  }\n  subs[eventname] = newsubs;\n};\n\n/**\n * Publishes event\n * @param eventname {string} Name of event\n * @constructor\n */\nPubSub.prototype.Publish = function (eventname) {\n  var esubs = this.subscribers[eventname];\n  var optargs = Array.prototype.slice.call(arguments, 1);\n  if (esubs) {\n    // Notify all subscribers - remove limited subscribers if they are done\n    var removeIndices = [];\n    esubs.forEach(function (entry,i) {\n      entry.count++;\n      entry.func.apply(entry.ctx, optargs);\n      // Check if subscriber are done!\n      if (entry.limit && entry.count >= entry.limit) {\n        removeIndices.push(i);\n      }\n    });\n    // Remove subscribers whose limit are reached\n    if (removeIndices.length > 0) {\n      console.log('Removing subscribers for event ' + eventname, removeIndices);\n      // Remove these!\n      var newsubs = [];\n      for (var i = 0; i < esubs.length; i++) {\n        if (removeIndices.indexOf(i) < 0) {\n          newsubs.push(esubs[i]);\n        }\n      }\n      this.subscribers[eventname] = newsubs;\n    }\n  }\n  if (eventname !== PubSub.ALL && this.subscribers[PubSub.ALL]) {\n    //console.log('publish to all');\n    this.Publish.apply(this, [PubSub.ALL,eventname].concat(optargs));\n  }\n};\n\nmodule.exports = PubSub;\n\n\n//# sourceURL=webpack://STK/./js/lib/PubSub.js?");

/***/ }),

/***/ "./js/lib/articulations/ArticulatedObject.js":
/*!***************************************************!*\
  !*** ./js/lib/articulations/ArticulatedObject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Articulation = __webpack_require__(/*! articulations/Articulation */ \"./js/lib/articulations/Articulation.js\");\nconst ArticulationState = __webpack_require__(/*! articulations/ArticulationState */ \"./js/lib/articulations/ArticulationState.js\");\nconst GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nconst OBBFitter = __webpack_require__(/*! geo/OBBFitter */ \"./js/lib/geo/OBBFitter.js\");\nconst Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst PartConnectivityGraph = __webpack_require__(/*! parts/PartConnectivityGraph */ \"./js/lib/parts/PartConnectivityGraph.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// TODO: Have ArticulatedObject be made up of ArticulatedPart\n\n/**\n * Articulated Object\n * @memberOf articulations\n */\nclass ArticulatedObject extends THREE.Object3D {\n    constructor(articulations, connectivity, partHierarchy, parts) {\n        super();\n        this.type = 'ArticulatedObject';\n        this.isArticulated = true;     // Indicates that this object is articulated\n        // TODO: Support more memory efficient remeshing of objects\n        if (partHierarchy) {\n            this.fromPartHierarchy(partHierarchy);\n        } else if (connectivity) {\n            this.fromConnectivityGraph(articulations, connectivity);\n        } else if (parts) {\n            this.fromParts(articulations, parts);\n        } else if (arguments.length) {\n            console.error(\"Cannot create ArticulatedObject\", [...arguments]);\n        }\n        this.articulationStates = _.map(this.articulations, art => {\n            const part = this.parts[art.pid];\n            const artNode = this.articulatableNodes[art.pid];\n            return new ArticulationState(part, art, artNode);\n        });\n    }\n\n    fromParts(articulations, parts) {\n        const connections = [];\n        for (let art of articulations) {\n            connections[art.pid] = connections[art.pid] || [];\n            connections[art.pid].push(...art.base);\n            for (let bpid of art.base) {\n                connections[bpid] = connections[bpid] || [];\n                connections[bpid].push(art.pid);\n            }\n        }\n        //console.log(connections, articulations);\n        const connectivity = new PartConnectivityGraph(connections, parts);\n        return this.fromConnectivityGraph(articulations, connectivity);\n    }\n\n    fromConnectivityGraph(articulations, connectivity) {\n        articulations = articulations || [];\n        this.articulations = _.map(articulations, art => new Articulation(art));\n        this.connectivityGraph = connectivity;\n        this.articulatableNodes = [];  // Array of articulatable nodes (indexed by pid so there will be holes)\n        // console.log('groupParts');\n        this.__groupParts();\n    }\n\n    fromPartHierarchy(partHierarchy) {\n        this.partHierarchy = partHierarchy;\n        this.connectivityGraph = PartConnectivityGraph.fromPartHierarchy(partHierarchy);\n        this.articulatableNodes = [];  // Array of articulatable nodes (indexed by pid so there will be holes)\n        this.articulations = [];\n        for (let part of this.connectivityGraph.parts) {\n            const userData = part.object3D.userData;\n            userData.type = 'Part';\n            userData.partId = part.pid;\n            if (part.articulation) {\n                userData.isArticulated = true;\n                userData.articulatablePartId = part.pid;\n                userData.isArticulatedNode = true;\n                this.articulatableNodes[part.pid] = part.object3D;\n                const arts = _.isArray(part.articulation)? part.articulation : [part.articulation];\n                for (let art of arts) {\n                    this.articulations.push(\n                      new Articulation({\n                          pid: part.pid,\n                          type: art.type,\n                          axis: art.axis,\n                          origin: art.origin,\n                          rangeMin: art.rangeMin,\n                          rangeMax: art.rangeMax,\n                          base: part.parent ? [part.parent.pid] : []\n                      })\n                    );\n                }\n            } else {\n                userData.isStatic = true;\n            }\n        }\n        this.add(partHierarchy.root.object3D);\n    }\n\n    copy(other, recursive) {\n        if (this.partHierarchy) {\n            this.fromPartHierarchy(this.partHierarchy.clone());\n        } else {\n            super.copy(other, recursive);\n            this.articulations = other.articulations.map(x => x.clone());\n            this.connectivityGraph = other.connectivityGraph;\n            this.articulatableNodes = other.articulatableNodes.map(n => this.__findArticulatableNode(n.userData.partId));\n        }\n        this.articulationStates = _.map(this.articulations, art => {\n            const part = this.parts[art.pid];\n            const artNode = this.articulatableNodes[art.pid];\n            return new ArticulationState(part, art, artNode);\n        });\n        return this;\n    }\n\n    clone(recursive) {\n        return new this.constructor().copy( this, recursive );\n    }\n\n    getNumArticulations() {\n        return this.articulations.length;\n    }\n\n    getArticulation(artIndex) {\n        return this.articulations[artIndex];\n    }\n\n    getArticulationState(artIndex) {\n        return this.articulationStates[artIndex];\n    }\n\n    findArticulationIndex(filter) {\n        return _.findIndex(this.articulations, filter);\n    }\n\n    findArticulationIndices(filter) {\n        const indices = [];\n        for (let i = 0; i < this.articulations.length; i++) {\n            if (filter(this.articulations[i])) {\n                indices.push(i);\n            }\n        }\n        return indices;\n    }\n\n    findParts(filter) {\n        return this.connectivityGraph.parts.filter(p => p && filter(p));\n    }\n\n    get parts() {\n        return this.connectivityGraph.parts;\n    }\n\n    applyArticulation(artIndex, delta) {\n        const articulationState = this.articulationStates[artIndex];\n        if (articulationState.articulatedNode) {\n            return articulationState.apply(delta);\n        } else {\n            console.warn('No articulatable node', articulationState.articulation.pid);\n            return 0;\n        }\n    }\n\n    toArticulatedPartsJson() {\n        // Combined structure with articulations and parts information\n        const json = this.connectivityGraph.toJson();\n        json.version = \"articulated-parts@0.0.1\";\n        json.metadata = { connectivity: json.metadata };\n        json.articulations = this.articulations.map(art => art? art.toJson() : undefined);\n        for (let part of json.parts) {\n            if (part) {\n                let articulationIds = this.findArticulationIndices(art => art.pid === part.pid);\n                if (articulationIds.length) {\n                    part.articulationIds = articulationIds;\n                }\n            }\n        }\n        return json;\n    }\n\n    toCondensed() {\n        // Takes existing object3D and merge some nodes\n        const origParts = this.connectivityGraph.parts;\n        const staticNode = Object3DUtil.findNode(this, n => n.name === 'Static');\n        const newParts = [null]; // Unknown part\n        const partIdRemap = [];\n        let pid = 1;\n        let staticPartId = undefined;\n        // Take children and merge them\n        if (staticNode) {\n            const mergedNode = GeometryUtil.mergeMeshes(staticNode);\n            const obb = OBBFitter.fitMeshOBB(mergedNode, { constrainedVertical: true });\n            staticPartId = pid;\n            mergedNode.name = 'Part' + pid;\n            mergedNode.userData.type = 'Part';\n            mergedNode.userData.isStatic = true;\n            mergedNode.userData.partId = pid;\n            const newPart = new Part(pid, 'static', 'static', obb, mergedNode);\n            const origPartNodes = Object3DUtil.findNodes(staticNode, n => n.userData.partId != null);\n            newPart.sourceParts = origPartNodes.map(n => origParts[n.userData.partId]);\n            newParts.push(newPart);\n            pid++;\n        }\n        const origArticulatableNodes = this.articulatableNodes.filter(n => n);\n        for (let i = 0; i < origArticulatableNodes.length; i++) {\n            const node = origArticulatableNodes[i].clone();\n            const origPart = origParts[node.userData.partId];\n            partIdRemap[node.userData.partId] = pid;\n            let newPart;\n            if (node instanceof THREE.Mesh) {\n                // Okay\n                const obb = origPart.obb? origPart.obb.clone() : OBBFitter.fitMeshOBB(node, { constrainedVertical: true });\n                newPart = new Part(pid, origPart.label, origPart.name, obb, node);\n                newPart.sourceParts = [origParts[node.userData.partId]];\n            } else {\n                const linkedNodes = node.children.filter(n => n.userData.articulatablePartId === node.userData.partId);\n                const mergedNode = GeometryUtil.mergeMeshes(linkedNodes);\n                const obb = OBBFitter.fitMeshOBB(mergedNode, { constrainedVertical: true });\n                mergedNode.name = 'Part' + pid;\n                mergedNode.userData.type = 'Part';\n                mergedNode.userData.isArticulated = true;\n                mergedNode.userData.partId = pid;\n                mergedNode.userData.articulatablePartId = pid;\n                for (let j = 0; j < linkedNodes.length; j++) {\n                    node.remove(linkedNodes[j]);\n                }\n                node.add(mergedNode);\n                newPart = new Part(pid, origPart.label, origPart.name, obb, mergedNode);\n                newPart.sourceParts = linkedNodes.map(n => origParts[n.userData.partId]);\n            }\n            newParts.push(newPart);\n            node.userData.partId = pid;\n            node.userData.articulatablePartId = pid;\n            pid++;\n        }\n\n        const connectivity = [];\n        for (let i = 0; i < newParts.length; i++) {\n            connectivity[i] = [];\n        }\n        const articulations = this.articulations.map( x => {\n            const origPart = origParts[x.pid];\n            const c = x.clone();\n            c.pid = partIdRemap[x.pid];\n            c.base = (origPart.parentId != undefined)? [partIdRemap[origPart.parentId]] :\n                (staticPartId != undefined)? [staticPartId] : [];\n            connectivity[c.pid] = connectivity[c.pid] || [];\n            for (let baseId of c.base) {\n                //connectivity[baseId] = connectivity[baseId] || [];\n                connectivity[c.pid].push(baseId);\n                connectivity[baseId].push(c.pid);\n            }\n            return c;\n        });\n        const cgmeta = this.connectivityGraph.metadata? _.clone(this.connectivityGraph.metadata) : undefined;\n        if (cgmeta) {\n            cgmeta.condensed = true;\n        }\n        const cg = new PartConnectivityGraph(connectivity, newParts, cgmeta);\n        return new ArticulatedObject(articulations, cg);\n    }\n\n    __findArticulatableNode(pid) {\n        return Object3DUtil.findNode(this, n => n.userData.partId === pid && n.userData.isArticulatedNode);\n    }\n\n    __groupParts() {\n        const parts = this.connectivityGraph.parts;\n        const pids = this.__identifyArticulatablePids();\n        const articulatablePids = pids.articulatablePids;\n        const staticPids = pids.staticPids;\n        const filteredStaticPids = _.filter(staticPids,\n                pid => parts[pid] && parts[pid].object3D && parts[pid].parentId == null);\n\n        if (filteredStaticPids.length > 0) {\n            const staticNode = new THREE.Group();\n            staticNode.name = 'Static';\n            staticNode.userData.id = staticNode.name;\n            this.add(staticNode);\n            for (let pid of filteredStaticPids) {\n                const part = parts[pid];\n                part.object3D.userData.isStatic = true;\n                Object3DUtil.attachToParent(part.object3D, staticNode);\n            }\n        }\n\n        if (articulatablePids.length > 0) {\n            const articulatableNode = this; // Have articulated nodes attach directly to this\n            //const articulatableNode = new THREE.Group();\n            //articulatableNode.name = 'Articulatable';\n            //this.add(articulatableNode);\n            for (let pid of articulatablePids) {\n                const part = parts[pid];\n                let partNode = part.object3D;\n                partNode.userData.isArticulated = true;  // Indicate that this part is articulated\n                if (part.childIds && part.childIds.length > 0) {\n                    const childrenNode = new THREE.Group();\n                    childrenNode.name = 'composite_part' + part.pid + \":\" + part.name;\n                    childrenNode.userData.id = childrenNode.name;\n                    Object3DUtil.attachToParent(part.object3D, childrenNode);\n                    for (let cid of part.childIds) {\n                        Object3DUtil.attachToParent(parts[cid].object3D, childrenNode);\n                        if (articulatablePids.indexOf(cid) < 0) {\n                            parts[cid].object3D.userData.articulatablePartId = part.pid;\n                        }\n                    }\n                    partNode = childrenNode;\n                }\n                part.object3D.userData.articulatablePartId = part.pid;\n                partNode.userData.isArticulatedNode = true;  // Indicate that this node is a main articulation node (may have children)\n                partNode.userData.partId = part.pid;\n                if (part.parentId == null) {\n                    Object3DUtil.attachToParent(partNode, articulatableNode);\n                } else {\n                    Object3DUtil.attachToParent(partNode, this.articulatableNodes[part.parentId]);\n                }\n                this.articulatableNodes[pid] = partNode;\n            }\n        }\n\n    }\n\n    __identifyArticulatablePids() {\n        // Takes articulations and create a appropriate hierarchy from the parts and add them to this\n        // Assumes that each part has a mesh representing that part\n\n        // Figure out the hierarchy\n        const parts = this.connectivityGraph.parts;\n        const articulationsByPartId = _.groupBy(this.articulations, 'pid');\n        const articulatablePids = _.keys(articulationsByPartId).map(x => parseInt(x));\n        const remainingPids = new Set(_.range(0, parts.length));\n        // console.log('remaining', remainingPids, articulationsByPartId);\n        _.each(articulationsByPartId, (arts, pid) => {\n            pid = parseInt(pid);\n            const part = parts[pid];\n            if (arts.length > 1) {\n                console.log(`Multiple articulations for part ${pid} (${part.name}): ${arts.length}`);\n            }\n            // Let's just handle one articulation\n            const basePids = new Set(_.uniq(_.flatMap(arts, 'base')));\n            const stopPids = new Set([...basePids,...articulatablePids]);\n            stopPids.add(pid);\n            const childPids = this.connectivityGraph.getConnectedPartIdsDeep([pid],\n                    id => stopPids.has(id), id => !basePids.has(id));\n            part.baseIds = [...basePids];\n            part.childIds = [...childPids].filter(cid => cid !== pid);\n            for (let cid of part.childIds) {\n                if (parts[cid].parentId != null) {\n                    console.log(`Part ${cid} already parented to ${parts[cid].parentId}`);\n                }\n                parts[cid].parentId = pid;\n                remainingPids.delete(cid)\n            }\n            remainingPids.delete(pid);\n        });\n        // console.log(this.connectivityGraph.parts);\n        // Make sure articulatablePids are in order (parent, then descendants)\n        const rootArticulatablePids = articulatablePids.filter(pid => parts[pid].parentId == null);\n        //console.log(articulatablePids, rootArticulatablePids);\n        const sortedArticulatablePids = [];\n        const todo = rootArticulatablePids.slice();\n        const done = new Set();\n        while (todo.length > 0) {\n            let pid = todo.shift();\n            if (articulatablePids.indexOf(pid) >= 0) {\n                sortedArticulatablePids.push(pid);\n            }\n            done.add(pid);\n            if (parts[pid].childIds) {\n                for (let cid of parts[pid].childIds) {\n                    if (!done.has(cid)) {\n                        todo.push(cid);\n                    }\n                }\n            }\n        }\n        //console.log(sortedArticulatablePids);\n        return { rootArticulatablePids: rootArticulatablePids, articulatablePids: sortedArticulatablePids, staticPids: [...remainingPids] };\n    }\n}\n\nmodule.exports = ArticulatedObject;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/ArticulatedObject.js?");

/***/ }),

/***/ "./js/lib/articulations/ArticulatedObjectLoader.js":
/*!*********************************************************!*\
  !*** ./js/lib/articulations/ArticulatedObjectLoader.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ArticulatedObject = __webpack_require__(/*! articulations/ArticulatedObject */ \"./js/lib/articulations/ArticulatedObject.js\");\nconst Object3DLoader = __webpack_require__(/*! loaders/Object3DLoader */ \"./js/lib/loaders/Object3DLoader.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nconst IndexedSegmentation = __webpack_require__(/*! geo/IndexedSegmentation */ \"./js/lib/geo/IndexedSegmentation.js\");\nconst Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst PartConnectivityGraph = __webpack_require__(/*! parts/PartConnectivityGraph */ \"./js/lib/parts/PartConnectivityGraph.js\");\nconst async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// Handles loading of everything that is needed for an articulated object\nclass ArticulatedObjectLoader {\n    constructor(params) {\n        this.assetManager = params.assetManager; // Used to load other stuff\n        this.mergeFixedParts = params.mergeFixedParts;\n        this.articulationsInfoField = (params.articulationsInfoField != null)? params.articulationsInfoField  : 'articulations';\n    }\n\n    checkModelHasArticulatedMesh(modelinfo) {\n        return _.get(modelinfo, [this.articulationsInfoField, 'files', 'mesh']);\n    }\n\n    load(modelinfo, callback) {\n        // TOOO: Have ArticulatedObjectLoader be more robust, explicit specify the format of the articulated mesh\n        const hasMeshFile = this.checkModelHasArticulatedMesh(modelinfo);\n        if (hasMeshFile) {\n            if (modelinfo.source === 'rpmnet') {\n                return this.__loadRpmNetPresegmented(modelinfo, callback);\n            } else {\n                return this.__loadWithSegmentation(modelinfo, callback);\n            }\n        } else {\n            callback('No mesh file for ' + this.articulationsInfoField);\n        }\n    }\n\n    // Load presegmented articulated model from RPMNet with one part per mesh\n    __loadRpmNetPresegmented(modelinfo, callback) {\n        const artInfo = modelinfo[this.articulationsInfoField];\n        const meshFilename = artInfo['files']['mesh'];\n        const articulationsFilename = artInfo['files']['articulations'];\n        const connectivityFilename = artInfo['files']['connectivity_graph'];\n        modelinfo.file = meshFilename;\n        modelinfo.format = undefined;\n        async.parallel([\n            (cb) => {\n                // Load mesh\n                const obj3dLoader = new Object3DLoader(this.assetManager);\n                obj3dLoader.loadErrorFirst(modelinfo, cb);\n            },\n            (cb) => {\n                // Load articulations\n                _.getJSON(articulationsFilename, cb);\n            },\n            (cb) => {\n                if (connectivityFilename) {\n                    _.getJSON(connectivityFilename, cb);\n                } else {\n                    cb();\n                }\n            }\n        ], (err, res) => {\n            if (err) {\n                callback(err, null);\n            } else {\n                try {\n                    const object3D = res[0];\n                    const meshes = Object3DUtil.getMeshList(object3D);\n                    const connectivityGraph = res[2]?  PartConnectivityGraph.fromJson(res[2]) : null;\n                    if (connectivityGraph) {\n                        const parts = connectivityGraph.parts;\n                        for (let i = 0; i < parts.length; i++) {\n                            const pid = parts[i].pid;\n                            const mesh = meshes[i];\n                            mesh.userData.pid = pid;\n                            mesh.userData.type = 'Part';\n                            mesh.userData.partId = pid;\n                            parts[i].object3D = mesh;\n                        }\n                        const articulationsJson = res[1];\n                        let articulatedObject = new ArticulatedObject(articulationsJson, connectivityGraph, null, null);\n                        articulatedObject.name = modelinfo.fullId + '-articulated';\n                        callback(null, articulatedObject);\n                    } else {\n                        const parts = [];\n                        for (let mesh of meshes) {\n                            const pid = mesh.userData.index;\n                            mesh.userData.pid = pid;\n                            mesh.userData.type = 'Part';\n                            mesh.userData.partId = pid;\n                            const obb = null;  // TODO: compute OBB\n                            parts[pid] = new Part(pid, undefined, mesh.name, obb, mesh);\n                        }\n                        const articulationsJson = res[1];\n                        let articulatedObject = new ArticulatedObject(articulationsJson, null, null, parts);\n                        articulatedObject.name = modelinfo.fullId + '-articulated';\n                        callback(null, articulatedObject);\n                    }\n                } catch (err) {\n                    callback(err);\n                }\n            }\n        });\n    }\n\n    // Load articulated model with separate parts file\n    __loadWithSegmentation(modelinfo, callback) {\n        const artInfo = modelinfo[this.articulationsInfoField];\n        const meshFilename = artInfo['files']['mesh'];\n        const articulationsFilename = artInfo['files']['articulations'];\n        const precomputedFilename = artInfo['files']['connectivity_graph'];\n        const partsFilename = artInfo['files']['parts'];\n        const segmentType = 'parts';\n        const segmentation = new IndexedSegmentation({\n            filename: partsFilename,\n            segmentType: segmentType\n        });\n        modelinfo.file = meshFilename;\n        modelinfo.format = undefined;\n        async.parallel([\n            (cb) => {\n                // Load mesh\n                const obj3dLoader = new Object3DLoader(this.assetManager);\n                obj3dLoader.loadErrorFirst(modelinfo, cb);\n            },\n            (cb) =>{\n                // Load segmentation\n                segmentation.load({ callback: cb })\n            },\n            (cb) => {\n                // Load articulations\n                _.getJSON(articulationsFilename, cb);\n            },\n            (cb) => {\n                // Load connectivity graph\n                _.getJSON(precomputedFilename, cb);\n            }\n        ], (err, res) => {\n            if (err) {\n                callback(err, null);\n            } else {\n                try {\n                    const object3D = res[0];\n                    const articulationsJson = res[2];\n                    const precomputedJson = res[3];\n                    const segmented = segmentation.getSegmentedMeshes({\n                        object3D: object3D,\n                        segmentType: segmentType,\n                        segmentName: 'parts'\n                    });\n                    if (precomputedJson.reducedConnectivityGraph) {\n                        precomputedJson.fullConnectivityGraph = precomputedJson.connectivityGraph;\n                        precomputedJson.connectivityGraph = precomputedJson.reducedConnectivityGraph;\n                    }\n                    const connectivityGraph = PartConnectivityGraph.fromJson(precomputedJson);\n                    const parts = connectivityGraph.parts;\n                    for (let i = 0; i < segmented.children.length; i++) {\n                        const object3D = segmented.children[i];\n                        const pid = object3D.userData.id;\n                        let part = parts[pid];\n                        if (part) {\n                            part.object3D = object3D;\n                            part.object3D.name = 'part' + pid + ':' + part.name;\n                            part.object3D.userData.type = 'Part';\n                            part.object3D.userData.partId = pid;\n                            //part.object3D.material = Object3DUtil.getSimpleFalseColorMaterial(i);\n                            delete object3D.userData.id;\n                        } else if (pid === 0) {\n                            // Unlabeled part (okay)\n                            part = new Part(0, 'unknown', 'unknown', null, object3D);\n                            part.object3D.name = 'part' + pid + ':' + part.name;\n                            part.object3D.userData.type = 'PartUnlabeled';\n                            part.object3D.userData.partId = pid;\n                            delete object3D.userData.id;\n                            parts[pid] = part;\n                        } else {\n                            console.warn('Cannot find part for ' + pid);\n                        }\n                    }\n                    let articulatedObject = new ArticulatedObject(articulationsJson, connectivityGraph);\n                    //console.log('Loaded articulated object', articulatedObject);\n                    if (this.mergeFixedParts) {\n                        articulatedObject = articulatedObject.toCondensed();\n                        //console.log('Condensed articulated object', articulatedObject);\n                    }\n                    articulatedObject.name = modelinfo.fullId + '-articulated';\n                    callback(null, articulatedObject);\n                } catch (err) {\n                    callback(err);\n                }\n            }\n        });\n    }\n}\n\nmodule.exports = ArticulatedObjectLoader;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/ArticulatedObjectLoader.js?");

/***/ }),

/***/ "./js/lib/articulations/Articulation.js":
/*!**********************************************!*\
  !*** ./js/lib/articulations/Articulation.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");  // Only used for convenient toVector3 function\nconst OBB = __webpack_require__(/*! ../geo/OBB */ \"./js/lib/geo/OBB.js\");\n\n/**\n * Returns a rotation matrix about a given axis and origin (i.e. center of rotation)\n * @private\n */\nvar rotationAxisOrigin = (function() {\n\tvar tmpMat1 = new THREE.Matrix4();\n\tvar tmpMat2 = new THREE.Matrix4();\n\tvar tmpMat3 = new THREE.Matrix4();\n\treturn function(axis, origin, angle) {\n\t\t// Translate origin to the world origin\n\t\tlet trans = tmpMat1.makeTranslation(-origin.x, -origin.y, -origin.z);\n\t\t// Rotate about axis\n\t\tconst rot = tmpMat2.makeRotationAxis(axis, angle);\n\t\tconst transRot = tmpMat3.multiplyMatrices(rot, trans);\n\t\t// Translate back to the origin\n\t\ttrans = tmpMat1.makeTranslation(origin.x, origin.y, origin.z);\n\t\treturn tmpMat2.multiplyMatrices(trans, transRot);\n\t};\n})();\n\n/**\n * Articulation\n * @memberOf articulations\n */\nclass Articulation {\n    constructor(params, keepOrigVector) {\n        this.copy(params, keepOrigVector);\n    }\n\n    copy(other, keepOrigVector) {\n        this.pid = other.pid;\n        this.type = other.type;\n        if (keepOrigVector) {\n            this.axis = other.axis;\n        } else {\n            this.axis = this.axis || new THREE.Vector3();\n            this.axis.copy(Object3DUtil.toVector3(other.axis));\n            this.axis.normalize();\n        }\n        if (other.origin) {\n            if (keepOrigVector) {\n                this.origin = other.origin;\n            } else {\n                this.origin = this.origin || new THREE.Vector3();\n                this.origin.copy(Object3DUtil.toVector3(other.origin));\n            }\n        }\n        if (other.ref) {\n            if (keepOrigVector) {\n                this.ref = other.ref;\n            } else {\n                this.ref = this.ref || new THREE.Vector3();\n                this.ref.copy(Object3DUtil.toVector3(other.ref));\n                if (!this.isTranslation) {\n                    this.ref.normalize();  // Make sure normalized\n                }\n            }\n        }\n        this.rangeMin = other.rangeMin;\n        this.rangeMax = other.rangeMax;\n        this.base = other.base? other.base.slice() : [];\n        this.defaultValue = other.defaultValue || 0;\n        if (other.value != null) {\n            this.value = other.value;\n        }\n    }\n\n    clone() {\n        return new Articulation(this);\n    }\n\n    get rangeAmount() {\n        return (this.rangeMax != null && this.rangeMin != null)? this.rangeMax - this.rangeMin : null;\n    }\n\n    getCappedDelta(amount, currentValue) {\n        if (amount > 0) {\n            if (this.rangeMax != null) {\n                if (currentValue + amount > this.rangeMax) {\n                    return Math.max(this.rangeMax - currentValue, 0);\n                }\n            }\n        } else if (amount < 0) {\n            if (this.rangeMin != null) {\n                if (currentValue + amount < this.rangeMin) {\n                    return Math.min(this.rangeMin - currentValue, 0);\n                }\n            }\n        }\n        return amount;\n    }\n\n    getCappedValue(value) {\n        if (this.rangeMin != undefined && this.rangeMin > value) {\n            return this.rangeMin;\n        } else if (this.rangeMax != undefined && this.rangeMax < value) {\n            return this.rangeMax;\n        } else {\n            return value;\n        }\n    }\n\n    get isTranslation() {\n        return this.type && this.type.toLowerCase() === Articulation.Type.TRANSLATION.toLowerCase();\n    }\n\n    applyMatrix(mat) {\n        this.axis.transformDirection(mat);\n        if (this.origin) {\n            this.origin.applyMatrix4(mat);\n        }\n        return this;\n    }\n\n    /**\n     * Transform a mesh object by some amount according to this articulation\n     */\n    applyToObject3D(object3D, amount) {\n        if (this.isTranslation) {\n            object3D.translateOnAxis(this.axis, amount);\n        } else {\n            object3D.applyMatrix(rotationAxisOrigin(this.axis, this.origin, amount));\n        }\n    }\n\n    /**\n     * Returns a hash string of this articulation\n     */\n    getHashString() {\n        const precision = 5;\n        const orig = this.origin.toArray().map( a => a.toFixed(precision));\n        const axis = this.axis.toArray().map( a => a.toFixed(precision));\n        const range = [this.rangeMin, this.rangeMax].map( a => a.toFixed(precision));\n        const baseIds = this.base.sort();\n        const defaultValue = this.defaultValue.toFixed(precision);\n        const ref = (this.ref != null)? this.ref.toArray().map( a => a.toFixed(precision)) : null;\n\n        let hashString = \"pid=\"+this.pid+\"&base=\"+JSON.stringify(baseIds)\n            +\"&type=\"+this.type+\"&origin=\"+JSON.stringify(orig)\n            +\"&axis=\"+JSON.stringify(axis)+\"&range=\"+JSON.stringify(range)\n            +\"&defaultValue=\"+JSON.stringify(defaultValue);\n        if (ref != null) {\n            hashString = hashString + \"&ref=\" + JSON.stringify(ref);\n        }\n        return hashString;\n    }\n\n    /**\n     * Create a long, thin box mesh illustrating the axis of this articulation\n     */\n    toMesh(length=1.5 , width=0.05) {\n        const longAxis = this.axis;\n        const randVec = new THREE.Vector3(Math.random(), Math.random(), Math.random());\n        const shortAxis1 = new THREE.Vector3().crossVectors(longAxis, randVec);\n        const shortAxis2 = new THREE.Vector3().crossVectors(longAxis, shortAxis1);\n        longAxis.normalize();\n        shortAxis1.normalize();\n        shortAxis2.normalize();\n        const obb = new OBB().fromJSON({\n            centroid: this.origin.toArray(),\n            axesLengths: [length, width, width],\n            normalizedAxes: longAxis.toArray().concat(shortAxis1.toArray()).concat(shortAxis2.toArray())\n        });\n        return obb.toMesh();\n    }\n\n    toJson() {\n        return {\n            pid: this.pid,      // partId\n            type: this.type,\n            axis: this.axis? this.axis.toArray() : undefined,\n            origin: this.origin? this.origin.toArray() : undefined,\n            rangeMin: this.rangeMin,\n            rangeMax: this.rangeMax,\n            base: this.base,    // baseIds\n            defaultValue: this.defaultValue\n        };\n    }\n\n}\n\nArticulation.Type = Object.freeze({\n\tROTATION: 'Central Rotation',\n\tHINGE_ROTATION: 'Hinge Rotation',\n\tTRANSLATION: 'Translation',\n});\n\nmodule.exports = Articulation;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/Articulation.js?");

/***/ }),

/***/ "./js/lib/articulations/ArticulationPlayer.js":
/*!****************************************************!*\
  !*** ./js/lib/articulations/ArticulationPlayer.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class ArticulationPlayer {\n    constructor(params) {\n        this.articulatedObject = params.articulatedObject;\n        //this.modelInstance = params.modelInstance || Object3DUtil.getModelInstance(this.articulatedObject);\n        this.assetManager = params.assetManager;\n\n        // Whether to automatically reverse after limit is reached\n        this.autoReverse = true;\n\n        // State for the play\n        this.isPaused = true;\n        this.selectArticulation(0);\n\n        // Tell people that we are ready\n        this.assetManager.Publish('dynamicAssetLoaded', this);\n    }\n\n    // Exposed operations\n    getOperations() {\n        return ['pause', 'play', 'turnOn', 'turnOff', 'toggle', 'next', 'select'];\n    };\n\n    pause() {\n        this.isPaused = true;\n    };\n\n    play() {\n        this.isPaused = false;\n    };\n\n    turnOn() {\n        this.play();\n    }\n\n    turnOff() {\n        this.pause();\n    }\n\n    toggle() {\n        if (this.isPaused) {\n            this.play();\n        } else {\n            this.pause();\n        }\n        return !this.isPaused;\n    };\n\n    select(label) {\n        label = label.replace(\"_\", \" \");\n        let index = this.selectPartByName(label);\n        if (index < 0) {\n            index = this.selectPartByLabel(label);\n        }\n        return index;\n    }\n\n    // Select articulation to play\n    selectArticulation(i) {\n        this.currentArtIndex = i;\n        if (this.articulatedObject.getArticulation(this.currentArtIndex).isTranslation) {\n            this.delta = 0.001;\n        } else {\n            this.delta = 0.005;\n        }\n    }\n\n    selectPart(pid) {\n        const index = this.articulatedObject.findArticulationIndex(art => art.pid === pid);\n        if (index >= 0) {\n            this.selectArticulation(index);\n        }\n        return index;\n    }\n\n    selectPartByLabel(label) {\n        return this.selectMatchingPart(p => p.label === label);\n    }\n\n    selectPartByName(name) {\n        return this.selectMatchingPart(p => p.name === name);\n    }\n\n    selectMatchingPart(filter) {\n        const matchingParts = this.articulatedObject.findParts(filter);\n        const matchingPids = matchingParts.map(p => p.pid);\n        //console.log(matchingPids);\n        const index = this.articulatedObject.findArticulationIndex(art => matchingPids.indexOf(art.pid) >= 0);\n        if (index >= 0) {\n            this.selectArticulation(index);\n        }\n        //console.log('got index', index);\n        return index;\n    }\n\n\n    getActivePartId() {\n        return this.articulatedObject.getArticulation(this.currentArtIndex).pid;\n    }\n\n    // Go to next articulation\n    next() {\n        this.select((this.currentArtIndex + 1) % this.articulatedObject.getNumArticulations());\n    }\n\n    // Dynamic asset callbacks\n    update() {\n        if (!this.isPaused) {\n            const delta = this.articulatedObject.applyArticulation(this.currentArtIndex, this.delta);\n            if (Math.abs(delta) < Math.abs(this.delta)) {\n                // At limit\n                if (this.autoReverse) {\n                    this.delta = -this.delta;\n                }\n            }\n        }\n    }\n\n    destroy() {\n\n    };\n}\n\nmodule.exports = ArticulationPlayer;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/ArticulationPlayer.js?");

/***/ }),

/***/ "./js/lib/articulations/ArticulationState.js":
/*!***************************************************!*\
  !*** ./js/lib/articulations/ArticulationState.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Represents the state of a part together with a set of articulation parameters\n * @memberOf articulations\n */\nclass ArticulationState {\n  constructor(part, articulation, articulatedNode, value) {\n    this.part = part;\n    this.articulation = articulation;\n    this.articulatedNode = articulatedNode;\n    this.__value = (value != undefined)? value : this.articulation.defaultValue;\n    this.direction = 1;\n  }\n\n  get type() {\n    return this.articulation.type;\n  }\n\n  get pid() {\n    return this.articulation.pid;\n  }\n\n  get axis() {\n    return this.articulation.axis;\n  }\n\n  get origin() {\n    return this.articulation.origin;\n  }\n\n  get ref() {\n    return this.articulation.ref;\n  }\n\n  get defaultValue() {\n    return this.articulation.defaultValue;\n  }\n\n  get rangeMin() {\n    return this.articulation.rangeMin;\n  }\n\n  get rangeMax() {\n    return this.articulation.rangeMax;\n  }\n\n  get rangeAmount() {\n    return this.articulation.rangeAmount;\n  }\n\n  get defaultRangeAmount() {\n    if (this.articulation.isTranslation) {\n      return this.part.obb.diagonalLength()*2;\n    } else {\n      return 2*Math.PI;\n    }\n  }\n\n  get value() {\n    return this.__value;\n  }\n\n  set value(v) {\n    // Note this allows for any value (not capped by min/max)\n    const delta = v - this.value;\n    if (delta !== 0) {\n      this.apply(delta, true);\n    }\n  }\n\n  setValueCapped(v) {\n    const newValue = this.articulation.getCappedValue(v);\n    this.value = newValue;\n  }\n\n  /**\n   * Applies this articulation on an object3D (restrict range to be within min/max)\n   * (similar to applyToObject3D but is capped)\n   * @param delta {number}\n   * @param unlimited {boolean} Allow for unlimited value (outside of range)\n   */\n  apply(delta, unlimited = false) {\n    const amount = unlimited? delta : this.articulation.getCappedDelta(delta, this.value);\n    this.articulation.applyToObject3D(this.articulatedNode, amount);\n    this.__value += amount;\n    return amount;\n  }\n\n  setToMin() {\n    this.value = this.articulation.rangeMin;\n  }\n\n  setToMax() {\n    this.value = this.articulation.rangeMax;\n  }\n\n  setToDefault() {\n    this.value = this.articulation.defaultValue;\n  }\n\n  get atMax() {\n    return this.value === this.rangeMax;\n  }\n\n  get atMin() {\n    return this.value === this.rangeMin;\n  }\n\n  get atDefault() {\n    return this.value === this.articulation.defaultValue;\n  }\n\n  get inRange() {\n    return (this.rangeMin == null || this.value >= this.rangeMin) && (this.rangeMax == null || this.value <= this.rangeMax);\n  }\n\n}\n\nmodule.exports = ArticulationState;\n\n\n//# sourceURL=webpack://STK/./js/lib/articulations/ArticulationState.js?");

/***/ }),

/***/ "./js/lib/articulations/ArticulationsRenderHelper.js":
/*!***********************************************************!*\
  !*** ./js/lib/articulations/ArticulationsRenderHelper.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const md5 = __webpack_require__(/*! md5 */ \"../node_modules/md5/md5.js\");\nconst async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nconst Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nconst Articulation = __webpack_require__(/*! articulations/Articulation */ \"./js/lib/articulations/Articulation.js\");\nconst ArticulatedObject = __webpack_require__(/*! articulations/ArticulatedObject */ \"./js/lib/articulations/ArticulatedObject.js\");\nconst DisplayAxis = __webpack_require__(/*! articulations/DisplayAxis */ \"./js/lib/articulations/DisplayAxis.js\");\nconst DisplayRadar = __webpack_require__(/*! articulations/DisplayRadar */ \"./js/lib/articulations/DisplayRadar.js\");\nconst PartsLoader = __webpack_require__(/*! articulations/PartsLoader */ \"./js/lib/articulations/PartsLoader.js\");\nconst AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nconst Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nconst GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nconst SceneSetupHelper = __webpack_require__(/*! gfx/SceneSetupHelper */ \"./js/lib/gfx/SceneSetupHelper.js\");\nconst SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nclass ArticulationsRenderHelper {\n  constructor(params) {\n    this.__fs = params.fs || Constants.sys.fs;\n    this.assetManager = params.assetManager;\n    this.renderer = params.renderer;\n    this.showAxisRadar = params.showAxisRadar;\n    this.useDirectionalLights = params.useDirectionalLights;\n    this.useLights = params.useLights;\n    this.backgroundColor = params.backgroundColor;\n    this.minIterations = params.minIterations || 10;\n    this.maxIterations = params.maxIterations || 20;\n    this.defaultTilt = 30;\n    this.defaultAzimuth = -45;\n    //this.minRotation = Math.PI/180;\n    //this.maxRotation = 20*Math.PI/180;\n    //this.minTranslation = 0.005;\n\n    this.materials = {\n      'neutral': Object3DUtil.getSimpleFalseColorMaterial(0, params.neutralColor || '#a3a3a3'),\n      'highlight': Object3DUtil.getSimpleFalseColorMaterial(1, params.highlightColor || '#42bc67'),\n      'faded_highlight': Object3DUtil.getSimpleFalseColorMaterial(2,\n        Colors.lighten(Colors.toColor(params.highlightColor || '#42bc67'))),\n      'basepart_highlight': Object3DUtil.getSimpleFalseColorMaterial(5, params.basepart_highlight || '#9467bd'),\n    };\n    this.backgroundColor = params.backgroundColor;\n    this.staticColor = params.staticColor || 'neutral';  // Color for static unmoving parts\n    this.movingPartColor = params.movingPartColor || 'highlight';  // Color for moving parts\n    this.attachedMovingPartColor = params.attachedMovingPartColor || 'faded_highlight'; // Color for attached moving part (vs main moving part)\n    this.basePartColor = params.basePartColor || 'basepart_highlight'; // Color for basepart\n    if (this.staticColor !== 'original') {\n      this.staticPartMaterial = this.materials[this.staticColor] ||\n        Object3DUtil.getSimpleFalseColorMaterial(3, params.staticColor);\n    }\n    if (this.movingPartColor !== 'original') {\n      this.movingPartMaterial = this.materials[this.movingPartColor] ||\n        Object3DUtil.getSimpleFalseColorMaterial(4, params.movingPartColor);\n    }\n    if (this.attachedMovingPartColor !== 'original') {\n      this.attachedMovingPartMaterial = this.materials[this.attachedMovingPartColor] ||\n        Object3DUtil.getSimpleFalseColorMaterial(6, params.attachedMovingPartColor);\n    }\n\n    if (this.basePartColor !== 'original') {\n      this.basePartMaterial = this.materials[this.basePartColor] ||\n        Object3DUtil.getSimpleFalseColorMaterial(7, this.basePartColor);\n    }\n\n    this.staticPartOpacity = params.staticOpacity;\n    this.basePartOpacity = (params.baseOpacity != null)? params.baseOpacity : this.staticPartOpacity;\n  }\n\n  // Functions for rendering joints\n  renderJointsForId(modelId, joints, options, callback) {\n    const partsField = options.partsField || 'articulation-parts';\n    const partsLoader = new PartsLoader({ assetManager: this.assetManager });\n    partsLoader.lookupPartsInfo(modelId, partsField, (err, partsInfo) => {\n      if (err) {\n        console.error('Error locating ' + partsField + ' for ' + modelId, err);\n        callback(err);\n      } else {\n        partsLoader.loadPartsWithConnectivityGraph(modelId, partsInfo, { discardHierarchy: true }, (err, partData) => {\n          if (err) {\n            console.error(`Error loading parts fullId=${modelId}`, err);\n            callback(err);\n          } else {\n            // Setup the scene and render\n            const scope = this;\n            function render() {\n              scope.setupRenderJointsWithConnectivity(modelId, partData.connectivityGraph, joints, options, callback);\n            }\n\n            if (options.waitImagesLoaded) {\n              options.waitImagesLoaded(render);\n            } else {\n              render();\n            }\n          }\n        });\n      }\n    });\n  }\n\n  setupRenderJointsWithConnectivity(modelId, connectivityGraph, joints, options, callback) {\n    this.__setupRender(modelId, options,\n      (scene, objectNode, renderOpts, cb) =>\n        this.renderJointsWithConnectivity(scene, objectNode, connectivityGraph, joints, renderOpts, cb),\n      callback)\n  }\n\n  renderJointsWithConnectivity(scene, objectNode, connectivityGraph, joints, options, callback) {\n    const processed = [];\n    const processedByHash = {};\n    for (let index = 0; index < joints.length; index++) {\n      const joint = joints[index];\n      // Create a fake articulation\n      const pid = joint.movingPartId;\n      const baseId = joint.basePartId;\n      // Create fake articulation\n      const articulation = new Articulation({\n        pid: pid,\n        base: [baseId],\n        axis: [0,0,1]\n      });\n      const basename = options.basename + '-' + pid + '-' + baseId;\n      const hash = pid + '-' + baseId;\n      const filename = basename + '.png';\n      const fileExists = this.__fs && this.__fs.existsSync(filename);\n      let status = fileExists ? 'overwrite' : 'new';\n      if (options.skipExisting && fileExists) {\n        // Skip\n        status = 'exists';\n      } else if (processedByHash[hash]) {\n        // Already processed this one (skip)\n        status = 'repeat';\n      } else {\n        // Create articulated object and articulated state\n        const articulatedObject = new ArticulatedObject([articulation], connectivityGraph);\n        const articulationState = articulatedObject.articulationStates[0];\n\n        // Add to objectNode\n        objectNode.add(articulatedObject);\n        /** Apply part colorings */\n        this.applyPartColorings(articulatedObject, articulationState, true);\n\n        /** Render articulation animation file */\n        const opts = _.defaults({ basename: basename, transform: objectNode.matrixWorld }, options);\n        this.renderStatic(scene, articulatedObject, null, opts);\n        // Cleanup\n        objectNode.remove(articulatedObject);\n        connectivityGraph.discardPartHierarchy();\n      }\n\n      const info = {\n        index: index,\n        pid: pid,\n        filename: filename,\n        status: status\n      };\n      processed.push(info);\n      processedByHash[hash] = true;\n    }\n\n    callback(null, processed);\n  }\n\n  // Functions for rendering proposed articulations\n  renderProposedArticulationsForId(modelId, articulations, options, callback) {\n    const partsField = options.partsField || 'articulation-parts';\n    const partsLoader = new PartsLoader({ assetManager: this.assetManager });\n    partsLoader.lookupPartsInfo(modelId, partsField, (err, partsInfo) => {\n      if (err) {\n        console.error('Error locating ' + partsField + ' for ' + modelId, err);\n        callback(err);\n      } else {\n        partsLoader.loadPartsWithConnectivityGraph(modelId, partsInfo, { discardHierarchy: true }, (err, partData) => {\n          if (err) {\n            console.error(`Error loading parts fullId=${modelId}`, err);\n            callback(err);\n          } else {\n            // Setup the scene and render\n            const scope = this;\n            function render() {\n              scope.setupRenderProposedArticulationsWithConnectivity(modelId, partData.connectivityGraph, articulations, options, callback);\n            }\n\n            if (options.waitImagesLoaded) {\n              options.waitImagesLoaded(render);\n            } else {\n              render();\n            }\n          }\n        });\n      }\n    });\n  }\n\n  __setupRender(modelId, options, renderCallback, doneCallback) {\n    const cameraControls = options.cameraControls || SceneSetupHelper.createCameraControls(this.renderer, {\n      camera: options.camera, width: this.renderer.width, height: this.renderer.height\n    });\n    const scene = SceneSetupHelper.createScene(cameraControls.camera, {\n      backgroundColor: this.backgroundColor,\n      useLights: this.useLights,\n      useDirectionalLights: this.useDirectionalLights\n    });\n    const wrappedCallback = function (err, result) {\n      Object3DUtil.dispose(scene);\n      doneCallback(err, result);\n    };\n\n    const objectNode = new THREE.Group();\n    scene.add(objectNode);\n    const assetInfo = this.assetManager.getLoadModelInfo(null, modelId);\n    if (assetInfo != null) {\n      const front = AssetGroups.getDefaultFront(assetInfo);\n      const up = AssetGroups.getDefaultUp(assetInfo);\n      Object3DUtil.alignToUpFrontAxes(objectNode, up, front, Constants.worldUp, Constants.worldFront);\n    }\n    scene.updateMatrixWorld();\n\n    const logdata = options.logdata ? _.defaults({ fullId: modelId, toWorld: objectNode.matrixWorld.toArray() }, options.logdata) : null;\n    const renderOpts = _.merge(\n      _.pick(options, ['basename', 'framerate', 'tilt', 'skipExisting', 'skipVideo', 'combineAll', 'iterations', 'width', 'height']),\n      {\n        cameraControls: cameraControls,\n        logdata: logdata\n      }\n    );\n\n    renderCallback(scene, objectNode, renderOpts, wrappedCallback);\n  }\n\n  setupRenderProposedArticulationsWithConnectivity(modelId, connectivityGraph, articulations, options, callback) {\n    this.__setupRender(modelId, options,\n      (scene, objectNode, renderOpts, cb) =>\n        this.renderProposedArticulationsWithConnectivity(scene, objectNode, connectivityGraph, articulations, renderOpts, cb),\n      callback)\n  }\n\n  renderProposedArticulationsWithConnectivity(scene, objectNode, connectivityGraph, articulations, options, callback) {\n    const articulationHashInfos = [];\n    const hashInfosByHashId = {};\n    for (let index = 0; index < articulations.length; index++) {\n      const articulation = new Articulation(articulations[index]);\n      const articulationHash = md5(articulation.getHashString());\n      const pid = articulation.pid;\n\n      const basename = options.basename + '-' + pid + '-' + articulationHash;\n      const filename = basename + '.gif';\n      const fileExists = this.__fs && this.__fs.existsSync(filename);\n      let status = fileExists ? 'overwrite' : 'new';\n      if (options.skipExisting && fileExists) {\n        // Skip\n        status = 'exists';\n      } else if (hashInfosByHashId[articulationHash] && hashInfosByHashId[articulationHash].length) {\n        // Already processed this one (skip)\n        status = 'repeat';\n      } else {\n        // Create articulated object and articulated state\n        const articulatedObject = new ArticulatedObject([articulation], connectivityGraph);\n        const articulationState = articulatedObject.articulationStates[0];\n\n        // Add to objectNode\n        objectNode.add(articulatedObject);\n        /** Apply part colorings */\n        this.applyPartColorings(articulatedObject, articulationState, true);\n\n        /** Render articulation animation file */\n        const opts = _.defaults({ basename: basename, transform: objectNode.matrixWorld }, options);\n        this.renderArticulation(scene, articulatedObject, articulationState, opts);\n        // Cleanup\n        objectNode.remove(articulatedObject);\n        connectivityGraph.discardPartHierarchy();\n      }\n\n      const hashInfo = {\n        index: index,\n        pid: pid,\n        hash: articulationHash,\n        filename: filename,\n        status: status\n      };\n      articulationHashInfos.push(hashInfo);\n      hashInfosByHashId[articulationHash] = hashInfosByHashId[articulationHash] || [];\n      hashInfosByHashId[articulationHash].push(hashInfo);\n    }\n\n    // TODO: Should we support the combineAll feature here?\n    callback(null, articulationHashInfos);\n  }\n\n  // Functions for rendering final annotations with articulated object\n  renderArticulatedForId(fullId, metadata, options, callback) {\n    this.assetManager.getModelInstance(null, fullId,\n      (mInst) => {\n        if (!Constants.isBrowser) {\n          // Ensure is normal geometry (for some reason, BufferGeometry not working with ssc)\n          Object3DUtil.traverseMeshes(mInst.object3D, false, function (m) {\n            m.geometry = GeometryUtil.toGeometry(m.geometry);\n          });\n        }\n\n        const cameraControls = options.cameraControls || SceneSetupHelper.createCameraControls(this.renderer, {\n          camera: options.camera, width: this.renderer.width, height: this.renderer.height\n        });\n        const scene = SceneSetupHelper.createScene(cameraControls.camera, {\n          backgroundColor: this.backgroundColor,\n          useLights: this.useLights,\n          useDirectionalLights: this.useDirectionalLights\n        });\n        const wrappedCallback = function (err, result) {\n          Object3DUtil.dispose(scene);\n          callback(err, result);\n        };\n\n        const sceneState = new SceneState(null, mInst.model.info);\n        sceneState.addObject(mInst, this.assetManager.autoAlignModels);\n        scene.add(sceneState.fullScene);\n        const sceneBBox = Object3DUtil.getBoundingBox(mInst.object3D);\n        const bbdims = sceneBBox.dimensions();\n        console.log('Loaded ' + sceneState.getFullID() +\n          ' bbdims: [' + bbdims.x + ',' + bbdims.y + ',' + bbdims.z + ']');\n        const logdata = options.logdata ? _.defaults({ fullId: fullId, toWorld: mInst.getObject3D('Model').matrixWorld.toArray() }, options.logdata) : null;\n\n        const renderOpts = _.merge(\n          _.pick(options, ['basename', 'framerate', 'tilt', 'skipExisting', 'skipVideo', 'combineAll', 'iterations', 'width', 'height']),\n          {\n            cameraControls: cameraControls,\n            targetBBox: sceneBBox,\n            logdata: logdata\n          }\n        );\n\n        const scope = this;\n        function render() {\n          scope.renderArticulatedModelInstance(scene, mInst, renderOpts, wrappedCallback);\n        }\n\n        if (options.waitImagesLoaded) {\n          options.waitImagesLoaded(render);\n        } else {\n          render();\n        }\n      },\n      (error) => {\n        console.error('Error loading ' + fullId, error);\n        callback(error, null);\n      },\n      metadata);\n  }\n\n  renderArticulatedModelInstance(scene, mInst, options, callback) {\n    const articulatedObjects = mInst.getArticulatedObjects();\n    if (articulatedObjects.length) {\n      async.eachSeries(articulatedObjects, (artObj, cb) => {\n        const opts = (articulatedObjects.length === 1) ? options :\n          _.defaults({ basename: options.basename + '/1' }, options);\n        this.renderArticulatedObject(scene, artObj, opts, cb)\n      }, callback);\n    } else {\n      console.log(`No articulated objects for ${mInst.model.getFullID()}`);\n      callback();\n    }\n  }\n\n  renderArticulatedObject(scene, articulatedObject, options, callback) {\n    const articulationStates = articulatedObject.articulationStates;\n    const articulationStatesByPart = _.groupBy(articulationStates, 'pid');\n    for (let pid of Object.keys(articulationStatesByPart)) {\n      /** Render articulation animation files */\n      const opts = _.defaults({ basename: options.basename + '-' + pid }, options);\n      this.renderArticulations(scene, articulatedObject, articulationStatesByPart[pid], opts)\n    }\n    if (!options.skipVideo && options.combineAll) {\n      // TODO: be careful here - if there are other gifs that matches, lots of things will be combined\n      this.renderer.removeFile(options.basename + '.gif');\n      this.renderer.gifSeqToGif(options.basename + '*.gif', options.basename + '.gif');\n    }\n    const res = _.map(articulatedObject.articulations, art => {\n      const s = art.toJson();\n      s.hash = md5(art.getHashString());\n      return s;\n    });\n    // console.log(res);\n    callback(null, res);\n  }\n\n  renderArticulations(scene, articulatedObject, articulationStates, options) {\n    let index = 0;\n    for (let articulationState of articulationStates) {\n      /** Apply part colorings */\n      this.applyPartColorings(articulatedObject, articulationState, true);\n\n      /** Render articulation animation files */\n      // Handle multiple articulations per part by adding to basename\n      const opts = _.defaults({ basename: options.basename + '-' + index, transform: articulatedObject.matrixWorld }, options);\n      this.renderArticulation(scene, articulatedObject, articulationState, opts);\n      index++;\n    }\n  }\n\n  setBBoxView(bbox, opts) {\n    const cameraControls = opts.cameraControls;\n    const tilt = (opts.tilt != null) ? opts.tilt : this.defaultTilt;\n    const azimuth = (opts.azimuth != null) ? opts.azimuth : this.defaultAzimuth;\n    const theta = tilt / 180 * Math.PI;\n    const phi = azimuth / 180 * Math.PI;\n    const distanceScale = opts.distanceScale || 1.5;\n\n    cameraControls.viewTarget({\n      targetBBox: bbox, distanceScale: distanceScale,\n      phi: phi,\n      theta: theta\n    });\n  }\n\n  setArticulationView(scene, node, articulationState, opts) {\n    const targetBBox = opts.targetBBox;\n    const bbox = this.getBBoxWithArticulations(node, articulationState, opts);\n    if (targetBBox) {\n      bbox.includeBBox(targetBBox);\n    }\n    this.setBBoxView(bbox, opts);\n  }\n\n  setNodeView(scene, node, opts) {\n    const targetBBox = opts.targetBBox;\n    const bbox = new BBox();\n    bbox.includeObject3D(node);\n    if (targetBBox) {\n      bbox.includeBBox(targetBBox);\n    }\n    this.setBBoxView(bbox, opts);\n  }\n\n  getBBoxWithArticulations(node, articulationState, opts) {\n    const maxIterations = opts.iterations || this.minIterations;\n    if (_.isFinite(articulationState.rangeMin)) {\n      articulationState.setToMin();\n    } else {\n      articulationState.setToDefault();\n    }\n    const rangeAmount = _.isFinite(articulationState.rangeAmount) ? articulationState.rangeAmount : articulationState.defaultRangeAmount;\n    let delta = rangeAmount / (maxIterations - 1);\n    let iter = 0;\n    let done = false;\n    const bbox = new BBox();\n    while (!done && iter < maxIterations) {\n      articulationState.apply(delta);\n      bbox.includeObject3D(node);\n      iter++;\n      if (articulationState.atMax) {\n        done = true;\n      }\n    }\n\n    articulationState.setToDefault();\n    return bbox;\n  }\n\n  renderArticulation(scene, node, articulationState, opts) {\n    const basename = opts.basename;\n    console.time('render ' + basename);\n    this.renderArticulationFrames(scene, node, articulationState, opts,\n      (scene, camera, iter, renderOpts) => {\n        const pngfile = basename + '-' + _.padStart(iter.toString(), 4, '0') + '.png';\n        this.renderer.renderToPng(scene, camera, pngfile, renderOpts);\n      });\n\n    if (!opts.skipVideo) {\n      console.time('convert ' + basename);\n      this.renderer.pngSeqToGif(basename + '*.png', basename + '.gif', {\n        framerate: opts.framerate\n      });\n      console.timeEnd('convert ' + basename);\n    }\n    console.log('rendered ' + basename + '.gif');\n    console.timeEnd('render ' + basename);\n  }\n\n  renderArticulationFrames(scene, node, articulationState, opts, addFrame) {\n    const cameraControls = opts.cameraControls;\n    const maxIterations = opts.iterations || this.maxIterations;\n\n    this.setArticulationView(scene, node, articulationState, opts);\n\n    const renderOpts = _.clone(opts);\n    renderOpts.logdata = _.defaults({ cameraConfig: cameraControls.lastViewConfig }, opts.logdata || {});\n\n    if (_.isFinite(articulationState.rangeMin)) {\n      articulationState.setToMin();\n    } else {\n      articulationState.setToDefault();\n    }\n\n    let widgetsNode;\n    let onStateUpdated;\n    if (this.showAxisRadar) {\n      //console.log('showAxisRadar', opts.transform);\n      widgetsNode = new THREE.Group();\n      widgetsNode.applyMatrix(opts.transform);\n      const displayAxis = new DisplayAxis({ articulation: articulationState });\n      displayAxis.update(articulationState.articulation.isTranslation);  // show axis points\n      displayAxis.attach(widgetsNode);\n      if (articulationState.articulation.isTranslation) {\n        onStateUpdated = function() {\n          displayAxis.updateValue();\n        }\n      } else {\n        const displayRadar = new DisplayRadar({articulation: articulationState});\n        displayRadar.update();\n        displayRadar.attach(widgetsNode);\n        onStateUpdated = function() {\n          displayRadar.updateValue();\n        }\n      }\n      scene.add(widgetsNode);\n    }\n\n    // TODO: set delta appropriately\n    const rangeAmount = _.isFinite(articulationState.rangeAmount) ? articulationState.rangeAmount : articulationState.defaultRangeAmount;\n    let delta = 2 * rangeAmount / (maxIterations - 1);\n    let iter = 0;\n    let done = false;\n    while (!done && iter < maxIterations) {\n      const d = articulationState.apply(delta);\n      if (onStateUpdated) {\n        onStateUpdated(d);\n      }\n      addFrame(scene, cameraControls.camera, iter, renderOpts);\n      iter++;\n\n      // Check if we need to reverse\n      if (articulationState.atMax) {\n        delta = -delta;\n      }\n      if (articulationState.atMin) {\n        done = true;\n      }\n    }\n    articulationState.setToDefault();\n\n    if (widgetsNode) {\n      scene.remove(widgetsNode);\n      // TODO: Make sure to destroy the displayAxis and displayRadar so there is no memory leak\n    }\n  }\n\n  // Render static image\n  // If articulationState information is provided and showAxisRadar, then axisRadar will be rendered\n  renderStatic(scene, node, articulationState, opts) {\n    const basename = opts.basename;\n    const cameraControls = opts.cameraControls;\n\n    let widgetsNode;\n    if (articulationState && this.showAxisRadar) {\n      //console.log('showAxisRadar', opts.transform);\n      widgetsNode = new THREE.Group();\n      widgetsNode.applyMatrix(opts.transform);\n      const displayAxis = new DisplayAxis({ articulation: articulationState.articulation });\n      const displayRadar = new DisplayRadar({ articulation: articulationState.articulation });\n      displayAxis.update();\n      displayRadar.update();\n      displayAxis.attach(widgetsNode);\n      displayRadar.attach(widgetsNode);\n      scene.add(widgetsNode);\n    }\n\n    this.setNodeView(scene, node, opts);\n\n    const renderOpts = _.clone(opts);\n    renderOpts.logdata = _.defaults({ cameraConfig: cameraControls.lastViewConfig }, opts.logdata || {});\n\n    const pngfile = basename + '.png';\n    this.renderer.renderToPng(scene, cameraControls.camera, pngfile, renderOpts);\n\n    if (widgetsNode) {\n      scene.remove(widgetsNode);\n      // TODO: Make sure to destroy the displayAxis and displayRadar so there is no memory leak\n    }\n  }\n\n  applyPartColorings(articulatedObject, articulationState, resetFlag) {\n    if (resetFlag) {\n      this.resetObject3DColor(articulatedObject);\n    }\n    if (this.staticPartMaterial) {\n      this.setMaterial(articulatedObject, this.staticPartMaterial, this.staticPartOpacity);\n    }\n    if (this.staticColor !== this.attachedMovingPartColor) {\n      this.colorObject3D(articulationState.articulatedNode, this.attachedMovingPartColor, this.attachedMovingPartMaterial);\n    }\n    if (this.movingPartColor !== this.attachedMovingPartColor) {\n      this.colorObject3D(articulationState.part.object3D, this.movingPartColor, this.movingPartMaterial);\n    }\n    if (this.basePartColor !== this.staticColor) {\n      for (let baseId of articulationState.part.baseIds) {\n        const baseObject = articulatedObject.parts[baseId].object3D;\n        this.colorObject3D(baseObject, this.basePartColor, this.basePartMaterial, this.basePartOpacity);\n      }\n    }\n  }\n\n  applyMultiplePartColorings(articulatedObject, articulationState, resetFlag) {\n    if (resetFlag) {\n      this.resetObject3DColor(articulatedObject);\n    }\n    if (this.staticPartMaterial && resetFlag) {\n      this.setMaterial(articulatedObject, this.staticPartMaterial, this.staticPartOpacity);\n    }\n\n    if (this.staticColor !== this.attachedMovingPartColor) {\n      this.colorObject3D(articulationState.articulatedNode, this.attachedMovingPartColor, this.attachedMovingPartMaterial);\n    }\n    if (this.movingPartColor !== this.attachedMovingPartColor) {\n      this.colorObject3D(articulationState.part.object3D, this.movingPartColor, this.movingPartMaterial);\n    }\n  \n    if (this.basePartColor !== this.staticColor) {\n      for (let baseId of articulationState.part.baseIds) {\n        for (let baseId of articulationState.part.baseIds) {\n          const baseObject = articulatedObject.parts[baseId].object3D;\n          this.colorObject3D(baseObject, this.basePartColor, this.basePartMaterial, this.basePartOpacity);\n        }\n      }\n    }\n\n  }\n\n  colorObject3D(object3D, colorMode, material, opacity) {\n    if (colorMode === 'original') {\n      this.resetObject3DColor(object3D);\n    } else {\n      this.setMaterial(object3D, material, opacity);\n    }\n  }\n\n  resetObject3DColor(object3D) {\n    Object3DUtil.revertMaterials(object3D, true, true);\n  }\n\n  setMaterial(object3D, mat, opacity) {\n    Object3DUtil.setMaterial(object3D, mat, Object3DUtil.MaterialsAll, true);\n    if (opacity != null && opacity < 1) {\n      Object3DUtil.setOpacity(object3D, opacity);\n    }\n  }\n\n}\n\nmodule.exports = ArticulationsRenderHelper;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/ArticulationsRenderHelper.js?");

/***/ }),

/***/ "./js/lib/articulations/DisplayAxis.js":
/*!*********************************************!*\
  !*** ./js/lib/articulations/DisplayAxis.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MatrixUtil = __webpack_require__(/*! math/MatrixUtil */ \"./js/lib/math/MatrixUtil.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\nclass DisplayAxis {\n\t/**\n\t * @param params.articulation {{axis: THREE.Vector3, origin: THREE.Vector3, rangeMin: number, rangeMax: number, ref: THREE.Vector3, defaultValue: number, value: number}}\n\t * @param params.color {THREE.Color|number|string} Color for axis (default: black)\n\t * @param params.axisPointColor {THREE.Color|number|string} Color for min/max axis points (default: light red)\n\t * @param params.currentPointColor {THREE.Color|number|string} Color for current position (default: blue)\n\t * @param params.originPointColor {THREE.Color|number|string} Color for axis origin (default: red)\n\t * @param params.initialPointColor {THREE.Color|number|string} Color for initial position (default: yellow)\n\t */\n\tconstructor(params) {\n\t\tthis.articulation = params.articulation;\n\t\tthis.color = (params.color != null) ? params.color : 0x000000;\n\t\tthis.axisPointColor = (params.axisPointColor != null)? params.axisPointColor : 0x800080;\n\t\tthis.currentPointColor = (params.currentPointColor != null)? params.currentPointColor : 0x0000ff;\n\t\tthis.originPointColor = (params.originPointColor != null)? params.originPointColor : 0xff0000;\n\t\tthis.initialPointColor = (params.initialPointColor != null)? params.initialPointColor : 0xff0000;\n\n\t\tthis.node = new THREE.Group();\n\t\tthis.node.name = 'ArticulationAxis';\n\n\t\tthis.__posAxis = new THREE.Vector3(0,0,1);\n\t\tthis.__negAxis = new THREE.Vector3(0,0,-1);\n\t}\n\n\tupdate(displayPoints, length=1) {\n\t\tthis.clear();\n\n\t\tconst axisColor = this.color;\n\t\tthis.arrowHelper1 = new THREE.ArrowHelper(this.__posAxis, new THREE.Vector3(0,0,0), length, axisColor, 0.2);\n\t\t// this.arrowHelper2 = new THREE.ArrowHelper(this.__negAxis, new THREE.Vector3(0,0,0), length, axisColor, 0.2);\n\n\t\tObject3DUtil.setDepthTest(this.arrowHelper1, false);\n\t\t// Object3DUtil.setDepthTest(this.arrowHelper2, false);\n\n\t\tthis.node.add(this.arrowHelper1);\n\t\t// this.node.add(this.arrowHelper2);\n\n\t\t// NOTE: Assumes positive axis is Z\n\t\tconst m = MatrixUtil.getRotationMatrixFromZ(this.articulation.axis);\n\t\tthis.node.setRotationFromMatrix(m);\n\t\tthis.node.position.copy(this.articulation.origin);\n\n\t\tif (displayPoints) {\n\t\t\tthis.displayAxisPoints();\n\t\t}\n\t}\n\n\tupdateAxisPoint(delta) {\n\t\tthis.axisPoint.translateOnAxis(this.__posAxis, delta);\n\t}\n\n\tupdateValue() {\n\t\tthis.axisPoint.position.set(0,0,0);\n\t\tthis.axisPoint.translateOnAxis(this.__posAxis, this.articulation.value);\n\t}\n\n\tupdateRange(rangeMin, rangeMax) {\n\t\tif (rangeMin != undefined) {\n\t\t\tthis.articulation.rangeMin = rangeMin;\n\t\t}\n\t\tif (rangeMax != undefined) {\n\t\t\tthis.articulation.rangeMax = rangeMax;\n\t\t}\n\n\t\tthis.maxAxisPoint.position.set(0, 0, 0);\n\t\tthis.minAxisPoint.position.set(0, 0, 0);\n\n\t\tthis.maxAxisPoint.translateOnAxis(this.__posAxis, this.articulation.rangeMax);\n\t\tthis.minAxisPoint.translateOnAxis(this.__posAxis, this.articulation.rangeMin);\n\t}\n\n\tgetAxis(axis) {\n\t\t// Set articulation axis from the current node rotation\n\t\taxis = axis || new THREE.Vector3();\n\t\taxis.copy(this.__posAxis).applyQuaternion(this.node.quaternion);\n\t\treturn axis;\n\t}\n\n\t/**\n\t * Displays three points on axis of translation, each representing min translation\n\t * point, max translation point, and current translation point.\n\t */\n\tdisplayAxisPoints() {\n\t\tthis.clearPoints();\n\n\t\tconst geometry = new THREE.BoxGeometry(.07, .07, .07);\n\t\tconst geometry_current = new THREE.BoxGeometry(.03, .03, .03);\n\n\t\t// Material for min/max,  current value, origin\n\t\tconst material_minmax = new THREE.MeshBasicMaterial({ color: this.axisPointColor, transparent: true, opacity: 0.3, depthTest: false });\n\t\tconst material_current = new THREE.MeshBasicMaterial({ color: this.currentPointColor, depthTest: false });\n\t\tconst material_origin = new THREE.MeshBasicMaterial({ color: this.originPointColor, depthTest: false });\n\t\tconst material_initial = new THREE.MeshBasicMaterial({ color: this.initialPointColor, depthTest: false });\n\n\t\t// Create axis points\n\t\tthis.maxAxisPoint = new THREE.Mesh(geometry, material_minmax);\n\t\tthis.minAxisPoint = new THREE.Mesh(geometry, material_minmax);\n\t\tthis.originPoint = new THREE.Mesh(geometry_current, material_origin);\n\t\tthis.initialPoint = new THREE.Mesh(geometry_current, material_initial);\n\n\t\t// Object3DUtil.setOpacity(this.maxAxisPoint, 0.5);\n\t\t// Object3DUtil.setOpacity(this.minAxisPoint, 0.5);\n\n\t\tthis.maxAxisPoint.translateOnAxis(this.__posAxis, this.articulation.rangeMax);\n\t\tthis.minAxisPoint.translateOnAxis(this.__posAxis, this.articulation.rangeMin);\n\t\tthis.initialPoint.translateOnAxis(this.__posAxis, this.articulation.defaultValue);\n\t\t// this.originPoint.translateOnAxis(this.__posAxis, this.articulation.value);\n\n\t\tthis.node.add(this.initialPoint);\n\t\tthis.node.add(this.originPoint);\n\t\tthis.node.add(this.maxAxisPoint);\n\t\tthis.node.add(this.minAxisPoint);\n\n\t\tif (this.articulation.value != null) {\n\t\t\tthis.axisPoint = new THREE.Mesh(geometry_current, material_current);\n\t\t\tthis.axisPoint.translateOnAxis(this.__posAxis, this.articulation.value);\n\t\t\tthis.node.add(this.axisPoint);\n\t\t}\n\t}\n\n\t/**\n\t * Clear three axis points and axis if they exist.\n\t */\n\tclear() {\n\t\tthis.clearPoints();\n\n\t\tif (this.arrowHelper1) {\n\t\t\tthis.node.remove(this.arrowHelper1);\n\t\t\tthis.arrowHelper1 = null;\n\t\t}\n\n\t\t// if (this.arrowHelper2) {\n\t\t// \tthis.node.remove(this.arrowHelper2);\n\t\t// \tthis.arrowHelper2 = null;\n\t\t// }\n\t}\n\n\tclearPoints() {\n\t\tif (this.axisPoint) {\n\t\t\tthis.node.remove(this.axisPoint);\n\t\t\tthis.axisPoint = null;\n\t\t}\n\n\t\tif (this.maxAxisPoint) {\n\t\t\tthis.node.remove(this.maxAxisPoint);\n\t\t\tthis.maxAxisPoint = null;\n\t\t}\n\n\t\tif (this.minAxisPoint) {\n\t\t\tthis.node.remove(this.minAxisPoint);\n\t\t\tthis.minAxisPoint = null;\n\t\t}\n\t}\n\n\tattach(parent) {\n\t\tparent.add(this.node);\n\t}\n\n\tdetach() {\n\t\tif (this.node.parent != null) {\n\t\t\tthis.node.parent.remove(this.node);\n\t\t}\n\t}\n}\n\n// Exports\nmodule.exports = DisplayAxis;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/DisplayAxis.js?");

/***/ }),

/***/ "./js/lib/articulations/DisplayRadar.js":
/*!**********************************************!*\
  !*** ./js/lib/articulations/DisplayRadar.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const MatrixUtil = __webpack_require__(/*! math/MatrixUtil */ \"./js/lib/math/MatrixUtil.js\");\n\nclass DisplayRadar {\n\t/**\n\t * @param params.articulation {{axis: THREE.Vector3, origin: THREE.Vector3, rangeMin: number, rangeMax: number, ref: THREE.Vector3, defaultValue: number, value: number}}\n\t * @param params.color {THREE.Color|number|string} Color for radar (default: red)\n\t * @param params.currentLineColor {THREE.Color|number|string} Color for current pose (default: blue)\n\t * @param params.initialLineColor {THREE.Color|number|string} Color for initial pose (default: yellow)\n\t * @param params.refLineColor {THREE.Color|number|string} Color for ref axis (default: red)\n\t * @param params.radarOpacity {number} Opacity for radar\n\t */\n\tconstructor(params) {\n\t\tthis.articulation = params.articulation;\n\t\tthis.color = (params.color != null)? params.color : 0xff0000;\n\t\tthis.radarOpacity = params.radarOpacity || 0.35;\n\t\tthis.currentLineColor = (params.currentLineColor != null)? params.currentLineColor : 0x1f77b4;\n\t\tthis.refLineColor = (params.refLineColor != null)? params.refLineColor : 0xff0000;\n\t\tthis.initialLineColor = (params.initialLineColor != null)? params.initialLineColor : 0xff7f0e;\n\n\t\tthis.group = new THREE.Group();\n\t\tthis.group.name = 'ArticulationRotationRadarGroup';  // Radar node + reference line\n\t\tthis.node = new THREE.Group();\n\t\tthis.node.name = 'ArticulationRotationRadar';  // Radar node\n\n\t\tthis.__posAxis = new THREE.Vector3(0,0,1);\n\t\tthis.__radarAxis = new THREE.Vector3(1,0,0);\n\t}\n\n\tupdate() {\n\t\tthis.clear();\n\t\tconst radarLength = 0.10;\n\t\tconst lineLength = 0.15;\n\n\t\t// Add radar with range\n\t\t// Shows range of articulation (in xy plane, with 0 = x-axis)\n\t\tconst geometry = new THREE.CircleGeometry(radarLength, 256,\n\t\t\tthis.articulation.rangeMin, this.articulation.rangeMax - this.articulation.rangeMin);\n\n\t\tconst outerGeometry = new THREE.CircleGeometry(lineLength, 512);\n\t\touterGeometry.vertices.shift();\n\n\t\tconst radarLineGeometry = new THREE.Geometry();\n\t\tradarLineGeometry.vertices.push(\n\t\t\tnew THREE.Vector3(0, 0, 0),\n\t\t\tnew THREE.Vector3(1, 0, 0));\n\n\t\tconst radarMaterial = new THREE.MeshBasicMaterial({\n\t\t\tcolor: this.color,\n\t\t\tside: THREE.DoubleSide,\n\t\t\ttransparent: true,\n\t\t\topacity: this.radarOpacity,\n\t\t\tdepthTest: false,\n\t\t});\n\n\t\tconst radarLineMaterial = new THREE.LineBasicMaterial({\n\t\t\tcolor: this.color,\n\t\t\tdepthTest: false\n\t\t});\n\n\t\tconst circle = new THREE.Mesh(geometry, radarMaterial);\n\t\tconst outerCircle = new THREE.LineLoop(outerGeometry, radarLineMaterial);\n\t\tthis.node.add(circle);\n\t\tthis.node.add(outerCircle);\n\n\t\t// Add currentLine\n\t\tconst currentLine = new THREE.Line(radarLineGeometry, new THREE.LineBasicMaterial({\n\t\t\tcolor: this.currentLineColor, depthTest: false\n\t\t}));\n\t\tcurrentLine.name = 'CurrentLine';\n\t\tif (this.articulation.value != null) {\n\t\t\tcurrentLine.rotateOnWorldAxis(this.__posAxis, this.articulation.value);\n\t\t}\n\t\tcurrentLine.scale.multiplyScalar(lineLength);\n\t\tcurrentLine.renderOrder = 9;\n\t\tthis.node.add(currentLine);\n\n\t\t// Add initialLine\n\t\tconst initialLine = new THREE.Line(radarLineGeometry, new THREE.LineBasicMaterial({\n\t\t\tcolor: this.initialLineColor, depthTest: false\n\t\t}));\n\t\tinitialLine.scale.multiplyScalar(radarLength);\n\t\tinitialLine.name = 'InitialLine';\n\t\tinitialLine.rotateOnWorldAxis(this.__posAxis, this.articulation.defaultValue);\n\t\tinitialLine.renderOrder = 10;\n\t\tthis.node.add(initialLine);\n\n\t\tif (this.articulation.ref != null) {\n\t\t\tconst m = MatrixUtil.getAlignmentMatrix(this.__posAxis, this.__radarAxis, this.articulation.axis, this.articulation.ref);\n\t\t\tthis.node.setRotationFromMatrix(m);\n\n\t\t\t// Add ref line\n\t\t\tconst ref = this.articulation.ref.clone().multiplyScalar(lineLength);\n\t\t\tconst refLineGeometry = new THREE.Geometry();\n\t\t\trefLineGeometry.vertices.push(new THREE.Vector3(0, 0, 0), ref);\n\t\t\tconst refLine = new THREE.Line(refLineGeometry, new THREE.LineBasicMaterial({\n\t\t\t\tcolor: this.refLineColor, depthTest: true\n\t\t\t}));\n\t\t\trefLine.name = 'RefLine';\n\t\t\tthis.group.add(refLine);   // Add directly\n\t\t} else {\n\t\t\t// NOTE: Assumes positive axis is Z\n\t\t\tconst m = MatrixUtil.getRotationMatrixFromZ(this.articulation.axis);\n\t\t\tthis.node.setRotationFromMatrix(m);\n\t\t}\n\n\t\t// position group\n\t\tthis.group.position.copy(this.articulation.origin);\n\t\tthis.group.add(this.node);\n\n\t\t// Keep this so we can rotate it\n\t\tthis.currentLine = currentLine;\n\t}\n\n\trotate(delta) {\n\t\tthis.currentLine.rotateOnWorldAxis(this.__posAxis, delta);  // NOTE this is not really on worldAxis (just parent)\n\t}\n\n\tupdateValue() {\n\t\tthis.currentLine.rotation.set(0,0,0);\n\t\tthis.currentLine.rotateOnWorldAxis(this.__posAxis, this.articulation.value);\n\t}\n\n\tclear() {\n\t\twhile (this.group.children.length > 0) {\n\t\t\tthis.group.remove(this.group.children[0]);\n\t\t}\n\t\twhile (this.node.children.length > 0) {\n\t\t\tthis.node.remove(this.node.children[0]);\n\t\t}\n\t\tthis.currentLine = null;\n\t\tthis.refLine = null;\n\t}\n\n\tgetRefAxisFromMainAxis(out) {\n\t\t// Set articulation axis from the current node rotation\n\t\tout = out || new THREE.Vector3();\n\t\tout.copy(this.__radarAxis).applyQuaternion(this.node.quaternion);\n\t\treturn out;\n\t}\n\n\tattach(parent) {\n\t\tparent.add(this.group);\n\t}\n\n\tdetach() {\n\t\tif (this.group.parent != null) {\n\t\t\tthis.group.parent.remove(this.group);\n\t\t}\n\t}\n}\n\n// Exports\nmodule.exports = DisplayRadar;\n\n\n//# sourceURL=webpack://STK/./js/lib/articulations/DisplayRadar.js?");

/***/ }),

/***/ "./js/lib/articulations/IndexedMeshPartsLoader.js":
/*!********************************************************!*\
  !*** ./js/lib/articulations/IndexedMeshPartsLoader.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! loaders/OBJLoader */ \"./js/lib/loaders/OBJLoader.js\");\nconst Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nclass PartsLoader {\n\n  static loadPartMeshes(model_filename, parts_filename, callback) {\n    console.time('loadPartMeshes');\n    async.parallel([\n      function (cb) {\n        const loader = new THREE.OBJLoader();\n        loader.load(model_filename, (object) => cb(null, object), null, (err) => cb(err));\n      },\n      function (cb) {\n        _.getJSON(parts_filename, cb);\n      }\n    ], function (err, res) {\n      console.timeEnd('loadPartMeshes');\n      if (err) {\n        callback(err);\n      } else {\n        let object = res[0];\n        let partsJson = res[1];\n        let partsData = PartsLoader.parseParts(partsJson);\n        let partMeshes = PartsLoader.segmentObject(object, partsData.labels, partsData.indices, partsData.partNames, PartsLoader.MESH_OPACITY);\n        callback(null, { id: partsData.id, annId: partsData.annId, parts: partMeshes });\n      }\n    });\n  }\n\n  static loadPartsWithConnectivityGraph(partsFilesInfo, callback) {\n    // Load the precomputed connectivity graph and OBBs\n    const meshFilename = partsFilesInfo['mesh'];\n    const precomputedFilename = partsFilesInfo['connectivity_graph'];\n    const partsFilename = partsFilesInfo['parts'];\n    async.parallel([\n      (cb) => {\n        _.getJSON(precomputedFilename, cb);\n      },\n      (cb) => {\n        PartsLoader.loadPartMeshes(meshFilename, partsFilename, cb);\n      }\n    ], (err, res) => {\n      if (err) {\n        callback(err);\n      } else {\n        // Convert these into Part objects\n        const precomputedJson = res[0];\n        const partsData = res[1];\n        const graph = precomputedJson.connectivityGraph;\n        const parts = precomputedJson.parts.map(p => p? Part.fromJson(p):null);\n        const partMeshes = partsData.parts;\n        for (let i = 0; i < partMeshes.length; i++) {\n          const part = parts[i];\n          if (part) {\n            part.object3D = partMeshes[i];\n          }\n        }\n        callback(null, { annId: partsData.annId, parts: parts, connectivityGraph: graph});\n      }\n    });\n  }\n\n  static parseParts(json) {\n    const labels = json.segmentation[6].labels;\n    const indices = json.segmentation[6].index;\n\n    // Create map from labels -> PIDs (part IDs)\n    const partIndices = {};\n    for (let i = 0; i < labels.length; i++) {\n      const label = labels[i];\n\n      if (!partIndices[label]) {\n        partIndices[label] = [];\n      }\n\n      partIndices[label].push(i);\n    }\n\n    // Generate part \"names\" to be displayed in sidebar (i.e. \"wheel 1\", \"wheel 2\", etc.)\n    // Generate part \"types\" to be used to group annotation autocompleting\n    const partNames = [];\n    const partTypes = [];\n    Object.keys(partIndices).forEach(key => {\n      if (key !== 'unknown') {\n        let count = 1;\n        partIndices[key].forEach(pid => {\n          partNames[pid] = `${key} ${count}`;\n          partTypes[pid] = key;\n          count++;\n        });\n      }\n    });\n\n    return {\n      id: json.id,\n      annId: json.annId,\n      labels: labels,\n      indices: indices,\n      partIndices: partIndices,\n      partNames: partNames,\n      partTypes: partTypes\n    };\n  }\n\n  /**\n   * Segments object into parts and adds each part to scene.\n   *\n   * @param object {Object} Parsed object (in the geometric sense)\n   * @param labels {Array<String>} Part segmentation labels\n   * @param indices {Array<number>} Part segmentation indices\n   * @param partNames {Array<String>} PIDs -> part name (\"wheel 1\", \"wheel 2\", etc.)\n   * @returns {Array<THREE.Mesh>}\n   */\n  static segmentObject(object, labels, indices, partNames, opacity) {\n    console.time('segmentObject');\n    const color = new THREE.Color(0xaaaaaa);\n\n    // Map face index -> all triangles (indices) in face\n    const faces = PartsLoader.groupFaces(indices);\n    //const faces = _.groupByMulti(indices, x => x);\n\n    // Load entire object geometry\n    const objGeometry = new THREE.Geometry();\n    objGeometry.fromBufferGeometry(object.children[0].geometry);\n\n    // Create geometry from faces for each part\n    let parts = [];\n    for (let i = 1; i < faces.length; i++) {\n      const partVertices = new Float32Array(9 * faces[i].length);\n\n      for (let j = 0; j < faces[i].length; j++) {\n        const face = objGeometry.faces[faces[i][j]];\n\n        const a = face.a;\n        const b = face.b;\n        const c = face.c;\n\n        partVertices[9*j] = objGeometry.vertices[a].x;\n        partVertices[9*j + 1] = objGeometry.vertices[a].y;\n        partVertices[9*j + 2] = objGeometry.vertices[a].z;\n\n        partVertices[9*j + 3] = objGeometry.vertices[b].x;\n        partVertices[9*j + 4] = objGeometry.vertices[b].y;\n        partVertices[9*j + 5] = objGeometry.vertices[b].z;\n\n        partVertices[9*j + 6] = objGeometry.vertices[c].x;\n        partVertices[9*j + 7] = objGeometry.vertices[c].y;\n        partVertices[9*j + 8] = objGeometry.vertices[c].z;\n      }\n\n      // Convert buffer geometry to geometry for ease of pre-processing\n      const bufferGeometry = new THREE.BufferGeometry();\n      bufferGeometry.setAttribute('position', new THREE.BufferAttribute(partVertices, 3));\n      const geometry = new THREE.Geometry().fromBufferGeometry(bufferGeometry);\n\n      // Create part mesh\n      const mesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({\n        side: THREE.DoubleSide,\n        color: color,\n        transparent: true,\n        opacity: opacity,\n      }));\n\n      mesh.pid = i;\n      mesh.name = partNames[i];\n      mesh.userData.pid = i;\n      mesh.userData.name = partNames[i];\n      mesh.userData.label = labels[i];\n\n      parts[i] = mesh;\n    }\n    console.timeEnd('segmentObject');\n    return parts;\n  }\n\n  /**\n   * Maps each face (index) to triangle indices in face.\n   *\n   * @param indices {Array<number>} part segmentation indices\n   * @return {Array<number>}\n   */\n  static groupFaces(indices) {\n    const faces = [];\n    for (let i = 0; i < indices.length; i++) {\n      if (!faces[indices[i]]) {\n        faces[indices[i]] = [];\n      }\n\n      faces[indices[i]].push(i);\n    }\n\n    return faces;\n  }\n\n}\n\nPartsLoader.MESH_OPACITY = 0.5;\n\nmodule.exports = PartsLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/articulations/IndexedMeshPartsLoader.js?");

/***/ }),

/***/ "./js/lib/articulations/PartsLoader.js":
/*!*********************************************!*\
  !*** ./js/lib/articulations/PartsLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const PartConnectivityGraph = __webpack_require__(/*! parts/PartConnectivityGraph */ \"./js/lib/parts/PartConnectivityGraph.js\");\nconst IndexedMeshPartsLoader = __webpack_require__(/*! articulations/IndexedMeshPartsLoader */ \"./js/lib/articulations/IndexedMeshPartsLoader.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Provide functions for loading parts\n * @memberOf articulations\n */\nclass PartsLoader {\n  /**\n   * Creates a new PartsLoader\n   * @param params\n   * @param params.assetManager {assets.AssetManager}\n   */\n  constructor(params) {\n    this.assetManager = params.assetManager;\n  }\n\n  static loadIndexedPartMeshes(model_filename, parts_filename, callback) {\n    return IndexedMeshPartsLoader.loadPartMeshes(model_filename, parts_filename, callback);\n  }\n\n  /**\n   * Looks up part info\n   * @param fullId {string}\n   * @param partsField {string}\n   * @param callback {function(err, articulations.PartsLoader.LoadPartsInfo)}\n   */\n  lookupPartsInfo(fullId, partsField, callback) {\n    this.assetManager.lookupModelInfo(null, fullId, (modelInfo) => {\n      const partsInfo = (partsField != null) ? modelInfo[partsField] : null;\n      callback(null, partsInfo);\n    });\n  }\n\n  /**\n   * Load precomputed connectivity graph json by itself\n   * @param fullId\n   * @param options\n   * @param callback\n   */\n  loadPartConnectivityGraphJson(fullId, options, callback) {\n    const partsField = options? options.partsField : null;\n    this.assetManager.lookupModelInfo(null, fullId, (modelInfo) => {\n      const partsInfo = modelInfo[partsField];\n      const precomputedFilename = partsInfo['files']['connectivity_graph'];\n      _.getJSON(precomputedFilename, callback);\n    });\n  }\n\n  /**\n   * Load parts with connectivity graph\n   * @param fullId {string} Full model id\n   * @param partsInfo {articulations.PartsLoader.LoadPartsInfo}\n   * @param options {articulations.PartsLoader.LoadPartsOptions}\n   * @param callback {articulations.PartsLoader.partsLoadedCallback}\n   */\n  loadPartsWithConnectivityGraph(fullId, partsInfo, options, callback) {\n    // Load the precomputed connectivity graph and OBBs\n    if (!callback && options) {\n      if (typeof(options) === 'function') {\n        callback = options;\n        options = null;\n      } else if (typeof(options) === 'object') {\n        callback = options.callback;\n      }\n    }\n    this.loadPartMeshesForPartsInfo(fullId, partsInfo, options, (err, partsData) => {\n      if (err) {\n        callback(err);\n      } else {\n        if (!partsInfo['files']['connectivity_graph']) {\n          if (partsData.connectivityGraph) {\n            callback(null, {\n              annId: partsData.annId,\n              parts: partsData.connectivityGraph.parts,\n              connectivityGraph: partsData.connectivityGraph\n            });\n          } else {\n            callback('Cannot load connectivity graph for ' + fullId);\n          }\n        } else {\n          const precomputedFilename = partsInfo['files']['connectivity_graph'];\n          _.getJSON(precomputedFilename, function(err, precomputedJson) {\n            if (err) {\n              callback(err)\n            } else {\n              const graph = PartConnectivityGraph.fromJson(precomputedJson);\n              partsData.parts.forEach(m => {\n                graph.parts[m.userData.pid].object3D = m;\n              });\n              callback(null, {\n                annId: partsData.annId,\n                parts: graph.parts,\n                connectivityGraph: graph\n              })\n            }\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * Load part meshes\n   * @param fullId {string} Full model id\n   * @param partsInfo {articulations.PartsLoader.LoadPartsInfo}\n   * @param options {articulations.PartsLoader.LoadPartsOptions}\n   * @param callback {articulations.PartsLoader.partMeshesLoadedCallback}\n   */\n  loadPartMeshesForPartsInfo(fullId, partsInfo, options, callback) {\n    if (!callback && options) {\n      if (typeof(options) === 'function') {\n        callback = options;\n        options = null;\n      } else if (typeof(options) === 'object') {\n        callback = options.callback;\n      }\n    }\n    const discardHierarchy = options? options.discardHierarchy : false;\n    this.loadPartMeshesForPartsInfoSimple(fullId, partsInfo, (err, res) => {\n      if (discardHierarchy && res) {\n        // TODO: account for part transforms?\n        res.parts.forEach( p => {\n          p.children = p.children.filter(c => c.userData.pid == null);\n          p.parent = null;\n        });\n      }\n      callback(err, res);\n    });\n  }\n\n  /**\n   * Load part meshes\n   * @param fullId {string} Full model id\n   * @param partsInfo {articulations.PartsLoader.LoadPartsInfo}\n   * @param callback {articulations.PartsLoader.partMeshesLoadedCallback}\n   */\n  loadPartMeshesForPartsInfoSimple(fullId, partsInfo, callback) {\n    if (partsInfo && partsInfo.files.parts && partsInfo.files.mesh) {\n      //if (partsInfo.partType === 'indexedSegmentation') {\n      PartsLoader.loadIndexedPartMeshes(partsInfo.files.mesh, partsInfo.files.parts, callback);\n      //}\n    } else {\n      this.assetManager.loadModel({fullId: fullId}, function (err, modelInstance) {\n        if (err) {\n          callback(err);\n        } else {\n          const object3D = modelInstance.getObject3D('Model').children[0];\n          let partMeshes = null;\n          if (object3D.type === 'ArticulatedObject') {\n            console.log('Got ' + object3D.parts.length + ' parts from ArticulatedObject');\n            partMeshes = object3D.parts.map(p => p.object3D);\n          } else {\n            // Have parts be individual meshes\n            const meshes = Object3DUtil.getMeshList(object3D);\n            for (let mesh of meshes) {\n              const pid = mesh.userData.index;\n              mesh.userData.pid = pid;\n              mesh.userData.name = mesh.name;\n              delete mesh.userData.index;\n            }\n            partMeshes = meshes;\n          }\n          callback(null, { parts: partMeshes, connectivityGraph: object3D.connectivityGraph })\n        }\n      });\n    }\n  }\n\n  /**\n   * Load part meshes\n   * @param fullId {string} Full model id\n   * @param options {articulations.PartsLoader.LoadPartsOptions}\n   * @param callback {articulations.PartsLoader.partMeshesLoadedCallback}\n   */\n  loadPartMeshesById(fullId, options, callback) {\n    const partsField = options? options.partsField : null;\n    this.assetManager.lookupModelInfo(null, fullId, (modelInfo) => {\n      const partsInfo = (partsField != null) ? modelInfo[partsField] : null;\n      this.loadPartMeshesForPartsInfo(fullId, partsInfo, options, callback);\n    });\n  };\n}\n\n/**\n * Information about paths to use for loading parts.\n * @typedef articulations.PartsLoader.LoadPartsInfo\n * @type {object}\n * @property {Map<string,string>} files - Paths of files for parts <br>\n *      `parts` - Path of json file defining the part segmentation <br>\n *      `mesh`- Path of mesh <br>\n *      `connectivity_graph` - Path of precomputed connectivity graph\n * @property {string} label - Label that is stored internally\n */\n\n/**\n * Options about how to load parts.\n * @typedef articulations.PartsLoader.LoadPartsOptions\n * @type {object}\n * @property {string} partsField - Label that is stored internally\n * @property {boolean} discardHierarchy - Whether to discard loaded part hierarchy\n * @property {articulations.PartsLoader.partsLoadedCallback|articulations.PartsLoader.partMeshesLoadedCallback} [callback]\n */\n\n/**\n * Error first function callback for when parts are loaded\n * @callback articulations.PartsLoader.partsLoadedCallback\n * @param {string|*} error\n * @param {{annId: string, parts: parts.Part[], connectivityGraph: parts.PartConnectivityGraph}} [partData]\n */\n\n/**\n * Error first function callback for when part meshes are loaded\n * @callback articulations.PartsLoader.partMeshesLoadedCallback\n * @param {string|*} error\n * @param {{parts: THREE.Object3D[], connectivityGraph: parts.PartConnectivityGraph}} [partMeshData]\n */\n\nmodule.exports = PartsLoader;\n\n//# sourceURL=webpack://STK/./js/lib/articulations/PartsLoader.js?");

/***/ }),

/***/ "./js/lib/assets/AssetCache.js":
/*!*************************************!*\
  !*** ./js/lib/assets/AssetCache.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Basic cache for assets.\n * @param maxSize\n * @constructor\n * @memberOf assets\n */\nfunction AssetCache(maxSize) {\n  this.cache = {};\n  this.maxSize = maxSize;\n  this.debug = false;\n}\n\n// Consider allowing for timeout after x amount of time or using weakmap so unused entries can be garbage collected\nfunction CacheEntry(id, asset, aSize, dispose) {\n  this.id = id;\n  this.asset = asset;\n  this.aSize = aSize;\n  this.dispose = dispose;\n  this.timestamp = Date.now();\n}\n\nCacheEntry.prototype.update = function(asset, aSize, dispose) {\n  if (this.asset !== asset) {\n    if (this.dispose) {\n      this.dispose(this.asset);\n    }\n    this.asset = asset;\n    this.aSize = aSize;\n    this.dispose = dispose;\n  }\n  this.timestamp = Date.now();\n};\n\nAssetCache.prototype.get = function (id) {\n  if (this.cache.hasOwnProperty(id)) {\n    this.cache[id].timestamp = Date.now();  // touch entry\n    return this.cache[id].asset;\n  } else {\n    return null;\n  }\n};\n\nAssetCache.prototype.getOrElse = function (id, fetch, dispose) {\n  if (this.cache.hasOwnProperty(id)) {\n    this.cache[id].timestamp = Date.now();  // touch entry\n    return this.cache[id].asset;\n  } else {\n    var asset = fetch(id);\n    this.set(id, asset, null, dispose);\n    return asset;\n  }\n};\n\n// 'aSize' may be omitted, in which case it is assumed to be 1\n// (i.e. we aren't actually computing the sizes of assets and are\n// implicitly treating them as all the same size)\nAssetCache.prototype.set = function (id, asset, aSize, disposeCb) {\n  if (this.cache.hasOwnProperty(id)) {\n    this.cache[id].update(asset);\n    return;\n  }\n\n  aSize = aSize | 1;\n\n  // Evict, if necessary.\n  while (this.maxSize > 0 && this.computeSize() + aSize > this.maxSize) {\n    var lru = this.findLRU();\n    if (lru) {\n      this.__remove(lru.id);\n    }\n  }\n\n  this.cache[id] = new CacheEntry(id, asset, aSize, disposeCb);\n};\n\nAssetCache.prototype.__remove = function(id) {\n  var entry = this.cache[id];\n  if (this.debug) {\n    console.log('Removing cached asset: ' +  id + ', dispose=' + !!(entry && entry.dispose));\n  }\n  if (entry && entry.dispose) {\n    entry.dispose(entry.asset);\n  }\n  delete this.cache[id];\n};\n\nAssetCache.prototype.computeSize = function () {\n  var s = 0;\n  for (var id in this.cache) {\n    if (this.cache.hasOwnProperty(id)) {\n      s += this.cache[id].aSize;\n    }\n  }\n  return s;\n};\n\nAssetCache.prototype.findLRU = function () {\n  var lru = null;\n  var lrutime = Date.now();\n  for (var id in this.cache) {\n    if (this.cache.hasOwnProperty(id)) {\n      var entry = this.cache[id];\n      if (entry.timestamp < lrutime) {\n        lrutime = entry.timestamp;\n        lru = entry;\n      }\n    }\n  }\n  return lru;\n};\n\nAssetCache.prototype.clear = function (id) {\n  if (id != undefined) {\n    this.__remove(id);\n  } else {\n    for (var k in this.cache) {\n      if (this.cache.hasOwnProperty(k)) {\n        var entry = this.cache[k];\n        if (entry && entry.dispose) {\n          entry.dispose(entry.asset);\n        }\n      }\n    }\n    this.cache = {};\n  }\n};\n\n// Exports\nmodule.exports = AssetCache;\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetCache.js?");

/***/ }),

/***/ "./js/lib/assets/AssetGroup.js":
/*!*************************************!*\
  !*** ./js/lib/assets/AssetGroup.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * A AssetGroup represent a group of 3D assets\n * It should have the following attributes (these are what is interpreted and supported by the rest of the code):\n * <pre>\n *   name - The name of the AssetGroup (3dw, wss, etc)\n *   type - The type of asset found in the AssetGroup: model, scene, texture\n *   defaultFilter - Solr query indicate default filter to apply for this asset group (e.g. '+hasModel:true')\n *   defaultImageCount - number of images associated with the AssetGroup\n *   defaultImageIndex - which image to use as the default for the preview image\n *   defaultFront - vector indicating the default up direction (applies to model/scene)\n *   defaultUp - vector indicating the default front direction (applies to model/scene)\n *   defaultUnit - default unit this asset is modeled at (applies to model/scene)\n *   supportedFormats - Ordered array of supported formats (the first one will be the default format used)\n *   hasThumbnails - whether this AssetGroup has smaller thumbnail images\n *   texturePath - (for models only) separate path for which textures for the model are found (if not relative to model)\n *   lightSpecsFile - (for models only) path to file which specifies lights for each model id in this AssetGroup\n *   prefetchModelInfo\n *   roomFilesPath\n * </pre>\n *\n * In addition, a AssetGroup contains the following callback functions, each of which takes an id as the input parameter\n * <pre>\n *   getLoadInfo   - Returns information about how to load the asset with given id\n *     Optional parameters: format - format to load (an asset may come in multiple formats)\n *                          metadata - metadata about the asset\n *   getDefaultImageUrl - Returns the url of the default image\n *   getOriginalSourceUrl - Returns the url indicating where the asset originally came from\n *   getOriginalImageUrl - Returns the url of the original image that came with the asset\n *   getRotatingImageUrl - Returns the url of the rotating image for the asset\n *   getAllImageUrls - Returns all images associated with the asset with given id\n *   getImageUrl - Returns the image url\n *     Optional parameters: index - indicating the image requested\n *                          metadata - metadata about the asset (can include information to help determine if a image exist for an asset or not)\n *   getImagePreviewUrl - Returns the image preview url\n *     Optional parameters: index - indicating the image requested\n *                          metadata - metadata about the asset (can include information to help determine if a image exist for an asset or not)\n * </pre>\n * @param params\n * @memberOf assets\n * @constructor\n */\nfunction AssetGroup(params) {\n  // // interpolate params\n  if (params.__interpolateOptions) {\n    var defaultConstants = {'baseUrl': Constants.baseUrl, 'assetsDir': Constants.assetsDir};\n    var interpolatedParams = this.__createInterpolated(params, defaultConstants, params.__interpolateOptions);\n    params = _.defaults(interpolatedParams, params);\n  }\n\n  // TODO: Group images into sets of images with a type, index\n  var defaults = {\n    defaultImageCount: 1,\n    defaultImageIndex: -1\n  };\n\n  // Populate defaults\n  params.type = params.type || params.assetType;\n  var assetTypeInfo = Constants.assetTypes[params.type];\n  if (!this.assetTypeInfo) {\n    this.assetTypeInfo = assetTypeInfo;\n  }\n  if (this.assetTypeInfo && this.assetTypeInfo.defaults) {\n    _.extend(defaults, this.assetTypeInfo.defaults);\n  }\n\n  // Extend this with default values and then whatever is specified in params\n  // Anything specified in params will overwrite other values\n  _.extend(this, defaults, params);\n  this.__normalizeData();\n\n  // Set defaultFormat\n  if (this.defaultDataType != undefined && this.dataTypes) {\n    var dataTypeInfo = this.dataTypes[this.defaultDataType];\n    if (dataTypeInfo && !this.supportedFormats) {\n      this.supportedFormats = _.map(dataTypeInfo.data, 'name');\n    }\n  }\n\n  if (this.supportedFormats && this.defaultFormat == undefined) {\n    this.defaultFormat = this.supportedFormats[0];\n  }\n}\n\nAssetGroup.prototype.isFormatSupported = function(format) {\n  //console.log('Check assetGroup formats', format, this.supportedFormats);\n  return (this.supportedFormats && this.supportedFormats.indexOf(format) >= 0);\n};\n\nAssetGroup.prototype.setDefaultFormat = function(format) {\n  if (this.isFormatSupported(format)) {\n    this.defaultFormat = format;\n  } else {\n    if (this.defaultDataType != null) {\n      var f = this.defaultDataType + '-' + format;\n      if (this.isFormatSupported(f)) {\n        this.defaultFormat = f;\n        return;\n      }\n    }\n    console.log('Ignoring default format', format, ', supported formats ', this.supportedFormats);\n  }\n};\n\n// Takes the specified data and dataTypes and puts into normalized form\n// dataTypes: { type1: { data: [...], options ... } }\nAssetGroup.prototype.__normalizeData = function() {\n  if (!this.data && !this.dataTypes) return; // Nothing to do\n  // Parse data/dataTypes fields\n  if (this.dataTypes) {\n    // Make dataTypes consistent (Object with field data)\n    this.dataTypes = _.mapValues(this.dataTypes, function(v, k) {\n      if (Array.isArray(v)) {\n        return { data: v };\n      } else {\n        return v;\n      }\n    });\n  }\n  if (this.data) {\n    var dataByType = _.groupBy(this.data, 'dataType');\n    dataByType = _.mapValues(dataByType, function(v, k) {\n      return { data: v };\n    });\n    if (this.dataTypes) {\n      // merge dataByType into this.dataTypes\n      _.merge(this.dataTypes, dataByType);\n    } else {\n      this.dataTypes = dataByType;\n    }\n  }\n\n  // Handle variants\n  var interpolateOptions = this.__interpolateOptions;\n  _.each(this.dataTypes, function(dataTypeInfo, dataType) {\n    var hasVariants = _.filter(dataTypeInfo.data, function(d) { return d.variants; });\n    var noVariants = _.filter(dataTypeInfo.data, function(d) { return !d.variants; });\n    var variants = [];\n    _.each(hasVariants, function(d) {\n      var crossProd = _.product(_.pick(d.variants, d.variants.varying));\n      var omitKeys = d.variants.varying.concat(['varying']);\n      var defaults = _.defaults(_.omit(d.variants, omitKeys), _.omit(d, ['variants']));\n      for (var i = 0; i < crossProd.length; i++) {\n        var variant = crossProd[i];\n        variant = _.cloneDeepWithReplaceVars(_.defaults(variant, defaults), variant, { optionalPrefix: interpolateOptions.variable });\n        //variant = _.interpolate(_.defaults(variant, defaults), variant, interpolateOptions);\n        variant.variantOf = d.name;\n        variants.push(variant);\n      }\n    });\n    dataTypeInfo.data = noVariants.concat(variants);\n  });\n\n  // Create data\n  this.data = _.flatMap(this.dataTypes, 'data');\n  // Make sure each data element has a dataType and a name\n  _.each(this.dataTypes, function(dataTypeInfo, dataType) {\n    _.each(dataTypeInfo.data, function(d) {\n      d.dataType = dataType;\n      if (!_.has(d, 'name')) {\n        d.name = d.dataType + '-' + d.format;\n      }\n    });\n  });\n  // TODO: what if there are duplicate names?\n  this.dataByName = _.keyBy(this.data, 'name');\n  //console.log(this);\n};\n\nAssetGroup.prototype.getDataTypes = function() {\n  return this.dataTypes;\n};\n\nAssetGroup.prototype.__createInterpolated = function(params, vars, interpolateOptions) {\n  var ignoreFields = ['assetInfoType', 'assetFields', 'data', 'dataByName', 'dataTypes'];\n  var interpolated = _.pickBy(params, function(v,name) { return (ignoreFields.indexOf(name) < 0 && !name.startsWith('__')) && (_.isString(v) || _.isPlainObject(v)); });\n  interpolated = _.interpolate(interpolated, vars, interpolateOptions);\n  _.extend(interpolated, vars);\n  return interpolated;\n};\n\nAssetGroup.prototype.__getInterpolateContext = function() {\n  if (!this.__interpolateContext) {\n    var defaultConstants = {'baseUrl': Constants.baseUrl, 'assetsDir': Constants.assetsDir};\n    this.__interpolateContext = this.__createInterpolated(this, defaultConstants, this.__interpolateOptions);\n  }\n  return this.__interpolateContext;\n};\n\nAssetGroup.prototype.__getInterpolatedAssetInfo = function(obj, id, metadata) {\n  var vars = _.defaults(Object.create(null), {id: id}, metadata, this.__getInterpolateContext());\n  if (this.assetFields) {\n    var assetFields = _.interpolate(this.assetFields, vars, this.__interpolateOptions);\n    vars = _.extend(vars, assetFields);\n  }\n  return _.interpolate(obj, vars, this.__interpolateOptions);\n};\n\nAssetGroup.prototype.__getAssetFields = function(id, metadata) {\n  var vars = _.defaults(Object.create(null), {id: id}, metadata, this.__getInterpolateContext());\n  if (this.assetFields) {\n    var assetFields = _.interpolate(this.assetFields, vars, this.__interpolateOptions);\n    if (_.isString(assetFields.imageCount)) {\n      assetFields.imageCount = parseInt(assetFields.imageCount);\n    }\n    return assetFields;\n  }\n};\n\nAssetGroup.prototype.getDataInfo = function(id, metadata) {\n  if (this.dataTypes) {\n    //console.log('vars', vars);\n    var dataTypes = this.__getInterpolatedAssetInfo(this.dataTypes, id, metadata);\n    var data = _.flatMap(dataTypes, 'data');\n    _.each(data, function(loadInfo) {\n      // TODO: HACK!!! Make sure both path and file populated!!!\n      if (loadInfo.path == undefined && loadInfo.file != undefined) { loadInfo.path = loadInfo.file; }\n      if (loadInfo.file == undefined && loadInfo.path != undefined) { loadInfo.file = loadInfo.path; }\n    });\n    var dataByName = _.keyBy(data, 'name');\n    var dataInfo = {\n      dataTypes: dataTypes,   // Data grouped by dataType\n      data: data,             // List of all data\n      dataByName: dataByName  // Map of name to data\n    };\n    return dataInfo;\n  }\n};\n\nAssetGroup.prototype.__getInterpolatedField = function (id, metadata, path, field) {\n  var data = _.get(this, path);\n  if (data) {\n    var interpolated = this.__getInterpolatedAssetInfo(data, id, metadata);\n    if (interpolated && field != undefined) {\n      return interpolated[field];\n    } else {\n      return interpolated;\n    }\n  }\n};\n\nAssetGroup.prototype.__getBasicLoadInfo = function (id, dataName, metadata) {\n  var d = this.dataByName[dataName] || this.dataByName[this.defaultDataType + '-' + dataName];\n  if (d) {\n    var loadInfo = this.__getInterpolatedAssetInfo(d, id, metadata);\n    if (loadInfo.path == undefined && loadInfo.file != undefined) { loadInfo.path = loadInfo.file; }\n    if (loadInfo.file == undefined && loadInfo.path != undefined) { loadInfo.file = loadInfo.path; }\n    return loadInfo;\n  }\n};\n\nAssetGroup.prototype.__getBasicDataTypeInfo = function (id, dataType, metadata) {\n  var d = this.dataTypes[dataType];\n  if (d) {\n    var dataTypeInfo = this.__getInterpolatedAssetInfo(_.omit(d, 'data'), id, metadata);\n    return dataTypeInfo;\n  }\n};\n\nAssetGroup.prototype.getLoadInfo = function (id, dataName, metadata) {\n  if (dataName == undefined) {\n    // dataName is not specified - let's pick the default\n    dataName = this.defaultFormat;\n  }\n  var loadInfo = this.__getBasicLoadInfo(id, dataName, metadata);\n  // console.log('supportFormats', this.supportedFormats, dataName, this.defaultFormat);\n  if (loadInfo && loadInfo.isSupported === false && this.supportedFormats) {\n    var mainSupportedFormat = this.supportedFormats[0];\n    if (!this.isFormatSupported(dataName)) {\n      console.warn(dataName + ' not supported for ' + id + ', using ' + mainSupportedFormat + ' instead');\n      dataName = mainSupportedFormat;\n      loadInfo = this.__getBasicLoadInfo(id, dataName, metadata);\n    }\n  }\n  if (loadInfo) {\n    var assetFields = this.__getAssetFields(id, metadata);\n    var loadDataInfo = this.getDataInfo(id, _.defaults(loadInfo, assetFields, metadata || {}));\n\n    // TODO: CLEAN THIS CODE UP!!!!\n    // Merge default options into loadInfo\n    var dataTypeInfo = loadDataInfo.dataTypes[loadInfo.dataType];\n    loadInfo = _.clone(loadInfo);\n    var loadOptions = loadInfo.options || {};\n    if (metadata && metadata.options) {\n      _.merge(loadOptions, metadata.options);\n    }\n    loadInfo.options = _.defaults(loadOptions, dataTypeInfo.defaultOptions || {});\n    // Makes sure basic fields are populated\n    var source = this.source || this.name;\n    loadInfo.id = id;\n    loadInfo.source = source;\n    loadInfo.fullId = source + '.' + id;\n    loadInfo.options.source = source;\n\n    //console.log('loadInfo', loadInfo, dataName);\n\n    // HACK: Splat dataByName into loadInfo\n    _.defaults(loadInfo, loadDataInfo.dataByName);\n\n    // TODO: refactor other code (Segments/Voxels to use more orderly data structure)\n    loadInfo.dataInfo = loadDataInfo;\n    //console.log('loadInfo', loadInfo);\n    return loadInfo;\n  }\n};\n\nAssetGroup.prototype.getOriginalSourceUrl = function (id, metadata) {\n  var url = this.__getInterpolatedField(id, metadata, 'assetFields.originalSourceUrl');\n  return url;\n};\n\nAssetGroup.prototype.getImageCount = function(id, metadata) {\n  if (metadata && metadata.imageCount != null) {\n    return metadata.imageCount;\n  } else {\n    var assetFields = this.__getAssetFields(id, metadata);\n    return (assetFields && assetFields.imageCount != null)? assetFields.imageCount : this.defaultImageCount;\n  }\n};\n\nAssetGroup.prototype.getAllImageUrls = function (id, metadata) {\n  var imgs = [];\n  var nimgs = this.getImageCount(id, metadata);\n  for (var i = 0; i < nimgs; i++) {\n    var url = this.getImageUrl(id,i,metadata);\n    if (url) {\n      imgs.push(url);\n    }\n  }\n  if (this.getOriginalImageUrl) {\n    var url = this.getOriginalImageUrl(id);\n    if (url) {\n      imgs.push(url);\n    }\n  } else {\n    var imagePath = this.__getInterpolatedField(id, metadata, 'dataByName.originalImage.path');\n    if (imagePath) { imgs.push(imagePath); }\n  }\n  if (metadata) {\n    var moreImages = _.get(metadata, ['dataInfo', 'dataTypes', 'image', 'data']);\n    if (moreImages) {\n      imgs.push.apply(imgs, moreImages.map(function(x) { return x.path; }));\n    }\n  }\n\n  // Let's dedup too\n  imgs = _.uniq(imgs);\n  return imgs;\n};\n\nAssetGroup.prototype.getDefaultImageUrl = function (id) {\n  return Constants.screenShotDir + this.type + 's/' + this.name + '/' + id + '.png';\n};\n\nAssetGroup.prototype.loadLightSpecs = function (callback) {\n  var scope = this;\n  _.getJSON(this.lightSpecsFile)\n    .done(function (res) {\n      scope.lightSpecs = res;\n      if (callback) {\n        callback(null, res);\n      }\n    }).fail(function (err) {\n    if (callback) {\n      callback(err, null);\n    }\n  });\n};\n\nAssetGroup.prototype.getImageUrl = function (id, i, metadata) {\n  var index = (i !== undefined) ? i : this.defaultImageIndex;\n  var imgCount = this.getImageCount(id, metadata);\n  if (index !== undefined && index >= 0 && index < imgCount) {\n    var imagePath = this.__getInterpolatedField(id, _.defaults({index: i}, metadata), 'dataByName.screenshot.path');\n    return imagePath ? imagePath : Constants.screenShotDir + this.type + 's/' + this.name + '/' + id + '/' + id + '-' + index + '.png';\n  } else if (i === Constants.AssetGroup.ROTATING_IMAGE_INDEX) {\n    if (this.getRotatingImageUrl) {\n      return this.getRotatingImageUrl(id);\n    } else {\n      var imageInfo = this.__getInterpolatedField(id, metadata, 'dataByName.rotatingImage');\n      if (imageInfo && imageInfo.isSupported !== false) {\n        return imageInfo.path;\n      }\n    }\n  } else {\n    if (typeof index === 'string') {\n      var imagePath = this.__getInterpolatedField(id, metadata, 'dataByName.' + index + '.path');\n      if (imagePath) { return imagePath; }\n    }\n    if (this.getOriginalImageUrl) {\n      return this.getOriginalImageUrl(id);\n    } else {\n      var imagePath = this.__getInterpolatedField(id, metadata, 'dataByName.originalImage.path');\n      return imagePath? imagePath : this.getDefaultImageUrl(id);\n    }\n  }\n};\n\n// Default implementation just returns getImageUrl\nAssetGroup.prototype.getImagePreviewUrl = function (id, i, metadata) {\n  var url = this.getImageUrl(id, i, metadata);\n  if (url && Constants.enableThumbnail && this.hasThumbnails) {\n    // check that this is a regular image that we generated (and will therefore have thumbnail)\n    var regex = /.+-[0-9]+\\.png$/;\n    if (this.useThumbnails || regex.test(url) || (metadata && metadata.hasThumbnail)) {\n      url = url.substr(0, url.lastIndexOf('.')) + Constants.thumbnailPostfix;\n    }\n  }\n  return url;\n};\n\nAssetGroup.prototype.setAssetDb = function(assetDb) {\n  this.assetDb = assetDb;\n};\n\nAssetGroup.prototype.getAssetInfo = function(assetId) {\n  if (this.assetDb) {\n    var assetInfo = this.assetDb.getAssetInfo(assetId);\n    if (!assetInfo) {\n      return;\n    }\n    if (this.sounds && !assetInfo.sounds) {\n      assetInfo.sounds = this.sounds.getModelSounds(assetInfo);\n    }\n    if (this.dataTypes) {\n      var dataInfo = this.getDataInfo(assetInfo.id, assetInfo);\n      // TODO: Don't just merge in\n      _.defaults(assetInfo, dataInfo.dataByName);\n    }\n    return assetInfo;\n  } else {\n    // if (this.dataTypes) {\n    //   // TODO: Don't just merge in\n    //   var pos = assetId.indexOf('.');\n    //   var id = (pos > 0) ? assetId.substring(pos + 1) : assetId;\n    //   return this.getDataInfo(id).dataByName;\n    // }\n  }\n};\n\n// Exports\nmodule.exports = AssetGroup;\n\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetGroup.js?");

/***/ }),

/***/ "./js/lib/assets/AssetGroups.js":
/*!**************************************!*\
  !*** ./js/lib/assets/AssetGroups.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar AssetsDb = __webpack_require__(/*! assets/AssetsDb */ \"./js/lib/assets/AssetsDb.js\");\nvar AssetGroup = __webpack_require__(/*! assets/AssetGroup */ \"./js/lib/assets/AssetGroup.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\n\nvar AssetGroups = {\n  _assetGroups: {},\n  _assetGroupsByType: {},\n  _defaultGroupsRegistered: false\n};\n\n// Functions to get the different types of AssetGroups\nAssetGroups.getAssetGroups = function (type) {\n  if (!AssetGroups._defaultGroupsRegistered) {\n    // Make sure all asset groups are registered\n    _registerDefaultAssetGroups();\n  }\n  // Figure out what set of asset groups to return\n  if (type !== undefined) {\n    // Return all asset groups corresponding to the given type\n    return AssetGroups._assetGroupsByType[type];\n  } else {\n    // Return all asset groups\n    return AssetGroups._assetGroups;\n  }\n};\n\nAssetGroups.getAssetGroup = function (name) {\n  var groups = AssetGroups.getAssetGroups();\n  return groups[name];\n};\n\nAssetGroups.setDefaultFormat = function (format) {\n  var groups = AssetGroups.getAssetGroups();\n  AssetGroups.defaultFormat = format;\n  for (var name in groups) {\n    if (groups.hasOwnProperty(name)) {\n      var group = groups[name];\n      group.setDefaultFormat(format);\n    }\n  }\n};\n\n// Functions to get default up, front, unit\nfunction getAttributeFromInfo(info, attr, defaultValue) {\n  if (!info) return defaultValue;\n  if (info[attr]) {\n    return info[attr];\n  }\n  var source = info.source;\n  var assetGroup = AssetGroups.getAssetGroup(source);\n  if (assetGroup) {\n    return (assetGroup[attr] != undefined)? assetGroup[attr] : defaultValue;\n  } else {\n    return defaultValue;\n  }\n}\n\nAssetGroups.getDefaultUp = function (info, globalDefault) {\n  // TODO: what if scene?\n  var v = getAttributeFromInfo(info, 'defaultUp', globalDefault || new THREE.Vector3(0,1,0));\n  return Object3DUtil.toVector3(v);\n};\n\nAssetGroups.getDefaultFront = function (info, globalDefault) {\n  // TODO: what if scene?\n  var v = getAttributeFromInfo(info, 'defaultFront', globalDefault || new THREE.Vector3(0,0,1));\n  return Object3DUtil.toVector3(v);\n};\n\nAssetGroups.getDefaultUnit = function (info, globalDefault) {\n  // TODO: what if scene?\n  return getAttributeFromInfo(info, 'defaultUnit', globalDefault || Constants.defaultModelUnit);\n};\n\n// Functions to register AssetGroups\n\nAssetGroups.registerAssetGroup = function (assetGroup, opts) {\n  opts = opts || {};\n  if (opts.isDefault) {\n    assetGroup.isDefault = true;\n  }\n  if (AssetGroups._assetGroups[assetGroup.name]) {\n    if (assetGroup.isDefault && !AssetGroups._assetGroups[assetGroup.name].isDefault) {\n      console.log('Skipping registering of default asset group ' + assetGroup.name);\n      return;\n    }\n    // Remove old asset group\n    console.log('Replace asset group ' + assetGroup.name);\n    AssetGroups.unregisterAssetGroup(assetGroup.name);\n  }\n  AssetGroups._assetGroups[assetGroup.name] = assetGroup;\n  var type = assetGroup.type;\n  if (!AssetGroups._assetGroupsByType.hasOwnProperty(type)) {\n    AssetGroups._assetGroupsByType[type] = [];\n  }\n  AssetGroups._assetGroupsByType[type].push(assetGroup);\n  if (AssetGroups.defaultFormat) {\n    assetGroup.setDefaultFormat(AssetGroups.defaultFormat);\n  }\n\n  Constants.assetSources[type] = Constants.assetSources[type] || [];\n  _.addUnique(Constants.assetSources[type], assetGroup.name);\n};\n\nAssetGroups.unregisterAssetGroup = function (name) {\n  var assetGroup = AssetGroups._assetGroups[name];\n  if (assetGroup) {\n    delete AssetGroups._assetGroups[name];\n    var type = assetGroup.type;\n    if (AssetGroups._assetGroupsByType[type]) {\n      var index = AssetGroups._assetGroupsByType[type].indexOf(assetGroup);\n      if (index > -1) {\n        AssetGroups._assetGroupsByType[type].splice(index, 1);\n      }\n    }\n  }\n};\n\n\n// Helper functions for creating custom asset group\nAssetGroups.createCustomAssetGroup = function (options) {\n  if (options.data || options.dataTypes) {\n    return this.__parseAssetMetadataNew(options);\n  } else {\n    return this.__parseAssetMetadataOld(options);\n  }\n};\n\n// Parses new asset metadata format\nAssetGroups.__parseAssetMetadataNew = function(options) {\n  if (!Constants.isBrowser && options.rootPathLocal) {\n    options.rootPath = options.rootPathLocal;\n  }\n  // HACK!!!! Make sure undefined vars are not replaced\n  var defaultVars = _.createDefaultVars(options, 'vars.');\n  // HACK!!!! Make sure ${xyz} becomes ${vars.xyz} for future interpolation\n  options =  _.cloneDeepWith(options, function (x) {\n    if (_.isString(x)) { return _.appendVarPrefix(x, 'vars'); }\n  });\n  options.__interpolateOptions = { 'variable': 'vars',  'defaults': defaultVars,\n    isPossibleTemplate: function(str) {\n      // Lazy check for if a string is a template value\n      return _.includes(str, '$') || _.includes(str, '<%');\n    },\n    inferType: true\n  };\n\n  var assetGroup = new AssetGroup(options);\n  //console.log(assetGroup.__interpolateOptions);\n  return assetGroup;\n};\n\n// Parses old asset metadata format\nAssetGroups.__parseAssetMetadataOld = function (options) {\n  if (!Constants.isBrowser && options.rootPathLocal) {\n    if (!Constants.baseUrl.startsWith('http')) {\n      options.rootPath = options.rootPathLocal;\n    }\n  }\n  var formats = {};\n  var supportedFormats = [];\n  if (options.formats) {\n    for (var i = 0; i < options.formats.length; i++) {\n      var f = options.formats[i];\n      formats[f.name || f.format] = f;\n      supportedFormats.push(f.name || f.format);\n    }\n  }\n\n  var defaultConstants = {'baseUrl': Constants.baseUrl, 'assetsDir': Constants.assetsDir};\n  // TODO: Move custom fields into their asset files\n  var validAssetFields = ['texturePath', 'surfaces', 'prefetchModelInfo',\n    'regions', 'video', 'trajectory', 'voxelsField',\n    'voxels-surface', 'voxels-solid', 'voxels-labeled', 'voxels-color',\n    \"part-annotations\",\n    'segment-annotations-raw', 'segment-annotations-clean'];\n  if (options.assetFields) {\n    validAssetFields = validAssetFields.concat(options.assetFields);\n  }\n\n  function _getLoadAssetInfo(id, format, metadata) {\n    metadata = metadata || {};\n    if (format === undefined) { format = metadata.format || metadata.defaultFormat; }\n    if (format === undefined && this) { format = this.defaultFormat; }\n    var source = options.source;\n    var assetInfo = {\n      id: id,\n      source: source,\n      fullId: source + '.' + id,\n      options: {\n        source: source\n      }\n    };\n    var vars = _.merge(new Object(null), options, metadata, defaultConstants, _.omit(assetInfo, 'options'));\n    if (vars.baseVariantId == null || vars.baseVariantId === '')  { vars.baseVariantId = id; }\n    var m = formats[format];\n    //console.log(format);\n    //console.log(m);\n    if (m) {\n      m = _.cloneDeepWithReplaceVars(m, vars);\n      _.merge(assetInfo, m);\n      assetInfo['format'] = assetInfo['format'] || format;\n      assetInfo['file'] = assetInfo['file'] || m['path'];\n    }\n    var validFields = validAssetFields;\n    for (var i = 0; i < validFields.length; i++) {\n      var field = validFields[i];\n      var value = assetInfo[field] || options[field];\n      if (value) {\n        assetInfo[field] = _.cloneDeepWithReplaceVars(value, vars);\n      }\n    }\n\n    if (options.defaultMaterialType !== undefined) {\n      var defaultMaterialType = options.defaultMaterialType;\n      if (typeof defaultMaterialType === 'string') {\n        var meshMaterialsByName = {\n          'depth': THREE.MeshDepthMaterial,\n          'normal': THREE.MeshNormalMaterial,\n          'basic': THREE.MeshBasicMaterial,\n          'lambert': THREE.MeshLambertMaterial,\n          'phong': THREE.MeshPhongMaterial,\n          'standard': THREE.MeshStandardMaterial,\n          'physical': THREE.MeshPhysicalMaterial,\n          'toon': THREE.MeshToonMaterial\n        };\n\n        assetInfo.defaultMaterialType = meshMaterialsByName[defaultMaterialType];\n        if (!assetInfo.defaultMaterialType) {\n          console.warn(\"Unknown material type: \" + defaultMaterialType);\n        }\n      } else {\n        assetInfo.defaultMaterialType = defaultMaterialType;\n      }\n    }\n    if (assetInfo.options && assetInfo.options.defaultMaterial !== undefined) {\n      if (typeof assetInfo.options.defaultMaterial === \"boolean\") {\n        assetInfo.options.defaultMaterial = Object3DUtil.getSimpleFalseColorMaterial(0);\n      } else {\n        // TODO: parse material\n        console.warn('Need to parse defaultMaterial!');\n      }\n    }\n    return assetInfo;\n  }\n\n  var varsBasic = _.merge(new Object(null), options, defaultConstants );\n  var screenShotPaths = options.screenShotPaths;\n  var screenShotPathsByName = screenShotPaths? _.keyBy(screenShotPaths, 'name') : null;\n  var assetGroupOptions = {\n    name: options.source,\n    type: options.assetType,\n    supportedFormats: supportedFormats,\n    getImageUrl: function (id, i, metadata) {\n      metadata = metadata || {};\n      var screenShotPath = (screenShotPaths)? screenShotPaths[i] || screenShotPathsByName[i] : null;\n      var index = (i !== undefined && (screenShotPath || i >= 0)) ? i : options.defaultImageIndex;\n      //console.log('getImageUrl', id, i, index, options, metadata);\n      if (index == undefined && this.getOriginalImageUrl) {\n        return this.getOriginalImageUrl(id, metadata);\n      } else {\n        var vars = _.merge(new Object(null), varsBasic, metadata, {'id': id, 'index': index});\n        if (vars.baseVariantId == null || vars.baseVariantId === '') {\n          vars.baseVariantId = id;\n        }\n        if (screenShotPath) {\n          var path = screenShotPath;\n          if (typeof path !== 'string') { path = path.path; }\n          return _.replaceVars(path, vars);\n        }\n        return _.replaceVars(options['screenShotPath'], vars);\n      }\n    },\n    texturePath: _.replaceVars(options['texturePath'], varsBasic),\n    lightSpecsFile: _.replaceVars(options['lightSpecsFile'], varsBasic),\n    roomFilesPath: _.replaceVars(options['roomFilesPath'], varsBasic),\n    getLoadInfo: _getLoadAssetInfo,\n    getImageCount: function(id, metadata) {\n      if (metadata && metadata.imageCount != null) {\n        return metadata.imageCount;\n      } else if (screenShotPaths && screenShotPaths.length) {\n        return screenShotPaths.length;\n      } else {\n        return this.defaultImageCount;\n      }\n    }\n  };\n  if (options['originalScreenShotPath']) {\n    assetGroupOptions.getOriginalImageUrl = function (id, metadata) {\n      metadata = metadata || {};\n      var vars = _.merge(new Object(null), varsBasic, metadata, { 'id': id });\n      if (vars.baseVariantId == null || vars.baseVariantId === '')  { vars.baseVariantId = id; }\n      return _.replaceVars(options['originalScreenShotPath'], vars);\n    };\n  }\n  var opts = _.cloneDeepWithReplaceVars(options, varsBasic);\n  assetGroupOptions = _.merge(new Object(null), opts, assetGroupOptions);\n  var assetGroup = new AssetGroup( assetGroupOptions );\n  return assetGroup;\n};\n\n// Helper functions for creating various asset groups\n// Here after all asset groups defined\n\nvar _defaultAssets = Constants.assets;\n\nfunction expandLists(object, sourceList, expandFn) {\n  return _.cloneDeepWith(object, function(v) {\n    if (_.isPlainObject(v)) {\n      if (v['$list']) {\n        var element = v['$list'];\n        return _.map(sourceList, function(x) { return expandFn(element, x); });\n      }\n    }\n  });\n}\n\nfunction createAssetDbForAssetGroup(ag, config) {\n  config = config || {};\n  var groupDataFn = null;\n  var convertDataFn = null;\n  var lazyConvertDataFn = null;\n  var idField = ag.assetIdField || _.get(config, 'metadata.assetIdField') || config.assetIdField || 'id';\n  var groupBy = ag.groupBy || _.get(config, 'metadata.groupBy');\n  if (groupBy) {\n    groupDataFn = function(assetInfos) {\n      var infoFields = [groupBy.fieldName].concat(groupBy.infoFields || []);\n      return _.values(_.groupBy(assetInfos, groupBy.fieldName)).map(function(records) {\n        var info = _.pick(records[0], infoFields);\n        info.id = info[idField];\n        info.records = records;\n        return info;\n      });\n    };\n    lazyConvertDataFn = function(info) {\n      if (groupBy.data && !info.data) {\n        info.data = expandLists(ag.__getInterpolatedAssetInfo(groupBy.data, info[idField], info), info.records,\n          function(rec,vars) { return ag.__getInterpolatedAssetInfo(rec, info[idField], vars) });\n      }\n      return info;\n    }\n  }\n  return new AssetsDb({ assetIdField: idField, groupDataFn: groupDataFn,\n    convertDataFn: convertDataFn, lazyConvertDataFn: lazyConvertDataFn });\n}\nAssetGroups.createAssetDbForAssetGroup = createAssetDbForAssetGroup;\n\n\nfunction _registerDefaultAssetGroups() {\n\n  for (var i = 0; i < _defaultAssets.length; i++) {\n    var asset = _defaultAssets[i];\n    if (typeof asset.metadata === 'string') {\n      // TODO: pull metadata\n      // console.log('skipping asset: ' + asset.name);\n    } else {\n      var ag = AssetGroups.createCustomAssetGroup(asset.metadata);\n      //console.log('register asset: ' + asset.name, ag, asset.metadata);\n      if (ag.lightSpecsFile) {\n        ag.loadLightSpecs(function (err, res) {\n          console.log('Loaded LightSpecs for ' + _.keys(res).length + ' models');\n        });\n      }\n      AssetGroups.registerAssetGroup(ag, { isDefault: true });\n      var idsFile = ag.idsFile || asset.metadata.idsFile || asset.idsFile;\n      if (idsFile) {\n        var assetsDb = createAssetDbForAssetGroup(ag, asset);\n        ag.setAssetDb(assetsDb);\n        assetsDb.loadAssetInfo(ag, idsFile, function(err, assets) {\n          if (err) {\n            console.error('Error loading ids for ' + ag.name, err);\n          }\n        });\n      }\n    }\n  }\n\n  _.each(AssetGroups._assetGroupsByType, function(groups, type) {\n    for (var i = 0; i < groups.length; i++) {\n      Constants.assetSources[type] = Constants.assetSources[type] || [];\n      _.addUnique(Constants.assetSources[type], groups[i].name);\n    }\n  });\n  AssetGroups._defaultGroupsRegistered = true;\n}\n\nAssetGroups.registerDefaults = _registerDefaultAssetGroups;\n\nfunction getAssetsToRegister(assetsMap, assetGroupNames) {\n  var assetsToRegister = [];\n  for (var i = 0; i < assetGroupNames.length; i++) {\n    var name = assetGroupNames[i];\n    var info = assetsMap[name];\n    if (info) {\n      var requires = info.requires;\n      if (requires) {\n        //assetsToRegister = assetsToRegister.concat(requires);\n        for (var j = 0; j < requires.length; j++) {\n          if (assetGroupNames.indexOf(requires[j]) < 0) {\n            assetGroupNames.push(requires[j]);\n          }\n        }\n      }\n      if (info.metadata) {\n        assetsToRegister.push(name);\n      }\n    } else {\n      console.warn('Cannot register unknown asset ' + name);\n    }\n  }\n  assetsToRegister = _.uniq(assetsToRegister);\n  return assetsToRegister;\n}\nAssetGroups.getAssetsToRegister = getAssetsToRegister;\n\n\nmodule.exports = AssetGroups;\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetGroups.js?");

/***/ }),

/***/ "./js/lib/assets/AssetLoader.js":
/*!**************************************!*\
  !*** ./js/lib/assets/AssetLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\n\nfunction AssetLoader(params) {\n  FileLoader.call(this, params);\n}\n\nAssetLoader.prototype = Object.create(FileLoader.prototype);\nAssetLoader.prototype.constructor = AssetLoader;\n\nmodule.exports = AssetLoader;\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetLoader.js?");

/***/ }),

/***/ "./js/lib/assets/AssetLoaders.js":
/*!***************************************!*\
  !*** ./js/lib/assets/AssetLoaders.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AssetLoaders = {};\n\nAssetLoaders.registerDefaultLoaders = function(assetManager) {\n  // TODO: Update all loaders to error first callback with additional options on how the asset is to be loaded\n  assetManager.registerAssetLoader('scene', 'sceneState', __webpack_require__(/*! scene/SceneStateLoader */ \"./js/lib/scene/SceneStateLoader.js\"));\n  assetManager.registerAssetLoader('scene', 'wss', __webpack_require__(/*! scene/WssSceneLoader */ \"./js/lib/scene/WssSceneLoader.js\"));\n  assetManager.registerAssetLoader('scene', 'ssj', __webpack_require__(/*! scene/WssSceneLoader */ \"./js/lib/scene/WssSceneLoader.js\"));\n  assetManager.registerAssetLoader('scene', '*', __webpack_require__(/*! scene/SceneLoader */ \"./js/lib/scene/SceneLoader.js\"));\n\n  // TODO: Move some of this out of the main STK\n  assetManager.registerAssetLoader('scene', 'p5d', __webpack_require__(/*! scene/Planner5dLoader */ \"./js/lib/scene/Planner5dLoader.js\"));\n  assetManager.registerAssetLoader('scene', 'suncg', __webpack_require__(/*! scene/SUNCGLoader */ \"./js/lib/scene/SUNCGLoader.js\"));\n\n  // TODO: Have assetManager use these fancy loaders!\n  assetManager.registerAssetLoader('mesh', 'ply', __webpack_require__(/*! loaders/PLYLoader */ \"./js/lib/loaders/PLYLoader.js\"));\n  assetManager.registerAssetLoader('mesh', 'obj', __webpack_require__(/*! loaders/OBJLoader */ \"./js/lib/loaders/OBJLoader.js\"));\n  assetManager.registerAssetLoader('mesh', 'objmtl', __webpack_require__(/*! loaders/OBJMTLLoader */ \"./js/lib/loaders/OBJMTLLoader.js\"));\n  assetManager.registerAssetLoader('mesh', 'utf8', __webpack_require__(/*! loaders/UTF8Loader */ \"./js/lib/loaders/UTF8Loader.js\"));\n  //assetManager.registerAssetLoader('mesh', 'kmz', require('loaders/KMZLoader'));\n  assetManager.registerAssetLoader('mesh', 'dae', __webpack_require__(/*! loaders/ColladaLoader */ \"./js/lib/loaders/ColladaLoader.js\"));\n\n  assetManager.registerAssetLoader('materials', 'mtl', __webpack_require__(/*! loaders/MTLLoaderWrapper */ \"./js/lib/loaders/MTLLoaderWrapper.js\"));\n\n  // The following loaders already use error first callback style\n  assetManager.registerAssetLoader('alignmentMatrix', 'aln', __webpack_require__(/*! loaders/ALNLoader */ \"./js/lib/loaders/ALNLoader.js\"));\n  assetManager.registerAssetLoader('wall', 'wall', __webpack_require__(/*! loaders/WallLoader */ \"./js/lib/loaders/WallLoader.js\"));\n  assetManager.registerAssetLoader('voxel', '*', __webpack_require__(/*! loaders/VoxelLoader */ \"./js/lib/loaders/VoxelLoader.js\"));\n  assetManager.registerAssetLoader('navmesh', 'navmesh', __webpack_require__(/*! loaders/NavMeshLoader */ \"./js/lib/loaders/NavMeshLoader.js\"));\n  assetManager.registerAssetLoader('house', 'house', __webpack_require__(/*! loaders/HouseTxtLoader */ \"./js/lib/loaders/HouseTxtLoader.js\"));\n  assetManager.registerAssetLoader('labelMapping', '*', __webpack_require__(/*! util/LabelMapping */ \"./js/lib/util/LabelMapping.js\").Loader);\n  assetManager.registerAssetLoader('parts', 'obj', __webpack_require__(/*! loaders/OBJPartLoader */ \"./js/lib/loaders/OBJPartLoader.js\"));\n  assetManager.registerAssetLoader('custom', '*', __webpack_require__(/*! loaders/BasicLoader */ \"./js/lib/loaders/BasicLoader.js\"));\n};\n\nmodule.exports = AssetLoaders;\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetLoaders.js?");

/***/ }),

/***/ "./js/lib/assets/AssetManager.js":
/*!***************************************!*\
  !*** ./js/lib/assets/AssetManager.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Sounds = __webpack_require__(/*! audio/Sounds */ \"./js/lib/audio/Sounds.js\");\nvar Model = __webpack_require__(/*! model/Model */ \"./js/lib/model/Model.js\");\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar P5DTextureLoader = __webpack_require__(/*! loaders/P5DTextureLoader */ \"./js/lib/loaders/P5DTextureLoader.js\");\nvar LightsLoader = __webpack_require__(/*! assets/LightsLoader */ \"./js/lib/assets/LightsLoader.js\");\nvar Object3DLoader = __webpack_require__(/*! loaders/Object3DLoader */ \"./js/lib/loaders/Object3DLoader.js\");\nvar AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar AssetLoaders = __webpack_require__(/*! assets/AssetLoaders */ \"./js/lib/assets/AssetLoaders.js\");\nvar CachedAssetLoader = __webpack_require__(/*! assets/CachedAssetLoader */ \"./js/lib/assets/CachedAssetLoader.js\");\nvar AssetCache = __webpack_require__(/*! assets/AssetCache */ \"./js/lib/assets/AssetCache.js\");\nvar AssetLoader = __webpack_require__(/*! assets/AssetLoader */ \"./js/lib/assets/AssetLoader.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\nvar TaskQueue = __webpack_require__(/*! util/TaskQueue */ \"./js/lib/util/TaskQueue.js\");\nvar PubSub = __webpack_require__(/*! PubSub */ \"./js/lib/PubSub.js\");\nvar async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// TODO: Cache model, geometries, materials, textures\n// TODO: Simplify convoluted model loading code\n// Loaders (OBJMTLLoader, ColladaLoader, UTFv8Loader)\n//   will need to be updated so they can use the cache\n// Cache from url to geometry/texture\n// Cache from modelId to object3D, materialId to material\n// TODO: Compression of obj/collada models\n\n/**\n * Class for handling loading and retrieving of assets\n * @param params Configuration for asset manager\n * @param [params.searchController] {SearchController}\n * @param [params.assetCacheSize] {number} Size of asset cache\n * @param [params.cacheSettings] {Object} Cache settings keyed on asset type\n * @param [params.autoAlignModels=false] {boolean} If true, models are automatically aligned when loaded\n * @param [params.autoScaleModels=true] {boolean} If true, models are automatically rescaled when loaded\n * @param [params.autoLoadVideo=false] {boolean} If true, videos for models with video textures are loaded along with models\n * @param [params.enableLights=false] {boolean} If true, lights are enabled for models with lights.\n * @param [params.defaultLightState=false] {boolean} If true, lights are turned on for models with lights (requires `enableLights` to be true)\n * @param [params.includeModelInfo=true] {boolean} If true, model info is automatically queried from solr\n * @param [params.previewImageIndex=-1] {int} Which image to use for preview\n * @param [params.modelFilter=true] {function(model.ModelInfo): boolean} If true, model is loaded\n * @param [params.maxAnisotropy] {number}\n * @param [params.defaultSceneFormat='wss'] {string}\n * @param [params.useBuffers=false] {boolean}\n * @param [params.useDynamic=false] {boolean}\n * @param [params.useColladaScale=null] {boolean} Whether to apply the unit found in Collada files.  If specified, will override `applyScale` in load model options\n * @param [params.convertUpAxis=null] {boolean} Whether to convert up axis of Collada files.  If specifeid, will override `convertUpAxis` in load model options\n * @param [params.supportArticulated=false] {boolean} Whether to load articulation information and split model into separate meshes for articulation\n * @param [params.mergeFixedParts=false] {boolean} Whether to merge fixed parts into single meshes (if `supportArticulated` is `true`)\n * @constructor\n * @memberOf assets\n */\nfunction AssetManager(params) {\n  PubSub.call(this);\n  // Whether to try to return modelInfo with model (true by default)\n  this.includeModelInfo = true;\n\n  // Cache of model infos - can make into fancier cache if needed...\n  this.__modelInfoCache = new AssetCache();\n  this.__prefetchedQueryKeys = {};\n\n  // Cache of assets\n  var defaultCacheSettings = params? { assetCacheSize: params.assetCacheSize } : undefined;\n  var cacheSettings = {};\n  ['model', 'scene', 'other'].forEach(function(x) {\n    var s = (params && params.cacheSettings)? params.cacheSettings[x] : undefined;\n    cacheSettings[x] = s || defaultCacheSettings;\n  });\n  //console.log('cacheSettings', cacheSettings);\n  this.__cachedAssetLoaders = {\n    'model': new CachedAssetLoader(cacheSettings['model']),\n    'scene': new CachedAssetLoader(cacheSettings['scene']),\n    'other': new CachedAssetLoader(cacheSettings['other'])\n  };\n\n  // Whether to auto align models with world or not\n  this.autoAlignModels = false;\n\n  // Whether to auto scale models or not\n  this.autoScaleModels = true;\n\n  // Whether to automatically load a video (for p5d models with \"video\" texture)\n  this.autoLoadVideo = false;\n\n  // Whether to use BufferGeometry or not (more efficient memory usage)\n  // Set to false if this causes problems\n  this.useBuffers = true;\n\n  // Whether to have dynamic geometry (keep certain information around...)\n  // Needed for ray intersection to work...\n  this.useDynamic = false;\n\n  // What image to use for the preview (-1 for original image)\n  this.previewImageIndex = -1;\n\n  // Use collada scale?\n  this.useColladaScale = undefined;\n\n  // Convert up axis\n  this.convertUpAxis = undefined;\n\n  // Optional filter function takes modelinfo as input and returns whether to load model\n  this.modelFilter = undefined;\n\n  // Default scene format\n  this.defaultSceneFormat = 'wss';\n\n  // Asset loader helper for loading from file or url\n  this.assetLoader = new AssetLoader();\n\n  // Mapping of asset loader by type and format\n  // TODO: Put object loaders here too\n  this.__assetLoaders = {};\n\n  // Custom material bindings\n  this.__materialBindingsByModelId = {};\n\n  // Custom assetDbs (additional model information)\n  // Currently just one big pile...\n  this.__assetsDbs = [];\n\n  // Max anisotropy for textures\n  this.maxAnisotropy = undefined;\n\n  // Whether lights are automatically created and loaded\n  this.autoLoadLights = true;\n\n  if (params) {\n    // Search controller for fetching modelInfos\n    this.searchController = params.searchController;\n\n    if (params.autoAlignModels !== undefined) this.autoAlignModels = params.autoAlignModels;\n    if (params.autoScaleModels !== undefined) this.autoScaleModels = params.autoScaleModels;\n    if (params.autoLoadVideo !== undefined) this.autoLoadVideo = params.autoLoadVideo;\n    if (params.autoLoadLights !== undefined) this.autoLoadLights = params.autoLoadLights;\n    if (params.useBuffers !== undefined) this.useBuffers = params.useBuffers;\n    if (params.includeModelInfo !== undefined) this.includeModelInfo = params.includeModelInfo;\n    if (params.useDynamic !== undefined) this.useDynamic = params.useDynamic;\n    if (params.previewImageIndex !== undefined) this.previewImageIndex = params.previewImageIndex;\n    if (params.useColladaScale !== undefined) this.useColladaScale = params.useColladaScale;\n    if (params.convertUpAxis !== undefined) this.convertUpAxis = params.convertUpAxis;\n    if (params.modelFilter !== undefined) this.modelFilter = params.modelFilter;\n    if (params.defaultSceneFormat !== undefined) this.defaultSceneFormat = params.defaultSceneFormat;\n    if (params.maxAnisotropy !== undefined) this.maxAnisotropy = params.maxAnisotropy;\n    if (params.supportArticulated !== undefined) this.supportArticulated = params.supportArticulated;\n    if (params.mergeFixedParts !== undefined) this.mergeFixedParts = params.mergeFixedParts;\n  }\n\n  // Fields we want to preserve and send to the scene loaders\n  this.__sceneLoadInfoFields = ['preload', 'freezeObjects', 'floor', 'level', 'room',\n    'includeCeiling', 'includeWalls', 'includeFloor',\n    'attachWallsToRooms', 'useVariants',\n    'useDefaultMaterials', 'archOptions', \"adjustReplacementTransforms\",\n    'createArch', 'useArchModelId', 'ignoreOriginalArchHoles',\n    'keepInvalid', 'keepHidden', 'keepParse', 'keepMaterialInfo', 'precomputeAttachments',\n    'hideCategories', 'hideModelIds', 'replaceModels', 'loadModelFilter', 'skipElements',\n    'emptyRoom', 'archOnly', 'defaultModelFormat'];\n\n  this.__lightsLoader = new LightsLoader(params);\n\n  this.__registerDefaultLoaders();\n}\n\nAssetManager.prototype = Object.create(PubSub.prototype);\nAssetManager.prototype.constructor = AssetManager;\n\nAssetManager.toSourceId = function (defaultSource, id) {\n  if (!defaultSource) defaultSource = Constants.defaultModelSource;\n  var pos = id.lastIndexOf('.');\n  var source = defaultSource;\n  if (pos > 0) {\n    source = id.substring(0, pos);\n    id = id.substring(pos + 1);\n  }\n  return { source: source, id: id, fullId: source + '.' + id };\n};\n\nAssetManager.toFullId = function (defaultSource, id) {\n  if (!defaultSource) defaultSource = Constants.defaultModelSource;\n  var pos = id.indexOf('.');\n  return (pos > 0) ? id : defaultSource + '.' + id;\n};\n\nAssetManager.prototype.toFullId = function(defaultSource, id) {\n  return AssetManager.toFullId(defaultSource, id);\n};\n\nAssetManager.prototype.setSearchController = function (searchController) {\n  this.searchController = searchController;\n};\n\nAssetManager.prototype.getColoredMaterial = function (colorname, hex, options) {\n  var side = (options && options.side) ? options.side : THREE.FrontSide;\n  var name = (options && options.name) ? options.name : colorname;\n  var c = new THREE.Color(parseInt(hex, 16));\n  var a = new THREE.Color();\n  a.setRGB(c.r / 4, c.g / 4, c.b / 4);\n  var s = new THREE.Color();\n  s.setRGB(0.18, 0.18, 0.18);\n  var p = Materials.updateMaterialParams(Materials.DefaultMaterialType, {\n      color: c, /*ambient: a, */\n      specular: s,\n      shininess: 64,\n      side: side,\n      name: name\n    });\n  return new Materials.DefaultMaterialType(p);\n};\n\nAssetManager.prototype.getTexture = function (url, options) {\n  var texture = Object3DUtil.loadTexture(url);\n  texture.wrapS = (options && options.wrap) ? options.wrap : THREE.RepeatWrapping;\n  texture.wrapT = (options && options.wrap) ? options.wrap : THREE.RepeatWrapping;\n  if (options && options.repeat) {\n    texture.repeat.copy(options.repeat);\n  }\n  if (options && options.anisotropy) {\n    texture.anisotropy = options.anisotropy;\n  } else if (this.maxAnisotropy) {\n    texture.anisotropy = this.maxAnisotropy;\n  }\n  return texture;\n};\n\nAssetManager.prototype.getTexturedMaterialFromUrl = function (name, url, options) {\n  var texture = this.getTexture(url, options);\n  var side = (options && options.side) ? options.side : THREE.FrontSide;\n  var mname = (name !== undefined) ? name : null;\n  return new Materials.DefaultMaterialType({ map: texture, side: side, name: mname });\n};\n\nAssetManager.prototype.getTexturePath = function (source, id, metadata) {\n  var origExt;\n  if (id.endsWith('.jpg') || id.endsWith('.png')) {\n    origExt = _.getFileExtension(id);\n    id = id.substring(0, id.length - 4);\n  }\n  var sid = AssetManager.toSourceId(source, id);\n  var ext = origExt || 'jpg';\n  // Get path\n  var path = sid.id + '.' + ext;\n  // Hack here for now\n  if (sid.source === 'p5d') {\n    var p5dLoader = new P5DTextureLoader();\n    path = p5dLoader.getTexturePath(sid.id, origExt);\n  }\n\n  var assetGroup = AssetGroups.getAssetGroup(sid.source);\n  if (assetGroup && assetGroup.type === 'texture') {\n    return assetGroup.getImageUrl(sid.id, 'texture', metadata);\n  } else if (assetGroup && assetGroup.texturePath) {\n    var texturePath = assetGroup.texturePath;\n    if (!texturePath.endsWith('/')) {\n      texturePath = texturePath + '/';\n    }\n    return texturePath + path;\n  } else {\n    console.error('Unknown texture source: ' + sid.source);\n  }\n};\n\nAssetManager.prototype.getTexturedMaterial = function (source, id, options) {\n  if (!options) options = {};\n  var name = AssetManager.toFullId(source, id);\n  var path = this.getTexturePath(source, id, options.metadata);\n  if (path) {\n    return this.getTexturedMaterialFromUrl(name, path, options);\n  }\n};\n\nAssetManager.prototype.refreshModelInfo = function (source, id) {\n  var fullId = AssetManager.toFullId(source, id);\n  this.__modelInfoCache.clear(fullId);\n};\n\nAssetManager.prototype.registerAssetsDb = function (assetsDb) {\n  this.__assetsDbs.push(assetsDb);\n};\n\nAssetManager.prototype.__augmentAssetInfo = function (info) {\n  // Augments asset info with information from registered assetsDb\n  // for (var k in this.__assetsDbs) {\n  //   if (this.__assetsDbs.hasOwnProperty(k)) {\n  //     var assetsDb = this.__assetsDbs[k];\n  //     var assetInfo = assetsDb.getAssetInfo(info.fullId);\n  //     if (assetInfo) {\n  //       _.merge(info, assetInfo);\n  //     }\n  //   }\n  // }\n  var assetInfo = this.getAssetInfo(info.fullId);\n  if (assetInfo) {\n    _.merge(info, assetInfo);\n  }\n};\n\nAssetManager.prototype.__getMergedModelLoadInfo = function(info) {\n  // merge information from loadModeInfo into modelinfo\n  var merged = _.clone(info);\n  var loadModelInfo = this.getLoadModelInfo(null, info.fullId, info);\n  if (loadModelInfo) {\n    for (var prop in loadModelInfo) {\n      if (prop == 'name') { continue; } // HACK!!!! Filter out weird load format name\n      if (loadModelInfo.hasOwnProperty(prop) && (!merged.hasOwnProperty(prop) ||\n          (loadModelInfo.overrideFields && loadModelInfo.overrideFields[prop]))) {\n        merged[prop] = loadModelInfo[prop];\n      }\n    }\n  }\n  return merged;\n};\n\nAssetManager.prototype.__getCachedModelInfo = function (source, id, loadinfo) {\n  var fullId = AssetManager.toFullId(source, id);\n  var cached = this.__modelInfoCache.get(fullId);\n  if (cached && loadinfo) {\n    // TODO: consider if we dropped anything else from loadinfo\n    var info = _.defaults(Object.create(null), cached, { format: loadinfo.formatName });\n    if (loadinfo.copyFields) {\n      _.merge(info, _.pick(loadinfo, loadinfo.copyFields));\n    }\n    var merged = this.__getMergedModelLoadInfo(info);\n    if (loadinfo.options) {\n      merged.options = _.merge(merged.options || {}, loadinfo.options);\n    }\n    merged.format = loadinfo.format || merged.format;  // HACK: Fix format\n    return merged;\n  } else {\n    return cached;\n  }\n};\n\nAssetManager.prototype.cacheModelInfos = function (source, modelInfos) {\n  //if (!this.includeModelInfo) return;  // No need to cache....\n  for (var i = 0; i < modelInfos.length; i++) {\n    var info = modelInfos[i];\n    this.__augmentAssetInfo(info);\n\n    var fullId = (info.fullId) ? info.fullId : AssetManager.toFullId(source, info.id);\n    this.__modelInfoCache.set(fullId, info);\n  }\n};\n\nAssetManager.prototype.getAssetGroup = function (source) {\n  return AssetGroups.getAssetGroup(source);\n};\n\nAssetManager.prototype.getSourceDataType = function (source) {\n  var assetGroup = this.getAssetGroup(source);\n  if (assetGroup) {\n    return assetGroup.type;\n  } else {\n    if (source === 'models3d') {\n      return Constants.assetTypeModel;\n    } else if (source === 'scans') {\n      return Constants.assetTypeScan;\n    } else if (source === 'scenes') {\n      return Constants.assetTypeScene;\n    } else if (source === 'rooms') {\n      return Constants.assetTypeRoom;\n    } else if (source === 'textures') {\n      return Constants.assetTypeTexture;\n    } else {\n      console.error('Unknown source: ' + source);\n    }\n  }\n};\n\nAssetManager.prototype.getAssetInfo = function(id) {\n  if (id != undefined) {\n    var sid = AssetManager.toSourceId(null, id);\n    var assetGroup = AssetGroups.getAssetGroup(sid.source);\n    if (assetGroup) {\n      return assetGroup.getAssetInfo(sid.source + '.' + sid.id);\n    }\n  } else {\n    console.error('Asset id undefined');\n  }\n};\n\nAssetManager.prototype.getLoadInfo = function (source, id, metadata) {\n  var sid = AssetManager.toSourceId(source, id);\n  var assetGroup = this.getAssetGroup(sid.source);\n  if (assetGroup) {\n    var format = metadata? (metadata.format || metadata.defaultFormat) : undefined;\n    var loadInfo = assetGroup.getLoadInfo(sid.id, format, metadata);\n    loadInfo.formatName = loadInfo.format;\n    if (loadInfo.name && loadInfo.name != loadInfo.format) {\n      loadInfo.formatName = loadInfo.name;\n    }\n    switch (assetGroup.type) {\n      // Model - return model load info\n      case Constants.assetTypeScan:\n      case Constants.assetTypeModel: {\n        if (loadInfo) {\n          // augment options\n          if (!loadInfo.options) {\n            loadInfo.options = {};\n          }\n          if (!loadInfo.options.hasOwnProperty('useBuffers')) {\n            loadInfo.options['useBuffers'] = this.useBuffers;\n          }\n          if (!loadInfo.options.hasOwnProperty('useDynamic')) {\n            // TODO: Still needed?\n            loadInfo.options['useDynamic'] = this.useDynamic;\n          }\n          if (!loadInfo.options.hasOwnProperty('autoAlign')) {\n            loadInfo.options['autoAlign'] = this.autoAlignModels;\n          }\n          if (!loadInfo.options.hasOwnProperty('autoScale')) {\n            loadInfo.options['autoScale'] = this.autoScaleModels;\n          }\n        }\n        if (assetGroup.lightSpecs) {\n          loadInfo.lightSpecs = assetGroup.lightSpecs[sid.id];\n        }\n        return loadInfo;\n      }\n      // Other types - return loadInfo\n      default:\n        return loadInfo || {};\n    }\n  } else {\n    console.error('Unknown source: ' + sid.source);\n    console.error('Original source: ' + source);\n  }\n};\n\nAssetManager.prototype.getLoadModelInfo = function (source, id, metadata) {\n  return this.getLoadInfo(source, id, metadata);\n};\n\nAssetManager.prototype.getAllImageUrls = function (source, id, metadata) {\n  var sid = AssetManager.toSourceId(source, id);\n  var assetGroup = this.getAssetGroup(sid.source);\n  if (assetGroup) {\n    return assetGroup.getAllImageUrls(sid.id, metadata);\n  } else {\n    console.error('Unknown source: ' + source);\n  }\n};\n\nAssetManager.prototype.getOriginalSourceUrl = function (source, id) {\n  var sid = AssetManager.toSourceId(source, id);\n  var assetGroup = this.getAssetGroup(sid.source);\n  if (assetGroup) {\n    return assetGroup.getOriginalSourceUrl(sid.id);\n  } else {\n    console.error('Unknown source: ' + source);\n  }\n};\n\nAssetManager.prototype.getImagePreviewUrl = function (source, id, index, metadata) {\n  var sid = AssetManager.toSourceId(source, id);\n  var assetGroup = this.getAssetGroup(sid.source);\n  var idx = (index === undefined) ? this.previewImageIndex : index;\n  if (assetGroup) {\n    return assetGroup.getImagePreviewUrl(sid.id, idx, metadata);\n  } else {\n    console.error('Unknown source: ' + sid.source + ', original source ' + source);\n  }\n};\n\nAssetManager.prototype.__getCachingLoader = function(assetType, format) {\n  return this.__cachedAssetLoaders[assetType] || this.__cachedAssetLoaders['other'];\n};\n\nAssetManager.prototype.clearCache = function(cacheTypes) {\n  var scope = this;\n  if (cacheTypes) {\n    if (!Array.isArray(cacheTypes)) {\n      cacheTypes = [cacheTypes];\n    }\n    _.each(cacheTypes, function(cacheType) {\n      var loader = scope.__cachedAssetLoaders[cacheType];\n      if (loader) {\n        loader.getCache().clear();\n      }\n    });\n  } else {\n    _.each(this.__cachedAssetLoaders, function (loader) {\n      loader.getCache().clear();\n    });\n  }\n};\n\nAssetManager.prototype.getModelInstance = function (source, id, callback, onerror, metadata) {\n  var sid = AssetManager.toSourceId(source, id);\n  if (!onerror) {\n    onerror = function(err) { console.error(err); }\n  }\n  if (sid.source === 'shape') {\n    // special shape creator - create dummy shape model\n    if (sid.id === 'box') {\n      // TODO: use ShapeGenerator to generate shapes\n      var box = new THREE.BoxGeometry(1,1,1);\n      var mesh = new THREE.Mesh(box, Object3DUtil.TransparentMat);\n      var model = new Model(mesh, { id: sid.id, fullId: AssetManager.toFullId(sid.source, sid.id), source: sid.source, unit: this.virtualUnitToMeters });\n      callback(model.newInstance(false));\n    } else {\n      onerror('Unsupported shape ' + sid.id);\n    }\n  } else {\n    var modelInfo = this.getLoadModelInfo(source, id, metadata);\n    if (modelInfo) {\n      return this.getModelInstanceFromLoadModelInfo(modelInfo, callback, onerror);\n    } else {\n      onerror('Cannot determine load info for model ' + source + '.' + id);\n    }\n  }\n};\n\nAssetManager.prototype.getModelInstanceFromLoadModelInfo = function (modelInfo, callback, onerror) {\n  var scope = this;\n  var loader = this.__getCachingLoader('model');\n  var clone = modelInfo.skipCache? false : !!loader.getCache();\n  scope.__getModelWithModelInfoLookup(modelInfo, function(model) {\n    callback(model.newInstance(clone));\n  }, onerror);\n  // this.prefetchModelInfosForAssetGroup(modelInfo.source, function(err, data) {\n  //   scope.__getModelInstanceWithModelInfoLookup(modelInfo, callback, onerror);\n  // });\n};\n\nAssetManager.prototype.__getModelWithModelInfoLookup = function (modelInfo, callback, onerror) {\n  var scope = this;\n  return this.__lookupModelInfo(modelInfo, function(info) {\n    return scope.__loadModel(info, callback, onerror);\n  });\n};\n\nAssetManager.prototype.lookupModelInfo = function(source, id, callback) {\n  var sid = AssetManager.toSourceId(source, id);\n  return this.__lookupModelInfo(sid, callback);\n};\n\nAssetManager.prototype.__lookupModelInfo = function (modelInfo, callback) {\n  //console.log('lookupModelInfo', modelInfo);\n  if (modelInfo.id == undefined && modelInfo.fullId) {\n    var sid = AssetManager.toSourceId(null, modelInfo.fullId);\n    modelInfo.source = sid.source;\n    modelInfo.id = sid.id;\n  }\n  if (this.includeModelInfo && modelInfo.id != undefined) {\n    var cachedModelInfo = this.__getCachedModelInfo(modelInfo.source, modelInfo.id, modelInfo);\n    if (cachedModelInfo) {\n      modelInfo = cachedModelInfo;\n    } else {\n      var assetGroup = AssetGroups.getAssetGroup(modelInfo.source);\n      if (assetGroup) {\n        // Lookup info from local asset group (will potentially update if search controller is specified)\n        var localGroupAssetInfo = assetGroup.getAssetInfo(modelInfo.source + '.' + modelInfo.id);\n        if (localGroupAssetInfo) {\n          this.cacheModelInfos(modelInfo.source, [localGroupAssetInfo]);\n          modelInfo = this.__getCachedModelInfo(modelInfo.source, modelInfo.id, modelInfo);\n        }\n      }\n    }\n\n    if (!cachedModelInfo && this.searchController) {\n      var scope = this;\n      // Handle when we don't yet have info for this model.... need to explicitly fetch it\n      var fullId = AssetManager.toFullId(modelInfo.source, modelInfo.id);\n      var query = this.searchController.getQuery('fullId', fullId);\n      //console.log('search for ' + query);\n      // NOTE: Use modelinfo cache\n      var loader = this.__getCachingLoader('modelinfo');\n      loader.load({\n        skipCache: true,\n        key: 'modelinfo-' + fullId,\n        loadFn: function(opts, cb) {\n          scope.searchController.query({ source: modelInfo.source, query: query, start: 0, limit: 1 }, cb);\n        },\n        loadOpts: null,\n        callback: function(err, data) {\n          var info;\n          if (err) {\n            console.error('Search for ' + query + ' failed', err);\n          } else {\n            scope.cacheModelInfos(modelInfo.source, data.response.docs);\n            info = scope.__getCachedModelInfo(modelInfo.source, modelInfo.id, modelInfo);\n          }\n          if (!info) info = modelInfo;\n          return callback(info);\n        }\n      });\n      return;\n    }\n  }\n  return callback(modelInfo);\n};\n\nAssetManager.prototype.getModelInstanceFromModelInfo = function (modelInfo, onsuccess, onerror) {\n  var loader = this.__getCachingLoader('model');\n  var clone = modelInfo.skipCache? false : !!loader.getCache();\n  return this.__loadModel(modelInfo, function (model) {\n    onsuccess(model.newInstance(clone));\n  }, onerror);\n};\n\nAssetManager.prototype.prefetchModelInfosForAssetGroup = function (name, callback) {\n  var assetGroup = AssetGroups.getAssetGroup(name);\n  if (assetGroup && assetGroup.prefetchModelInfo) {\n    this.prefetchModelInfos(assetGroup.prefetchModelInfo, undefined, callback);\n  } else {\n    if (callback) {\n      callback('No prefetch info', null);\n    }\n  }\n};\n\nAssetManager.prototype.prefetchModelInfos = function (p, force, callback) {\n  var queryKey = p.source + '/' + p.query + '/' + p.limit;\n  var fetched = this.__prefetchedQueryKeys[queryKey] && !force;\n  if (!fetched && this.searchController) {\n    var scope = this;\n    // NOTE: Use modelinfo cache\n    var loader = this.__getCachingLoader('modelinfo');\n    loader.load({\n      skipCache: true,\n      key: queryKey,\n      loadFn: function(opts, cb) {\n        scope.searchController.query({ source: p.source, query: p.query, start: 0, limit: p.limit }, cb);\n      },\n      loadOpts: null,\n      callback: function(err, data) {\n        if (callback) {\n          callback(err, data);\n        } else if (!err) {\n          //console.log('populating prefetched model infos', queryKey);\n          if (data.response && data.response.docs) {\n            scope.cacheModelInfos(p.source, data.response.docs);\n            scope.__prefetchedQueryKeys[queryKey] = 1;\n          }\n        }\n      }\n    });\n  }\n};\n\nAssetManager.prototype.getModelVariant = function(model, variantId, callback) {\n  if (model.info.id === variantId) {\n    callback(null, model);\n  } else if (model.info.variantIds && model.info.variantIds.indexOf(variantId) >= 0) {\n    var loadInfo = this.getLoadInfo(model.info.source, variantId);\n    var scope = this;\n    this.__getModelWithModelInfoLookup(loadInfo, function(m) {\n      if (model.isFlipped) {\n        callback(null, scope.getFlippedModel(m));\n      } else {\n        callback(null, m);\n      }\n    }, function(err) {\n      callback(err, null);\n    });\n  } else {\n    callback('Unknown variant ' + variantId + ' for model ' + model.info.fullId);\n  }\n};\n\nAssetManager.prototype.getFlippedModel = function(model) {\n  // Create variation of model with flipped normals\n  if (model.__flipped) {\n    return model.__flipped;\n  }\n  var modelinfo = model.info;\n\n  var key =  'model-' + modelinfo.fullId + '-' + modelinfo.formatName + '-flipped';\n  var loader = this.__getCachingLoader('model');\n  var flipped = loader.getOrElse(key, function() {\n    // Create flipped model\n    // Deep clone model and flip geometry\n    var clone = model.deepClone();\n    clone.isFlipped = true;\n    Object3DUtil.flipForMirroring(clone.object3D);\n    model.__flipped = clone;\n    clone.__flipped = model;\n    return clone;\n  }, function(model) {\n    if (model && model.object3D) {\n      Object3DUtil.dispose(model.object3D);\n    }\n  });\n  return flipped;\n};\n\nAssetManager.prototype.__loadModel = function (modelinfo, callback, onerror) {\n  // check whether we really want to load, or just filter out this model\n  //console.log(\"loading model\", modelinfo);\n  onerror = onerror || function (err) { console.error(err); };\n  var isValidModel = this.modelFilter ? this.modelFilter(modelinfo) : true;\n  if (!isValidModel) {\n    onerror('Ignoring invalid model ' + modelinfo.fullId);\n    return;\n  }\n\n  // Load model with cache\n  var key = (modelinfo.fullId)? 'model-' + modelinfo.fullId + '-' + modelinfo.formatName : undefined;\n  var loader = this.__getCachingLoader('model');\n  var scope = this;\n  loader.load({\n    skipCache: modelinfo.skipCache,\n    key: key,\n    loadOpts: modelinfo,\n    loadFn: function(minfo, cb) {\n      return scope.__preloadAssets(minfo, function(err, res) {\n        scope.__loadModelUncached(minfo, cb);\n      });\n    },\n    dispose: function(model) {\n      if (model && model.object3D) {\n        Object3DUtil.dispose(model.object3D);\n      }\n    },\n    callback: function(err, value) {\n      if (err) {\n        onerror(err);\n      } else {\n        callback(value);\n      }\n    }\n  });\n};\n\nAssetManager.prototype.addMaterialBinding = function(modelId, options) {\n  for (var i = 0; i < options.materials.length; i++) {\n    var m = options.materials[i];\n    var side = (m.side != undefined)? m.side : Materials.DefaultMaterialSide;\n    if (!m.material) {\n      if (m.textureId) {\n        m.material = this.getTexturedMaterial(undefined, m.textureId, {side: side});\n      } else if (m.color != undefined) {\n        m.material = this.getColoredMaterial(m.name, m.color, {side: side});\n      }\n    }\n  }\n  options.materialsByName = _.keyBy(options.materials, 'name');\n  this.__materialBindingsByModelId[modelId] = options;\n};\n\nAssetManager.prototype.__createModel = function(object3D, modelInfo) {\n  if (modelInfo.groupMeshes) {\n    // Group meshes by chunkxxx_groupyyy_subzzz\n    //console.log('group meshes');\n    var meshes = Object3DUtil.getMeshList(object3D);\n    var grouped = new THREE.Group();\n    var groups = {};\n    var subgroups = {};\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var parts = mesh.name.split('_');\n      if (parts.length >= 2 && parts[1].startsWith('group')) {\n        var g = parts[1];\n        if (!groups[g]) {\n          groups[g] = new THREE.Group();\n          groups[g].name = g;\n          grouped.add(groups[g]);\n        }\n        if (parts.length >= 3 && parts[2].startsWith('sub')) {\n          var s = parts[1] + '_' + parts[2];\n          if (!subgroups[s]) {\n            subgroups[s] = new THREE.Group();\n            subgroups[s].name = s;\n            groups[g].add(subgroups[s]);\n          }\n          subgroups[s].add(mesh);\n        } else {\n          groups[g].add(mesh);\n        }\n      } else {\n        grouped.add(mesh);\n      }\n    }\n    //console.log(grouped);\n    _.merge(grouped.userData, object3D.userData);\n    object3D = grouped;\n  }\n  var model = new Model(object3D, modelInfo);\n  this.__preprocessModel(model);\n  return model;\n};\n\nAssetManager.prototype.__preprocessModel = function(model) {\n  // Apply custom textures\n  var modelId = model.info.fullId;\n  var bindings = this.__materialBindingsByModelId[modelId];  // custom material bindings\n  if (bindings) {\n    // array of new material bindings\n    // either from old material or old mesh to new material\n    var materialsByName = bindings.materialsByName;\n    var mappings = bindings.materialMappings;\n    for (var p in mappings) {\n      if (mappings.hasOwnProperty(p)) {\n        var originalMaterialName = p;\n        var m = materialsByName[mappings[p]];\n        // Going from material name to to new material\n        if (m && m.material) {\n          var newMaterial = m.material;\n          //Object3DUtil.setMaterial(model.object3D, newMaterial);\n          Object3DUtil.setMaterial(model.object3D, newMaterial, undefined, false, function (mesh) {\n            return mesh.material.name === originalMaterialName;\n          });\n        }\n      }\n    }\n  }\n  if (this.__lightsLoader && this.autoLoadLights) {\n    this.__lightsLoader.createLights(model.info, model.object3D);\n  }\n};\n\nAssetManager.prototype.__loadModelUncached = function (modelinfo, callback) {\n  var scope = this;\n  var onsuccess = function (object3D) {\n    var model = scope.__createModel(object3D, modelinfo); // custom preprocessing of the model\n    if (modelinfo.modelSpaceMetadataFile) {\n      // Weird hack for shapenet v2 modelspace normalization\n      scope.assetLoader.load(modelinfo.modelSpaceMetadataFile, 'json', function(json) {\n        modelinfo.modelSpaceMetadata = json;\n        callback(null, model);\n      }, null, function(err) {\n        console.warn('Error loading modelSpaceMetadataFile ' + modelinfo.modelSpaceMetadataFile, err);\n        callback(null, model);\n      });\n    } else {\n      callback(null, model);\n    }\n  };\n  var onerror = function(err) {\n    if (err) {\n      console.error('Error loading model', modelinfo, err);\n    }\n    callback(err, null);\n  };\n\n  return this.__loadObject3D(modelinfo, onsuccess, onerror);\n};\n\nAssetManager.prototype.__loadObject3D = function(modelinfo, onsuccess, onerror) {\n  if (this.supportArticulated && modelinfo.hasArticulations) {\n    var ArticulatedObjectLoader = __webpack_require__(/*! articulations/ArticulatedObjectLoader */ \"./js/lib/articulations/ArticulatedObjectLoader.js\");\n    var articulatedLoader = new ArticulatedObjectLoader({ assetManager: this, mergeFixedParts: this.mergeFixedParts });\n    if (articulatedLoader.checkModelHasArticulatedMesh(modelinfo)) {\n      articulatedLoader.load(modelinfo, function(err, res) {\n        if (err) { if (onerror) { onerror(err); }}\n        else { if (onsuccess) { onsuccess(res); }}\n      });\n    } else {\n      var obj3dLoader = new Object3DLoader(this);\n      obj3dLoader.load(modelinfo, onsuccess, onerror);\n    }\n  } else {\n    var obj3dLoader = new Object3DLoader(this);\n    obj3dLoader.load(modelinfo, onsuccess, onerror);\n  }\n};\n\nAssetManager.prototype.__getMaterialSide = function(modelInfo) {\n  var options = modelInfo.options || {};\n  var sidedness = options.materialSidedness || modelInfo.materialSidedness;\n  return Materials.getMaterialSide(sidedness, Materials.DefaultMaterialSide);\n};\n\nAssetManager.prototype.__getMaterial = function(modelInfo, materialKey, materialTypeKey, defaultMaterialType) {\n  var materialType = this.__getMaterialType(modelInfo, materialTypeKey, defaultMaterialType);\n  if (materialType) {\n    var options = modelInfo.options || {};\n    var side = this.__getMaterialSide(modelInfo);\n    var material = (options[materialKey]) ? options[materialKey] : new materialType(\n      { name: materialKey, side: side });\n    return material;\n  }\n};\n\nAssetManager.prototype.__getDefaultMaterial = function(modelInfo, defaultMaterialType) {\n  return this.__getMaterial(modelInfo, 'defaultMaterial', 'defaultMaterialType', defaultMaterialType);\n};\n\nAssetManager.prototype.__getOverrideMaterial = function(modelInfo, defaultMaterialType) {\n  return this.__getMaterial(modelInfo, 'overrideMaterial', 'overrideMaterialType', defaultMaterialType);\n};\n\nAssetManager.prototype.__getMaterialType = function(modelInfo, materialTypeKey, defaultMaterialType) {\n  var materialType = modelInfo.options? modelInfo.options[materialTypeKey] : null;\n  materialType = materialType || modelInfo[materialTypeKey] || defaultMaterialType;\n  if (_.isString(materialType)) {\n    materialType = Materials.getMaterialType(materialType);\n  }\n  return materialType;\n};\n\nAssetManager.prototype.__getDefaultMaterialType = function(modelInfo, defaultMaterialType) {\n  return this.__getMaterialType(modelInfo, 'defaultMaterialType', defaultMaterialType);\n};\n\nAssetManager.prototype.__getOverrideMaterialType = function(modelInfo, defaultMaterialType) {\n  return this.__getMaterialType(modelInfo, 'overrideMaterialType', defaultMaterialType);\n};\n\nAssetManager.prototype.__updateMaterialOptions = function(modelInfo, options, defaultMaterialType) {\n  // var side = this.__getMaterialSide(modelInfo);\n  options.materialBase = options.materialBase || options.texturePath || modelInfo.materialBase || modelInfo.texturePath;\n  options.defaultMaterialType = this.__getDefaultMaterialType(modelInfo, defaultMaterialType);\n  options.defaultMaterial = this.__getDefaultMaterial(modelInfo, defaultMaterialType);\n  options.overrideMaterialType = this.__getOverrideMaterialType(modelInfo, null);\n  options.overrideMaterial = this.__getOverrideMaterial(modelInfo, null);\n};\n\nAssetManager.prototype.loadAsset = function(info, callback) {\n  var assetType = info.assetType;\n  var sid = info.fullId? AssetManager.toSourceId(info.source, info.fullId) : null;\n  if (!assetType) {\n    var assetGroup = this.getAssetGroup(sid.source);\n    assetType = assetGroup.type;\n  }\n  if (assetType === Constants.assetTypeScene) {\n    return this.loadScene(info, callback);\n  } else if (assetType === Constants.assetTypeModel || assetType === Constants.assetTypeScan) {\n    return this.loadModel(info, callback);\n  } else if (assetType === Constants.assetTypeArch) {\n    var ArchLoader = __webpack_require__(/*! loaders/ArchLoader */ \"./js/lib/loaders/ArchLoader.js\");\n    var archLoader = new ArchLoader({fs: Constants.sys.fs,\n      archOptions: { filter: _.pick(info, this.__sceneLoadInfoFields)}});\n    return archLoader.loadAsScene(info, callback);\n  } else {\n    console.warn('Cannot load asset', info);\n    callback('Cannot load asset', null);\n  }\n};\n\nAssetManager.prototype.loadAssetAsScene = function(info, callback) {\n  var assetType = info.assetType;\n  var sid = info.fullId? AssetManager.toSourceId(info.source, info.fullId) : null;\n\n  if (!assetType && sid) {\n    var assetGroup = this.getAssetGroup(sid.source);\n    assetType = assetGroup.type;\n  }\n  if (assetType === Constants.assetTypeScene || assetType == undefined) {\n    if (info.defaultSceneFormat) {\n      info.defaultFormat = info.defaultSceneFormat;\n    }\n    return this.loadScene(info, callback);\n  } else if (assetType === Constants.assetTypeModel || assetType === Constants.assetTypeScan) {\n    // TODO: Restore defaultFormat\n    if (info.format && sid) {\n      var assetGroup = this.getAssetGroup(sid.source);\n      assetGroup.defaultFormat = info.format;\n    }\n    return this.loadModelAsScene(info, callback);\n  } else if (assetType === Constants.assetTypeArch) {\n    var ArchLoader = __webpack_require__(/*! loaders/ArchLoader */ \"./js/lib/loaders/ArchLoader.js\");\n    var archLoader = new ArchLoader({fs: Constants.sys.fs,\n      archOptions: { filter: _.pick(info, this.__sceneLoadInfoFields)}});\n    return archLoader.loadAsScene(info, callback);\n  } else {\n    console.warn('Cannot load asset', info);\n    callback('Cannot load asset', null);\n  }\n};\n\nAssetManager.prototype.loadModel = function (info, callback) {\n  var sid = info.fullId? AssetManager.toSourceId(info.source, info.fullId) : null;\n  if (sid) {\n    return this.getModelInstance(sid.source, sid.id,\n      function (mi) {\n        callback(null, mi);\n      },\n      function (err) {\n        callback(err, null);\n      },\n      info\n    );\n  } else {\n    return this.getModelInstanceFromLoadModelInfo(info,\n      function (mi) {\n        callback(null, mi);\n      },\n      function (err) {\n        callback(err, null);\n      },\n      info\n    );\n  }\n};\n\nAssetManager.prototype.loadModelAsScene = function (modelLoadInfo, callback) {\n  var scope = this;\n  // TODO: simplify crazy asset info manipulation\n  this.__lookupModelInfo(modelLoadInfo, function(modelInfo) {\n    var sceneInfo = _.clone(modelLoadInfo);\n    if (!sceneInfo.data) {\n      // Pretend that we are a scene\n      sceneInfo.rootObjectIndex = 0;\n      sceneInfo.data = {\n        \"format\": \"sceneState\",\n        \"object\": [\n          _.defaults({\n            \"modelId\": sceneInfo.fullId,\n            \"index\": 0,\n            \"parentIndex\": -1,\n            \"transform\": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]\n          }, modelLoadInfo.modelMetadata || {})\n        ]\n      };\n    }\n    if (sceneInfo.preload) {\n      _.each(sceneInfo.preload, function(p) {\n        sceneInfo[p] = modelInfo[p];\n      });\n    }\n\n    sceneInfo['baseModelInfo'] = modelInfo;\n    //console.log('Load model as scene', modelInfo, sceneInfo);\n    scope.loadScene(sceneInfo, callback);\n  });\n};\n\nAssetManager.prototype.loadScene = function (sceneinfo, callback) {\n  sceneinfo.archType = SceneState.getArchType(sceneinfo);\n  if (sceneinfo.createArch) {\n    sceneinfo.preload = sceneinfo.preload || [];\n    sceneinfo.preload.push('arch');\n  }\n  if (sceneinfo.cache && sceneinfo.fullId) {\n    var cachingLoader = this.__getCachingLoader('scene', sceneinfo.format);\n    var scope = this;\n    return cachingLoader.load({\n      key: 'scene-' + sceneinfo.fullId,\n      loadFn: function(opts, cb) {\n        scope.__loadSceneUncached(sceneinfo, cb);\n      },\n      loadOpts: null,\n      callback: callback,\n      dispose: function(sceneState) {\n        if (sceneState && sceneState.fullScene) {\n          Object3DUtil.dispose(sceneState.fullScene);\n        }\n      }\n    });\n  } else {\n    return this.__loadSceneUncached(sceneinfo, callback);\n  }\n};\n\n// Main entry point for loading a uncached scene\n// sceneinfo can be\n//    sceneId (string)\n//    object with file (url or local File object), fullId, or data (string/object to be parsed)\n//           optional: format (specifies the format of the scene to be loaded)\n//                     defaultFormat (specifies the defaultFormat to use if not specified in the actual data)\n// callback should be a function(err, sceneState)\nAssetManager.prototype.__loadSceneUncached = function (sceneinfo, callback) {\n  if (typeof sceneinfo === 'string') {\n    sceneinfo = { fullId: sceneinfo };\n  }\n  if (sceneinfo.prefetchModelInfo) {\n    this.prefetchModelInfos(sceneinfo.prefetchModelInfo);\n  }\n  if (sceneinfo['file']) {\n    return this.__loadSceneFromJsonFile(sceneinfo, callback);\n  } else if (sceneinfo['data']) {\n    return this.__loadSceneFromData(sceneinfo, callback);\n  //} else if (sceneinfo['format'] != undefined) {\n  //  return this.__loadSceneWithFormat(sceneinfo, callback);\n  } else if (sceneinfo['fullId'] != undefined) {\n    // TODO: Refactor....\n    // Try to load from DB or Solr\n    var assetInfo = this.getAssetInfo(sceneinfo.fullId);\n    if (assetInfo) {\n      _.defaults(sceneinfo, assetInfo);\n    }\n    var sid = AssetManager.toSourceId(sceneinfo.source, sceneinfo.fullId);\n    if (sid.source === 'db' || sid.source === 'mturk') {\n      return this.__loadSceneFromDb(sceneinfo, callback);\n    } else {\n      // TODO: Get scene from solr\n      var loadInfo = this.getLoadInfo(sid.source, sid.id, sceneinfo);\n      if (loadInfo) {\n        // HACK!!! Copy some important info from my sceneinfo to loadInfo\n        _.merge(loadInfo, _.pick(sceneinfo, this.__sceneLoadInfoFields));\n        return this.loadScene(loadInfo, callback);\n      }\n      console.error('Please implement me: AssetManager.loadScene from fullId');\n      if (callback) callback('Cannot load ' + sceneinfo.fullId);\n    }\n  } else {\n    console.error('Cannot load scene: ');\n    console.log(sceneinfo);\n    if (callback) callback('Cannot load scene with unknown scene format');\n  }\n};\n\nAssetManager.prototype.__preloadAssets = function(assetinfo, callback) {\n  return this.loadAssetDependencies(assetinfo,\n      { fields: assetinfo.preload }, callback);\n};\n\nAssetManager.prototype.loadAssetDependencies = function (assetinfo, options, callback) {\n  var scope = this;\n  var taskQueue = new TaskQueue({ concurrency: 4 });\n\n  // Add preloads\n  var preloads = options.fields;\n  // console.log('preloads', preloads, assetinfo);\n  if (preloads) {\n    _.each(preloads, function(preload) {\n      var preloadInfo = assetinfo[preload];\n      if (preloadInfo && preloadInfo.path) {\n        // TODO: Only update material options for the assets that need it\n        scope.__updateMaterialOptions(preloadInfo, preloadInfo);\n        var path = _.replaceVars(preloadInfo.path, assetinfo);\n        var assetLoader;\n        if (preloadInfo.assetType) {\n          var format = preloadInfo.format || _.getFileExtension(path);\n          var assetLoaderClass = scope.__lookupAssetLoader(preloadInfo.assetType, format);\n          if (assetLoaderClass) {\n            assetLoader = new assetLoaderClass(_.defaults({fs: Constants.sys.fs}, preloadInfo));\n          }\n        }\n        if (assetLoader) {\n          taskQueue.push(function(cb) {\n            console.log('preloading ' + path + ' using ' + assetLoader.constructor.name);\n            assetLoader.load(path, function(err, res) {\n              if (err) {\n                console.error('Error preloading ' + preload + ' for asset ' + assetinfo.fullId, path, err);\n              } else {\n                // TODO: Differentiate between data and parsed/processed?\n                preloadInfo.data = preloadInfo.processor? preloadInfo.processor(res) : res;\n                preloadInfo.isParsed = true;\n              }\n              cb(err, res);\n            });\n          });\n        } else {\n          taskQueue.push(function(cb) {\n            console.log('preloading ' + path);\n            scope.assetLoader.loadErrorFirst(path, preloadInfo.encoding, function(err, res) {\n              if (err) {\n                console.error('Error preloading ' + preload + ' for asset ' + assetinfo.fullId, path, err);\n              } else {\n                preloadInfo.data = preloadInfo.processor? preloadInfo.processor(res) : res;\n              }\n              cb(err, res);\n            });\n          });\n        }\n      }\n    });\n  }\n\n  taskQueue.awaitAll(function(err, res) {\n    callback(err, res);\n  });\n  return taskQueue;\n};\n\n// At this point, the actual format of the scene has been determined\n// (it was either specified explicitly in the scene, or was populated by user\n// This dispatches to the different loaders (we can have a map of format to loader\n//    instead of hand coding all loaders here)\n// All loadScene should hopefully end up here\nAssetManager.prototype.__loadSceneWithFormat = function (sceneinfo, callback) {\n  var wrappedCallback = function (err, sceneResult) {\n    // TODO: Create proper scene class\n    var sceneState = null;\n    var error;\n    sceneinfo = _.omit(sceneinfo, 'name'); // HACK!!!! omit weird format name\n    if (sceneResult instanceof SceneState) {\n      sceneState = sceneResult;\n      if (sceneState.info) {\n        _.merge(sceneinfo, sceneState.info);\n      }\n      sceneState.info = sceneinfo;\n      sceneState.finalizeScene();\n    } else if (sceneResult instanceof THREE.Scene) {\n      sceneState = new SceneState(sceneResult, sceneinfo);\n      sceneState.finalizeScene();\n    } else if (sceneResult && sceneResult.scene instanceof THREE.Scene) {\n      sceneState = new SceneState(sceneResult.scene, sceneinfo);\n      sceneState.finalizeScene();\n    } else {\n      error = err || 'Error loading scene: Unknown scene result';\n      console.error(error);\n      console.log(sceneResult);\n      console.log(sceneinfo);\n    }\n    if (sceneState) {\n      // Let's see if they wanted to hide some stuff!\n      if (sceneinfo.hideCategories) {\n        var cats = sceneinfo.hideCategories;\n        if (!_.isArray(cats)) {\n          cats = [cats];\n        }\n        sceneState.setVisible(\n          false, /* visibility */\n          function (node) {\n            var modelInstance = Object3DUtil.getModelInstance(node);\n            return modelInstance && modelInstance.model.hasCategoryIn(cats);\n          },\n          true /* recursive */\n        );\n      }\n      if (sceneinfo.hideModelIds) {\n        var modelIds = sceneinfo.hideModelIds;\n        if (!_.isArray(modelIds)) {\n          modelIds = [modelIds];\n        }\n        sceneState.setVisible(\n          false, /* visibility */\n          function (node) {\n            var modelInstance = Object3DUtil.getModelInstance(node);\n            return modelInstance && modelIds.indexOf(modelInstance.model.getFullID()) >= 0;\n          },\n          true /* recursive */\n        );\n      }\n      if (!sceneState.scene.name) {\n        sceneState.scene.name = sceneinfo.fullId;\n      }\n    }\n    callback(error, sceneState);\n  };\n  var loadOptions = { assetManager: this };\n  _.merge(loadOptions, _.pick(sceneinfo, this.__sceneLoadInfoFields));\n\n  // Replaced with more generic asset loader registry\n  var loaderClass = this.__lookupAssetLoader('scene', sceneinfo.format);\n  if (loaderClass) {\n    // Load scene + extra stuff that we are suppose to preload\n    var scope = this;\n    var loader = new loaderClass(loadOptions);\n    return this.__preloadAssets(sceneinfo, function(err, res) {\n      scope.__loadScene(loader, sceneinfo, function(loadSceneError, loadedScene) {\n        wrappedCallback(loadSceneError, loadedScene);\n      });\n    });\n  } else {\n    console.error('Cannot load scene with unsupported scene format: ' + sceneinfo['format']);\n    console.log(sceneinfo);\n    if (callback) callback('Cannot load scene with unsupported scene format: ' + sceneinfo['format']);\n  }\n};\n\nAssetManager.prototype.__findFormat = function (loadInfo) {\n  // Ugly code to try to guess format\n  var scope = this;\n  function guessFormatFromVersionString(json) {\n    if (typeof json.version === 'string') {\n      if (json.version.indexOf('@') > 0) {\n        var f = json.version.split('@')[0];\n        if (scope.__lookupAssetLoader('scene', f)) {\n          return f;\n        }\n      }\n    }\n  }\n  if (loadInfo.data) {\n    if (loadInfo.data.scene) {\n      if (typeof loadInfo.data.scene === 'string') {\n        loadInfo.data.scene = JSON.parse(loadInfo.data.scene);\n      }\n      var vformat = guessFormatFromVersionString(loadInfo.data.scene);\n      return loadInfo.data.scene.format || loadInfo.data.format || vformat || loadInfo.format;\n    } else {\n      var vformat = guessFormatFromVersionString(loadInfo.data);\n      return loadInfo.data.format || vformat || loadInfo.format;\n    }\n  } else {\n    if (loadInfo.scene) {\n      if (typeof loadInfo.scene === 'string') {\n        loadInfo.scene = JSON.parse(loadInfo.scene);\n      }\n      var vformat = guessFormatFromVersionString(loadInfo.scene);\n      return loadInfo.scene.format || vformat || loadInfo.format;\n    } else {\n      return loadInfo.format;\n    }\n  }\n};\n// Assumes that the scene has already be fetched from either file or url,\n//   and placed in the loadInfo.data\nAssetManager.prototype.__loadSceneFromData = function (loadInfo, callback) {\n  //console.log(loadInfo);\n  // Jump through some hoops to massage data into an appropriate json object\n  if (typeof loadInfo === 'string') {\n    loadInfo = JSON.parse(loadInfo);\n  }\n  if (loadInfo && typeof loadInfo.data === 'string') {\n    // May need to parse string...\n    loadInfo.data = JSON.parse(loadInfo.data);\n  }\n  loadInfo.format = this.__findFormat(loadInfo) || loadInfo['defaultFormat'] || this.defaultSceneFormat;\n  // try to figure out format\n  if (loadInfo.data) {\n    return this.__loadSceneWithFormat(loadInfo, callback);\n  } else if (loadInfo.format) {\n    // Need to wrap the data\n    // Again, jump through some hoops to handle somewhat inconsistent input data\n    var wrapped = { format: loadInfo.format, data: loadInfo };\n    if (loadInfo.format === 'sceneState' && !loadInfo.scene && loadInfo.object) {\n      wrapped.data = { scene: loadInfo };\n    }\n    return this.__loadSceneWithFormat(wrapped, callback);\n  } else {\n    // Something went wrong!!!\n    var filename = (loadInfo.file)?  (loadInfo.file.name || loadInfo.file):undefined;\n    var sceneName = loadInfo.fullId || filename;\n    console.error('Error fetching scene ' + sceneName + ': invalid scene.');\n    console.log(loadInfo);\n    if (callback) callback('Error fetching scene ' + sceneName + ': invalid scene.');\n  }\n};\n\nAssetManager.prototype.__loadSceneFromDb = function (sceneinfo, callback) {\n  var sid = sceneinfo.fullId;\n  var queryData = {\n    'qt': 'scene',\n    'sceneId': sid\n  };\n  return _.ajax({\n    type: 'GET',\n    url: Constants.baseUrl + '/query?' + _.param(queryData),\n    success: function (data, textStatus, jqXHR) {\n      if (typeof data === 'string') {\n        data = JSON.parse(data);\n      }\n      sceneinfo.data = data.data || data;\n      this.__loadSceneFromData(sceneinfo, callback);\n    }.bind(this),\n    error: function (jqXHR, textStatus, errorThrown) {\n      console.error('Error fetching scene ' + sid);\n      console.log('Error: ' + textStatus + ' ' + errorThrown);\n      if (callback) callback('Error fetching scene ' + sid);\n    },\n    timeout: 3000\n  });\n};\n\nAssetManager.prototype.__loadSceneFromJsonFile = function (sceneinfo, callback) {\n  var file = sceneinfo.file;\n  var filename = file.name || file;\n  //console.log('load file', sceneinfo);\n  return this.assetLoader.load(file, 'json',\n    function (data) {\n      sceneinfo.data = data;\n      // Populate additional load info, a bit perculiar\n      if (sceneinfo.id == null && data.id != null) {\n        sceneinfo.id = data.id;\n        if (sceneinfo.source) {\n          sceneinfo.fullId = sceneinfo.source + '.' + sceneinfo.id;\n          // Try to interpolate sceneinfo\n          var loadinfo = this.getLoadInfo(sceneinfo.source, sceneinfo.id, sceneinfo);\n          //console.log('got loadinfo', loadinfo);\n          if (loadinfo) {\n            sceneinfo =  _.defaults(sceneinfo, loadinfo);\n            //console.log('updated sceneinfo', sceneinfo);\n          }\n        }\n      }\n      this.__loadSceneFromData(sceneinfo, callback);\n    }.bind(this),\n    undefined,\n    function (event) {\n      console.error('Error fetching scene ' + filename);\n      console.log(event);\n      if (callback) callback('Error fetching scene ' + filename);\n    }\n  );\n};\n\nAssetManager.prototype.__loadScene = function (loader, sceneinfo, callback) {\n  if (sceneinfo.data) {\n    var data = (typeof sceneinfo.data === 'string') ? JSON.parse(sceneinfo.data) : sceneinfo.data;\n    loader.parse(data, function(s) { callback(null,s); }, null, sceneinfo);\n  } else if (sceneinfo.file) {\n    return loader.load(sceneinfo.file, function(s) { callback(null,s); }, null, function(err) { callback(err); }, sceneinfo);\n  } else {\n    console.error('Cannot load scene: neither data nor file specified');\n    if (callback) callback('Cannot load scene: neither data nor file specified');\n  }\n};\n\nAssetManager.prototype.registerAssetLoader = function(assetType, format, loader) {\n  if (!this.__assetLoaders[assetType]) {\n    this.__assetLoaders[assetType] = {};\n  }\n  this.__assetLoaders[assetType][format] = loader;\n};\n\nAssetManager.prototype.__lookupAssetLoader = function(assetType, format) {\n  if (this.__assetLoaders[assetType]) {\n    var loader = this.__assetLoaders[assetType][format];\n    if (!loader) {\n      loader = this.__assetLoaders[assetType]['*'];\n    }\n    return loader;\n  }\n};\n\nAssetManager.prototype.__registerDefaultLoaders = function() {\n  AssetLoaders.registerDefaultLoaders(this);\n};\n\nAssetManager.prototype.loadVideoTexture = function (videoPath) {\n  videoPath = videoPath || Constants.assetsDir + Constants.defaultVideo;\n  var VT = __webpack_require__(/*! geo/VideoTexture */ \"./js/lib/geo/VideoTexture.js\");\n  var vt = new VT(videoPath);\n  this.Publish('dynamicAssetLoaded', vt);\n  return vt;\n};\n\n\nAssetManager.prototype.registerAssetGroupWithSearchController = function(assetGroup, searchController) {\n  if (assetGroup.assetDb) {\n    searchController.registerSearchModule(assetGroup.name, assetGroup.assetDb);\n  } else if (assetGroup.solrUrl) {\n    searchController.registerSearchModule(assetGroup.name, assetGroup.solrUrl + '/select');\n  }\n};\n\n// TODO: Modify Viewer3D to use these functions\nAssetManager.prototype.registerCustomAssetGroup = function (options) {\n  var searchController = options.searchController || this.searchController;\n  var assetMetadataFile = options.assetMetadataFile;\n  var assetIdsFile = options.assetIdsFile;\n  var showWarning = options.showWarning;\n  var callback = options.callback;\n\n  var scope = this;\n  var assetLoader = this.assetLoader;\n  function _loadTextFile(filename, onLoad, errorMessage) {\n    assetLoader.load(filename, 'utf-8', onLoad, null, function(err) {\n      if (callback) {\n        callback(errorMessage + (err? ': ' + err : ''));\n      }\n    });\n  }\n  function _registerAssetGroup(assetGroup) {\n    AssetGroups.registerAssetGroup(assetGroup);\n    console.log('Registered asset group: ' + assetGroup.name);\n    if (searchController) {\n      scope.registerAssetGroupWithSearchController(assetGroup, searchController);\n    }\n    if (callback) {\n      //console.log('callback', assetGroup);\n      callback(null, assetGroup);\n    }\n    scope.Publish('AssetGroupRegistered', assetGroup);\n  }\n  function _assetListLoaded(assetGroup, filename, data) {\n    if (showWarning && searchController && searchController.hasSource(assetGroup.name)) {\n      showWarning('Replacing assets for source ' + assetGroup.name);\n    }\n    var assetsDb = AssetGroups.createAssetDbForAssetGroup(assetGroup, options);\n    assetsDb.loadAssetInfoFromData(assetGroup, data, filename, { format: options.assetIdsFileFormat });\n    assetGroup.setAssetDb(assetsDb);\n    _registerAssetGroup(assetGroup);\n  }\n  function _metadataLoaded(json) {\n    if (typeof json === 'string') {\n      json = JSON.parse(json);\n    }\n    var assetGroup = AssetGroups.createCustomAssetGroup(json);\n    if (assetGroup.type == undefined && options.assetType != null) {\n      assetGroup.type = options.assetType;\n    }\n    assetIdsFile = assetIdsFile || assetGroup.idsFile;\n    if (assetIdsFile) {\n      var filename = (assetIdsFile instanceof File) ? assetIdsFile.name : assetIdsFile;\n      _loadTextFile(assetIdsFile, _assetListLoaded.bind(scope, assetGroup, filename), 'Error loading ids file');\n    } else {\n      _registerAssetGroup(assetGroup);\n    }\n  }\n\n  if (typeof assetMetadataFile === 'string') {\n    _loadTextFile(assetMetadataFile, _metadataLoaded.bind(scope), 'Error loading metadata file');\n  } else {\n    _metadataLoaded(assetMetadataFile);\n  }\n};\n\nAssetManager.prototype.__registerCustomAssetGroups = function (options) {\n  var scope = this;\n  var searchController = options.searchController || this.searchController;\n  var allAssetFiles = options.assetFiles;\n  allAssetFiles = _.map(allAssetFiles, function(x,i) {\n    if (typeof x === 'string') {\n      x = {metadata: x};\n    }\n    if (x.name == null) {\n      x.name = 'asset_' + i;\n    }\n    return x;\n  });\n  var assetFiles = allAssetFiles;\n  if (options.filter) {\n    assetFiles = _.filter(assetFiles, options.filter);\n  } else if (options.filterByAssetId) {\n    var sid = AssetManager.toSourceId(this.defaultSource, options.filterByAssetId);\n    assetFiles = _.filter(assetFiles, function(x) { return x.name === sid.source; });\n  } else if (options.filterBySource) {\n    var sources = Array.isArray(options.filterBySource)? options.filterBySource : [options.filterBySource];\n    assetFiles = _.filter(assetFiles, function(x) { return sources.indexOf(x.name) >= 0; });\n  } else if (options.filterByType) {\n    var types = Array.isArray(options.filterByType)? options.filterByType : [options.filterByType];\n    assetFiles = _.filter(assetFiles, function(x) { return types.indexOf(x.type) >= 0; });\n  }\n  if (assetFiles.length > 0) {\n    var assetGroupNames = _.map(assetFiles, 'name');\n    var assetsMap = _.keyBy(allAssetFiles, 'name');  // Have map be original set of assetFiles (so we can get dependencies)\n    var assetsToRegister = AssetGroups.getAssetsToRegister(assetsMap, assetGroupNames);\n    var finalAssetFiles = _.map(assetsToRegister, function(x) { return assetsMap[x]; });\n    async.mapLimit(finalAssetFiles, Constants.MAX_ASYNC_REQS, function (f, cb) {\n        f = _.cloneDeepWithReplaceVars(f, { baseUrl: Constants.baseUrl, assetsDir: Constants.assetsDir }, { optionalPrefix: 'vars'});\n        //console.log(f);\n        scope.registerCustomAssetGroup({\n          searchController: searchController,\n          assetIdField: f.assetIdField,\n          assetIdsFile: f.ids,\n          assetIdsFileFormat: f.assetIdsFileFormat,\n          assetType: f.type,\n          assetMetadataFile: f.metadata,\n          callback: function (err, res) {\n            if (f.callback) {\n              f.callback(err, res);\n            }\n            // Ignore errors (don't need all to load successfully)\n            cb(null, res);\n          }\n        });\n      },\n      function (err, results) {\n        //console.log('registered ', err, results);\n        if (options.callback) {\n          options.callback(err, results);\n        }\n      });\n  } else {\n    if (options.callback) {\n      options.callback('No assets to register');\n    }\n  }\n};\n\nAssetManager.prototype.registerCustomAssetGroups = function (options) {\n  function handleError(err) {\n    console.error('Error registering custom asset groups', err);\n    if (options.callback) {\n      options.callback(err);\n    }\n  }\n  if (options.assetFiles) {\n    if (_.isArray(options.assetFiles)) {\n      // Array of asset files\n      this.__registerCustomAssetGroups(options);\n    } else if (_.isString(options.assetFiles)) {\n      // File to assets\n      var scope = this;\n      var assetLoader = this.assetLoader;\n      assetLoader.load(options.assetFiles, 'json',\n        function(data) {\n          var opts = _.clone(options);\n          opts.assetFiles = data;\n          scope.__registerCustomAssetGroups(opts);\n        },\n        null,\n        handleError\n      );\n    } else {\n      handleError('Unsupported type for assetFiles');\n    }\n  } else {\n    handleError('Missing assetFiles');\n  }\n};\n\nAssetManager.prototype.loadSoundSpecs = function(assetGroup, cb) {\n  if (!assetGroup.sounds && assetGroup.soundsFile) {\n    _.getJSON(assetGroup.soundsFile, function(err, json) {\n      if (json) {\n        assetGroup.sounds = new Sounds();\n        assetGroup.sounds.import(json);\n      }\n      cb(err, assetGroup.sounds);\n    });\n  } else {\n    cb(null, assetGroup.sounds);\n  }\n};\n\nmodule.exports = AssetManager;\n\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetManager.js?");

/***/ }),

/***/ "./js/lib/assets/AssetsDb.js":
/*!***********************************!*\
  !*** ./js/lib/assets/AssetsDb.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// In memory database of asset infos\n// For quick and dirty assets\n\n\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar AssetLoader = __webpack_require__(/*! assets/AssetLoader */ \"./js/lib/assets/AssetLoader.js\");\nvar DataUtils = __webpack_require__(/*! data/DataUtils */ \"./js/lib/data/DataUtils.js\");\nvar IOUtil = __webpack_require__(/*! io/IOUtil */ \"./js/lib/io/IOUtil.js\");\nvar SolrQueryParser = __webpack_require__(/*! search/SolrQueryParser */ \"./js/lib/search/SolrQueryParser.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Simple in memory database of assets\n * @param params\n * @param [params.assetIdField='id'] {string} What field to use for asset id\n * @param [params.fieldOptions] {object}\n * @param [params.convertDataFn] {function(object): object} Convert asset info\n * @param [params.lazyConvertDataFn] {function(object): object} Lazy convert asset info\n * @param [params.groupDataFn] {function(object[]): object[]} Reshape asset info array\n * @param [params.defaults] {object}\n * @constructor\n * @memberOf assets\n */\nvar AssetsDb = function (params) {\n  params = params || {};\n  this.assetIdField = params.assetIdField || 'id';\n  this.fieldOptions = params.fieldOptions;\n  this.assetInfos = [];\n  this.assetIdToInfo = {};\n  this.lazyConvertDataFn = params.lazyConvertDataFn;\n  this.convertDataFn = params.convertDataFn;\n  this.groupDataFn = params.groupDataFn;\n  this.defaults = params.defaults;\n  this.fields = [];\n};\n\nAssetsDb.prototype.__getSimpleFilter = function(queryTerms) {\n  // Old style, simplified parsing\n  var queryPairs = queryTerms.map(function (x) { return x.split(':', 2); });\n  var filter = function (m) {\n    for (var i = 0; i < queryPairs.length; i++) {\n      var f = queryPairs[i][0];\n      var v = queryPairs[i][1];\n      if (v === '*') {\n        if (m[f] === null || m[f] === undefined) {\n          return false;\n        }\n      } else if (m[f] !== v) {\n        return false;\n      }\n    }\n    return true;\n  };\n  return filter;\n};\n\n/**\n * Execute basic query\n * @param params Query parameters\n * @param [params.query=*:*] {string} Query\n * @param [params.start=0] {int} Record to start at\n * @param [params.limit=0] {int} Limit on number of records to fetch\n * @param [params.sort] {string} Sort order\n * @param [params.fields] {string} Fields to return\n * @param [params.filter] {string} Additional filter (ex: '+datasets:ShapeNet')\n * @param callback Error first callback\n */\nAssetsDb.prototype.query = function (params, callback) {\n  var query = params.query;\n  var start = params.start || 0;\n  var limit = params.limit || 0;\n  query = query.trim();\n  if (query === '' || query === '*:*') {\n    var resp = this.getMatching(null, start, limit);\n    var data = { response: resp };\n    // parameters to callback: data, textStatus, jqXH\n    callback(null, data);\n  } else {\n    var queryTerms = query.split(' ');\n    if (queryTerms.length === 1 && queryTerms[0].startsWith('fullId:')) {\n      // Special handling if search by fullId\n      var assetInfo = this.getAssetInfo(queryTerms[0].substring('fullId:'.length));\n      var docs = [];\n      if (assetInfo) {\n        docs.push(assetInfo);\n      }\n      var data = { response: { docs: docs, start: 0, numFound: docs.length } };\n      callback(null, data);\n    } else {\n      var filter;\n      try {\n        // Try parsing with special solrQueryParser\n        filter = SolrQueryParser.getFilter(query);\n        //console.log(filter);\n      } catch (err) {\n        console.error('Invalid query \"' + query + '\": ' + err.message);\n        console.error(err);\n        // Try simple filter\n        filter = this.__getSimpleFilter(queryTerms);\n      }\n      var resp = this.getMatching(filter, start, limit);\n      var data = {response: resp};\n      // parameters to callback: data, textStatus, jqXH\n      callback(null, data);\n    }\n  }\n  // TODO: CHECK FOR ERRORS IN QUERY\n  //  callback('Unsupported query ' + query)\n};\n\nAssetsDb.prototype.getFilter = function(query) {\n  if (query == null || query === '' || query === '*:*') {\n    return null;\n  } else {\n    var filter;\n    try {\n      // Try parsing with special solrQueryParser\n      filter = SolrQueryParser.getFilter(query);\n      //console.log(filter);\n    } catch (err) {\n      console.error('Invalid query \"' + query + '\": ' + err.message);\n      console.error(err);\n      // Try simple filter\n      var queryTerms = query.split(' ');\n      filter = this.__getSimpleFilter(queryTerms);\n    }\n    return filter;\n  }\n};\n\nAssetsDb.prototype.getMatching = function (filter, start, limit, sort) {\n  if (start == null) {\n    start = 0;\n  }\n  if (limit == null) {\n    limit = 0;\n  }\n  var matched = [];\n  var nMatched = 0;\n  var infos = this.assetInfos;\n  if (sort) {\n    infos = sort(infos);\n  }\n  if (filter) {\n    for (var i = 0; i < infos.length; i++) {\n      var m = infos[i];\n      if (filter(m)) {\n        if (nMatched >= start && (limit <= 0 || matched.length < limit)) {\n          matched.push(m);\n        }\n        nMatched++;\n      }\n    }\n  } else {\n    if (limit > 0) {\n      matched = infos.slice(start, start + limit);\n    } else {\n      matched = infos.slice(start);\n    }\n    nMatched = infos.length;\n  }\n  if (this.lazyConvertDataFn) {\n    matched = _.map(matched, this.lazyConvertDataFn);\n  }\n  return { docs: matched, start: start, numFound: nMatched };\n};\n\nAssetsDb.prototype.getAssetInfo = function (assetId) {\n  var assetInfo = this.assetIdToInfo[assetId];\n  if (this.lazyConvertDataFn) {\n    return assetInfo? this.lazyConvertDataFn(assetInfo) : null;\n  } else {\n    return assetInfo;\n  }\n};\n\nAssetsDb.prototype.getAssetIds = function() {\n  return _.keys(this.assetIdToInfo);\n};\n\nAssetsDb.prototype.clear = function () {\n  this.assetInfos = [];\n  this.assetIdToInfo = {};\n};\n\nAssetsDb.prototype.__loadAssetInfoFromAssetIdList = function (assetGroup, data) {\n  var lines = data.split('\\n');\n  lines = lines.map(function (line) { return line.trim(); })\n    .filter(function (line) { return line.length > 0; });\n  var assetInfos = lines.map(function (s) {\n    return { id: s };\n  });\n  console.log('Got ' + assetInfos.length + ' assets');\n  return assetInfos;\n};\n\nAssetsDb.prototype.__updateAssetInfo = function(assetGroup, m) {\n  var assetIdField = this.assetIdField;\n  if (assetGroup) {\n    m['fullId'] = assetGroup.name + '.' + m[assetIdField];\n    m['source'] = assetGroup.name;\n    if (assetIdField !== 'id' && m['id'] == null) {\n      m['id'] = m[assetIdField];\n    }\n    if (assetGroup.assetFields && _.isArray(assetGroup.assetFields)) {\n      var loadInfo = assetGroup.getLoadInfo(m[assetIdField], m['format'], m);\n      _.defaults(m, _.pick(loadInfo, assetGroup.assetFields));\n    }\n  }\n  if (this.defaults) {\n    _.defaults(m, this.defaults);\n  }\n};\n\nAssetsDb.prototype.__loadAssetInfoFromCsvData = function (assetGroup, data) {\n  var scope = this;\n  var parsed = IOUtil.parseDelimited(data, { header: true, skipEmptyLines: true,\n    dynamicTyping: function(fieldname) {\n        // Make sure id is treated as a string, but other fields are dynamically typed\n        if (fieldname === scope.assetIdField || fieldname === 'id') {\n          return false;\n        } else {\n          return true;\n        }\n    }\n  });\n  var splitFields = assetGroup.arrayFields;\n  if (!splitFields) {\n    splitFields = _.get(Constants.assetTypes, [assetGroup.type, 'arrayFields']);\n  }\n  var assetInfos = parsed.data;\n  if (this.groupDataFn) {\n    assetInfos = this.groupDataFn(assetInfos);\n  }\n  for (var i = 0; i < assetInfos.length; i++) {\n    if (this.convertDataFn) {\n      assetInfos[i] = this.convertDataFn(assetInfos[i]);\n    }\n    var m = assetInfos[i];\n    if (splitFields) {\n      _.each(m, function(v,k) {\n        if (splitFields.indexOf(k) >= 0 && v != undefined) {\n          if (typeof(v) != 'string') {\n            v = v.toString();\n          }\n          v = v.trim();\n          if (v.length > 0) {\n            m[k] = v.split(',');\n          } else {\n            m[k] = [];\n          }\n        }\n      });\n    }\n  }\n  console.log('Got ' + assetInfos.length + ' assets');\n  return assetInfos;\n};\n\nAssetsDb.prototype.__loadAssetInfoFromJsonData = function (assetGroup, data) {\n  if (typeof data === 'string') {\n    data = JSON.parse(data);\n  }\n  var assetInfos = data;\n  console.log('Got ' + assetInfos.length + ' assets for ' + assetGroup.name);\n  return assetInfos;\n};\n\nAssetsDb.prototype.__loadAssetInfoFromJsonlData = function (assetGroup, data) {\n  if (typeof data === 'string') {\n    data = IOUtil.parseJsonl(data, { flatten: true });\n  }\n  var assetInfos = data;\n  console.log('Got ' + assetInfos.length + ' assets for ' + assetGroup.name);\n  return assetInfos;\n};\n\nAssetsDb.prototype.loadAssetInfoFromData = function (assetGroup, data, filename, options) {\n  options = options || {};\n  var assetInfos;\n  if (filename.endsWith('json') || options.format === 'json') {\n    assetInfos = this.__loadAssetInfoFromJsonData(assetGroup, data);\n  } else if (filename.endsWith('jsonl') || options.format === 'jsonl') {\n    assetInfos = this.__loadAssetInfoFromJsonlData(assetGroup, data);\n  } else if (filename.endsWith('csv') || filename.endsWith('tsv') || options.format === 'csv' || options.format === 'tsv') {\n    assetInfos = this.__loadAssetInfoFromCsvData(assetGroup, data);\n  } else {\n    assetInfos = this.__loadAssetInfoFromAssetIdList(assetGroup, data);\n  }\n\n  this.assetIdField = options.assetIdField || this.assetIdField;\n  var assetIdField = this.assetIdField;\n  if (options.mode === 'merge' && options.assetField) {\n    for (var i = 0; i < assetInfos.length; i++) {\n      var m = assetInfos[i];\n      var fullId = assetGroup.name + '.' + m[assetIdField];\n      var asset = this.assetIdToInfo[fullId];\n      _.set(asset, options.assetField, _.omit(m, [assetIdField, 'fullId', 'source']));\n    }\n  } else {\n    var assetIdToInfo = {};\n    for (var i = 0; i < assetInfos.length; i++) {\n      var m = assetInfos[i];\n      this.__updateAssetInfo(assetGroup, m);\n      m.isCustomAsset = true;\n      assetIdToInfo[m.fullId] = m;\n    }\n    this.assetInfos = assetInfos;\n    this.assetIdToInfo = assetIdToInfo;\n    this.fields = DataUtils.extractFieldsFromData(this.assetInfos, this.fieldOptions);\n  }\n};\n\nAssetsDb.prototype.loadAssetInfo = function (assetGroup, file, callback, options) {\n  var scope = this;\n  var loader = new AssetLoader();\n  return loader.loadErrorFirst(file, undefined, function(err, data) {\n    if (!err) {\n      scope.loadAssetInfoFromData(assetGroup, data, file.name || file, options);\n    }\n    if (callback) {\n      callback(err, scope);\n    }\n  });\n};\n\nmodule.exports = AssetsDb;\n\n\n//# sourceURL=webpack://STK/./js/lib/assets/AssetsDb.js?");

/***/ }),

/***/ "./js/lib/assets/CachedAssetLoader.js":
/*!********************************************!*\
  !*** ./js/lib/assets/CachedAssetLoader.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AssetCache = __webpack_require__(/*! assets/AssetCache */ \"./js/lib/assets/AssetCache.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction LoadingAsset(id) {\n  // Asset is in progress\n  this.id = id;\n  this.__callbacks = [];\n}\n\nLoadingAsset.prototype.addCallback = function (fn) {\n  this.__callbacks.push(fn);\n};\n\nLoadingAsset.prototype.done = function (err, value) {\n  //console.log('asset done ' + this.id + ' notify ' + this.__callbacks.length);\n  //console.log(value);\n  // Call all the callbacks\n  for (var i = 0; i < this.__callbacks.length; i++) {\n    this.__callbacks[i](err, value);\n  }\n};\n\n/**\n * Smart asset loader that can cache and not send multiple requests if an asset is already being fetched\n * @param params\n * @constructor\n * @memberOf assets\n */\nfunction CachedAssetLoader(params) {\n  params = params || {};\n  // Cache of assets\n  this.__defaultLoadFn = params.loadFn;\n  this.__assetCache = (params.assetCacheSize >= 0) ? new AssetCache(params.assetCacheSize) : undefined;\n  this.__loading = {};\n  this.debug = false;\n}\n\nCachedAssetLoader.prototype.getCache = function() {\n  return this.__assetCache;\n};\n\nCachedAssetLoader.prototype.get = function(key) {\n  return this.__assetCache.get(key);\n};\n\nCachedAssetLoader.prototype.getOrElse = function(key, fetch, dispose) {\n  return this.__assetCache.getOrElse(key, fetch, dispose);\n};\n\nCachedAssetLoader.prototype.load = function(opts) {\n  opts = _.defaults(new Object(null), opts, {\n    cache: this.__assetCache,\n    loadFn: this.__defaultLoadFn\n  });\n  return this.__loadAsset(opts);\n};\n\nCachedAssetLoader.prototype.__loadAsset = function(opts) {\n  var cache = opts.cache;\n  var key = opts.key;\n  var callback = opts.callback;\n  var loadFn = opts.loadFn;\n  var loadOpts = opts.loadOpts;\n  var skipCache = opts.skipCache;\n\n  if (cache && key) {\n    var asset = skipCache? undefined : cache.get(key);\n    if (asset != undefined) {\n      if (this.debug) {\n        console.log('Load asset (from cache): ' + key);\n      }\n      callback(null, asset);\n    } else {\n      // Load and add to asset cache\n      var scope = this;\n      var loadingAsset = this.__loading[key];\n      if (loadingAsset) {\n        if (this.debug) {\n          console.log('Load asset (add listener): ' + key);\n        }\n        loadingAsset.addCallback(callback);\n      } else {\n        if (this.debug) {\n          console.log('Load asset (new request): ' + key);\n        }\n        loadingAsset = new LoadingAsset(key);\n        loadingAsset.addCallback(function (err, x) {\n          if (!err) {\n            if (!skipCache) {\n              cache.set(key, x, null, opts.dispose);\n            }\n          } else {\n            console.error('Error fetching ' + key, err);\n          }\n          delete scope.__loading[key];\n        });\n        loadingAsset.addCallback(callback);\n        scope.__loading[key] = loadingAsset;\n        return loadFn(loadOpts, function(err, result) {\n          loadingAsset.done(err, result);\n        });\n      }\n    }\n  } else {\n    return loadFn(loadOpts, function(err, result) {\n      callback(err, result);\n    });\n  }\n};\n\nmodule.exports = CachedAssetLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/assets/CachedAssetLoader.js?");

/***/ }),

/***/ "./js/lib/assets/LightsLoader.js":
/*!***************************************!*\
  !*** ./js/lib/assets/LightsLoader.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\n\nfunction LightsLoader(params) {\n  params = params || {};\n  this.enableLights = params.enableLights;\n  this.defaultLightState = params.defaultLightState;\n  this.intensityScale = params.intensityScale || (1 / 60);  // TODO(MS): Properly map light unit\n  this.shadowBias = params.shadowBias || 0.005;\n  this.lights = {};\n}\n\nLightsLoader.prototype.__specToLight = function (s) {\n  var light = null;\n\n  var color = new THREE.Color(s.color);\n  var position = new THREE.Vector3(s.position[0], s.position[1], s.position[2]);\n  var intensity = s.power * this.intensityScale;\n  var distance = 5*Constants.metersToVirtualUnit;\n  var shadowMapSize = 512;\n\n  if (s.type === 'PointLight') {\n    light = new THREE.PointLight(color, intensity, distance, 2);\n    light.position.copy(position);\n  } else if (s.type === 'SpotLight') {\n    light = new THREE.SpotLight(color, intensity, distance, s.cutoffAngle, 0.25, 2);\n    light.position.copy(position);\n    var direction = new THREE.Vector3(s.direction[0], s.direction[1], s.direction[2]);\n    light.target.position.copy(position).add(direction);\n  } else if (s.type === 'LineLight') {\n    var p2 = new THREE.Vector3(s.position2[0], s.position2[1], s.position2[2]);\n    var midpoint = position.add(p2).multiplyScalar(0.5);\n    light = new THREE.SpotLight(color, intensity, distance, s.cutoffAngle, 0.25, 2);\n    light.position.copy(midpoint);\n    var direction = new THREE.Vector3(s.direction[0], s.direction[1], s.direction[2]);\n    light.target.position.copy(midpoint).add(direction);\n  }\n\n  if (light) {\n    light.name = s.type;\n    light.power = s.power / 5;\n    if (light.shadow) {\n      light.shadow.bias = this.shadowBias;\n      light.shadow.mapSize.set(shadowMapSize, shadowMapSize);\n    }\n    // Should already be set by distance passed into the light\n    //if (light.shadow.camera) { light.shadow.camera.far = distance; }\n    light.userData.intensity = light.intensity;\n    light.userData.isOn = this.defaultLightState;\n    light.intensity = this.defaultLightState ? light.intensity : 0;\n  }\n\n  return light;\n};\n\nLightsLoader.prototype.createLights = function (modelInfo, object3D) {\n  if (!this.enableLights || !modelInfo.lightSpecs) {\n    return null;\n  }\n\n  var lights = [];\n\n  var modelId = modelInfo.id;\n  if (!this.lights[modelId]) {\n    this.lights[modelId] = [];\n  }\n  var lightsBin = this.lights[modelId];\n\n  var specs = modelInfo.lightSpecs.lights;\n  if (!specs) { return null; }\n  for (var i = 0; i < specs.length; ++i) {\n    if (!lightsBin[i]) {\n      lightsBin[i] = this.__specToLight(specs[i]);\n    }\n    lights[i] = lightsBin[i].clone();\n  }\n  // if object3D given, add lights and mark default light state\n  if (object3D) {\n    lights.forEach(function (light) { object3D.add(light);});\n    object3D.userData.lightsOn = this.defaultLightState;\n  }\n\n  //console.log('Lights:', lights);\n  return lights;\n};\n\nmodule.exports = LightsLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/assets/LightsLoader.js?");

/***/ }),

/***/ "./js/lib/audio/Sounds.js":
/*!********************************!*\
  !*** ./js/lib/audio/Sounds.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction Sounds() {\n  // Index of sound files\n  this.__soundsByModelId = {};\n  this.__soundsByCategory = {};\n}\n\nSounds.prototype.getModelSounds = function(modelInfo) {\n  var modelId = modelInfo.id;\n  var res = {};\n  var categories = modelInfo.category;\n  for (var i = 0; i < categories.length; i++) {\n    var c = categories[i];\n    var soundsForCategory = this.__soundsByCategory[c];\n    if (soundsForCategory) {\n      _.merge(res, soundsForCategory);\n    }\n  }\n  var soundsForModel = this.__soundsByModelId[modelId];\n  if (soundsForModel) {\n    _.merge(res, soundsForModel);\n  }\n  return res;\n};\n\nSounds.prototype.import = function(json) {\n  this.__sounds = json;\n  for (var i = 0; i < json.length; i++) {\n    var s = json[i];\n    //console.log('processing ', s);\n    if (s.modelIds) {\n      for (var j = 0; j < s.modelIds.length; j++) {\n        this.__soundsByModelId[s.modelIds[j]] = s.sounds;\n      }\n    } else if (s.category) {\n      if (Array.isArray(s.category)) {\n        for (var j = 0; j < s.category.length; j++) {\n          this.__soundsByCategory[s.category[j]] = s.sounds;\n        }\n      } else {\n        this.__soundsByCategory[s.category] = s.sounds;\n      }\n    }\n  }\n  // console.log('soundsByModelId', this.__soundsByModelId);\n  // console.log('soundsByCategory', this.__soundsByCategory);\n};\n\nmodule.exports = Sounds;\n\n//# sourceURL=webpack://STK/./js/lib/audio/Sounds.js?");

/***/ }),

/***/ "./js/lib/capabilities/LightControls.js":
/*!**********************************************!*\
  !*** ./js/lib/capabilities/LightControls.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\nfunction LightControls(params) {\n  this.object3D = params.object3D;\n  this.modelInstance = params.modelInstance || Object3DUtil.getModelInstance(this.object3D);\n  this.assetManager = params.assetManager;\n  this.isOn = this.modelInstance? this.modelInstance.getLightState() : this.object3D.userData.lightsOn;\n\n  var scope = this;\n  this.getOperations = function() {\n    return ['turnOn', 'turnOff', 'toggle'];\n  };\n\n  this.setLights = function(flag) {\n    scope.isOn = flag;\n    if (scope.modelInstance) {\n      scope.modelInstance.setLightState(flag, scope.assetManager);\n    } else {\n      Object3DUtil.setLights(scope.object3D, flag);\n    }\n    return scope.isOn;\n  };\n\n  this.turnOn = function() {\n    return scope.setLights(true);\n  };\n\n  this.turnOff = function() {\n    return scope.setLights(false);\n  };\n\n  this.toggle = function() {\n    if (scope.isOn) {\n      scope.turnOff();\n    } else {\n      scope.turnOn();\n    }\n    return scope.isOn;\n  };\n}\n\nmodule.exports = LightControls;\n\n//# sourceURL=webpack://STK/./js/lib/capabilities/LightControls.js?");

/***/ }),

/***/ "./js/lib/capabilities/Mirror.js":
/*!***************************************!*\
  !*** ./js/lib/capabilities/Mirror.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n__webpack_require__(/*! three-mirror */ \"./js/vendor/three/gfx/Mirror.js\");\n\nfunction Mirror(opts) {\n  this.object3D = opts.object3D;\n  this.mirrorMaterials = opts.mirrorMaterials;\n  this.assetManager = opts.assetManager;\n  this.ignoreSelfModel = opts.ignoreSelfModel;\n  this.camera = opts.camera;\n\n  if (THREE.CombinedCamera && this.camera instanceof THREE.CombinedCamera) {\n    //console.log('Using combined camera');\n    this.combinedCamera = this.camera;\n    this.camera = this.combinedCamera.cameraP;\n  }\n\n  this.mirror = new THREE.Mirror(\n    opts.renderer,\n    this.camera,\n    { debugMode: false, textureWidth: opts.width, textureHeight: opts.height, color: opts.color }\n  );\n\n  // TODO: Handle multiple mirror on same object....\n  var scope = this;\n  _.each(this.mirrorMaterials, function(mat) {\n    mat.mesh.add(scope.mirror);\n    mat.setMaterial(scope.mirror.material);\n  });\n\n  this.assetManager.Publish('dynamicAssetLoaded', this);\n}\n\nMirror.prototype.__update = function() {\n  if (this.combinedCamera) {\n    this.combinedCamera.updateProjectionMatrix();\n    this.camera.updateProjectionMatrix();\n  }\n  //this.mirror.matrixNeedsUpdate = true;\n  this.mirror.render();\n};\n\nMirror.prototype.update = function() {\n  if (this.ignoreSelfModel) {\n    var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n    var modelInstance = Object3DUtil.getModelInstance(this.object3D, true);\n    if (modelInstance) {\n      Object3DUtil.setVisible(modelInstance.object3D, false);\n    }\n    this.__update();\n    if (modelInstance) {\n      Object3DUtil.setVisible(modelInstance.object3D, true);\n    }\n  } else {\n    this.__update();\n  }\n};\n\nMirror.prototype.destroy = function() {\n\n};\n\nmodule.exports = Mirror;\n\n//# sourceURL=webpack://STK/./js/lib/capabilities/Mirror.js?");

/***/ }),

/***/ "./js/lib/capabilities/VideoPlayer.js":
/*!********************************************!*\
  !*** ./js/lib/capabilities/VideoPlayer.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// Add functions to object3D that allows for toggling of video\nfunction VideoPlayer(params) {\n  this.object3D = params.object3D;\n  this.videoMaterials = params.videoMaterials;\n  this.assetManager = params.assetManager;\n  this.isOn = false;\n  this.isPaused = false;\n\n  var scope = this;\n\n  this.getOperations = function() {\n    return ['load', 'pause', 'play', 'turnOn', 'turnOff', 'toggle'];\n  };\n\n  this.load = function(path) {\n    scope.videoTexture = scope.assetManager.loadVideoTexture(path);\n    scope.videoMaterial = new THREE.MeshBasicMaterial( {\n      name: \"video\",\n      map: scope.videoTexture.texture,\n      overdraw: 0.5 // TODO: what is right value here?\n    });\n    scope.videoMaterial.video = scope.videoTexture.video;\n  };\n\n  this.__pause = function() {\n    scope.videoTexture.video.pause();\n  };\n\n  this.pause = function() {\n    scope.__pause();\n    scope.isPaused = true;\n  };\n\n  this.play = function(path) {\n    if (path || !scope.videoTexture) {\n      scope.load(path);\n    }\n    if (!scope.isOn) {\n      scope.__turnOn();\n    }\n    scope.videoTexture.video.play();\n    scope.isPaused = false;\n  };\n\n  this.__turnOn = function() {\n    _.each(scope.videoMaterials, function(mat) {\n      mat.setMaterial(scope.videoMaterial);\n    });\n    scope.isOn = true;\n    return scope.isOn;\n  };\n\n  this.turnOn = function() {\n    if (!scope.isOn) {\n      scope.play();\n    }\n  };\n\n  this.turnOff = function() {\n    scope.__pause();\n    _.each(scope.videoMaterials, function(mat) {\n      mat.setMaterial(mat.material);\n    });\n    scope.isOn = false;\n    return scope.isOn;\n  };\n\n  this.toggle = function() {\n    if (scope.isOn) {\n      scope.turnOff();\n    } else {\n      scope.turnOn();\n    }\n    return scope.isOn;\n  };\n}\n\nmodule.exports = VideoPlayer;\n\n//# sourceURL=webpack://STK/./js/lib/capabilities/VideoPlayer.js?");

/***/ }),

/***/ "./js/lib/controls/CameraControls.js":
/*!*******************************************!*\
  !*** ./js/lib/controls/CameraControls.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar ViewGenerator = __webpack_require__(/*! gfx/ViewGenerator */ \"./js/lib/gfx/ViewGenerator.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\n__webpack_require__(/*! three-controls */ \"./js/vendor/three/controls.js\");\n\nfunction CameraControls(params) {\n  this.camera = params.camera;\n  this.container = params.container;\n  this.autoRotateCheckbox = params.autoRotateCheckbox;\n  if (this.autoRotateCheckbox) this.autoRotateCheckbox.change(function () {\n    this.updateAutoRotate();\n  }.bind(this));\n  this.renderCallback = params.renderCallback;\n  this.controlType = params.controlType || 'orbit';\n  this.clock = new THREE.Clock();\n  this.cameraStates = [];\n  this.allControls = {};\n  if (this.controlType !== 'none') {\n    this.setControls();\n  }\n  this.movementSpeed = this.camera.far / 25;\n  this.defaultDistanceScale = 1.0;\n  this.cameraPositionStrategy = params.cameraPositionStrategy || 'positionToFit';\n}\n\nCameraControls.prototype = Object.create(ViewGenerator.prototype);\nCameraControls.prototype.constructor = CameraControls;\n\nObject.defineProperty(CameraControls.prototype, 'lastViewConfig', {\n  get: function () {return this.__lastViewConfig; }\n});\n\nCameraControls.prototype.setControls = function () {\n  //console.log(\"Using control type \" + this.controlType);\n  var oldControls = this.controls;\n  if (oldControls) {\n    if (oldControls.enabled) {\n      oldControls.enabled = false;\n    }\n  }\n  if (this.orbitControls) {\n    this.orbitControls.enabled = false;\n    this.orbitControls = null;\n  }\n  if (this.controlType === 'trackballWithOrbit' ||\n    this.controlType === 'trackballNoOrbit' ||\n    this.controlType === 'trackball') {\n    var trackBallControls = this.getControls('trackball', true);\n    var useOrbitControls = (this.controlType === 'trackballWithOrbit');\n    var orbitControls = this.getControls('orbit', useOrbitControls);\n    if (orbitControls) {\n      orbitControls.enabled = !orbitControls;\n      this.updateAutoRotate(orbitControls);\n    }\n    // trackBallControls.noZoom = useOrbitControls;  // Use orbit controls for zoom\n\n    if (useOrbitControls) this.orbitControls = orbitControls;\n    this.controls = trackBallControls;\n    this.controls.enabled = true;\n  } else if (this.controlType === 'firstPerson') {\n    this.controls = this.getControls(this.controlType, true);\n    this.controls.enabled = true;\n    this.controls.movementSpeed = this.movementSpeed;\n  } else if (this.controlType === 'firstPersonClickDrag') {\n    this.controls = this.getControls(this.controlType, true);\n    this.controls.enabled = true;\n    this.controls.movementSpeed = this.movementSpeed;\n  } else if (this.controlType === 'pointerLock') {\n    // Not working\n    this.controls = this.getControls(this.controlType, true);\n    this.controls.enabled = true;\n  } else if (this.controlType === 'orbit' || this.controlType === 'orbitRightClick') {\n    this.controls = this.getControls(this.controlType, true);\n    this.controls.enabled = true;\n    this.controls.userRotate = false;\n    this.updateAutoRotate(this.controls);\n    this.orbitControls = this.controls;\n  } else if (this.controlType === 'fly') {\n    // Not tested\n    this.controls = this.getControls(this.controlType, true);\n    this.controls.enabled = true;\n    this.controls.movementSpeed = this.movementSpeed * Constants.metersToVirtualUnit;\n    this.controls.movementSpeed = 0.005 * this.movementSpeed * Constants.metersToVirtualUnit;\n  } else {\n    console.error('Invalid controlType: ' + this.controlType);\n  }\n\n  if (oldControls) {\n    if (oldControls.target && this.controls.target) {\n      this.controls.target.copy(oldControls.target);\n    }\n  }\n};\n\n\nCameraControls.prototype.getControls = function (controlType, createControls) {\n  var controls = this.allControls[controlType];\n  if (!controls && createControls) {\n    controls = this.createControls(controlType);\n    if (controls) this.allControls[controlType] = controls;\n  }\n  return controls;\n};\n\nCameraControls.prototype.createControls = function (controlType) {\n  //console.log(\"Creating controller for control type \" + controlType);\n  var controls = null;\n  if (controlType === 'trackball') {\n    // Create trackball controls with reasonable defaults\n    // Used for panning (right mouse button) and rotating (left mouse button)\n    controls = new THREE.TrackballControls(this.camera, this.container);\n\n    controls.rotateSpeed = 1.0;\n    controls.zoomSpeed = 1.2;\n    controls.panSpeed = 0.8;\n\n    controls.noZoom = false;\n    controls.noPan = false;\n\n    controls.staticMoving = true;\n    controls.dynamicDampingFactor = 0.3;\n\n    // keys for rotate, zoom, pan (press and hold?)\n    controls.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n    controls.addEventListener('change', this.renderCallback);\n\n    // Prevent default mousewheel action (zoom in/out on mousewheel)\n    this.container.addEventListener('mousewheel', this.mousewheel.bind(this), false);\n  } else if (controlType === 'firstPerson') {\n    controls = new THREE.FirstPersonControls(this.camera, this.container);\n    controls.activeLook = false;\n    controls.movementSpeed = this.movementSpeed;\n  } else if (controlType === 'firstPersonClickDrag') {\n    controls = new THREE.FirstPersonControlsClickDragRotation(this.camera, this.container);\n    controls.activeLook = false;\n    controls.movementSpeed = this.movementSpeed;\n  } else if (controlType === 'pointerLock') {\n    // Not working\n    controls = new THREE.PointerLockControls(this.camera);\n  } else if (controlType === 'orbit') {\n    // Use orbit controls for the auto rotate\n    controls = new THREE.OrbitControls(this.camera, this.container);\n    controls.enableKeys = false;\n    controls.userRotate = false;\n    this.updateAutoRotate(controls);\n    controls.addEventListener('change', this.renderCallback);\n  } else if (controlType === 'orbitRightClick') {\n    // Use orbit controls for the auto rotate\n\n    controls = new THREE.OrbitControls(this.camera, this.container);\n    controls.mouseMappings = [\n      { action: controls.actions.PAN,    button: THREE.MOUSE.RIGHT, keys: ['shiftKey'] },\n      { action: controls.actions.ORBIT,  button: THREE.MOUSE.RIGHT },\n      { action: controls.actions.ZOOM,   button: THREE.MOUSE.MIDDLE }\n    ];\n    controls.enableKeys = false;\n    controls.userRotate = false;\n    this.updateAutoRotate(controls);\n    controls.addEventListener('change', this.renderCallback);\n  } else if (controlType === 'fly') {\n    controls = new THREE.FlyControls(this.camera, this.container);\n  } else {\n    console.error('Invalid controlType: ' + controlType);\n  }\n  return controls;\n};\n\nCameraControls.prototype.setControlType = function (controlType) {\n  // TODO: Make it so we can switch between control types...doesn't quite work\n  if (controlType !== this.controlType) {\n    // we are trying to switch the controlType...\n    this.controlType = controlType;\n    // TODO: Cleanup events for old controls or at least disable old controls\n    this.setControls();\n  }\n};\n\nCameraControls.prototype.mousewheel = function (event) {\n  event.preventDefault();\n  event.stopPropagation();\n};\n\nCameraControls.prototype.update = function () {\n  if (this.orbitControls && this.controls !== this.orbitControls) this.orbitControls.update();\n  this.controls.update(this.clock.getDelta());\n};\n\nCameraControls.prototype.handleResize = function () {\n  if (this.controls && this.controls.handleResize) {\n    this.controls.handleResize();\n  }\n};\n\nCameraControls.prototype.updateAutoRotate = function (controls) {\n  if (!controls) controls = this.orbitControls;\n  if (controls && this.autoRotateCheckbox) {\n    controls.autoRotate = this.autoRotateCheckbox.prop('checked');\n  }\n};\n\nCameraControls.prototype.setAutoRotate = function (flag, controls) {\n  if (!controls) controls = this.orbitControls;\n  if (controls) {\n    if (this.autoRotateCheckbox) {\n      this.autoRotateCheckbox.prop('checked', flag);\n    }\n    controls.autoRotate = flag;\n  }\n};\n\nCameraControls.prototype.getAutoRotate = function (controls) {\n  if (!controls) controls = this.orbitControls;\n  if (controls) {\n    return controls.autoRotate || false;\n  } else { return false; }\n};\n\nCameraControls.prototype.setAutoRotateSpeed = function (speed, controls) {\n  if (!controls) controls = this.orbitControls;\n  if (controls) {\n    controls.autoRotateSpeed = speed;\n  }\n};\n\nCameraControls.prototype.timedAutoRotate = function (totalMillis, speed, callback, controls) {\n  this.setAutoRotateSpeed(speed, controls);\n  this.setAutoRotate(true, controls);\n  var timeoutID = window.setTimeout(function () {\n    this.setAutoRotate(false, controls);\n    if (callback) {\n      callback(timeoutID);\n    }\n  }.bind(this), totalMillis);\n};\n\n/**\n * View target\n * @param options\n * @param [options.target] {THREE.Vector3} Target point to look at (if not specified, then must specify `targetBBox` - then the `targetBBox` centroid is used as target)\n * @param [options.position] {THREE.Vector3} Camera position to look from (if not specified, then must specify `targetBBox` - then the `target` and `targetBBox` along with other parameters are used to determine the position)\n * @param [options.targetBBox] {geo.BBox} Target bounding box to look at (used if either `target` or `position` not specified)\n * @param [options.up] {THREE.Vector3} Camera up (existing camera up is used if not specified)\n * @param [options.lookatUp] {THREE.Vector3} Up to use for lookat computation (`up` is used if not specified)\n * @param [options.distanceScale=this.defaultDistanceScale] {number}\n * @param [options.viewIndex] {int}\n * @param [options.theta] {number}\n * @param [options.phi] {number}\n * @param [options.fitRatio] {number}\n * @param [options.defaultPosition] {number}\n * @param [options.fov] {number} Vertical field of view (in radians)\n * @param [options.near] {number} Near in virtual units\n * @param [options.far] {number} Far in virtual units\n */\nCameraControls.prototype.viewTarget = function (options) {\n  // console.log('view', options);\n  var target = Object3DUtil.toVector3(options.target);        // Target to look at\n  var position = Object3DUtil.toVector3(options.position);    // Camera position\n  var up = Object3DUtil.toVector3(options.up);  // Up direction\n  var lookatUp = Object3DUtil.toVector3(options.lookatUp) || up;  // Up to use for looking at target\n  var distanceScale = options.distanceScale || this.defaultDistanceScale;\n\n  this.__lastViewConfig = {\n    target: target? target.toArray() : undefined,\n    targetBBox: options.targetBBox? options.targetBBox.toJSON() : undefined,\n    eye: position? position.toArray() : undefined,\n    lookatUp: lookatUp? lookatUp.toArray() : undefined,\n    distanceScale: distanceScale,\n    theta: options.theta,\n    phi: options.phi,\n    fitRatio: options.fitRatio,\n    viewIndex: options.viewIndex\n  };\n  if ((!target || !position) && options.targetBBox) {\n    // Don't have a precise point, but a bbox\n    var bb = options.targetBBox;\n    var centroid = bb.centroid();\n    // Figure out a good position for the camera\n    if (!target) target = centroid;\n    if (!position) {\n      var dims = bb.dimensions();\n      var maxDim = Math.max(dims.x, dims.y, dims.z);\n      this.camera.near = maxDim / Constants.defaultCamera.nearFarMultiplier;\n      this.camera.far = maxDim * Constants.defaultCamera.nearFarMultiplier;\n      //console.log('changing camera near/far to ' + this.camera.near + '/' + this.camera.far);\n      if (THREE.CombinedCamera && this.camera instanceof THREE.CombinedCamera) {\n        this.camera.updateNearFar();\n      }\n      this.movementSpeed = maxDim / 5;\n      var viewIndex = options.viewIndex;\n      if (viewIndex === undefined || viewIndex <= 0) {\n        if (options.theta !== undefined/* latitude */ && options.phi !== undefined /* longitude */) {\n          var viewbb = bb;\n          if (options.fitRatio) {\n            viewbb =  viewbb.scaleBy(options.fitRatio);\n          }\n          var view = this.getViewForBBox({ name: 'view', target: viewbb, theta: options.theta, phi: options.phi, dists: distanceScale});\n          position = Object3DUtil.toVector3(view.position);\n        } else if (options.defaultPosition) {\n          position = options.defaultPosition;\n        } else {\n          position = new THREE.Vector3(centroid.x, centroid.y, bb.min.z - maxDim * distanceScale);\n        }\n      } else {\n        var views = [\n          new THREE.Vector3(bb.min.x - maxDim * distanceScale, centroid.y, centroid.z),\n          new THREE.Vector3(bb.max.x + maxDim * distanceScale, centroid.y, centroid.z),\n          new THREE.Vector3(centroid.x, bb.min.y - maxDim * distanceScale, centroid.z),\n          new THREE.Vector3(centroid.x, bb.max.y + maxDim * distanceScale, centroid.z),\n          new THREE.Vector3(centroid.x, centroid.y, bb.min.z - maxDim * distanceScale),\n          new THREE.Vector3(centroid.x, centroid.y, bb.max.z + maxDim * distanceScale)\n        ];\n        position = views[viewIndex - 1];\n      }\n    }\n    //console.log(bb);\n    //console.log(target);\n    //console.log(position);\n  }\n  // Set up to use for lookAt\n  var cameraUp = up || this.camera.up.clone();\n  if (lookatUp) {\n    this.camera.up.copy(lookatUp);\n  }\n  this.camera.position.copy(position);\n  this.camera.lookAt(target);\n\n  // Adjust left/right/top/bottom for orthographic camera\n  if (this.camera instanceof THREE.OrthographicCamera) {\n    // The size that we set is the mid plane of the viewing frustum\n    var hyperfocus = target.clone().sub(this.camera.position).length();\n    var halfHeight = Math.tan( this.camera.fov * Math.PI / 180 / 2 ) * hyperfocus;\n    var planeHeight = 2 * halfHeight;\n    var planeWidth = planeHeight * this.camera.aspect;\n    var halfWidth = planeWidth / 2;\n\n    this.camera.left = - halfWidth;\n    this.camera.right = halfWidth;\n    this.camera.top = halfHeight;\n    this.camera.bottom = - halfHeight;\n  }\n\n  if (options.fov) {\n    this.camera.fov = options.fov;\n  }\n  if (options.near) {\n    this.camera.near = options.near;\n  }\n  if (options.far) {\n    this.camera.far = options.far;\n  }\n\n  //console.log(\"Camera should look at: \" );\n  //console.log(target);\n  this.__setControlsTarget(target);\n\n  // Set back up to use for camera\n  this.camera.up.copy(cameraUp);\n  this.camera.updateMatrix();\n  this.camera.updateProjectionMatrix(target);\n};\n\nCameraControls.prototype.__setControlsTarget = function (target) {\n  if (this.controls) {\n    if (target && this.controls.target) {\n      this.controls.target.copy(target);\n      // If first person camera set the movement to be somewhat reasonable based on camera far/near\n      if (this.controlType === 'firstPerson' || this.controlType === 'firstPersonClickDrag') {\n        this.controls.movementSpeed = this.movementSpeed;\n      } else if (this.controlType === 'fly') {\n        this.controls.movementSpeed = this.movementSpeed * Constants.metersToVirtualUnit;\n        this.controls.rollSpeed = 0.005 * this.movementSpeed * Constants.metersToVirtualUnit;\n      } else if (this.controlType === 'pointerLock') {\n      }\n    }\n    this.controls.update();\n  }\n};\n\nCameraControls.prototype.saveCameraState = function (clearCameraStates) {\n  if (clearCameraStates) {\n    this.cameraStates.length = 0;\n  }\n  var cameraState = this.getCurrentCameraState();\n  this.cameraStates.push(cameraState);\n};\n\nCameraControls.prototype.getCurrentCameraState = function () {\n  var cameraState = {\n    position: (this.camera.position) ? this.camera.position.clone() : undefined,\n    target: (this.controls.target) ? this.controls.target.clone() : undefined,\n    up: (this.camera.up) ? this.camera.up.clone() : undefined\n  };\n  if (this.camera instanceof THREE.CombinedCamera) {\n    cameraState['isOrtho'] = this.camera.inOrthographicMode;\n  }\n  return cameraState;\n};\n\nCameraControls.prototype.resetCamera = function () {\n  this.restoreCameraState();\n};\n\nCameraControls.prototype.restoreCameraState = function (state) {\n  if (!state && this.cameraStates.length > 0) {\n    state = this.cameraStates[this.cameraStates.length - 1];\n  }\n  if (state) {\n    if (state.position) {\n      if (this.camera.position) this.camera.position.copy(state.position);\n    }\n    if (state.up) {\n      if (this.camera.up) this.camera.up.copy(state.up);\n    }\n    if (state.target) {\n      if (this.controls.target) this.controls.target.copy(state.target);\n      this.camera.lookAt(state.target);\n    }\n    this.camera.updateMatrix();\n    if (this.camera instanceof THREE.CombinedCamera) {\n      this.camera.inOrthographicMode = state.isOrtho || false;\n      this.camera.inPerspectiveMode = !this.camera.inOrthographicMode;\n    }\n    this.camera.updateProjectionMatrix(this.controls.target);\n    this.controls.update();\n  }\n};\n\nCameraControls.prototype.popCameraState = function () {\n  return this.cameraStates.pop();\n};\n\nCameraControls.prototype.viewObject3DArray = function (object3Darr) {\n  var bbox = new BBox();\n  for (var i = 0; i < object3Darr.length; i++) {\n    var object3d = object3Darr[i];\n    bbox.includeObject3D(object3d);\n  }\n  var bboxDims = bbox.dimensions();\n  var width = bboxDims.x;\n  var height = bboxDims.z;\n  var depth = bboxDims.y;\n\n  var epsilon = 0.2 * height;\n\n  this.camera.position.y = -(0.5 * depth + 0.75 * width + epsilon);\n  this.camera.position.z = 0.5 * height + epsilon;\n  this.camera.position.x = 0;\n\n  var maxDim = Math.max(bboxDims.x, bboxDims.y, bboxDims.z);\n  this.camera.far = maxDim * Constants.defaultCamera.nearFarMultiplier;\n  this.camera.near = maxDim / Constants.defaultCamera.nearFarMultiplier;\n  this.movementSpeed = maxDim / 5;\n  if (THREE.CombinedCamera && this.camera instanceof THREE.CombinedCamera) {\n    this.camera.updateNearFar();\n  }\n  this.camera.updateMatrix();\n  this.camera.updateProjectionMatrix(bbox.centroid());\n};\n\nCameraControls.prototype.panLeft = function (delta) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.panLeft(delta);\n  }\n};\n\nCameraControls.prototype.panUp = function (delta) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.panUp(delta);\n  }\n};\n\nCameraControls.prototype.rotateLeft = function (delta) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.rotateLeft(delta);\n  }\n};\n\nCameraControls.prototype.rotateUp = function (delta) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.rotateUp(delta);\n  }\n};\n\nCameraControls.prototype.dollyIn = function (dollyScale) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.dollyIn(dollyScale);\n  }\n};\n\nCameraControls.prototype.dollyOut = function (dollyScale) {\n  if (this.orbitControls && this.orbitControls.enabled) {\n    this.orbitControls.dollyOut(dollyScale);\n  }\n};\n//    CameraControls.prototype.toCameraCoords = function(position) {\n//        return this.camera.matrixWorldInverse.multiplyVector3(position.clone());\n//    };\n\nCameraControls.prototype.getBaseCamera = function () {\n  if (THREE.CombinedCamera && this.camera instanceof THREE.CombinedCamera) {\n    this.camera.updateProjectionMatrix();\n    if (this.camera.inPerspectiveMode) {\n      this.camera.cameraP.updateMatrixWorld();\n      return this.camera.cameraP;\n    } else {\n      this.camera.cameraO.updateMatrixWorld();\n      return this.camera.cameraO;\n    }\n  } else {\n    return this.camera;\n  }\n};\n\nCameraControls.prototype.toJSON = function () {\n  var baseCamera = this.getBaseCamera();\n  var json = baseCamera.toJSON();\n  return json;\n};\n\nCameraControls.prototype.setCameraMatrix = function(xform) {\n  Object3DUtil.setMatrix(this.camera, xform);\n  this.camera.updateMatrix();\n  this.camera.updateProjectionMatrix();\n  this.controls.update();\n};\n\nCameraControls.prototype.setCameraPosition = function(position) {\n  this.camera.position.copy(position);\n  this.camera.updateMatrix();\n  this.camera.updateProjectionMatrix(this.controls.target);\n  this.controls.update();\n};\n\n// Exports\nmodule.exports = CameraControls;\n\n\n//# sourceURL=webpack://STK/./js/lib/controls/CameraControls.js?");

/***/ }),

/***/ "./js/lib/controls/GPUPicker.js":
/*!**************************************!*\
  !*** ./js/lib/controls/GPUPicker.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// NOTE: Currently uses RGB (24-bit) for indexing allowing up to ~16M vertices\n\nvar FaceIDShader = {\n  vertexShader: [\n    \"attribute float id;\",\n    \"\",\n    \"uniform float size;\",\n    \"uniform float scale;\",\n    \"uniform float baseId;\",\n    \"\",\n    \"varying vec4 worldId;\",\n    \"\",\n    \"void main() {\",\n    \"  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n    \"  gl_PointSize = size * ( scale / length( mvPosition.xyz ) );\",\n    \"  float i = baseId + id;\",\n    \"  vec3 a = fract(vec3(1.0/255.0, 1.0/(255.0*255.0), 1.0/(255.0*255.0*255.0)) * i);\",\n    \"  a -= a.xxy * vec3(0.0, 1.0/255.0, 1.0/255.0);\",\n    \"  worldId = vec4(a,1);\",\n    \"  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join(\"\\n\"),\n\n  fragmentShader: [\n    \"#ifdef GL_ES\\n\",\n    \"precision highp float;\\n\",\n    \"#endif\\n\",\n    \"\",\n    \"varying vec4 worldId;\",\n    \"\",\n    \"void main() {\",\n    \"  gl_FragColor = worldId;\",\n    \"}\"\n  ].join(\"\\n\")\n};\n\nvar FaceIDMaterial = function () {\n  THREE.ShaderMaterial.call(this, {\n    uniforms: {\n      baseId: { type: \"f\", value: 0 },\n      size: { type: \"f\", value: 0.01 },\n      scale: { type: \"f\", value: 400 }\n    },\n    vertexShader: FaceIDShader.vertexShader,\n    fragmentShader: FaceIDShader.fragmentShader\n  });\n};\nFaceIDMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);\nFaceIDMaterial.prototype.constructor = FaceIDMaterial;\nFaceIDMaterial.prototype.setBaseID = function (baseId) {\n  this.uniforms.baseId.value = baseId;\n};\nFaceIDMaterial.prototype.setPointSize = function (size) {\n  this.uniforms.size.value = size;\n};\nFaceIDMaterial.prototype.setPointScale = function (scale) {\n  this.uniforms.scale.value = scale;\n};\n\n// flag to override Object3D copy such that it keeps reference to original Object3D\nTHREE.Object3D.keepOriginalObjectReference = false;\n\n//add a ref originalObject to Object3D\n(function (copy) {\n  THREE.Object3D.prototype.copy = function (src, recursive) {\n    copy.call(this, src, recursive);\n    if (THREE.Object3D.keepOriginalObjectReference) {\n      // keep a ref to originalObject\n      this.originalObject = src;\n    }\n    return this;\n  };\n}(THREE.Object3D.prototype.copy));\n\nTHREE.Mesh.prototype.raycastWithID = ( function () {\n  var vA = new THREE.Vector3();\n  var vB = new THREE.Vector3();\n  var vC = new THREE.Vector3();\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var triangle = new THREE.Triangle();\n  var plane = new THREE.Plane();\n\n  return function (elID, raycaster) {\n    var geometry = this.geometry;\n    var attributes = geometry.attributes;\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n    var a, b, c;\n    if (geometry.index != undefined) {\n      console.log(\"WARNING: raycastWithID does not support indexed vertices\");\n    } else {\n      var positions = attributes.position.array;\n      var j = elID * 9;\n      vA.fromArray(positions, j);\n      vB.fromArray(positions, j + 3);\n      vC.fromArray(positions, j + 6);\n      a = elID * 3;\n      b = a + 1;\n      c = b + 1;\n    }\n    triangle.set(vA, vB, vC);\n    var targetPoint = new THREE.Vector3();\n    var intersectionPoint = ray.intersectPlane(triangle.getPlane(plane), targetPoint);\n\n    if (intersectionPoint == null) {\n      // console.log(\"WARNING: intersectionPoint missing\");\n      return;\n    }\n\n    intersectionPoint.applyMatrix4(this.matrixWorld);\n\n    var distance = raycaster.ray.origin.distanceTo(intersectionPoint);\n\n    if (distance < raycaster.near || distance > raycaster.far) { return; }\n\n    var normal = new THREE.Vector3();\n    THREE.Triangle.getNormal(vA, vB, vC, normal);\n    var intersect = {\n      distance: distance,\n      point: intersectionPoint,\n      face: new THREE.Face3(a, b, c, normal),\n      index: elID, // triangle number in positions buffer semantics\n      object: this\n    };\n    return intersect;\n  };\n\n}() );\n\nTHREE.Line.prototype.raycastWithID = (function () {\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n\n  var vStart = new THREE.Vector3();\n  var vEnd = new THREE.Vector3();\n  var interSegment = new THREE.Vector3();\n  var interRay = new THREE.Vector3();\n  return function (elID, raycaster) {\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n    var geometry = this.geometry;\n    if (geometry instanceof THREE.BufferGeometry) {\n\n      var attributes = geometry.attributes;\n\n      if (geometry.index != undefined) {\n        console.log(\"WARNING: raycastWithID does not support indexed vertices\");\n      } else {\n        var positions = attributes.position.array;\n        var i = elID * 6;\n        vStart.fromArray(positions, i);\n        vEnd.fromArray(positions, i + 3);\n\n        // var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n        var distance = ray.origin.distanceTo(interRay);\n\n        if (distance < raycaster.near || distance > raycaster.far) return;\n\n        var intersect = {\n          distance: distance,\n          // What do we want? intersection point on the ray or on the segment??\n          // point: raycaster.ray.at( distance ),\n          point: interSegment.clone().applyMatrix4(this.matrixWorld),\n          index: i,\n          face: null,\n          faceIndex: null,\n          object: this\n        };\n        return intersect;\n      }\n\n    }\n  };\n\n})();\n\nTHREE.PointCloud.prototype.raycastWithID = ( function () {\n\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n\n  return function (elID, raycaster) {\n    var object = this;\n    var geometry = object.geometry;\n\n    inverseMatrix.getInverse(this.matrixWorld);\n    ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);\n    var position = new THREE.Vector3();\n\n    var testPoint = function (point, index) {\n      var rayPointDistance = ray.distanceToPoint(point);\n      var intersectPoint = ray.closestPointToPoint(point);\n      intersectPoint.applyMatrix4(object.matrixWorld);\n\n      var distance = raycaster.ray.origin.distanceTo(intersectPoint);\n\n      if (distance < raycaster.near || distance > raycaster.far) return;\n\n      var intersect = {\n        distance: distance,\n        distanceToRay: rayPointDistance,\n        point: intersectPoint.clone(),\n        index: index,\n        face: null,\n        object: object\n      };\n      return intersect;\n    };\n    var attributes = geometry.attributes;\n    var positions = attributes.position.array;\n    position.fromArray(positions, elID * 3);\n\n    return testPoint(position, elID);\n\n  };\n\n}() );\n\n/**\n * GPUPicker (adapted from https://github.com/brianxu/GPUPicker) for triangle level picking offscreen\n * @license MIT License <https://github.com/brianxu/GPUPicker/blob/master/LICENSE>\n * @constructor\n * @memberOf controls\n */\nTHREE.GPUPicker = function (option) {\n  if (option === undefined) {\n    option = {};\n  }\n  this.pickingScene = new THREE.Scene();\n  this.pickingTexture = new THREE.WebGLRenderTarget();\n  this.pickingTexture.texture.minFilter = THREE.LinearFilter;\n  this.pickingTexture.texture.generateMipmaps = false;\n  this.lineShell = option.lineShell !== undefined ? option.lineShell : 4;\n  this.pointShell = option.pointShell !== undefined ? option.pointShell : 0.1;\n  this.debug = option.debug !== undefined ? option.debug : false;\n  this.useFullBuffer = option !== undefined? option.useFullBuffer : false;\n  this.needUpdate = true;\n  if (option.renderer) {\n    this.setRenderer(option.renderer);\n  }\n\n  // array of original objects\n  this.container = [];\n  this.objectsMap = {};\n  //default filter\n  this.setFilter();\n};\n\nTHREE.GPUPicker.prototype.setRenderer = function (renderer) {\n  this.renderer = renderer;\n  var size = renderer.getSize();\n  this.resizeTexture(size.width, size.height);\n  this.needUpdate = true;\n};\n\nTHREE.GPUPicker.prototype.resizeTexture = function (width, height) {\n  this.pickingTexture.setSize(width, height);\n  this.pixelBuffer = this.useFullBuffer? new Uint8Array(4*width*height) : new Uint8Array(4);\n  this.needUpdate = true;\n};\n\nTHREE.GPUPicker.prototype.setCamera = function (camera) {\n  this.camera = camera;\n  this.needUpdate = true;\n};\n\nTHREE.GPUPicker.prototype.update = function (mouse, forceUpdate) {\n  if (this.needUpdate || forceUpdate) {\n    this.renderer.setRenderTarget(this.pickingTexture);\n    this.renderer.clear();\n    this.renderer.render(this.pickingScene, this.camera);\n    //read the rendering texture\n    if (this.useFullBuffer) {\n      this.renderer.readRenderTargetPixels(this.pickingTexture, 0, 0, this.pickingTexture.width, this.pickingTexture.height, this.pixelBuffer);\n    }\n    this.needUpdate = false;\n    if (this.debug) console.log(\"GPUPicker rendering updated\");\n  }\n  if (!this.useFullBuffer) {\n    this.renderer.readRenderTargetPixels(this.pickingTexture, mouse.x, mouse.y, 1, 1, this.pixelBuffer);\n  }\n};\n\nTHREE.GPUPicker.prototype.setFilter = function (func) {\n  if (func instanceof Function) {\n    this.filterFunc = func;\n  } else {\n    //default filter\n    this.filterFunc = function (object) {\n      return true;\n    };\n  }\n};\n\nTHREE.GPUPicker.prototype.setScene = function (scene) {\n  var oldKeepRef = THREE.Object3D.keepOriginalObjectReference;\n  THREE.Object3D.keepOriginalObjectReference = true;\n  this.pickingScene = scene.clone();\n  THREE.Object3D.keepOriginalObjectReference = oldKeepRef;\n  this._processObject(this.pickingScene, 0);\n  this.needUpdate = true;\n};\n\nTHREE.GPUPicker.prototype.pick = function (mouse, raycaster) {\n  var m = { x: mouse.x, y: this.pickingTexture.height - mouse.y};\n  this.update(m);\n\n  var index = this.useFullBuffer? (m.x + m.y * this.pickingTexture.width) : 0;\n  //interpret the pixel as an ID\n  return this.__pickAt(index, raycaster);\n};\n\nTHREE.GPUPicker.prototype.__pickAt = function(index, raycaster) {\n  var id = (this.pixelBuffer[index * 4 + 2] * 255 * 255) + (this.pixelBuffer[index * 4 + 1] * 255) + (this.pixelBuffer[index * 4 + 0]);\n  var alpha = this.pixelBuffer[index * 4 + 3];\n  if (alpha === 0) {\n    return null;  // no intersection\n  }\n\n  // get object with this id in range\n  // var object = this._getObject(id);\n  if (this.debug) console.log(\"pick id:\", id);\n  var result = this._getObject(this.pickingScene, 0, id);\n  var object = result[1];\n  var elementId = id - result[0];\n  if (object) {\n    if (!raycaster) {\n      return { object: object.originalObject, faceIndex: elementId };  // No raycaster, just return object and faceIndex\n    }\n    if (object.raycastWithID) {\n      var intersect = object.raycastWithID(elementId, raycaster);\n      if (intersect) {\n        intersect.object = object.originalObject;\n        intersect.faceIndex = intersect.index;\n        if (object.originalObject.geometry.index) {  // also revert face vertex indices\n          var idx = object.originalObject.geometry.index.array;\n          var offset = intersect.faceIndex * 3;\n          intersect.face.a = idx[offset];\n          intersect.face.b = idx[offset + 1];\n          intersect.face.c = idx[offset + 2];\n        }\n        return intersect;\n      }\n    }\n  }\n};\n\n/*\n * get object by id\n */\nTHREE.GPUPicker.prototype._getObject = function (object, baseId, id) {\n  // if (this.debug) console.log(\"_getObject \",baseId);\n  if (object.elementsCount !== undefined && id >= baseId && id < baseId + object.elementsCount) {\n    return [baseId, object];\n  }\n  if (object.elementsCount !== undefined) {\n    baseId += object.elementsCount;\n  }\n  var result = [baseId, undefined];\n  for (var i = 0; i < object.children.length; i++) {\n    result = this._getObject(object.children[i], result[0], id);\n    if (result[1] !== undefined)\n      break;\n  }\n  return result;\n};\n\n/*\n * process the object to add elementId information\n */\nTHREE.GPUPicker.prototype._processObject = function (object, baseId) {\n  baseId += this._addElementID(object, baseId);\n  for (var i = 0; i < object.children.length; i++) {\n    baseId = this._processObject(object.children[i], baseId);\n  }\n  return baseId;\n};\n\nTHREE.GPUPicker.prototype._addElementID = function (object, baseId) {\n  if (!this.filterFunc(object) && object.geometry !== undefined) {\n    object.visible = false;\n    return 0;\n  }\n\n  if (object.geometry) {\n    var __pickingGeometry;\n    //check if geometry has cached geometry for picking\n    if (object.geometry.__pickingGeometry) {\n      __pickingGeometry = object.geometry.__pickingGeometry;\n    } else {\n      __pickingGeometry = object.geometry;\n      // convert geometry to buffer geometry\n      if (object.geometry instanceof THREE.Geometry) {\n        if (this.debug) console.log(\"convert geometry to buffer geometry\");\n        __pickingGeometry = new THREE.BufferGeometry().setFromObject(object);\n      }\n      var units = 1;\n      if (object instanceof THREE.PointCloud) {\n        units = 1;\n      } else if (object instanceof THREE.Line) {\n        units = 2;\n      } else if (object instanceof THREE.Mesh) {\n        units = 3;\n      }\n      var el, el3, elementsCount, i, indices, positionBuffer, vertex3, verts, vertexIndex3;\n      if (__pickingGeometry.index != undefined) {\n        __pickingGeometry = __pickingGeometry.clone();\n        if (this.debug) console.log(\"convert indexed geometry to non-indexed geometry\");\n\n        indices = __pickingGeometry.index.array;\n        verts = __pickingGeometry.attributes.position.array;\n        delete __pickingGeometry.attributes.position;\n        __pickingGeometry.index = null;  // NOTE: THREE checks geometry.index !== null to determine if indexed\n        delete __pickingGeometry.attributes.normal;\n        elementsCount = indices.length / units;\n        positionBuffer = new Float32Array(elementsCount * 3 * units);\n\n        __pickingGeometry.setAttribute('position', new THREE.BufferAttribute(positionBuffer, 3));\n        for (el = 0; el < elementsCount; ++el) {\n          el3 = units * el;\n          for (i = 0; i < units; ++i) {\n            vertexIndex3 = 3 * indices[el3 + i];\n            vertex3 = 3 * (el3 + i);\n            positionBuffer[vertex3] = verts[vertexIndex3];\n            positionBuffer[vertex3 + 1] = verts[vertexIndex3 + 1];\n            positionBuffer[vertex3 + 2] = verts[vertexIndex3 + 2];\n          }\n        }\n        __pickingGeometry.computeVertexNormals();\n      }\n      if (object instanceof THREE.Line && !(object instanceof THREE.LineSegments)) {\n        if (this.debug) console.log(\"convert Line to LineSegments\");\n        verts = __pickingGeometry.attributes.position.array;\n        delete __pickingGeometry.attributes.position;\n        elementsCount = verts.length / 3 - 1;\n        positionBuffer = new Float32Array(elementsCount * units * 3);\n\n        __pickingGeometry.setAttribute('position', new THREE.BufferAttribute(positionBuffer, 3));\n        for (el = 0; el < elementsCount; ++el) {\n          el3 = 3 * el;\n          vertexIndex3 = el3;\n          vertex3 = el3 * 2;\n          positionBuffer[vertex3] = verts[vertexIndex3];\n          positionBuffer[vertex3 + 1] = verts[vertexIndex3 + 1];\n          positionBuffer[vertex3 + 2] = verts[vertexIndex3 + 2];\n          positionBuffer[vertex3 + 3] = verts[vertexIndex3 + 3];\n          positionBuffer[vertex3 + 4] = verts[vertexIndex3 + 4];\n          positionBuffer[vertex3 + 5] = verts[vertexIndex3 + 5];\n        }\n\n        __pickingGeometry.computeVertexNormals();\n        object.__proto__ = THREE.LineSegments.prototype; //make the renderer render as line segments\n      }\n      var attributes = __pickingGeometry.attributes;\n      var positions = attributes.position.array;\n      var vertexCount = positions.length / 3;\n      var ids = new THREE.Float32BufferAttribute(vertexCount, 1);\n      //set vertex id color\n\n      for (var i = 0, il = vertexCount / units; i < il; i++) {\n        for (var j = 0; j < units; ++j) {\n          ids.array[i * units + j] = i;\n        }\n      }\n      __pickingGeometry.setAttribute('id', ids);\n      __pickingGeometry.elementsCount = vertexCount / units;\n      // console.log('elementsCount', __pickingGeometry.elementsCount, 'vertexCount', vertexCount);\n      //cache __pickingGeometry inside geometry\n      object.geometry.__pickingGeometry = __pickingGeometry;\n    }\n\n    //use __pickingGeometry in the picking mesh\n    object.geometry = __pickingGeometry;\n    object.elementsCount = __pickingGeometry.elementsCount;//elements count\n\n    var pointSize = object.material.size || 0.01;\n    var linewidth = object.material.linewidth || 1;\n    object.material = new FaceIDMaterial();\n    object.material.linewidth = linewidth + this.lineShell;//make the line a little wider to hit\n    object.material.setBaseID(baseId);\n    object.material.setPointSize(pointSize + this.pointShell);//make the point a little wider to hit\n    object.material.setPointScale(this.renderer.getSize().height * this.renderer.getPixelRatio() / 2);\n    return object.elementsCount;\n  }\n  return 0;\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/controls/GPUPicker.js?");

/***/ }),

/***/ "./js/lib/controls/OffscreenPicker.js":
/*!********************************************!*\
  !*** ./js/lib/controls/OffscreenPicker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Picker = __webpack_require__(/*! controls/Picker */ \"./js/lib/controls/Picker.js\");\nvar RendererFactory = __webpack_require__(/*! gfx/RendererFactory */ \"./js/lib/gfx/RendererFactory.js\");\n__webpack_require__(/*! controls/GPUPicker */ \"./js/lib/controls/GPUPicker.js\");\n\n/**\n * Utility class for offscreen picking\n * @param [opts.renderer] {gfx.Renderer} Renderer used for rendering view for offscreen picking\n * @param [opts.camera] {THREE.Camera} Camera used for rendering view for offscreen picking\n * @param [opts.width] {int} Width of image to be rendered for picking\n * @param [opts.height] {int} Height of image to be rendered for picking\n * @param [opts.useFullBuffer=false] {boolean} Read entire buffer into memory\n * @param [opts.debug=false] {boolean} Enable debug messages\n * @constructor\n * @memberOf controls\n */\nfunction OffscreenPicker(opts) {\n  opts = opts || {};\n  this.__offscreenRenderer = opts.renderer || this.__getOffscreenRenderer(opts);\n  this.__gpuPicker = new THREE.GPUPicker({renderer: this.__offscreenRenderer.renderer, debug: opts.debug, useFullBuffer: opts.useFullBuffer});\n  this.__gpuPicker.setFilter(function (object) {return true;});\n  if (opts.camera) {\n    this.__gpuPicker.setCamera(opts.camera);\n  }\n  this.__scene = null;\n}\n\nOffscreenPicker.prototype = Object.create(Picker.prototype);\nOffscreenPicker.prototype.constructor = OffscreenPicker;\n\nOffscreenPicker.prototype.__setSize = function(width, height) {\n  this.__getOffscreenRenderer().setSize(width, height);\n  this.__gpuPicker.resizeTexture(width, height);\n};\n\nOffscreenPicker.prototype.__getOffscreenRenderer = function(opts) {\n  if (!this.__offscreenRenderer) {\n    this.__offscreenRenderer = RendererFactory.createOffscreenRenderer({\n      camera: opts.camera,\n      width: opts.width,\n      height: opts.height\n    });\n  }\n  return this.__offscreenRenderer;\n};\n\nOffscreenPicker.prototype.getOffscreenCoordinates = function (container, screenPosition) {\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    var x = screenPosition.clientX - rect.left;\n    var y = screenPosition.clientY - rect.top;\n    return new THREE.Vector2(x, y);\n  } else {\n    return new THREE.Vector2(screenPosition.x, screenPosition.y);\n  }\n};\n\nOffscreenPicker.prototype.__updateScene = function(scene) {\n  if (this.__scene !== scene) {\n    // Make sure scene is visible when we process it (NOTE: children may still be not visible)\n    // the __gpuPicker actually makes a copy and create a pickingScene\n    // if child nodes visibility changes, they should be updated...\n    var oldSceneVisibility = scene.visible;\n    scene.visible = true;\n    this.__gpuPicker.setScene(scene);\n    this.__scene = scene;\n    scene.visible = oldSceneVisibility;\n  }\n};\n\n/**\n * Returns object picked\n * @param options\n * @param [options.container] container\n * @param [options.scene] {THREE.Scene} scene to pick against\n * @param options.position Screen position (contains `clientX, clientY` if `container` provided or `x,y,width,height` if no container)\n * @param options.camera {THREE.Camera}\n * @param options.objects {THREE.Object3D[]} Array of objects to intersect against\n * @param options.ignore {THREE.Object3D[]} Array of objects to ignore\n * @param options.targetType {string} What type of target (`mesh|object`)\n * @returns {Intersect}\n */\nOffscreenPicker.prototype.pick = function (options) {\n  var raycastMouse = this.getCoordinates(options.container, options.position);\n  var offscreenMouse = this.getOffscreenCoordinates(options.container, options.position);\n  var raycaster =  this.getRaycaster(raycastMouse.x, raycastMouse.y, options.camera);\n\n  var scene = options.scene;\n  this.__updateScene(scene);\n  if (options.ignore) {\n    for (var i = 0; i < options.ignore.length; i++) {\n      options.ignore[i].userData.__visible = options.ignore[i].visible;\n      options.ignore[i].visible = false;\n    }\n  }\n  this.__gpuPicker.setCamera(options.camera);\n  var intersected = this.__gpuPicker.pick(offscreenMouse, raycaster);\n  if (options.ignore) {\n    for (var i = 0; i < options.ignore.length; i++) {\n      options.ignore[i].visible = options.ignore[i].userData.__visible;\n      delete options.ignore[i].userData.__visible;\n    }\n  }\n  if (intersected) {\n    if (options.targetType === 'mesh') {\n      var intersected2 = this.selectIntersectedMeshes([intersected], [scene], [], 1);\n      return intersected2[0];\n    } else if (options.targetType === 'object') {\n      // console.log('intersected', intersected, 'scene', scene);\n      var intersected2 = this.selectIntersectedObjects([intersected], [scene], [], 1, true);\n      // console.log('intersected2', intersected2);\n      return intersected2[0];\n    } else {\n      console.error('Unsupport targetType', options.targetType);\n    }\n  }\n};\n\nOffscreenPicker.prototype.getIntersectedFromScreenPosition = function (container, screenPosition, camera, scene) {\n  var raycastMouse = this.getCoordinates(container, screenPosition);\n  var offscreenMouse = this.getOffscreenCoordinates(container, screenPosition);\n  var raycaster =  this.getRaycaster(raycastMouse.x, raycastMouse.y, camera);\n\n  this.__updateScene(scene);\n  this.__gpuPicker.setCamera(camera);\n  var intersected = this.__gpuPicker.pick(offscreenMouse, raycaster);\n  if (intersected) {\n    // console.log('intersected', intersected, 'scene', scene);\n    var intersected2 = this.selectIntersectedObjects([intersected], [scene], [], 1, true);\n    // console.log('intersected2', intersected2);\n    return intersected2[0];\n  }\n};\n\n/**\n * Update set of meshes and triangle that are pickabled by rendering the scene from given camera viewpoint\n * @param camera {THREE.Camera}\n * @param scene {THREE.Object3D}\n * @param [pickables] {Object<int, Object<int, int>>} Optional counts of pickable mesh ids and face indices to be updated\n * @returns {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n */\nOffscreenPicker.prototype.updatePickables = function(camera, scene, pickables) {\n  // Get all pickable triangles from this view point\n  this.__updateScene(scene);\n  this.__gpuPicker.setCamera(camera);\n  var width = this.__gpuPicker.pickingTexture.width;\n  var height = this.__gpuPicker.pickingTexture.height;\n  // TODO: Switch from generic object to actual Map!\n  pickables = pickables || {};\n  for (var i = 0; i < width; i++) {\n    for (var j = 0; j < height; j++) {\n      var m = { x: i, y: j };\n      var intersected = this.__gpuPicker.pick(m);\n      if (intersected) {\n        pickables[intersected.object.id] = pickables[intersected.object.id] || {};\n        pickables[intersected.object.id][intersected.faceIndex] = (pickables[intersected.object.id][intersected.faceIndex] || 0) + 1;\n      }\n    }\n  }\n  return pickables;\n};\n\nOffscreenPicker.prototype.onResize = function(container) {\n  var width = container.clientWidth;\n  var height = container.clientHeight;\n  this.__setSize(width, height);\n};\n\nmodule.exports = OffscreenPicker;\n\n//# sourceURL=webpack://STK/./js/lib/controls/OffscreenPicker.js?");

/***/ }),

/***/ "./js/lib/controls/Picker.js":
/*!***********************************!*\
  !*** ./js/lib/controls/Picker.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar RaycasterUtil = __webpack_require__(/*! geo/RaycasterUtil */ \"./js/lib/geo/RaycasterUtil.js\");\n\nfunction Picker(params) {\n  params = params || {};\n  this.highlightMaterial = params.highlightMaterial ||\n    Object3DUtil.getSimpleFalseColorMaterial('selected', new THREE.Color(0xef9f56));\n  this.__customColorObjectFn = params.colorObject;\n  this.__renderer = params.renderer;\n  this.highlighted = null;\n}\n\n// Stuffs arguments into object\nPicker.prototype.__processArguments = function(args, argNames) {\n  if (args.length === 1) {\n    // Assume single argument is object - return as is\n    return args[0];\n  } else {\n    var res = {};\n    var n = Math.min(argNames.length, args.length);\n    for (var i = 0; i < n; i++) {\n      res[argNames[i]] = args[i];\n    }\n    return res;\n  }\n};\n\nPicker.prototype.getCoordinates = function (container, screenPosition) {\n  if (container) {\n    var rect = container.getBoundingClientRect();\n    var x = ((screenPosition.clientX - rect.left) / container.clientWidth) * 2 - 1;\n    var y = -((screenPosition.clientY - rect.top) / container.clientHeight) * 2 + 1;\n    return new THREE.Vector2(x, y);\n  } else {\n    var x = (screenPosition.x/screenPosition.width) * 2 - 1 ;\n    var y = -(screenPosition.y/screenPosition.height) * 2 + 1;\n    return new THREE.Vector2(x, y);\n  }\n};\n\n/**\n * Returns object picked\n * @param options\n * @param options.container container\n * @param options.position Screen position (contains `clientX, clientY` if `container` provided or `x,y,width,height` if no container)\n * @param options.camera {THREE.Camera}\n * @param options.objects {THREE.Object3D[]} Array of objects to intersect against\n * @param options.ignore {THREE.Object3D[]} Array of objects to ignore\n * @param options.targetType {string} What type of target (`mesh|object`)\n * @returns {Intersect}\n */\nPicker.prototype.pick = function(options) {\n  var raycastMouse = this.getCoordinates(options.container, options.position);\n  if (options.targetType === 'mesh') {\n    return this.getFirstIntersectedMesh(raycastMouse.x, raycastMouse.y, options.camera, options.objects, options.ignore);\n  } else if (options.targetType === 'object') {\n    return this.getFirstIntersected(raycastMouse.x, raycastMouse.y, options.camera, options.objects, options.ignore);\n  } else {\n    console.error('Unsupported targetType', options.targetType);\n  }\n};\n\n/**\n * Returns the first intersected object\n * Input parameter can also be a single object with the following field names.\n * @param x {number} x coordinate (already transformed from screen space into image space)\n * @param y {number} y coordinate (already transformed from screen space into image space)\n * @param camera {THREE.Camera}\n * @param objects {THREE.Object3D[]} Array of objects to intersect against\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @returns {Intersect}\n */\nPicker.prototype.getFirstIntersected = function (x, y, camera, objects, ignore) {\n  var args = this.__processArguments(arguments, ['x', 'y', 'camera', 'objects', 'ignore']);\n  args.n = 1;\n  var intersected = this.getIntersected(args);\n  if (intersected.length > 0) {\n    // console.log('Picker intersected', intersected[0]);\n    return intersected[0];\n  }\n};\n\nPicker.prototype.getIntersectedNormal = RaycasterUtil.getIntersectedNormal;\n\n/**\n * Returns intersected objects\n * Input parameter can also be a single object with the following field names.\n * @param x {number} x coordinate (already transformed from screen space into image space)\n * @param y {number} y coordinate (already transformed from screen space into image space)\n * @param camera {THREE.Camera}\n * @param objects {THREE.Object3D[]} Array of objects to intersect against\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @param [n] {int} Number of intersected objects to return\n * @param [raycaster] {THREE.Raycaster} Optional raycaster (provided so previously computed raycaster can be reused)\n * @returns {Intersect[]}\n */\nPicker.prototype.getIntersected = function (x, y, camera, objects, ignore, n, raycaster) {\n  var args = this.__processArguments(arguments, ['x', 'y', 'camera', 'objects', 'ignore', 'n', 'raycaster']);\n  // Get intersected takes up to 10ms for large scenes\n  var intersected = this.getIntersectedDescendants(args);\n  return this.selectIntersectedObjects(intersected, args.objects, args.ignore, args.n, args.allowAllModelInstances);\n};\n\n/**\n * Returns intersected for a specfied raycaster\n * @param raycaster {THREE.Raycaster}\n * @param objects {THREE.Object3D[]} Array of objects to intersect against\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @param [n] {int} Number of intersected objects to return\n * @returns {Intersect[]|*}\n */\nPicker.prototype.getIntersectedForRay = function (raycaster, objects, ignore, n) {\n  var intersected = raycaster.intersectObjects(objects, true);\n  intersected = RaycasterUtil.filterClipped(intersected, this.__renderer);\n  RaycasterUtil.sortIntersectionsByNormal(raycaster.ray, intersected);\n  return this.selectIntersectedObjects(intersected, objects, ignore, n);\n};\n\nPicker.prototype.selectIntersectedObjects = RaycasterUtil.selectIntersectedObjects;\n\n/**\n * Returns first intersected mesh\n * Input parameter can also be a single object with the following field names.\n * @param x {number} x coordinate (already transformed from screen space into image space)\n * @param y {number} y coordinate (already transformed from screen space into image space)\n * @param camera {THREE.Camera}\n * @param objects {THREE.Object3D[]} Array of objects to intersect against\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @param [n] {int} Number of intersected objects to return\n * @returns {Intersect|boolean}\n */\nPicker.prototype.getFirstIntersectedMesh = function (x, y, camera, objects, ignore) {\n  var intersected = this.getIntersectedMeshes(x, y, camera, objects, ignore, 1);\n  if (intersected.length > 0) {\n    return intersected[0];\n  } else {\n    return false;\n  }\n};\n\n/**\n * Returns intersected meshes\n * Input parameter can also be a single object with the following field names.\n * @param x {number} x coordinate (already transformed from screen space into image space)\n * @param y {number} y coordinate (already transformed from screen space into image space)\n * @param camera {THREE.Camera}\n * @param objects {THREE.Object3D[]} Array of objects to intersect against\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @param [n] {int} Number of intersected objects to return\n * @returns {Intersect[]}\n */\nPicker.prototype.getIntersectedMeshes = function (x, y, camera, objects, ignore, n) {\n  var intersected = this.getIntersectedDescendants(x, y, camera, objects);\n  return this.selectIntersectedMeshes(intersected, objects, ignore, n);\n};\n\nPicker.prototype.selectIntersectedMeshes = function (intersected, objects, ignore, n) {\n  var meshes = [];\n  for (var i = 0; i < intersected.length; i++) {\n    var m = intersected[i].object;\n    //var ignoreObject = (ignore && ignore.indexOf(m) >= 0);\n    var ignoreObject = (ignore && Object3DUtil.isDescendantOf(m, ignore));\n    if (!ignoreObject) {\n      meshes.push(intersected[i].object);\n    }\n    if (n && meshes.length > n) break;\n  }\n  return meshes;\n};\n\n// Returns actual meshes that are intersected\n// raycaster is optional (provided so previously computed raycaster can be reused)\nPicker.prototype.getIntersectedDescendants = function (x, y, camera, objects, raycaster) {\n  var args = this.__processArguments(arguments, ['x', 'y', 'camera', 'objects', 'raycaster']);\n  if (!args.raycaster) args.raycaster = this.getRaycaster(args.x, args.y, args.camera);\n\n  // NOTE: intersect does not work with buffered geometry\n  //   (unless we set the geometry.dynamic to be true - by default, it is false and\n  //        some attributes are not set (actually cleared) to save memory)\n  // To have intersect work, use a AssetManager with useDynamic = true when useBuffered = true\n  //   (useBuffered will still take up less memory)\n  //\n  // Also, need to do recursive intersect since intersect is done at the mesh level\n  var intersects = args.raycaster.intersectObjects(args.objects, true);\n  intersects = RaycasterUtil.filterClipped(intersects, this.__renderer);\n  RaycasterUtil.sortIntersectionsByNormal(args.raycaster.ray, intersects);\n  return intersects;\n};\n\nPicker.prototype.getRaycaster = function (x, y, camera, raycaster) {\n  if (!raycaster) {\n    raycaster = new THREE.Raycaster();\n    //this.__raycaster = raycaster;\n  }\n  raycaster.setFromCamera({ x: x, y: y}, camera);\n  return raycaster;\n};\n\nPicker.prototype.__colorObject = function (object3D, highlighted, highlightMaterial) {\n  // Recolor objects to indicate highlight or no highlight\n  if (this.__customColorObjectFn) {\n    this.__customColorObjectFn(object3D, highlighted, highlightMaterial);\n  } else {\n    if (highlighted) {\n      Object3DUtil.setMaterial(object3D, highlightMaterial, Object3DUtil.MaterialsAll, true);\n    } else {\n      Object3DUtil.revertMaterials(object3D);\n    }\n  }\n};\n\nPicker.prototype.bind = function(name, fn) {\n  if (name === 'colorObject') {\n    this.__customColorObjectFn = fn;\n  } else {\n    console.warn('Unsupported function: ' + name);\n  }\n};\n\n/**\n * Color object with highlight material\n * @param object3D {THREE.Object3D}\n */\nPicker.prototype.highlightObject = function (object3D) {\n  if (!object3D.isHighlighted) {\n    this.__colorObject(object3D, true, this.highlightMaterial);\n    this.highlighted = object3D;\n    object3D.isHighlighted = true;\n  }\n};\n\n/**\n * Uncolor object with highlight material\n * @param object3D {THREE.Object3D}\n */\nPicker.prototype.unhighlightObject = function (object3D) {\n  if (object3D.isHighlighted) {\n    this.__colorObject(object3D, false, this.highlightMaterial);\n    this.highlighted = null;\n    object3D.isHighlighted = false;\n  }\n};\n\n/**\n * Color objects with highlight material\n * @param objects {THREE.Object3D[]}\n */\nPicker.prototype.highlightObjects = function (objects) {\n  if (objects) {\n    for (var i = 0; i < objects.length; i++) {\n      var object3D = objects[i];\n      if (!object3D.isHighlighted) {\n        this.__colorObject(object3D, true, this.highlightMaterial);\n        object3D.isHighlighted = true;\n      }\n    }\n  }\n  this.highlighted = objects;\n};\n\n/**\n * Uncolors objects with highlight material\n * @param objects {THREE.Object3D[]}\n */\nPicker.prototype.unhighlightObjects = function (objects) {\n  if (objects) {\n    for (var i = 0; i < objects.length; i++) {\n      var object3D = objects[i];\n      if (object3D.isHighlighted) {\n        this.__colorObject(object3D, false, this.highlightMaterial);\n        object3D.isHighlighted = false;\n      }\n    }\n  }\n  this.highlighted = null;\n};\n\n// Exports\nmodule.exports = Picker;\n\n\n//# sourceURL=webpack://STK/./js/lib/controls/Picker.js?");

/***/ }),

/***/ "./js/lib/data/DataUtils.js":
/*!**********************************!*\
  !*** ./js/lib/data/DataUtils.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar TypeUtils = __webpack_require__(/*! data/TypeUtils.js */ \"./js/lib/data/TypeUtils.js\");\n\nvar DataUtils = {};\n\nDataUtils.DAY_DURATION = 1000*60*60*24;  // milliseconds to seconds to minutes to hours to days\n\nvar jsToVizTypeMap = Object.freeze({\n  string: 'categorical',\n  boolean: 'boolean',\n  number: 'numeric'\n});\n\n//maximum value of a numeric field given raw query data\nDataUtils.max = function (field, data) {\n  return Math.max.apply(Math, data.map(function (d) {\n    return d[field];\n  }));\n};\n\n//minimum value of a numeric field given raw query data\nDataUtils.min = function (field, data) {\n  return Math.min.apply(Math, data.map(function (d) {\n    return d[field];\n  }));\n};\n\n//filters data, leaving only the elements that are defined for a specific attribute\nDataUtils.filterData = function (field, data) {\n  return data.filter(function (d) {\n    return d[field] != undefined;\n  });\n};\n\nDataUtils.filterNumbers = function (field, data) {\n  return data.filter(function (d) {\n    var v = d[field];\n    var number = Number(v);\n    return !isNaN(number);\n  });\n};\n\nDataUtils.filterDates = function (field, data) {\n  return data.filter(function (d) {\n    var v = d[field];\n    return TypeUtils.getType(v) === 'Date';\n  });\n};\n\n//given a category field and a numeric field, returns the average numeric field count per category\n//firstField must be categorical and secondField must be numeric\nDataUtils.getAverageData = function (firstField, secondField, data) {\n  var averageData = {}; //object that will hold all average information\n  var averages = {}; //raw averages per category\n\n  data.forEach(function (d) {\n    var categories = d[firstField] || 'undefined'; //get category of each model\n    if (!(categories instanceof Array)) {\n      categories = [categories];\n    }\n    categories.forEach(function (category) {\n      if (!averages[category]) {\n        averages[category] = {  //create initial count for this category, to be averaged later\n          sum: d[secondField] || 0,\n          count: 1\n        };\n      } else {\n        averages[category].sum += d[secondField] || 0; //add to sum, increment count\n        averages[category].count += 1;\n      }\n    });\n  });\n\n  //average over all categories\n  Object.keys(averages).forEach(function (category) {\n    averages[category] = parseInt(averages[category].sum / averages[category].count);\n  });\n\n  averageData.counts = averages;\n  averageData.field = secondField;\n  averageData.maxCount = this.getMaxCount(averages);\n\n  return averageData;\n};\n\n//returns count data in object form, with a field count mapping to how many models in data\n//contain that field count, used on numeric data, supports binning\nDataUtils.getCountData = function (field, data, numBins) {\n  var countData = {};\n  var counts = {};\n  data = DataUtils.filterNumbers(field, data);\n  var max = DataUtils.max(field, data);\n\n  //set numBins to max if null, or if the number of bins exceeds the maximum number of categories\n  if (!numBins || max / numBins === 0) {\n    numBins = max;\n  }\n\n  var stepsize = Math.ceil(max / numBins);\n\n  //set all fields to 0 initially\n  for (var i = 0; i <= max; i += stepsize) {\n    counts[i] = 0;\n  }\n\n  //console.log(counts);\n  data.forEach(function (d) {\n    var count = d[field];\n    var bin = Math.floor(count / stepsize) * stepsize;\n    if (!count) return;\n    counts[bin]++;\n  });\n\n  countData.maxCount = DataUtils.getMaxCount(counts);\n  countData.field = field;\n  countData.counts = counts;\n\n  return countData;\n};\n\n//get count of every category of a given dataset, must be categorical\nDataUtils.getCategoryCounts = function (field, data) {\n  var countData = {};\n  var counts = {};\n\n  data.forEach(function (d) {\n    var values = d[field] || 'undefined';\n    if (!(values instanceof Array)) {\n      values = [values];\n    }\n\n    values.forEach(function (value) {\n      if (!value) return;\n      if (!counts[value]) {\n        counts[value] = 1;\n      } else {\n        counts[value]++;\n      }\n    });\n  });\n\n  countData.maxCount = DataUtils.getMaxCount(counts);\n  countData.field = field;\n  countData.counts = counts;\n\n  return countData;\n};\n\n//this function bins numeric data into numBins amount of range, returns data packet with distributions\n//don't need this anymore\nDataUtils.getBinnedData = function (countData, numBins) {\n  var binnedCountMap = {};\n  var binnedCounts = {};\n  var max = countData.max;\n  var stepsize = max / numBins;\n\n  var counts = countData.counts;\n  Object.keys(counts).forEach(function (count) {\n    var bin = (count % numBins) * stepsize;\n\n    if (!binnedCounts[bin]) binnedCounts[bin] = counts[count];\n    else binnedCounts[bin] += counts[count];\n  });\n\n  //store various binning properties\n  binnedCountMap.counts = binnedCounts;\n  binnedCountMap.max = max;\n  binnedCountMap.field = countData.field;\n  binnedCountMap.numBins = numBins;\n  binnedCountMap.maxCount = this.getMaxCount(binnedCounts);\n  binnedCountMap.field = countData.field;\n\n  return binnedCountMap;\n};\n\n//returns the max count of a categorical data form\nDataUtils.getMaxCount = function (counts) {\n  return Math.max.apply(Math, Object.keys(counts).map(function (count) {\n    return counts[count];\n  }));\n};\n\n/**\n * Given data, extract list of fields and information about each field\n * @param data {objects[]}\n * @param [options]\n * @param [options.fields] {Map<fieldname,fieldinfo>}\n * @param [options.ignore] {string[]} List of fieldnames to igore\n * @param [options.keepAllValues] {boolean} Whether to keep array of all values for the field\n * @param [options.keepValues] {boolean} Whether to keep a set of distinct values for the field\n * @param [options.keepCounts] {boolean} Whether to keep count of number of times a fieldvalue has occured\n * @param [options.keepStats] {boolean} Whether to keep statistics about the field (min, max, sum)\n * @return {Map<fieldname,fieldinfo>}\n */\nDataUtils.extractFieldsFromData = function(data, options) {\n  // Figure out fields from data\n  options = options || {};\n  var fields = {};\n  for (var i = 0; i < data.length; i++) {\n    var d = data[i];\n    for (var attr in d) {\n      var ignore = options.ignore && options.ignore.indexOf(attr) >= 0;\n      if (d.hasOwnProperty(attr) && !ignore) {\n        var v = d[attr];\n        if (v == undefined || v === '') continue; // ignore empty fields\n        if (!fields[attr]) {\n          var jstype = typeof v;\n          var type = null;\n          if (options.fields && options.fields[attr]) {\n            type = options.fields[attr].type;\n          }\n          if (!type) {\n            type = jsToVizTypeMap[jstype];\n          }\n          fields[attr] = { name: attr, jstype: jstype, type: type};\n          if (options.keepAllValues) {\n            fields[attr].allValues = [v];\n          }\n          if (options.keepValues) {\n            fields[attr].values = new Set();\n            fields[attr].values.add(v);\n          }\n          if (options.keepCounts) {\n            fields[attr].counts = { v: 1 };\n          }\n          if (options.keepStats) {\n            fields[attr].stats = { count: 1, min: v, max: v, sum: v, sumOfSquares: v*v };\n          }\n        } else {\n          var f = fields[attr];\n          if (options.keepAllValues) {\n            f.allValues.append(v);\n          }\n          if (options.keepValues) {\n            f.values.add(v);\n          }\n          if (options.keepCounts) {\n            if (f.counts[v]) {\n              f.counts[v]++;\n            } else {\n              f.counts[v] = 1;\n            }\n          }\n          if (options.keepStats && f.jstype === 'number') {\n            f.stats.min = Math.min(f.stats.min, v);\n            f.stats.max = Math.max(f.stats.max, v);\n            f.stats.sum += v;\n            f.stats.sumOfSquares += v*v;\n            f.stats.count++;\n          }\n        }\n      }\n    }\n  }\n  if (options.keepValues) {\n    // Turn values from Set into array\n    for (var fn in fields) {\n      if (fields.hasOwnProperty(fn)) {\n        var f = fields[fn];\n        if (f.values) {\n          f.values = Array.from(f.values);\n        }\n      }\n    }\n  }\n  return fields;\n};\n\n//exports\nmodule.exports = DataUtils;\n\n\n//# sourceURL=webpack://STK/./js/lib/data/DataUtils.js?");

/***/ }),

/***/ "./js/lib/data/TypeUtils.js":
/*!**********************************!*\
  !*** ./js/lib/data/TypeUtils.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var self = {};\n\n// TODO: Consolidate type definitions used in Grid, NRRDReader, PLYExporter/PLYLoader, sim/server\n\n// Basic definition of numeric types with number of bytes and array type\nvar types = Object.freeze({\n  'int8': { bytes: 1, array: Int8Array },\n  'uint8': { bytes: 1, array: Uint8Array },\n  'uchar': { bytes: 1, array: Uint8Array },\n  'int16': { bytes: 2, array: Int16Array },\n  'uint16': { bytes: 2, array: Uint16Array },\n  'int32': { bytes: 4, array: Int32Array },\n  'uint32': { bytes: 4, array: Uint32Array },\n  'int64': { bytes: 8 },\n  'uint64': { bytes: 8 },\n  'float32': { bytes: 4, array: Float32Array },\n  'float64': { bytes: 8, array: Float64Array }\n});\n\nvar __typedArrayToType = {\n  'Int8Array': 'int8',\n  'Int16Array': 'int16',\n  'Int32Array': 'int32',\n  'Uint8Array': 'uint8',\n  'Uint8ClampedArray': 'uint8',\n  'Uint16Array': 'uint16',\n  'Uint32Array': 'uint32',\n  'Float32Array': 'float32',\n  'Float64Array': 'float64'\n};\n\nfunction nameToTypedArray(name) {\n  if (types[name]) {\n    return types[name].array;\n  }\n  var t = __typedArrayToType[name];\n  return t? types[t].array : undefined;\n}\nself.nameToTypedArray = nameToTypedArray;\n\nfunction rle(array) {\n  var data = [];\n  if (array.length) {\n    var curr = NaN;\n    var count = 0;\n    for (var i = 0; i < array.length; i++) {\n      var d = array[i];\n      if (d !== curr) {\n        if (isNaN(d) && isNaN(curr)) {\n          count++;\n        } else {\n          if (count > 0) {\n            data.push(curr);\n            data.push(count);\n          }\n          curr = d;\n          count = 1;\n        }\n      } else {\n        count++;\n      }\n    }\n    if (count > 0) {\n      data.push(curr);\n      data.push(count);\n    }\n  }\n  return data;\n}\n\nfunction arrayToJson(array, opts) {\n  opts = opts || {};\n  var encoding = opts.encoding || 'raw';\n  var t = __typedArrayToType[array.constructor.name];\n  if (t) {\n    var data;\n    if (encoding === 'raw') {\n      data = new Array(array.length);\n      for (var i = 0; i < array.length; i++) {\n        data[i] = array[i];\n      }\n    } else if (encoding === 'rle') {\n      data = rle(array);\n    } else {\n      throw 'Unknown encoding: ' + encoding;\n    }\n    return {type: 'array', datatype: t, length: array.length, encoding: encoding, data: data};\n  } else if (Array.isArray(array)) {\n    if (encoding === 'raw') {\n      return array;\n    } else if (encoding === 'rle') {\n      var data = rle(array);\n      return {type: 'array', length: array.length, encoding: encoding, data: data};\n    } else {\n      throw 'Unknown encoding: ' + encoding;\n    }\n  } else {\n    throw 'Unsupported array type';\n  }\n\n}\nself.arrayToJson = arrayToJson;\n\nfunction jsonToArray(json, defaultValue) {\n  if (Array.isArray(json)) {\n    return json;\n  } else if (json.type === 'array') {\n    var datatype = types[json.datatype];\n    var arrayType = datatype? (datatype.array || Array) : Array;\n    var array = new arrayType(json.length);\n    var encoding = json.encoding || 'raw';\n    if (encoding === 'raw') {\n      for (var i = 0; i < json.data.length; i++) {\n        array[i] = json.data[i];\n      }\n    } else if (encoding === 'rle') {\n      var ai = 0;\n      for (var i = 0; i < json.data.length; i+=2) {\n        var d = json.data[i];\n        if (d === null) {\n          d = defaultValue;\n        }\n        var c = json.data[i+1];\n        array.fill(d, ai, ai + c);\n        ai += c;\n      }\n    } else {\n      throw 'Unknown encoding: ' + encoding;\n    }\n    return array;\n  } else {\n    throw 'Cannot convert from json to Array';\n  }\n}\nself.jsonToArray = jsonToArray;\n\nfunction getType(obj) {\n  var t = typeof obj;\n  if (t === 'object' && obj.constructor) {\n    return obj.constructor.name || t;\n  } else {\n    return t;\n  }\n}\nself.getType = getType;\n\nfunction ensureDate(obj) {\n  if (obj != undefined) {\n    var t = getType(obj);\n    if (t !== 'Date') {\n      return new Date(obj);\n    }\n  }\n  return obj;\n}\nself.ensureDate = ensureDate;\n\n// Takes string and tries to guess the type of the string (\nfunction convertString(str) {\n  if (typeof str !== 'string') return str;  // not string\n  var lowercase = str.toLowerCase();\n  if (lowercase === 'true') {\n    return true;\n  } else if (lowercase === 'false') {\n    return false;\n  } else {\n    var number = Number(str);\n    if (!isNaN(number)) {\n      return number;\n    } else {\n      // TODO: this date parsing is not very robust to different date formats\n      var date = new Date(str);\n      if (date !== \"Invalid Date\" && !isNaN(date)) {\n        return date;\n      } else {\n        return str;\n      }\n    }\n  }\n}\nself.convertString = convertString;\n\nmodule.exports = self;\n\n\n//# sourceURL=webpack://STK/./js/lib/data/TypeUtils.js?");

/***/ }),

/***/ "./js/lib/ds/BinaryHeap.js":
/*!*********************************!*\
  !*** ./js/lib/ds/BinaryHeap.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * A min heap (set scoreFunc to negative to turn into max heap)\n * @param options\n * @constructor\n * @memberOf ds\n */\nfunction BinaryHeap(options){\n  if (typeof(options) === 'function') {\n    options = { scoreFunc: options };\n  } else {\n    options = options || {};\n  }\n  this.values = [];\n  this.scoreFunc = options.scoreFunc || function (x) { return x; };\n}\nBinaryHeap.prototype.constructor = BinaryHeap;\n\nObject.defineProperty(BinaryHeap.prototype, 'isEmpty', {\n  get: function () { return this.values.length === 0; }\n});\n\nBinaryHeap.prototype.clone = function() {\n  var b = new BinaryHeap({ scoreFunc: this.scoreFunc });\n  b.values = b.values.concat(this.values);\n  return b;\n};\n\nBinaryHeap.prototype.push = function(element) {\n  for (var i = 0; i < arguments.length; i++) {\n    this.__push(arguments[i]);\n  }\n};\n\nBinaryHeap.prototype.add = function(element) {\n  for (var i = 0; i < arguments.length; i++) {\n    this.__push(arguments[i]);\n  }\n};\n\nBinaryHeap.prototype.__push = function(element) {\n  this.values.push(element);\n  this.bubbleUp(this.values.length - 1);\n};\n\nBinaryHeap.prototype.pop = function() {\n  var result = this.values[0];\n  var end = this.values.pop();\n  if (this.values.length > 0) {\n    this.values[0] = end;\n    this.sinkDown(0);\n  }\n  return result;\n};\n\n// Returns elements in sorted order\nBinaryHeap.prototype.getSorted = function(convertFn) {\n var sorted = [];\n var b = this.clone();\n while (b.size() > 0) {\n   if (convertFn) {\n     sorted.push(convertFn(b.pop()));\n   } else {\n     sorted.push(b.pop());\n   }\n }\n return sorted;\n};\n\nBinaryHeap.prototype.peek = function() {\n  return this.values[0];\n};\n\nBinaryHeap.prototype.remove = function(node) {\n  return this.removeWhere(function(n) { return n == node; });\n};\n\nBinaryHeap.prototype.removeWhere = function(predicate) {\n  var length = this.values.length;\n  var removed;\n  for (var i = 0; i < length; i++) {\n    if (!predicate(this.values[i])) { continue; }\n    var end = this.values.pop();\n    if (i == length - 1) { break; }\n    removed = this.values[i];\n    this.values[i] = end;\n    this.bubbleUp(i);\n    this.sinkDown(i);\n    break;\n  }\n  return removed;\n};\n\nBinaryHeap.prototype.size = function() {\n  return this.values.length;\n};\n\nBinaryHeap.prototype.bubbleUp = function(n) {\n  var element = this.values[n];\n  var score = this.scoreFunc(element);\n  while (n > 0) {\n    var parentN = Math.floor((n + 1) / 2) - 1;\n    var parent = this.values[parentN];\n    if (score >= this.scoreFunc(parent)) { break; }\n    this.values[parentN] = element;\n    this.values[n] = parent;\n    n = parentN;\n  }\n};\n\nBinaryHeap.prototype.sinkDown = function(n) {\n  var length = this.values.length;\n  var element = this.values[n];\n  var elemScore = this.scoreFunc(element);\n\n  while(true) {\n    var child2N = (n + 1) * 2, child1N = child2N - 1;\n    var swap = null;\n    var child1Score = null;\n    if (child1N < length) {\n      var child1 = this.values[child1N];\n      child1Score = this.scoreFunc(child1);\n      if (child1Score < elemScore) {\n        swap = child1N;\n      }\n    }\n    if (child2N < length) {\n      var child2 = this.values[child2N];\n      var child2Score = this.scoreFunc(child2);\n      if (child2Score < (swap == null ? elemScore : child1Score)) {\n        swap = child2N;\n      }\n    }\n\n    if (swap == null) { break; }\n\n    this.values[n] = this.values[swap];\n    this.values[swap] = element;\n    n = swap;\n  }\n};\n\nmodule.exports = BinaryHeap;\n\n\n//# sourceURL=webpack://STK/./js/lib/ds/BinaryHeap.js?");

/***/ }),

/***/ "./js/lib/ds/BoundedBinaryHeap.js":
/*!****************************************!*\
  !*** ./js/lib/ds/BoundedBinaryHeap.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var BinaryHeap = __webpack_require__(/*! ds/BinaryHeap */ \"./js/lib/ds/BinaryHeap.js\");\n\n/**\n * Binary heap that is bounded in size.\n * Note: The binary heap has as the head the element with the lowest score (based on ordering)\n *       We only compare against the head, and so end up keeping the elements with the highest scores.\n * To get values out in lowest order to highest (use getSorted)\n *\n * This is a bit weird - really should use a MinMaxHeap (heap that is easy to get both min and max)\n * To keep lowest actual scores s: use scoreFunc = -s\n *                                 this will keep k highest -s (so lowest s)\n *                                 and then use getSorted.reverse to get k ordered from lowest to highest\n * @constructor\n * @memberOf ds\n */\nfunction BoundedBinaryHeap(options) {\n  BinaryHeap.call(this, options);\n  this.maxSize = options.maxSize;\n}\n\nBoundedBinaryHeap.prototype = Object.create(BinaryHeap.prototype);\nBoundedBinaryHeap.prototype.constructor = BoundedBinaryHeap;\n\nObject.defineProperty(BoundedBinaryHeap.prototype, 'isFull', {\n  get: function () { return this.values.length >= this.maxSize; }\n});\n\nBoundedBinaryHeap.prototype.clone = function() {\n  var b = new BoundedBinaryHeap({ scoreFunc: this.scoreFunc, maxSize: this.maxSize });\n  b.values = b.values.concat(this.values);\n  return b;\n};\n\nBoundedBinaryHeap.prototype.__push = function(element) {\n  if (this.values.length >= this.maxSize) {\n    // keep maxSize highest scores...\n    // compare against element with lowest priority, if we are higher add ourselves\n    var head = this.peek();\n    if (this.scoreFunc(element) > this.scoreFunc(head)) {\n      this.pop();\n      BinaryHeap.prototype.__push.call(this, element);\n    }\n  } else {\n    BinaryHeap.prototype.__push.call(this, element);\n  }\n};\n\nmodule.exports = BoundedBinaryHeap;\n\n\n//# sourceURL=webpack://STK/./js/lib/ds/BoundedBinaryHeap.js?");

/***/ }),

/***/ "./js/lib/ds/Counter.js":
/*!******************************!*\
  !*** ./js/lib/ds/Counter.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// A structure that accumulates counts\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction Counter(opts) {\n  opts = opts || {};\n  this.__defaultCount = opts.defaultCount || 0;\n  if (opts.id) {\n    if (_.isFunction(opts.id)) {\n      this.__idFn = opts.id;\n    } else if (_.isString(opts.id)) {\n      this.__idFn = function(x) { return x[opts.id]; };\n    } else {\n      throw new TypeError('Unsupported id field: ' + opts.id);\n    }\n  } else {\n    this.__idFn = function(x) { return x; };\n  }\n  this.clear();\n}\n\nObject.defineProperty(Counter.prototype, 'sum', {\n  get: function () {\n    if (this.__sum == undefined) {\n      this.__sum = _.sum(_.values(this.__counts));\n    }\n    return this.__sum;\n  }\n});\n\nCounter.prototype.clear = function() {\n  this.__counts = {};\n  this.__sum = undefined;\n};\n\nCounter.prototype.size = function() {\n  return _.size(this.__counts);\n};\n\nCounter.prototype.set = function(obj, count) {\n  var id = this.__idFn(obj);\n  if (this.__sum != undefined) {\n    this.__sum += (count - (this.__counts[id] || 0));\n  }\n  this.__counts[id] = count;\n};\n\nCounter.prototype.get = function(obj) {\n  var id = this.__idFn(obj);\n  return this.__counts[id] || this.__defaultCount;\n};\n\nCounter.prototype.getCounts = function() {\n  return this.__counts;\n};\n\nCounter.prototype.add = function(obj, count) {\n  count = count || 1;\n  var id = this.__idFn(obj);\n  this.__counts[id] = (this.__counts[id] || this.__defaultCount) + count;\n  if (this.__sum != undefined) {\n    this.__sum += count;\n  }\n};\n\nCounter.prototype.update = function(counts) {\n  if (Array.isArray(counts)) {\n    for (var i = 0; i < counts.length; i++) {\n      this.add(counts[i], 1);\n    }\n  } else {\n    var scope = this;\n    _.forEach(counts, function(v,k) {\n      scope.add(k, v);\n    });\n  }\n};\n\nCounter.prototype.sample = function(opts) {\n  opts = opts || {};\n  var cumulativeWeights = [];\n  var keys = [];\n  var total = this.__defaultCount;\n  var counts = this.__counts;\n  _.each(counts, function(count, key) {\n    if (!opts.filter || opts.filter(key)) {\n      total += count;\n      cumulativeWeights.push(total);\n      keys.push(key);\n    }\n  });\n\n  // pick random weighted\n  var rng = opts.rng || RNG.global;\n  var r = rng.random() * total;\n  var index = _.sortedIndex(cumulativeWeights, r);\n  //console.log('sample ' + keys[index] + ' with count ' + this.__counts[keys[index]]);\n  return keys[index];\n};\n\nCounter.prototype.filterCounts = function(filter) {\n  this.__counts = _.pickBy(this.__counts, filter);\n  this.__sum = undefined;\n};\n\nCounter.prototype.filter = function(filter) {\n  var c = new Counter();\n  c.copy(this, filter);\n  return c;\n};\n\nCounter.prototype.clone = function() {\n  var c = new Counter();\n  c.copy(this);\n  return c;\n};\n\nCounter.prototype.copy = function(counter, filter) {\n  this.__idFn = counter.__idFn;\n  this.__defaultCount = counter.__defaultCount;\n  if (filter) {\n    this.__counts = _.pickBy(counter.__counts, filter);\n    this.__sum = undefined;\n  } else {\n    this.__counts = _.clone(counter.__counts);\n    this.__sum = counter.__sum;\n  }\n};\n\nmodule.exports = Counter;\n\n//# sourceURL=webpack://STK/./js/lib/ds/Counter.js?");

/***/ }),

/***/ "./js/lib/ds/Index.js":
/*!****************************!*\
  !*** ./js/lib/ds/Index.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// A structure that maps from objects to integers\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction Index(opts) {\n  opts = opts || {};\n  this.name = opts.name;\n  this.filename = opts.filename || opts.name;\n  if (opts.id) {\n    if (_.isFunction(opts.id)) {\n      this.__idFn = opts.id;\n    } else if (_.isString(opts.id)) {\n      this.__idFn = function(x) { return x[opts.id]; };\n    } else {\n      throw new TypeError('Unsupported id field: ' + opts.id);\n    }\n  } else {\n    this.__idFn = function(x) { return x; };\n  }\n  this.clear();\n}\n\nIndex.prototype.clear = function() {\n  this.__objects = [];\n  this.__idToIndex = new Map();\n\n  // Support additional metadata associated with the index\n  this.__indexToMetadata = {}; // Additional metadata for objects (by index)\n  this.__metadataFields = [];\n};\n\nObject.defineProperty(Index.prototype, 'idToIndex', {\n  get: function () { return this.__idToIndex; }\n});\n\nIndex.prototype.id = function(obj) {\n  return this.__idFn(obj);\n};\n\nIndex.prototype.indexOf = function(obj, add, metadata) {\n  var id = this.__idFn(obj);\n  var i = this.__idToIndex[id];\n  if (i == undefined) {\n    if (add) {\n      i = this.__objects.length;\n      this.__objects.push(obj);\n      this.__idToIndex[id] = i;\n      if (metadata) {\n        this.__indexToMetadata[i] = metadata;\n        var scope = this;\n        _.forEach(metadata, function(v,k) {\n          if (scope.__metadataFields.indexOf(k) < 0) {\n            scope.__metadataFields.push(k);\n          }\n        });\n      }\n    }\n  }\n  return i;\n};\n\nIndex.prototype.get = function(index) {\n  return this.__objects[index];\n};\n\nIndex.prototype.metadata = function(index, field) {\n  var m = this.__indexToMetadata[index];\n  if (field != null) {\n    return m? m[field] : undefined;\n  } else {\n    return m;\n  }\n};\n\nIndex.prototype.add = function(obj, metadata) {\n  // return true if added, false otherwise\n  var sz = this.size();\n  var index = this.indexOf(obj, true, metadata);\n  return (index >= sz);\n};\n\nIndex.prototype.addAll = function(list) {\n  for (var i = 0; i < list.length; i++) {\n    this.indexOf(list[i], true);\n  }\n};\n\nIndex.prototype.indices = function(filter) {\n  var keys = _.map(this.__objects, function(v,k) { return filter(v,k)? k : -1; });\n  return _.filter(keys, function(i) { return i >= 0; });\n};\n\nIndex.prototype.objects = function() {\n  return this.__objects;\n};\n\nIndex.prototype.size = function() {\n  return this.__objects.length;\n};\n\nIndex.prototype.importCsv = function(opts) {\n  var fs = opts.fs;\n  var filename = opts.filename;\n  var callback = opts.callback;\n\n  var scope = this;\n  fs.readAsync(filename, 'utf-8', function(err, data) {\n    if (data) {\n      scope.parse(data, opts);\n    }\n    callback(err, scope);\n  });\n};\nIndex.prototype.import = Index.prototype.importCsv;\n\nIndex.prototype.parse = function(data, opts) {\n  opts = opts || {};\n  var indexField = opts.indexField || 'index';\n  var idField = opts.idField || 'label';\n  this.clear();\n  var IOUtil = __webpack_require__(/*! io/IOUtil */ \"./js/lib/io/IOUtil.js\");\n  var parsed = IOUtil.parseDelimited(data, { header: true, skipEmptyLines: true, dynamicTyping: true });\n  var fields = parsed.meta.fields;\n  this.__metadataFields = fields.filter(function(x) { return x !== idField && x !== indexField; });\n  for (var i = 0; i < parsed.data.length; i++) {\n    var d = parsed.data[i];\n    this.__objects[d[indexField]] = d[idField];\n    this.__idToIndex[d[idField]] = d[indexField];\n    if (this.__metadataFields.length) {\n      this.__indexToMetadata[d.index] = _.omit(d, [indexField, idField]);\n    }\n  }\n};\n\nIndex.prototype.fromLabelIndexMap = function(map) {\n  var scope = this;\n  _.forEach(map, function(i,k) {\n    scope.__objects[i] = k;\n    scope.__idToIndex[k] = i;\n  });\n};\n\nIndex.prototype.exportCsv = function(opts) {\n  var fs = opts.fs;\n  var outfilename = opts.filename;\n  var callback = opts.callback;\n\n  var scope = this;\n  var header = _.concat(['index', 'label'], this.__metadataFields);\n  var labelsStr = header.map(function(x) { return _.escapeCsv(x); }).join(',') + '\\n' + _.map(this.__objects, function(object,i) {\n    var label = scope.__idFn(object);\n    var metadata = scope.__indexToMetadata[i] || {};\n    var row = _.concat([i, label], scope.__metadataFields.map(function(x) { return (metadata[x] != undefined)? metadata[x] : ''; }));\n    return row.map(function(x) { return _.escapeCsv(x); }).join(',');\n  }).join('\\n');\n  fs.fsWriteToFile(outfilename, labelsStr, function() {\n    fs.fsExportFile(outfilename, outfilename);\n    console.log('Exported label index to ' + outfilename);\n    callback(null, null);\n  }, function(err) {\n    console.warn('Error exporting labels to ' + outfilename + ': ', err);\n    callback(err, null);\n  });\n};\nIndex.prototype.export = Index.prototype.exportCsv;\n\nIndex.import = function(opts) {\n  var index = new Index();\n  index.import(opts);\n  return index;\n};\n\nmodule.exports = Index;\n\n//# sourceURL=webpack://STK/./js/lib/ds/Index.js?");

/***/ }),

/***/ "./js/lib/ds/IndexedCounters.js":
/*!**************************************!*\
  !*** ./js/lib/ds/IndexedCounters.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nvar Counter = __webpack_require__(/*! ds/Counter */ \"./js/lib/ds/Counter.js\");\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction IndexedCounters(opts) {\n  this.name = opts.name;\n  this.filename = opts.filename || opts.name;\n  this.indices = opts.indices;\n  if (opts.fieldnames) {\n    this.fieldnames = _.map(this.indices, function(x,i) {\n      var name = (opts.fieldnames[i] != undefined)? opts.fieldnames[i] : x.name;\n      return name;\n    });\n  } else {\n    this.fieldnames = _.map(this.indices, function(x) { return x.name; });\n  }\n  this.counters = {};   // TODO: Consider changing to be NestedCounter\n  this.depth = this.indices.length;\n}\n\nIndexedCounters.prototype.sample = function(keys, opts) {\n  opts = opts || {};\n  var rng = opts.rng || RNG.global;\n  var isIndexedKeys = opts.isIndexedKeys;\n  var c = this.get(keys, isIndexedKeys);\n  if (c) {\n    var sampled = [];\n    while (c && !(c instanceof Counter)) {\n      var ckeys = _.keys(c);\n      // TODO: Sampling here should be on aggregated weights (NOT uniform)\n      var i = rng.random() * ckeys.length;\n      var k = ckeys[i];\n      if (isIndexedKeys) {\n        sampled.push(k);\n      } else {\n        // Convert to meaningful values\n        var v = this.indices[keys.length + sampled.length].get(k);\n        sampled.push(v);\n      }\n      c = c[k];\n    }\n    if (c) {\n      var s = c.sample(opts);\n      if (isIndexedKeys) {\n        sampled.push(s);\n      } else {\n        // Convert to meaningful values\n        var v = this.indices[keys.length + sampled.length].get(s);\n        sampled.push(v);\n      }\n    }\n    return sampled;\n  }\n};\n\nIndexedCounters.prototype.get = function(keys, isIndexedKeys) {\n  var c = this.counters;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var k = (this.indices && !isIndexedKeys)? this.indices[i].indexOf(key, true) : key;\n    if (i === keys.length - 1) {\n      return (c instanceof Counter)? c.get(k) : c[k];\n    } else {\n      c = c[k];\n    }\n  }\n  return c;\n};\n\nIndexedCounters.prototype.filter = function(filter) {\n  var indices = this.indices;\n  function __filter(src, dest, keys) {\n    if (src instanceof Counter) {\n      var counter = src.filter(function(c,k) {\n        return filter(c, _.concat(keys, [k]), indices);\n      });\n      //return (counter.size > 0)? counter : null;\n      return counter;\n    } else {\n      _.each(src, function (c, k) {\n        var ks = _.concat(keys, [k]);\n        dest[k] = __filter(c, {}, ks);\n      });\n      return dest;\n    }\n  }\n  var copy = new IndexedCounters({ indices: indices });\n  __filter(this.counters, copy.counters, []);\n  return copy;\n};\n\nIndexedCounters.prototype.add = function(keys, count, isIndexedKeys) {\n  var c = this.counters;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var k = (this.indices && !isIndexedKeys)? this.indices[i].indexOf(key, true) : key;\n    if (i === keys.length - 1) {\n      c.add(k, count);\n    } else {\n      if (i < keys.length - 2) {\n        c[k] = c[k] || {};\n      } else {\n        c[k] = c[k] || new Counter();\n      }\n      c = c[k];\n    }\n  }\n};\n\nIndexedCounters.prototype.clear = function() {\n  this.counters = {};\n};\n\nIndexedCounters.prototype.importCsv = function(opts) {\n  var fs = opts.fs;\n  var filename = opts.filename;\n  var callback = opts.callback;\n\n  var scope = this;\n  fs.readAsync(filename, 'utf-8', function(err, data) {\n    if (data) {\n      scope.parse(data, opts);\n    }\n    callback(err, scope);\n  });\n};\n\nIndexedCounters.prototype.parse = function(data, opts) {\n  opts = opts || {};\n  var useSavedIndex = opts.useSavedIndex;\n  this.clear();\n  var IOUtil = __webpack_require__(/*! io/IOUtil */ \"./js/lib/io/IOUtil.js\");\n  var parsed = IOUtil.parseDelimited(data, { header: true, skipEmptyLines: true, dynamicTyping: true });\n  var keyFields = _.map(this.fieldnames, function(x) { return useSavedIndex? x + '_index':x; });\n  for (var i = 0; i < parsed.data.length; i++) {\n    var d = parsed.data[i];\n    var keys = _.map(keyFields, function(f) { return d[f]; });\n    this.add(keys, d.count, useSavedIndex);\n  }\n};\n\nIndexedCounters.prototype.exportCsv = function(opts) {\n  var fs = opts.fs;\n  var outfilename = opts.filename;\n  var callback = opts.callback;\n\n  var scope = this;\n  var header = _.flatMap(this.fieldnames, function(x) { return [x, x + '_index']; });\n  header.push('count');\n\n  function exportCounts(c, i, values, cb) {\n    var index = scope.indices[i];\n    if (c instanceof Counter) {\n      var output = _.map(c.getCounts(), function(count,k) {\n        var label = index.get(k);\n        var row = _.concat(values, [label, k, count]);\n        return row.map(function(x) { return _.escapeCsv(x); }).join(',');\n      }).join('\\n') + '\\n';\n      fs.fsAppendToFile(outfilename, output, function() {\n        setTimeout(function() { cb(null, null); }, 0);\n      }, function(err) {\n        setTimeout(function() { cb(err, null); }, 0);\n      });\n    } else {\n      async.forEachOfSeries(c, function(value, k, cb2) {\n        var label = index.get(k);\n        exportCounts(c[k], i+1, _.concat(values, [label, k]), cb2);\n      }, function(err, results) {\n        setTimeout(function() { cb(err, null); }, 0);\n      });\n    }\n  }\n\n  var labelsStr = header.map(function(x) { return _.escapeCsv(x); }).join(',') + '\\n';\n  var scope = this;\n  fs.fsWriteToFile(outfilename, labelsStr, function() {\n    exportCounts(scope.counters, 0, [], function() {\n      fs.fsExportFile(outfilename, outfilename);\n      console.log('Exported indexed counts to ' + outfilename);\n      callback(null, null);\n    });\n  }, function(err) {\n    console.warn('Error exporting indexed counts to ' + outfilename + ': ', err);\n    callback(err, null);\n  });\n};\n\nmodule.exports = IndexedCounters;\n\n//# sourceURL=webpack://STK/./js/lib/ds/IndexedCounters.js?");

/***/ }),

/***/ "./js/lib/ds/Tree.js":
/*!***************************!*\
  !*** ./js/lib/ds/Tree.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Tree {\n  constructor(root) {\n    this.root = root;\n  }\n\n  getNodes(filter) {\n    var nodes = [];\n    this.traverse(x => {\n      if (!filter || filter(x)) {\n        nodes.push(x);\n      }\n    });\n    return nodes;\n  };\n\n  traverse(cbPre, cbPost, checkPre) {\n    this.traverseNode(this.root, cbPre, cbPost, checkPre);\n  };\n\n  traverseNode(node, cbPre, cbPost, checkPre) {\n    if (cbPre) {\n      const traverseMore = cbPre(node);\n      if (checkPre && !traverseMore) {\n        return; // Stop traversal\n      }\n    }\n    if (node.children) {\n      for (let i = 0; i < node.children.length; i++) {\n        this.traverseNode(node.children[i], cbPre, cbPost, checkPre);\n      }\n    }\n    if (cbPost) {\n      cbPost(node);\n    }\n  };\n\n  convert(convertFn) {\n    const root = this.convertNodes(this.root, convertFn);\n    return new this.constructor(root);\n  }\n\n  convertNodes(node, convertFn) {\n    const converted = convertFn(node);\n    if (node.children) {\n      converted.children = node.children.map(c => this.convertNodes(c, convertFn));\n      converted.children.forEach(c => c.parent = converted);\n    }\n    return converted;\n  }\n}\n\nmodule.exports = Tree;\n\n//# sourceURL=webpack://STK/./js/lib/ds/Tree.js?");

/***/ }),

/***/ "./js/lib/ds/VPTree.js":
/*!*****************************!*\
  !*** ./js/lib/ds/VPTree.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n *                                                                                                         \n *      vptree.js v0.2.3                                                                                   \n *      https://github.com/fpirsch/vptree.js                                                               \n *                                                                                                         \n *      A javascript implementation of the Vantage-Point Tree algorithm                                    \n *      ISC license (http://opensource.org/licenses/ISC). Franois Pirsch. 2013.                           \n *                                                                                                         \n *      Date: 2015-12-24T11:39Z                                                                            \n *                                                                                                         \n *\n */\n\n/*\n    Selection/partition algorithm                                           \n */\n\nfunction partition(list, left, right, pivotIndex, comp) {\n  var pivotValue = list[pivotIndex];\n  var swap = list[pivotIndex];\t// Move pivot to end\n  list[pivotIndex] = list[right];\n  list[right] = swap;\n  var storeIndex = left;\n  for (var i = left; i < right; i++) {\n    if (comp(list[i], pivotValue)) {\n      swap = list[storeIndex];\n      list[storeIndex] = list[i];\n      list[i] = swap;\n      storeIndex++;\n    }\n  }\n  swap = list[right];\t\t\t\t// Move pivot to its final place\n  list[right] = list[storeIndex];\n  list[storeIndex] = swap;\n  return storeIndex;\n}\n\n// Pivot selection : computes the median of elements a, b and c of the list,\n// according to comparator comp.\nfunction medianOf3(list, a, b, c, comp) {\n  var A = list[a], B = list[b], C = list[c];\n  return comp (A, B) ?\n    comp (B, C) ? b : comp (A, C) ? c : a :\n    comp (A, C) ? a : comp (B, C) ? c : b;\n}\n\n/**\n * Quickselect : Finds the nth smallest number in a list according to comparator comp.\n * All elements smaller than the nth element are moved to its left (in no particular order),\n * and all elements greater thant the nth are moved to its right.\n *\n * The funny mix of 0-based and 1-based indexes comes from the C++\n * Standard Library function nth_element.\n *\n * @param {Array} list - the list to partition\n * @param {int} left - index in the list of the first element of the sublist.\n * @param {int} right - index in the list of the last element of the sublist (inclusive)\n * @param {int} nth - index, in the range [1, sublist.length] of the element to find.\n * @param {function} comp - a comparator, i.e. a boolean function accepting two parameters a and b,\n *        and returning true if a < b and false if a >= b.\n *\n * See http://en.wikipedia.org/wiki/Quickselect\n * And /include/bits/stl_algo.h in the GCC Standard Library ( http://gcc.gnu.org/libstdc++/ )\n * @private\n */\nfunction nth_element(list, left, nth, right, comp) {\n  if (nth <= 0 || nth > (right-left+1)) throw new Error(\"VPTree.nth_element: nth must be in range [1, right-left+1] (nth=\"+nth+\")\");\n  var pivotIndex, pivotNewIndex, pivotDist;\n  for (;;) {\n    // select pivotIndex between left and right\n    pivotIndex = medianOf3(list, left, right, (left + right) >> 1, comp);\n    pivotNewIndex = partition(list, left, right, pivotIndex, comp);\n    pivotDist = pivotNewIndex - left + 1;\n    if (pivotDist === nth) {\n      return list[pivotNewIndex];\n    }\n    else if (nth < pivotDist) {\n      right = pivotNewIndex - 1;\n    }\n    else {\n      nth -= pivotDist;\n      left = pivotNewIndex + 1;\n    }\n  }\n}\n\n\n/**\n * Wrapper around nth_element with a 0-based index.\n * @private\n */\nfunction select(list, k, comp) {\n  if (k < 0 || k >= list.length) {\n    throw new Error(\"VPTree.select: k must be in range [0, list.length-1] (k=\"+k+\")\");\n  }\n  return nth_element(list, 0, k+1, list.length-1, comp);\n}\n\n\n/*\n    vp-tree creation                                                        \n */\n/** Selects a vantage point in a set.\n *  We trivially pick one at random.\n *  TODO this could be improved by random sampling to maximize spread.\n * @private\n */\nfunction selectVPIndex(list) {\n  return Math.floor(Math.random() * list.length);\n}\n\nvar distanceComparator = function(a, b) { return a.dist < b.dist; };\n\n/**\n * Builds and returns a vp-tree from the list S.\n * @param {Array|int} S array of objects to structure into a vp-tree.  Can optionally be a integer (then the array is assumed to be the range 0..S).\n * @param {function} distance a function returning the distance between 2 objects from the list S.\n * @param {number} nb (maximum) bucket size. 0 or undefined = no buckets used.\n * @return {object} vp-tree.\n * @private\n */\nfunction buildVPTree(S, distance, nb) {\n  if (typeof S === 'number') {\n    var size = S;\n    // S is meant to be indices\n    // Create array\n    // this.S = (S < 65536)? new Uint16Array(S) : new Uint32Array(S);\n    S = new Array(size);\n    for (var i = 0; i < size; i++) {\n      S[i] = i;\n    }\n  }\n\n  var list = [];\n  for (var i = 0, n = S.length; i < n; i++) {\n    list[i] = {\n      i: i\n      //hist: []\t\t// unused (yet)\n    };\n  }\n\n  var tree = recurseVPTree(S, list, distance, nb);\n  return new VPTree(S, distance, tree);\n}\n\nfunction recurseVPTree(S, list, distance, nb) {\n  if (list.length === 0) return null;\n  var i;\n\n  // Is this a leaf node ?\n  var listLength = list.length;\n  if (nb > 0 && listLength <= nb) {\n    var bucket = [];\n    for (i = 0; i < listLength; i++) {\n      bucket[i] = list[i].i;\n    }\n    return bucket;\n  }\n\n  // Non-leaf node.\n  // Constructs a node with the selected vantage point extracted from the set.\n  var vpIndex = selectVPIndex(list),\n    node = list[vpIndex];\n  list.splice(vpIndex, 1);\n  listLength--;\n  // We can't use node.dist yet, so don't show it in the vp-tree output.\n  node = { i: node.i };\n  if (listLength === 0) return node;\n\n  // Adds to each item its distance to the vantage point.\n  // This ensures each distance is computed only once.\n  var vp = S[node.i],\n    dmin = Infinity,\n    dmax = 0,\n    item, dist, n;\n  for (i = 0, n = listLength; i < n; i++) {\n    item = list[i];\n    dist = distance(vp, S[item.i]);\n    item.dist = dist;\n    //item.hist.push(dist);\t// unused (yet)\n    if (dmin > dist) dmin = dist;\n    if (dmax < dist) dmax = dist;\n  }\n  node.m = dmin;\n  node.M = dmax;\n\n  // Partitions the set around the median distance.\n  var medianIndex = listLength >> 1,\n    median = select(list, medianIndex, distanceComparator);\n\n  // Recursively builds vp-trees with the 2 resulting subsets.\n  var leftItems = list.splice(0, medianIndex),\n    rightItems = list;\n  node.mu = median.dist;\n  node.L = recurseVPTree(S, leftItems, distance, nb);\n  node.R = recurseVPTree(S, rightItems, distance, nb);\n  return node;\n}\n\n\n/**\n * Stringifies a vp-tree data structure.\n *  JSON without the null nodes and the quotes around object keys, to save space.\n * @function stringify\n * @memberOf VPTree\n * @instance\n */\nfunction stringify(root) {\n  var stack = [root || this.tree], s = '';\n  while (stack.length) {\n    var node = stack.pop();\n\n    // Happens if the bucket size is greater thant the dataset.\n    if (node.length) return '['+node.join(',')+']';\n\n    s += '{i:' + node.i;\n    if (node.hasOwnProperty('m')) {\n      s += ',m:' + node.m + ',M:' + node.M + ',mu:' + node.mu;\n    }\n    if (node.hasOwnProperty('b')) {\n      s += ',b:[' + node.b + ']';\n    }\n    if (node.hasOwnProperty('L')) {\n      var L = node.L;\n      if (L) {\n        s += ',L:';\n        if (L.length) s += '[' + L + ']';\n        else s += stringify(L);\n      }\n    }\n    if (node.hasOwnProperty('R')) {\n      var R = node.R;\n      if (R) {\n        s += ',R:';\n        if (R.length) s += '[' + R + ']';\n        else s += stringify(R);\n      }\n    }\n    s += '}';\n  }\n  return s;\n}\n\n/*\n    Priority Queue, used to store search results.                           \n */\n\n/**\n * @constructor\n * @class PriorityQueue manages a queue of elements with priorities.\n *\n * @param {number} size maximum size of the queue. Only lowest priority items will be retained.\n * @private\n */\nfunction PriorityQueue(size) {\n  var contents = [];\n\n  function binaryIndexOf(priority) {\n    var minIndex = 0,\n      maxIndex = contents.length - 1,\n      currentIndex,\n      currentElement;\n\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) >> 1;\n      currentElement = contents[currentIndex].priority;\n\n      if (currentElement < priority) {\n        minIndex = currentIndex + 1;\n      }\n      else if (currentElement > priority) {\n        maxIndex = currentIndex - 1;\n      }\n      else {\n        return currentIndex;\n      }\n    }\n\n    return -1 - minIndex;\n  }\n\n  var api = {\n    // This breaks IE8 compatibility. Who cares ?\n    get length() {\n      return contents.length;\n    },\n\n    insert: function(data, priority) {\n      var index = binaryIndexOf(priority);\n      if (index < 0) index = -1 - index;\n      if (!size || index < size) {\n        contents.splice(index, 0, {data: data, priority: priority});\n        if (size && contents.length > size) {\n          contents.length--;\n        }\n      }\n      return (size && contents.length === size)? contents[contents.length - 1].priority : undefined;\n    },\n\n    list: function() {\n      return contents.map(function(item){ return {i: item.data, d: item.priority}; });\n    }\n  };\n\n  return api;\n}\n\n\n/*\n    vp-tree search                                                          \n */\n\n/**\n * @param {object} q - query : any object the distance function can be applied to.\n * @param {number} [limit=infinity] - number of nearest neighbors to find\n * @param {number} [maxDistance=infinity] - maximum distance from element q\n *\n * @return {object[]} list of search results, ordered by increasing distance to the query object.\n *                    Each result has a property i which is the index of the element in S, and d which\n *                    is its distance to the query object.\n * @function search\n * @memberOf VPTree\n * @instance\n */\nfunction searchVPTree(q, limit, maxDistance, queryDistFn, filterFn) {\n  var n = limit;\n  maxDistance = maxDistance || Infinity;\n  var tau = maxDistance;\n  var W = new PriorityQueue(n),\n    S = this.S,\n    distance = queryDistFn || this.distance,\n    comparisons = 0;\n\n  function doSearch(node) {\n    if (node === null) return;\n\n    // Leaf node : test each element in this node's bucket.\n    if (node.length) {\n      for (var i = 0, n = node.length; i < n; i++) {\n        comparisons++;\n        var elementID = node[i],\n          element = S[elementID],\n          elementDist = distance(q, element);\n        if (elementDist < tau) {\n          if (!filterFn || filterFn(element)) {\n            tau = W.insert(elementID, elementDist) || tau;\n          }\n        }\n      }\n      return;\n    }\n\n    // Non-leaf node\n    var id = node.i,\n      p = S[id],\n      dist = distance(q, p);\n\n    comparisons++;\n\n    // This vantage-point is close enough to q.\n    if (dist < tau) {\n      if (!filterFn || filterFn(p)) {\n        tau = W.insert(id, dist) || tau;\n      }\n    }\n\n    // The order of exploration is determined by comparison with mu.\n    // The sooner we find elements close to q, the smaller tau and the more nodes we skip.\n    // P. Yianilos uses the middle of left/right bounds instead of mu.\n    // We search L if dist is in (m - tau, mu + tau), and R if dist is in (mu - tau, M + tau)\n    var mu = node.mu, L = node.L, R = node.R;\n    if (mu === undefined) return;\n    if (dist < mu) {\n      if (L && node.m - tau < dist) doSearch(L);\n      if (R && mu - tau < dist) doSearch(R);\n    }\n    else {\n      if (R && dist < node.M + tau) doSearch(R);\n      if (L && dist < mu + tau) doSearch(L);\n    }\n  }\n\n  doSearch(this.tree);\n  this.comparisons = comparisons;\n  return W.list();\n}\n\n\n\n/*\n    vp-tree constructor                                                     \n */\n\n/**\n * @constructor\n * @class VPTree manages a vp-tree.\n *\n * @param {Array} S the initial set of elements\n * @param {Function} distance the distance function\n * @param {Object} the vp-tree structure\n * @memberOf ds\n */\nfunction VPTree(S, distance, tree) {\n  this.S = S;\n  this.distance = distance;\n  this.tree = tree;\n\n  this.search = searchVPTree;\n  this.comparisons = 0;\n  this.stringify = stringify;\n}\n\n/*\n    Build Public API                                                        \n */\n\nvar VPTreeFactory = {\n  select: select,\n  build: buildVPTree,\n  load: function (S, distance, tree) {\n    return new VPTree(S, distance, tree);\n  }\n};\n\nmodule.exports = VPTreeFactory;\n\n//# sourceURL=webpack://STK/./js/lib/ds/VPTree.js?");

/***/ }),

/***/ "./js/lib/ds/util.js":
/*!***************************!*\
  !*** ./js/lib/ds/util.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const DSUtils = {};\n\n/**\n * Compute which parts is connected to which other parts\n * @param partIndices {int[]}\n * @param isConnected {function(int, int): boolean} Function that returns if part i and part j are connected\n * @returns {Array<Array<int>>} Array of connected component (each represented as array of part ids)\n */\nDSUtils.identifyConnectedComponents = function(partIndices, isConnected) {\n  let components = [];\n  let remaining = partIndices.slice();\n  while (remaining.length > 0) {\n    let connected = [remaining.shift()];\n    let done = false;\n    while (!done) {\n      let rest = [];\n      for (let i = 0; i < remaining.length; i++) {\n        const di = remaining[i];\n        let added = false;\n        for (let j = 0; j < connected.length; j++) {\n          const dj = connected[j];\n          if (isConnected(di, dj)) {\n            connected.push(di);\n            added = true;\n            break;\n          }\n        }\n        if (!added) {\n          rest.push(di);\n        }\n      }\n      done = (rest.length === remaining.length); // Nothing was added\n      remaining = rest;\n    }\n    components.push(connected);\n  }\n\n  return components;\n};\n\n/**\n * Compute which parts is connected to which other parts\n * @param partIndices {int[]}\n * @param distanceMatrix Array<Array[number]> Array where element i,j contains distance from part i to part j\n * @param distanceThreshold {number} Treat anything less than this as connected\n * @param getDistanceFn {function(x)} Extract distance from distance matrix\n * @returns {Array<Array<int>>} Array of connected component (each represented as array of part ids)\n */\nDSUtils.identifyConnectedComponentsFromDistanceMatrix = function(partIndices, distanceMatrix, distanceThreshold, getDistanceFn) {\n  return DSUtils.identifyConnectedComponents(partIndices, (di,dj) => {\n    const dist = distanceMatrix.get(di, dj);\n    if (getDistanceFn) {\n      return (getDistanceFn(dist) < distanceThreshold);\n    } else {\n      return (dist < distanceThreshold);\n    }\n  });\n};\n\n/**\n * Compute which parts is connected to which other parts\n * @param parts {Array}\n * @param partIndices {int[]}\n * @param distanceMatrix Array<Array[number]> Array where element i,j contains distance from part i to part j\n * @param distanceThreshold {number} Treat anything less than this as connected\n * @param distanceFn {function(i,j)} Compute distance between part i and part j\n * @param getDistanceFn {function(x)} Extract distance from distance matrix\n * @returns {Array<Array<int>>} Array of connected component (each represented as array of part ids)\n */\nDSUtils.identifyConnectedComponentsWithCachedDistanceMatrix = function(parts, partIndices, distanceMatrix,\n                                                                       distanceThreshold, distanceFn, getDistanceFn) {\n  return DSUtils.identifyConnectedComponents(partIndices, (di,dj) => {\n    let dist = distanceMatrix.get(di, dj);\n    if (dist == null) {\n      dist = distanceFn(parts[di], parts[dj]);\n      distanceMatrix.put(di,dj, dist);\n    }\n    if (getDistanceFn) {\n      return (getDistanceFn(dist) < distanceThreshold);\n    } else {\n      return (dist < distanceThreshold);\n    }\n  });\n};\n\n\nmodule.exports = DSUtils;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/ds/util.js?");

/***/ }),

/***/ "./js/lib/geo/ArchCreator.js":
/*!***********************************!*\
  !*** ./js/lib/geo/ArchCreator.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Intersections = __webpack_require__(/*! geo/Intersections */ \"./js/lib/geo/Intersections.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Create architecture consisting of walls with holes cut out for windows and door\n * @param params\n * @param params.up {THREE.Vector3|string|number[]} Up direction for the architecture\n * @param params.front {THREE.Vector3|string|number[]} Front direction for the architecture\n * @param [params.unit=0.01] {number} Unit in meters\n * @param [params.defaults] {{'Wall': { depth: number, extraHeight: number }}} Default values to use for different architectural elements\n * @param [params.assetManager] {assets.AssetManager} AssetManager (used to fetch textures)\n * @memberOf geo\n * @constructor\n */\nfunction ArchCreator(params) {\n  this.up = Object3DUtil.toVector3(params.up);\n  this.front = Object3DUtil.toVector3(params.front);\n  this.left = new THREE.Vector3();\n  this.left.crossVectors(this.up, this.front);\n  this.unit = params.unit || 0.01;\n  this.defaults = _.defaultsDeep(Object.create(null), params.defaults || {}, { 'Wall': { depth: 0.10 / this.unit, extraHeight: 0 }}); // in cm\n  this.assetManager = params.assetManager;\n}\n\nObject.defineProperty(ArchCreator.prototype, 'wallDepth', {\n  get: function () {return this.defaults.Wall.depth; },\n  set: function (v) { this.defaults.Wall.depth = v; }\n});\n\nObject.defineProperty(ArchCreator.prototype, 'wallExtraHeight', {\n  get: function () {return this.defaults.Wall.extraHeight; },\n  set: function (v) { this.defaults.Wall.extraHeight = v; }\n});\n\nArchCreator.getFilter = function(opts) {\n  return function(element) {\n    var include = true;\n    if (!opts.includeCeiling) {\n      include = include && (element.type !== 'Ceiling');\n    }\n    if (!opts.includeFloor) {\n      include = include && (element.type !== 'Floor');\n    }\n    if (!opts.includeWalls) {\n      include = include && (element.type !== 'Wall');\n    }\n    if (!include) {\n      return false;\n    }\n    if (opts.room != undefined && opts.level != undefined) {\n      return element.roomId === (opts.level + '_' + opts.room);\n    } else if (opts.level != undefined) {\n      return element.roomId && element.roomId.startsWith(opts.level + '_');\n    } else if (opts.archIds) {\n      return opts.archIds.indexOf(element.roomId) >= 0 || opts.archIds.indexOf(element.id) >= 0;\n    } else {\n      return true;\n    }\n  };\n};\n\nArchCreator.prototype.__getMaterial = function (color, texture, options) {\n  if (texture && this.assetManager) {\n    var out = this.assetManager.getTexturedMaterial(this.defaultSource, texture, options);\n    out.color = new THREE.Color(color || '#ffffff');\n    return out;\n  } else {\n    return Object3DUtil.getMaterial(color);\n  }\n};\n\nArchCreator.prototype.__getMaterials = function(w) {\n  var scope = this;\n  var materials = (!this.useDefaultMaterials && w.materials)? w.materials : _.get(this.defaults, w.type + '.materials');\n  // console.log(\"materials\", materials);\n  return _.map(materials, function (m) {\n    return scope.__getMaterial(m.diffuse, m.texture);\n  });\n};\n\n/**\n * Create architecture\n * @param arch\n * @param opts\n * @param [opts.filterElements] {function()}\n * @param [opts.groupWalls] {boolean} Whether to group walls by room id (under `<roomId>w`)\n * @param [opts.getMaterials] {function(geo.ArchElement): THREE.Material[]}\n * @param [opts.groupRoomsToLevels] {boolean} Whether to group rooms into levels\n * @returns {{rooms, outside: Array, elementsById, holeToWalls}}\n */\nArchCreator.prototype.createArch = function(arch, opts) {\n  var scope = this;\n  opts = _.defaults(Object.create(null), opts || {}, { getMaterials: function(x) { return scope.__getMaterials(x); } });\n  var archElements = this.createArchElements(arch, opts);\n  var elementsByRoom = _.groupBy(_.values(archElements), function(x) { return (x instanceof THREE.Object3D)? x.userData.roomId : x.roomId; });\n  var rooms = {};\n  var outsideElements = [];\n  _.each(elementsByRoom, function(relements, roomId) {\n    if (roomId != null) {\n      var room = new THREE.Group();\n      room.name = 'Room#' + roomId;\n      room.userData.id = roomId;\n      room.userData.type = 'Room';\n      for (var i = 0; i < relements.length; i++) {\n        if (!opts.filterElements || opts.filterElements(relements[i])) {\n          room.add((relements[i] instanceof THREE.Object3D) ? relements[i] : relements[i].object3D);\n        }\n      }\n      rooms[roomId] = room;\n    } else {\n      outsideElements = relements;\n    }\n  });\n  var walls = _.filter(arch.elements, function(x) { return x.type === 'Wall'; });\n  var holeToWalls = {};\n  _.each(walls, function(w) {\n    if (w.holes) {\n      _.each(w.holes, function(h) {\n        holeToWalls[h.id] = holeToWalls[h.id] || [];\n        holeToWalls[h.id].push(w.id);\n      });\n    }\n  });\n  var res = { rooms: rooms, outside: outsideElements, elementsById: archElements, holeToWalls: holeToWalls };\n  if (opts.groupRoomsToLevels) {\n    res.levels = this.roomsToLevels(rooms);\n  }\n  return res;\n};\n\nArchCreator.prototype.roomsToLevels = function(rooms) {\n  var regex = /^(\\d+)_(\\d+)$/;\n  var levels = [];\n  _.each(rooms, function (room, roomId) {\n    var matched = regex.exec(roomId);\n    if (matched) {\n      room.userData.level = parseInt(matched[1]);\n    } else {\n      room.userData.level = 0;\n    }\n\n    var li = room.userData.level;\n    if (!levels[li]) {\n      var group = new THREE.Group();\n      group.name = 'Level#' + li;\n      group.userData.type = 'Level';\n      levels[li] = group;\n    }\n    var level = levels[li];\n    level.add(room);\n  });\n  return levels;\n};\n\n/**\n * Information about an architectural element.\n * @typedef ArchElement\n * @type {geo.WallDef|geo.CeilingDef|geo.FloorDef}\n * @property {string} type - Type of architectural element (`Wall|Ceiling|Floor|Ground`)\n * @property {string} id - Id of the element\n * @property {string} roomId - Room the architectural element is associated with\n * @property {THREE.Vector3} offset - Amount of offset for the points\n * @memberOf geo\n */\n\n/**\n * Information about a wall.\n * @typedef WallDef\n * @type {object}\n * @property {THREE.Vector3[]} points - List of points associated with the wall\n * @property {Object} parent - Parent of the wall\n * @property {Object[]} holes - Array with information about the holes in the wall (include box)\n * @property {BBox[]} mergedHoleBoxes - Merged holes bounding boxes\n * @property {number} height - Height of the wall\n * @property {number} depth - Thickness of the wall\n * @property {Object} json - Original json object from which the wall is parsed\n * @memberOf geo\n */\n\n/**\n * Information about a ceiling.\n * @typedef CeilingDef\n * @type {object}\n * @property {THREE.Vector3[]} points - List of points associated with the ceiling\n * @property {number} depth - Thickness of the ceiling\n * @memberOf geo\n */\n\n/**\n * Information about a floor.\n * @typedef FloorDef\n * @type {object}\n * @property {THREE.Vector3[]} points - List of points associated with the floor\n * @property {number} depth - Thickness of the floor\n * @memberOf geo\n */\n\n/**\n * Create architecture elements\n * @param arch Architectural specification of walls\n * @param [arch.elements] {geo.ArchElement[]} Architectural elements\n * @param opts\n * @param [opts.groupWalls] {boolean} Whether to group walls by room id (under `<roomId>w`)\n * @param [opts.getMaterials] {function(geo.ArchElement): THREE.Material[]}\n * @returns {Map<id,geo.ArchElement>}\n */\nArchCreator.prototype.createArchElements = function(arch, opts) {\n  var oldDefaults = this.defaults;\n  if (arch.defaults) {\n    this.defaults = _.defaultsDeep({}, arch.defaults, oldDefaults);\n  }\n  function __to2D(groupedPoints) {\n    return _.map(groupedPoints, function(g) {\n      return _.map(g, function(p) {\n        return new THREE.Vector2(p[0], p[2]);\n      });\n    });\n  }\n\n  var elements = _.keyBy(arch.elements, 'id');\n  var partitioned = _.partition(arch.elements, function(x) { return x.type === 'Wall'; });\n  var wallObject3Ds = this.createWalls(partitioned[0],\n    function(wall) {\n      return wall.points;\n    }, opts.getMaterials);\n  _.each(wallObject3Ds, function(w) {\n    elements[w.userData.id].object3D = w;\n  });\n  if (opts.groupWalls) {\n    var wallsByRoomId = _.groupBy(wallObject3Ds, function(x) { return x.userData.roomId; });\n    _.each(wallsByRoomId, function(ws, roomId) {\n      elements[roomId + 'w'] = _.map(ws, function(w) { return elements[w.userData.id]; });\n    });\n  }\n\n  var rest = partitioned[1];\n  for (var i = 0; i < rest.length; i++) {\n    var e = rest[i];\n    var object3D;\n    if (e.type === 'Ceiling') {\n      var depth = e.depth || _.get(this.defaults, e.type + '.depth');\n      var mats = opts.getMaterials(e);\n      object3D = this.makeCeiling(__to2D(e.points), depth, mats[0], 0);\n    } else if (e.type === 'Floor' || e.type === 'Ground') {\n      var depth = e.depth || _.get(this.defaults, e.type + '.depth');\n      var mats = opts.getMaterials(e);\n      object3D = this.makeGround(__to2D(e.points), depth, mats[0], 0);\n    }\n    if (object3D) {\n      object3D.name = e.type + '#' + e.id;\n      object3D.userData.id = e.id;\n      object3D.userData.type = e.type;\n      object3D.userData.roomId = e.roomId;\n      if (e.offset) {\n        object3D.position.set(e.offset[0], e.offset[1], e.offset[2]);\n      }\n      elements[e.id].object3D = object3D;\n    } else {\n      console.warn('Ignoring unknown arch type ' + e.type);\n    }\n  }\n  this.defaults = oldDefaults;\n  return elements;\n};\n\nArchCreator.prototype.makeGround = function(pointGroups, depth, materialOrColor, heightPos) {\n  heightPos = heightPos || 0;\n  var bevelSize = this.wallDepth/5;\n  var up = this.up;\n  var front = this.front;\n\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var shapes = pointGroups.map(function (points) { return new THREE.Shape(points); });\n  var geometry = null;\n  if (depth !== 0) {  // extrude box\n    geometry = new THREE.ExtrudeGeometry(shapes, { depth: depth, bevelEnabled: true, bevelThickness: 0, bevelSize: bevelSize });\n  } else {  // single plane\n    geometry = new THREE.ShapeGeometry(shapes);\n  }\n  var mesh = new THREE.Mesh(geometry, material);\n  Object3DUtil.alignToUpFrontAxes(mesh,\n    new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0),\n    up, front\n  );\n  mesh.userData.isSupportObject = true;\n  mesh.userData.isPickable = true;\n  mesh.userData.isEditable = false;\n  mesh.userData.isSelectable = false;\n  mesh.position.set(0, heightPos, 0);\n  return mesh;\n};\n\nArchCreator.prototype.makeCeiling = function(pointGroups, depth, materialOrColor, heightPos) {\n  heightPos = heightPos || 0;\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var bevelSize = this.wallDepth/5;\n  var up = this.up;\n  var front = this.front;\n\n  var shapes = pointGroups.map(function (points) { return new THREE.Shape(points); });\n  var geometry = null;\n  if (depth !== 0) {  // extrude box\n    geometry = new THREE.ExtrudeGeometry(shapes, { depth: depth, bevelEnabled: true, bevelThickness: 0, bevelSize: bevelSize });\n  } else {  // single plane\n    geometry = new THREE.ShapeGeometry(shapes);\n  }\n  var mesh = new THREE.Mesh(geometry, material);\n  Object3DUtil.alignToUpFrontAxes(mesh,\n    new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0),\n    up, front\n  );\n  mesh.userData.isSupportObject = true;\n  mesh.userData.isPickable = true;\n  mesh.userData.isEditable = false;\n  mesh.userData.isSelectable = false;\n  mesh.position.set(0, heightPos, 0);\n  return mesh;\n};\n\n/**\n * Create geometry and meshes for walls\n * @param walls {geo.WallDef[]} Array of walls\n * @param getWallPoints {function(geo.WallDef): number[][]} Function returning points for wall\n * @param getMaterials {function(geo.WallDef): THREE.Materials[]} Function returning inside and outside materials for wall\n * @returns {THREE.Object3D[]}\n */\nArchCreator.prototype.createWalls = function(walls, getWallPoints, getMaterials) {\n  var up = this.up;\n  var wallExtraHeight = this.wallExtraHeight;\n\n  // HACK: merge pairs of intersecting holes into bigger holes\n  // TODO: check more than pairs, and do proper box-box union\n  function mergeHoles(holeBBoxes) {\n    //a4fcb9fb91c4018fc9b54623c674d121\n    return Object3DUtil.mergeHoles(holeBBoxes);\n  }\n\n  var wallObject3Ds = [];\n  for (var iWall = 0; iWall < walls.length; iWall++) {\n    var wall = walls[iWall];\n    var wallPoints = getWallPoints(wall);\n    if (wallPoints[0][0] === wallPoints[1][0] && wallPoints[0][2] === wallPoints[1][2]) {\n      // Not real wall, skip\n      continue;\n    }\n    if (wall.holes) {\n      var holeBoxes = wall.holes.map(function(x) {\n        var box = Object3DUtil.toBox2(x.box);\n        return box.clone();\n      });\n      wall.mergedHoleBoxes = mergeHoles(holeBoxes);\n    }\n    var baseStart = new THREE.Vector3(wallPoints[0][0], wallPoints[0][1], wallPoints[0][2]);\n    var baseEnd = new THREE.Vector3(wallPoints[1][0], wallPoints[1][1], wallPoints[1][2]);\n    var roomId = (wall.roomId != undefined)? wall.roomId : wall.parent.id;\n    var materials = getMaterials(wall);\n    var wallHeight = (wall.height != null)? wall.height : _.get(this.defaults, 'Wall.height');\n    var wallDepth = (wall.depth != null)? wall.depth : _.get(this.defaults, 'Wall.depth');\n    var mesh = Object3DUtil.makeWallWithHoles(baseStart, baseEnd,\n      up, wallHeight, wallExtraHeight, wallDepth, wall.mergedHoleBoxes, materials);\n    Object3DUtil.traverseMeshes(mesh, false, function(w) {\n      w.userData.type = w.name;\n      w.userData.id = wall.id; // Same id as actual wall (not cool)\n      w.userData.roomId = roomId;\n      w.userData.isEditable = false;\n    });\n    wall.object3D = mesh;\n    Object3DUtil.setVisible(mesh, wall.json? !wall.json.hidden : true);\n    mesh.name = 'Wall#' + wall.id;\n    mesh.userData.type = 'Wall';\n    mesh.userData.id = wall.id;\n    mesh.userData.roomId = roomId;\n    mesh.userData.holeIds = _.map(wall.holes, 'id');\n    mesh.userData.isSupportObject = true;\n    mesh.userData.isPickable = true;\n    mesh.userData.isEditable = false;\n\n    wallObject3Ds.push(mesh);\n  }\n  return wallObject3Ds;\n};\n\nArchCreator.prototype.associateWallsWithHoles = function(walls, holes, getHoleBBox, getPoints2D, threshold) {\n  //console.log('associateWallsWithHoles');\n\n  // For each wall, figure out holes to cut\n  var holeBBoxes = holes.map(function(hole) { return getHoleBBox(hole); });\n  // associate each hole with appropriate wall by clipping line walls against hole BBox\n  for (var i = 0; i < holeBBoxes.length; i++) {\n    var holeBBox = holeBBoxes[i];\n    var holeObject = holes[i].object3D;\n\n    // assign hole to intersecting wall\n    for (var iWall = 0; iWall < walls.length; iWall++) {\n      var wall = walls[iWall];\n      //console.log('check if hole ' + i + ' intersects wall ' + iWall);\n      if (!wall.height) {\n        console.error('No wall height!!!!');\n      } else if (wall.height < 0) {\n        console.error('Negative wall height: ' + wall.height);\n      }\n      var points2D = getPoints2D(wall);\n      var wallLine = { a: points2D[0], b: points2D[1] };\n      wall.width = wallLine.a.distanceTo(wallLine.b);\n\n      // Check whether box intersects wall (from top down view)\n      // console.log('check', wallLine.a, wallLine.b, holeBBox.min, holeBBox.max);\n      var clip = Intersections.clipLine(holeBBox.min, holeBBox.max, wallLine);\n      if (clip.intersects) {\n        // console.log('intersected', holeBBox, wallLine);\n        // Consider wall not axis aligned if more than 2.5 cm different in x or y\n        var min = new THREE.Vector2(wall.width*Math.max(clip.E, 0), Math.max(holeBBox.min.z, wall.height * 0));\n        var max = new THREE.Vector2(wall.width*Math.min(clip.L, 1), Math.min(holeBBox.max.z, wall.height * 1));\n        if (Math.abs(wallLine.a.x - wallLine.b.x) >= threshold && Math.abs(wallLine.a.y - wallLine.b.y) >= threshold) {\n          //console.log('Wall not axis-aligned: ', wallLine);\n          // Take corners of bbox in original model coordinates and project onto wall\n          var corners = Object3DUtil.computeBoundingBoxLocal(holeObject).getCorners();\n          var points = corners.map(function(c) {\n            var v3 = c.clone().applyMatrix4(holeObject.matrixWorld);\n            return new THREE.Vector2(v3.x, v3.z);\n          });\n          var ratios = Intersections.projectPointsToRatio(wallLine, points);\n          var rmin = Math.min.apply(null, ratios);\n          var rmax = Math.max.apply(null, ratios);\n          min = new THREE.Vector2(wall.width*Math.max(rmin, 0), Math.max(holeBBox.min.z, wall.height * 0));\n          max = new THREE.Vector2(wall.width*Math.min(rmax, 1), Math.min(holeBBox.max.z, wall.height * 1));\n        }\n        // Make sure it is a valid hole\n        if (min.x >= max.x || min.y >= max.y) {\n          continue; // Skip this\n        }\n        var holeBox = new THREE.Box2(min, max);\n        if (!wall.holes) { wall.holes = []; }\n        var holeType;\n        if (holes[i].modelInstance.model.isDoor()) { holeType = 'Door'; }\n        else if (holes[i].modelInstance.model.isWindow()) { holeType = 'Window'; }\n        wall.holes.push({ id: holeObject.userData.id, modelId: holes[i].modelId, type: holeType, box: holeBox});\n        if (!wall.holeIds) { wall.holeIds = []; }\n        wall.holeIds.push(holeObject.userData.id);\n\n        if (!(wall.json && wall.json.hidden) || !this.keepHidden) {\n          if (!holeObject.userData.wallIds) { holeObject.userData.wallIds = []; }\n          holeObject.userData.wallIds.push(wall.id);\n        }\n\n        //console.log('INTERSECTS wall ' + iWall, holes[i], wall);\n      }\n    }\n  }\n\n  return walls;\n};\n\nArchCreator.prototype.getWallPoints = function(elements, swapWallPoints) {\n  var walls = _.filter(elements, function(x) { return x.type === 'Wall' && x.points.length; });\n  var allWallPoints = [];\n  var groupedWalls = [];\n  if (walls.length) {\n    var wallsGroupedByPoints = _.groupByMulti(walls, function (w) {\n      return w.points;\n    });\n    var iter = 0;\n    while (_.size(wallsGroupedByPoints) > 0 && iter < walls.length) {\n      // Get points\n      var wallPoints = [];\n      var selectedWalls = [];\n      var wall = _.find(wallsGroupedByPoints, function(x) { return true; })[0];\n      var lastPt = null;\n      while (wall != null && iter < walls.length) {\n        // Add wall points\n        iter++;\n        selectedWalls.push(wall);\n        var pts = wall.points;\n        if (lastPt === null) {\n          // Append all wallpoints\n          wallPoints.push.apply(wallPoints, pts);\n        } else {\n          var index = _.findIndex(pts, function(x) { return x.toString() == lastPt; });\n          var newWallPoints = [pts[index]];\n          for (var i = index+1; i < pts.length; i++) {\n            wallPoints.push(pts[i]);\n            if (swapWallPoints) {\n              newWallPoints.push(pts[i]);\n            }\n          }\n          for (var i = 0; i < index; i++) {\n            wallPoints.push(pts[i]);\n            if (swapWallPoints) {\n              newWallPoints.push(pts[i]);\n            }\n          }\n          if (swapWallPoints) {\n            wall.points = newWallPoints;\n          }\n        }\n        lastPt = wallPoints[wallPoints.length - 1];\n\n        _.each(pts, function (p) {\n          var g = wallsGroupedByPoints[p];\n          _.pull(g, wall);\n          if (g.length === 0) {\n            delete wallsGroupedByPoints[p];\n          }\n        });\n        var g2 = wallsGroupedByPoints[lastPt];\n        wall = g2? g2[0] : null;\n      }\n      allWallPoints.push(wallPoints);\n      groupedWalls.push(selectedWalls);\n    }\n  }\n  return { wallPoints: allWallPoints, groupedWalls: groupedWalls };\n};\n\nArchCreator.prototype.toSceneState = function(json, arch, finalize) {\n  var SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\n  var scene = new THREE.Scene();\n  var sceneState = new SceneState(scene, {up: json.up, front: json.front, unit: json.scaleToMeters});\n  //console.log(arch);\n  _.each(arch.levels, function(level, levelId) {\n    scene.add(level);\n  });\n  _.each(arch.rooms, function (room, roomId) {\n    sceneState.addExtraObject(room, true);\n  });\n  if (finalize) {\n    sceneState.finalizeScene();\n  }\n  return sceneState;\n};\n\nArchCreator.DEFAULTS = {\n  up: new THREE.Vector3(0,1,0),\n  front: new THREE.Vector3(0,0,1),\n  unit: 1,\n  defaults: {\n    'Wall': {\n      depth: 0.1,\n      height: 2.7,\n      extraHeight: 0.035,\n      materials: [\n        {\n          \"name\": \"inside\",                          // Name of material (\"inside\" for inside wall)\n          \"diffuse\": \"#ffffff\"                       // Diffuse color in hex\n        },\n        {\n          \"name\": \"outside\",                         // Name of material (\"outside\" for outside wall)\n          \"diffuse\": \"#ffffff\"                       // Diffuse color in hex\n        }\n      ]\n    },\n    'Ceiling': {\n      depth: 0.05,\n      offset: 0.04,    // Bit offset above wall extraHeight\n      materials: [\n        {\n          \"name\": \"surface\",\n          \"diffuse\": \"#ffffff\"\n        }\n      ]\n    },\n    'Floor': {\n      depth: 0.05,\n      materials: [\n        {\n          \"name\": \"surface\",\n          \"diffuse\": \"#ffffff\"\n\n        }\n      ]\n    },\n    'Ground': {\n      depth: 0.08,\n      materials: [\n        {\n          \"name\": \"surface\",\n          \"diffuse\": \"#ffffff\"\n        }\n      ]\n    }\n  },\n  filter: {\n    includeCeiling: true,\n    includeFloor: true,\n    includeWalls: true\n  }\n};\n\n\n// Exports\nmodule.exports = ArchCreator;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/ArchCreator.js?");

/***/ }),

/***/ "./js/lib/geo/Attachments.js":
/*!***********************************!*\
  !*** ./js/lib/geo/Attachments.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar Picker = __webpack_require__(/*! controls/Picker */ \"./js/lib/controls/Picker.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Utility functions for identifying attachments\n * @module Attachments\n */\nvar Attachments = {};\n\n/**\n * Attachment information\n * @typedef Attachment\n * @type {object}\n * @property {THREE.Object3D} child\n * @property {model.ModelInstance} childInst\n * @property {THREE.Object3D} parent\n * @property {model.ModelInstance} parentInst\n * @property {THREE.Vector3} parentSurfaceNorm\n * @property {int} childWorldBBFaceIndex\n * @property {geo.Intersect} parentAttachment\n * @property {model.AttachmentPoint} childAttachment\n */\n\n\n/**\n * Wrapper object containing a model instance with attachment points\n * @typedef ModelInstanceWithAttachmentPoints\n * @type {object}\n * @property {ModelInstance} modelInstance\n * @property {model.AttachmentPoint[]} attachments\n */\n\n/**\n * Identify and score attachments\n * @param parents\n * @param modelInstWithCandidates\n * @param opts {object} Additional options\n * @param [opts.includeCandidates] {boolean} Whether all candidates should be returned or just the best\n * @param [opts.maxCandidates] {int} Maximum number of candidates to track\n * @param [opts.maxCandidatesToCheck] {int} Max candidates to check per attachment\n * @param [opts.deltaContactDistThreshold] {number}\n * @param [opts.contactDistThreshold] {number}\n * @param [opts.sameModelCost] {number}\n * @param [opts.disallowSameModelHorizontalAttachment] {boolean}\n * @param [opts.checkOpposite] {boolean}\n * @param [opts.aggregatedSceneStatistics]\n * @returns {{best: Attachment, candidates: Attachment[]}}\n */\nfunction identifyAttachments(parents, modelInstWithCandidates, opts) {\n  // Options\n  // sameModelCost - Cost for same model\n  // contactDistThreshold - Contact dist threshold\n  // includeAllCandidates - Returns array of all candidates within threshold\n  opts = opts || {};\n  var debug = opts.debug;\n  if (debug) {\n    console.log('identifyAttachments opts', opts);\n  }\n  var maxCandidates = opts.maxCandidates || Infinity;  // max candidate to track\n  var maxCandidatesToCheckPerAttachment = opts.maxCandidatesToCheck || maxCandidates;  // Max candidates to check per attachment\n  var deltaContactDistThresholdPerAttachment = (opts.deltaContactDistThreshold != undefined)? opts.deltaContactDistThreshold : (0.02 * Constants.metersToVirtualUnit); // maximum distance from closest attachment to furthest\n  var contactDistThreshold = (opts.contactDistThreshold != undefined)? opts.contactDistThreshold : (0.10 * Constants.metersToVirtualUnit);  // maximum distance from attachment point to support\n  var modelInstance = modelInstWithCandidates.modelInstance;\n  var candidatesAttachments = modelInstWithCandidates.attachments;\n  var childModelId = modelInstance? modelInstance.model.info.fullId : null;\n  var childObjectId = modelInstance? modelInstance.object3D.userData.id : null;\n\n  if (debug) {\n    var childBBox = modelInstance.getBBox();\n    //var childFaceDims = childBBox.getFaceDims();\n    console.log('Child bbox', childBBox);\n    console.log('Candidate parent bboxes', parents.map(function (p) {\n      return Object3DUtil.getBoundingBox(p);\n    }));\n  }\n\n  function getRoomIds(object3D) {\n    var roomIds = _.get(object3D, ['userData', 'roomIds']);\n    if (roomIds) { return roomIds; }\n    var roomId = _.get(object3D, ['userData', 'roomId']);\n    if (roomId != undefined) {\n      return [roomId];\n    } else {\n      return [];\n    }\n  }\n\n  function hasCommonRoomId(roomIds1, roomIds2) {\n    var intersection = _.intersection(roomIds1, roomIds2);\n    return intersection.length > 0;\n  }\n\n  var childRoomIds = modelInstance? getRoomIds(modelInstance.object3D) : [];\n\n  function isBetter(cand, best, debug) {\n    var intersected = cand.parentAttachment;\n    //console.log('compare', cand, best);\n    if (intersected.distance > contactDistThreshold) {\n      return false;\n    }\n    if (!best) {\n      return true;\n    }\n    var modelIdSameCostBest = 0;\n    var modelIdSameCostCurr = 0;\n    if (opts.sameModelCost > 0) {\n      // Check if the two models are the same\n      var bestModelInst = best.parentInst;\n      var currentModelInst = cand.parentInst;\n      var parentModelIdBest = bestModelInst? bestModelInst.model.info.fullId : null;\n      var parentModelIdCurr = currentModelInst? currentModelInst.model.info.fullId : null;\n      var modelIdSameBest = parentModelIdBest? parentModelIdBest === childModelId : false;\n      modelIdSameCostBest = modelIdSameBest? opts.sameModelCost : 0;\n      var modelIdSameCurr = parentModelIdCurr? parentModelIdCurr === childModelId : false;\n      modelIdSameCostCurr = modelIdSameCurr? opts.sameModelCost : 0;\n      //if (debug) console.log('modelIdSameCosts: ', modelIdSameCostBest, modelIdSameCostCurr);\n    }\n    if (Math.abs(intersected.distance - best.parentAttachment.distance) < contactDistThreshold*0.75) {\n      if (Math.abs(intersected.normSim - best.parentAttachment.normSim) < 0.01) {\n        if (opts.aggregatedSceneStatistics) {\n          var ss = opts.aggregatedSceneStatistics;\n          // Determine preferred normal and attachment based on object id/type (curtain to windows, etc)\n          // Get parent child statistics for the object types\n          var childIdAttachmentCounts = ss.getObjectIdChildAttachmentCounts();\n          var counter = childIdAttachmentCounts.get([childModelId]);\n          var total = counter? counter.sum : 0;\n          var modelCats = modelInstance ? modelInstance.model.getCategories() : [];\n          var selectedCat = null;\n          while (total < 20 && modelCats.length) {\n            var cat = modelCats[modelCats.length - 1];\n            var childTypeAttachmentCounts = ss.getObjectTypeChildAttachmentCounts();\n            counter = childTypeAttachmentCounts.get([cat]);\n            total = counter? counter.sum : 0;\n            selectedCat = cat;\n          }\n          if (total > 50) {\n            var countThreshold = total * 0.1;\n            var candAttachmentFace = ss.bbfaceIndexToAttachmentTypeIndex(cand.childAttachment.bbfaceIndex);\n            var bestAttachmentFace = ss.bbfaceIndexToAttachmentTypeIndex(best.childAttachment.bbfaceIndex);\n            var candCount = counter.get(candAttachmentFace);\n            var bestCount = counter.get(bestAttachmentFace);\n            //if (debug) console.log('got attachment priors for object', childObjectId, 'model', childModelId, selectedCat,\n            //  'total', total, 'threshold', countThreshold,\n            //  'cand', ss.getAttachmentType(candAttachmentFace), candCount,\n            //  'best', ss.getAttachmentType(bestAttachmentFace), bestCount);\n            if (candCount > (bestCount + countThreshold)) {\n              //if (debug) console.log('select cand', childObjectId);\n              return true;\n            } else if (bestCount > (candCount + countThreshold)) {\n              //if (debug) console.log('select best', childObjectId);\n              return false;\n            }\n          }\n        }\n        // Check normal\n        if (intersected.normal.dot(best.parentSurfaceNormal) > 0.9) {\n          // Prefer correct room\n          // Check candidate and best rooms\n          var candRoomIds = getRoomIds(cand.parent);\n          var bestRoomIds = getRoomIds(best.parent);\n          //if (debug) console.log('check room ids', childRoomIds, candRoomIds, bestRoomIds);\n          var candInSameRoom = hasCommonRoomId(childRoomIds, candRoomIds);\n          var bestInSameRoom = hasCommonRoomId(childRoomIds, bestRoomIds);\n          if (candInSameRoom !== bestInSameRoom) {\n            return candInSameRoom; // Favor candidate\n          } else {\n            // TODO: Do we want to do other checks here - maybe favor smaller parent surface?\n            return false;\n          }\n        } else {\n          // Favor big flat surfaces (of the child bounding box)\n          var candBBFaceDims = _.get(cand, ['childAttachment', 'world', 'faceDims']);\n          var bestBBFaceDims = _.get(best, ['childAttachment', 'world', 'faceDims']);\n          var candFaceMin = candBBFaceDims ? Math.min(candBBFaceDims.x, candBBFaceDims.y) : 0;\n          var bestFaceMin = bestBBFaceDims ? Math.min(bestBBFaceDims.x, bestBBFaceDims.y) : 0;\n          //if (debug) console.log('compare faces', childModelId, cand, candFaceMin, best, bestFaceMin);\n          if (candFaceMin > bestFaceMin*5) {\n            return true;\n          } else if (bestFaceMin > candFaceMin*5) {\n            return false;\n          }\n          // prefer world bottom attachment\n          if (intersected.normal.dot(Constants.worldUp) > 0.99) {\n            return true;\n          } else if (best.parentSurfaceNormal.dot(Constants.worldUp) > 0.99) {\n            return false;\n          } else if (intersected.normal.dot(Constants.worldUp) < -0.99) {\n            return false;\n          } else if (best.parentSurfaceNormal.dot(Constants.worldUp) < -0.99) {\n            return true;\n          } else {\n            var candFaceArea = candBBFaceDims? candBBFaceDims.x * candBBFaceDims.y : 0;\n            var bestFaceArea = bestBBFaceDims? bestBBFaceDims.x * bestBBFaceDims.y : 0;\n            //if (debug) console.log('compare faces', childModelId, cand, candFaceArea, best, bestFaceArea);\n            if (candFaceArea > bestFaceArea*2) {\n              return true;\n            } else if (bestFaceArea > candFaceArea*2) {\n              return false;\n            }\n          }\n        }\n      } else {\n        return (intersected.normSim > best.parentAttachment.normSim);\n      }\n    }\n    return (modelIdSameCostCurr < modelIdSameCostBest || intersected.distance < best.parentAttachment.distance);\n  }\n  // Raytrace out from candidate attachments\n  var picker = new Picker();\n  var raycaster = new THREE.Raycaster();\n  var raycasterOpposite = new THREE.Raycaster();\n  var best = null;\n  var candidates = [];\n  for (var i = 0; i < candidatesAttachments.length; i++) {\n    var candidate = candidatesAttachments[i];\n    //console.log('candidate', candidate);\n    raycaster.ray.origin.copy(candidate.world.pos);\n    // Go back just a little\n    var s = candidate.world.size;\n    //var s = Math.abs(bbdims.x * candidate.world.out.x) + Math.abs(bbdims.y * candidate.world.out.y) + Math.abs(bbdims.z * candidate.world.out.z);\n    //console.log('compare', s, candidate.world.size);\n    var offset = 0.2*s;\n    raycaster.ray.origin.addScaledVector(candidate.world.out, -offset);\n    raycaster.ray.direction.copy(candidate.world.out);\n    var intersected = picker.getIntersectedForRay(raycaster, parents);\n    // Select the closest parent (favoring attachment with parent surface normal up)\n    if (debug) {\n      console.log('intersected', deltaContactDistThresholdPerAttachment, intersected, raycaster.ray.origin, raycaster.ray.direction);\n    }\n    if (intersected.length > 0) {\n      _.forEach(intersected, function(i) { i.distance = Math.max(i.distance - offset, 0); }); // subtract offset from distance\n      if (debug) {\n        console.log('intersected revised distances', deltaContactDistThresholdPerAttachment, intersected, raycaster.ray.origin, raycaster.ray.direction);\n      }\n      var closest = intersected[0];\n      if (closest.distance > contactDistThreshold) {\n        if (debug) {\n          console.log('Skipping intersected since closest is too far', closest.distance, contactDistThreshold);\n        }\n        continue; // Skip\n      }\n      var distThreshold = Math.min(contactDistThreshold, closest.distance + deltaContactDistThresholdPerAttachment);\n      var intersectedWithinThreshold = intersected.filter( function(x) {\n        return x.distance <= distThreshold;\n      });\n\n      if (debug) {\n        console.log('closest', childObjectId, closest, intersectedWithinThreshold);\n      }\n\n      // Don't remember what this is for - decide if this is still useful\n      // Check if there is a better intersection slightly before this one\n      if (opts.checkOpposite && intersectedWithinThreshold.length > 1) {\n        raycasterOpposite.ray.origin.copy(closest.point);\n        raycasterOpposite.ray.direction.copy(candidate.world.out);\n        raycasterOpposite.ray.direction.negate();\n        var intersectedOpposite = picker.getIntersectedForRay(raycasterOpposite, parents);\n        if (intersectedOpposite.length > 0) {\n          if (debug) {\n            console.log('intersectedOpposite', intersectedOpposite);\n          }\n          for (var j = 1; j < intersectedWithinThreshold.length; j++) {\n            var intersect1 = intersectedWithinThreshold[j];\n            for (var k = 0; k < intersectedOpposite.length; k++) {\n              var intersect2 = intersectedOpposite[k];\n              if (intersect2.distance < contactDistThreshold) {\n                if (intersect2.object === intersect1.object) {\n                  if (debug) {\n                    console.log('Using intersectedOpposite', intersect1, intersect2);\n                  }\n                  closest = intersect1;\n                  break;\n                }\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        console.log('closest', childObjectId, closest, intersectedWithinThreshold);\n      }\n      // Compute normSim\n      var candidateNormOut = candidate.world.out.clone().negate();\n      for (var j = 0; j < intersectedWithinThreshold.length; j++) {\n        var c = intersectedWithinThreshold[j];\n        c.order = j;\n        var norm = picker.getIntersectedNormal(c);\n        if (c.normSim == undefined) {\n          c.normSim = candidateNormOut.dot(norm);\n        }\n      }\n\n      if (opts.disallowSameModelHorizontalAttachment && childModelId != null) {\n        intersectedWithinThreshold = _.filter(intersectedWithinThreshold, function(intersect) {\n          var parentInst = Object3DUtil.getModelInstance(intersect.object, true);\n          if (parentInst && parentInst.model.info.fullId === childModelId) {\n            if (childWorldBBFaceIndex === Constants.BBoxFaces.TOP || childWorldBBFaceIndex === Constants.BBoxFaces.BOTTOM) {\n              return true;\n            } else {\n              console.log('filtering out potential support due to disallowSameModelHorizontalAttachment for ' +  childObjectId + ' and ' + intersect.object.userData.id);\n              return false;\n            }\n          } else {\n            return true;\n          }\n        });\n      }\n      // Group by object id\n      var groupedByObjectId = _.groupBy(intersectedWithinThreshold, function(x) { return x.object.uuid; });\n      var objectIds = _.keys(groupedByObjectId);\n      objectIds = _.sortBy(objectIds, function(id) { return groupedByObjectId[id][0].order; });\n\n      // Update acceptable candidates (next to)\n      var nCandidates = Math.min(objectIds.length, maxCandidates);\n      for (var k = 0; k < nCandidates; k++) {\n        var objectId = objectIds[k];\n        if (debug) {\n          console.log('Check ' + objectId);\n        }\n        var intersectsForObject = groupedByObjectId[objectId];\n        for (var j = 0; j < intersectsForObject.length; j++) {\n          var c = intersectsForObject[j];\n          var norm = picker.getIntersectedNormal(c);\n          var childWorldBBFaceIndex = Object3DUtil.findClosestBBFaceByInNormal(norm);\n          //childWorldBBFaceDims = bbox.getFaceDims()[childWorldBBFaceIndex];\n          var parentInst = Object3DUtil.getModelInstance(c.object, true);\n          var candidateToCheck = {\n            child: modelInstance ? modelInstance.object3D : undefined,\n            childInst: modelInstance ? modelInstance : undefined,\n            parent: c.object,\n            parentInst: parentInst,\n            parentSurfaceNormal: norm,\n            childWorldBBFaceIndex: childWorldBBFaceIndex,\n            //childWorldBBFaceDims: childWorldBBFaceDims,\n            parentAttachment: c,\n            childAttachment: candidate // Candidate attachment point\n          };\n          if (k < maxCandidatesToCheckPerAttachment && isBetter(candidateToCheck, best, false)) {\n            best = candidateToCheck;\n            if (debug) {\n              console.log('updating best', childObjectId, best.parent.userData.id, best);\n            }\n          }\n          if (opts.includeCandidates) {\n            candidates.push(candidateToCheck);\n          }\n        }\n      }\n    }\n  }\n  var res = {\n    best: best\n  };\n  if (opts.includeCandidates) {\n    candidates.sort(function(a,b) { return isBetter(a,b,false)? -1 : 1; });  // NOTE this compare is not necessarily valid\n    res.candidates = candidates;\n  }\n  return res;\n}\n\nAttachments.identifyAttachments = identifyAttachments;\n\nfunction identifyAttachment(parents, candidatesAttachments, opts) {\n  // Returns best attachment\n  var attachments = identifyAttachments(parents, candidatesAttachments, opts);\n  if (attachments.best) {\n    return attachments.best;\n  }\n}\n\nAttachments.identifyAttachment = identifyAttachment;\n\n// Exports\nmodule.exports = Attachments;\n\n//# sourceURL=webpack://STK/./js/lib/geo/Attachments.js?");

/***/ }),

/***/ "./js/lib/geo/BBox.js":
/*!****************************!*\
  !*** ./js/lib/geo/BBox.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// Patch THREE.Box2 with legacy function names\nif (!_.isFunction(THREE.Box2.prototype.intersects)) {\n  THREE.Box2.prototype.intersects = function (box) {\n    return this.intersectsBox(box);\n  };\n}\nif (!_.isFunction(THREE.Box2.prototype.includeBBox)) {\n  THREE.Box2.prototype.includeBBox = function (box) {\n    return this.union(box);\n  };\n}\nif (!_.isFunction(THREE.Box2.prototype.contains)) {\n  THREE.Box2.prototype.contains = function (box) {\n    return this.containsBox(box);\n  };\n}\n\n/**\n * Axis aligned bounding box\n * @memberOf geo\n * @param min {THREE.Vector3}\n * @param max {THREE.Vector3}\n * @constructor\n */\nfunction BBox(min, max) {\n  this.min = min || new THREE.Vector3(Infinity, Infinity, Infinity);\n  this.max = max || new THREE.Vector3(-Infinity, -Infinity, -Infinity);\n}\n\nBBox.prototype.clone = function () {\n  var bbox = new BBox();\n  bbox.copy(this);\n  return bbox;\n};\n\nBBox.prototype.copy = function (bbox) {\n  this.min.copy(bbox.min);\n  this.max.copy(bbox.max);\n  this.clearCache();\n};\n\nBBox.prototype.isFinite = function () {\n  if (!isFinite(this.min.x)) return false;\n  if (!isFinite(this.min.y)) return false;\n  if (!isFinite(this.min.z)) return false;\n  if (!isFinite(this.max.x)) return false;\n  if (!isFinite(this.max.y)) return false;\n  if (!isFinite(this.max.z)) return false;\n  return true;\n};\n\nBBox.prototype.valid = function () {\n  // if (this.min.x == undefined || !isNaN(this.min.x)) return false;\n  // if (this.min.y == undefined || !isNaN(this.min.y)) return false;\n  // if (this.min.z == undefined || !isNaN(this.min.z)) return false;\n  // if (this.max.x == undefined || !isNaN(this.max.x)) return false;\n  // if (this.max.y == undefined || !isNaN(this.max.y)) return false;\n  // if (this.max.z == undefined || !isNaN(this.max.z)) return false;\n  return (this.min.x <= this.max.x) && (this.min.y <= this.max.y) && (this.min.z <= this.max.z);\n};\n\nBBox.prototype.fromCenterRadius = function (cx, cy, cz, rx, ry, rz) {\n  this.min.x = cx - rx;\n  this.min.y = cy - ry;\n  this.min.z = cz - rz;\n  this.max.x = cx + rx;\n  this.max.y = cy + ry;\n  this.max.z = cz + rz;\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.fromCenterRadiusArray = function (arr) {\n  this.fromCenterRadius(arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]);\n  return this;\n};\n\nBBox.prototype.includeBBox = function (bbox) {\n  if (bbox.valid()) {\n    this.__includePoint(bbox.min);\n    this.__includePoint(bbox.max);\n    this.clearCache();\n  }\n  return this;\n};\n\nBBox.prototype.includeOBB = function (obb) {\n  this.__includePoint(obb.min);\n  this.__includePoint(obb.max);\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.includeLine = function (line, transform) {\n  var scope = this;\n  GeometryUtil.forMeshVertices(line, function (v) {\n      scope.__includePoint(v, transform);\n    }\n  );\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.includeMesh = function (mesh, transform) {\n  var nFaces = GeometryUtil.getGeometryFaceCount(mesh.geometry);\n  if (nFaces > 0) {\n    var scope = this;\n    GeometryUtil.forMeshVertices(mesh, function (v) {\n        scope.__includePoint(v, transform);\n      }\n    );\n    // Three.js code to help compute bounding box\n    // Here for comparison, we shouldn't be slower\n    //var bboxHelper = new THREE.BoundingBoxHelper(mesh);\n    //bboxHelper.update();\n    //this.includeBBox(bboxHelper.box);\n    //        } else {\n    //            console.warn(\"Skipping mesh with no faces\");\n    //            console.log(mesh);\n  }\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.includeMeshes = function (meshes) {\n  for (var i = 0; i < meshes.length; i++) {\n    var mesh = meshes[i];\n    this.includeMesh(mesh);\n  }\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.includePoints = function (points, transform) {\n  var scope = this;\n  if (Array.isArray(points)) {\n    for (var i = 0; i < points.length; i++) {\n      scope.__includePoint(points[i], transform);\n    }\n  } else if (points instanceof THREE.Points) {\n    GeometryUtil.forMeshVertices(points, function (v) {\n        scope.__includePoint(v, transform);\n      }\n    );\n  } else {\n    throw \"Unsupported type for BBox.includePoints\"\n  }\n  this.clearCache();\n  return this;\n};\n\nBBox.prototype.includeObject3D = function (root, transform, filter) {\n  if (filter && !filter(root)) {\n    //console.log(\"filtering out \", root.userData);\n    return;  // root didn't pass filter (skip)\n  }\n  root.updateMatrixWorld();\n  // NOTE: We don't use the three.js bbox helper because\n  //   we filter out vertices that are not part of faces\n  //   (the filtering can also be done when loading models)\n  //var bboxHelper = new THREE.BoundingBoxHelper(root);\n  //bboxHelper.update();\n  //this.includeBBox(bboxHelper.box);\n  var bbox = new BBox();\n  if (root instanceof THREE.Mesh) {\n    bbox.includeMesh(root, transform);\n  } else if (root instanceof THREE.Line) {\n    bbox.includeLine(root, transform);\n  } else if (root instanceof THREE.Points) {\n    bbox.includePoints(root, transform);\n  }\n  if (root.children) {\n    for (var i = 0; i < root.children.length; i++) {\n      var child = root.children[i];\n      var include = !(child instanceof THREE.Camera);\n      if (include) {\n        var childBBox = new BBox();\n        childBBox.includeObject3D(root.children[i], transform, filter);\n        if (childBBox.valid()) bbox.includeBBox(childBBox);\n      }\n    }\n  }\n  this.includeBBox(bbox);\n  return this;\n};\n\n// Return world position given relative point, center is (0.5,0.5,0.5)\nBBox.prototype.getWorldPosition = function (relPoint) {\n  if (relPoint) {\n    var x = (1.0 - relPoint.x) * this.min.x + relPoint.x * this.max.x;\n    var y = (1.0 - relPoint.y) * this.min.y + relPoint.y * this.max.y;\n    var z = (1.0 - relPoint.z) * this.min.z + relPoint.z * this.max.z;\n    var p = new THREE.Vector3(x, y, z);\n    return p;\n  } else {\n    return this.centroid();\n  }\n};\n\nBBox.prototype.centroid = function (out) {\n  var centroid = out || new THREE.Vector3();\n  centroid.addVectors(this.min, this.max);\n  centroid.multiplyScalar(0.5);\n  return centroid;\n};\nBBox.prototype.getCenter = BBox.prototype.centroid;\n\nBBox.prototype.radius = function () {\n  return this.min.distanceTo(this.max) / 2;\n};\n\nBBox.prototype.contains = function (p) {\n  if (p instanceof BBox) {\n    return this.contains(p.min) && this.contains(p.max);\n  } else {\n    return !(p.x < this.min.x || p.x > this.max.x ||\n      p.y < this.min.y || p.y > this.max.y ||\n      p.z < this.min.z || p.z > this.max.z);\n  }\n};\n\nBBox.prototype.closestPoint = function (p, out) {\n  var v = out || new THREE.Vector3();\n  v.copy(p);\n  v.clamp(this.min, this.max);\n  return v;\n};\n\nBBox.prototype.closestBoundaryPoint = function (p, out) {\n  var v = this.closestPoint(p, out);\n  var max = this.max, min = this.min;\n  var dists = [\n    ['max','x', Math.abs(v.x - max.x)], ['min', 'x', Math.abs(v.x - min.x)],\n    ['max','y', Math.abs(v.y - max.y)], ['min', 'y', Math.abs(v.y - min.y)],\n    ['max','z', Math.abs(v.z - max.z)], ['min', 'z', Math.abs(v.z - min.z)]\n  ];\n  var minDist = _.minBy(dists, function (d) { return d[2]; });\n  v[minDist[1]] = this[minDist[0]][minDist[1]];\n  return v;\n};\n\nBBox.prototype.distanceToPoint = function (p, opt) {\n  if (opt === 'clamped') {\n    return this.closestPoint(p).sub(p).length();\n  } else if (opt === 'signed') {\n    var d = this.closestBoundaryPoint(p).sub(p).length();\n    if (this.contains(p)) {\n      d = -d;\n    }\n    return d;\n  } else {\n    return this.closestBoundaryPoint(p).sub(p).length();\n  }\n};\n\n// Assymetric (i.e. forward / directed ) Hausdorff distance from this to bbox\nBBox.prototype.hausdorffDistanceDirected = function (bbox, opt) {\n  var corners = this.getCorners();\n  var maxDist = -Infinity;\n  for (var i = 0; i < 8; ++i) {\n    var p = corners[i];\n    var distToP = bbox.distanceToPoint(p, opt);\n    if (distToP > maxDist) {\n      maxDist = distToP;\n    }\n  }\n  return maxDist;\n};\n\n// Symmetric Hausdorff distance between this and bbox\nBBox.prototype.hausdorffDistance = function (bbox, opt) {\n  var dAB = this.hausdorffDistanceDirected(bbox, opt);\n  var dBA = bbox.hausdorffDistanceDirected(this, opt);\n  //console.log(dAB, dBA);\n  if (dAB > dBA) { return dAB; } else { return dBA; }\n};\n\nBBox.prototype.distanceTo = function (bbox) {\n  if (this.valid() && bbox.valid()) {\n    var ca = this.centroid();\n    var cb = bbox.centroid();\n    var ha = this.dimensions().multiplyScalar(0.5);\n    var hb = bbox.dimensions().multiplyScalar(0.5);\n    var dc = ca.sub(cb);\n    dc.x = Math.abs(dc.x);\n    dc.y = Math.abs(dc.y);\n    dc.z = Math.abs(dc.z);\n    var hh = ha.add(hb);\n    var d = dc.sub(hh);\n    var isInside = d.x < 0 && d.y < 0 && d.z < 0;\n    var clampedD = new THREE.Vector3(Math.max(0, d.x), Math.max(0, d.y), Math.max(0, d.z));\n    return isInside ? 0 : clampedD.length();\n  }\n};\n\nBBox.prototype.dimensions = function (out) {\n  var dims = out || new THREE.Vector3();\n  dims.subVectors(this.max, this.min);\n  return dims;\n};\nBBox.prototype.getSize = BBox.prototype.dimensions;\n\nBBox.prototype.volume = function() {\n  var dims = this.dimensions();\n  return dims.x * dims.y * dims.z;\n};\n\nBBox.prototype.maxDim = function () {\n  var dims = this.dimensions();\n  var maxDim = Math.max(dims.x, dims.y, dims.z);\n  return maxDim;\n};\n\nBBox.prototype.maxDimAxisIndex = function () {\n  var dims = this.dimensions();\n  var dimsWithIndices = [[0, dims.x], [1, dims.y], [2, dims.z]];\n  var maxDim = _.maxBy(dimsWithIndices, function (d) { return d[1]; });\n  return maxDim[0];\n};\n\nBBox.prototype.maxDimAxisName = function () {\n  return ['x','y','z'][this.maxDimAxisIndex()];\n};\n\nBBox.prototype.maxDimAxis = function (out) {\n  out = out || new THREE.Vector3();\n  var i = this.maxDimAxisIndex();\n  out.set(0,0,0);\n  out.setComponent(i, 1);\n  return out;\n};\n\nBBox.prototype.minDim = function () {\n  var dims = this.dimensions();\n  var minDim = Math.min(dims.x, dims.y, dims.z);\n  return minDim;\n};\n\nBBox.prototype.minDimAxisIndex = function () {\n  var dims = this.dimensions();\n  var dimsWithIndices = [[0, dims.x], [1, dims.y], [2, dims.z]];\n  var maxDim = _.minBy(dimsWithIndices, function (d) { return d[1]; });\n  return maxDim[0];\n};\n\nBBox.prototype.minDimAxisName = function () {\n  return ['x','y','z'][this.minDimAxisIndex()];\n};\n\nBBox.prototype.minDimAxis = function (out) {\n  out = out || new THREE.Vector3();\n  var i = this.minDimAxisIndex();\n  out.set(0,0,0);\n  out.setComponent(i, 1);\n  return out;\n};\n\nBBox.prototype.getNumValidDimensions = function(min) {\n  min = min || 0;\n  var dims = this.dimensions();\n  var okayDims = _.filter(['x','y','z'], function(d) { return dims[d] > min; });\n  return okayDims.length;\n};\n\nBBox.prototype.includePoint = function (point, transform) {\n  this.__includePoint(point, transform);\n  this.clearCache();\n};\n\nBBox.prototype.__includePoint = function (point, transform) {\n  // Private version (cache not cleared)\n  var p = point;\n  if (transform) {\n    p = point.clone();\n    p.applyMatrix4(transform);\n  }\n\n  this.min.min(p);\n  this.max.max(p);\n  //this.min.x = Math.min(this.min.x, point.x);\n  //this.min.y = Math.min(this.min.y, point.y);\n  //this.min.z = Math.min(this.min.z, point.z);\n\n  //this.max.x = Math.max(this.max.x, point.x);\n  //this.max.y = Math.max(this.max.y, point.y);\n  //this.max.z = Math.max(this.max.z, point.z);\n};\n\n// NOTE: This function is not right, can't multiply min/max by transform and still get bbox!  But who uses it?\nBBox.prototype.transform = function (matrix) {\n  console.warn('STK - BBox transform is deprecated!!!');\n  var bbox = new BBox();\n  bbox.copy(this);\n  bbox.min.applyMatrix4(matrix);\n  bbox.max.applyMatrix4(matrix);\n  return bbox;\n};\n\n// Create bbox by transforming corners.  NOTE: This may result in much larger bbox!!!!\nBBox.prototype.toTransformedBBox = function (matrix) {\n  var bbox = new BBox();\n  var corners = this.getCorners();\n  for (var i = 0; i < corners.length; i++) {\n    bbox.__includePoint(corners[i], matrix);\n  }\n  return bbox;\n};\n\nBBox.prototype.scaleBy = function (scale) {\n  var center = this.centroid();\n  var extents = this.dimensions().multiplyScalar(scale * 0.5);\n  var bbox = new BBox();\n  bbox.fromCenterRadius(center.x, center.y, center.z, extents.x, extents.y, extents.z);\n  return bbox;\n};\n\nBBox.prototype.expandBy = function (delta) {\n  var center = this.centroid();\n  var extents = (delta instanceof THREE.Vector3)?\n    this.dimensions().multiplyScalar(0.5).add(delta) :\n    this.dimensions().multiplyScalar(0.5).addScalar(delta);\n  var bbox = new BBox();\n  bbox.fromCenterRadius(center.x, center.y, center.z, extents.x, extents.y, extents.z);\n  return bbox;\n};\n\nBBox.prototype.sample = function(rng, out) {\n  out = out || new THREE.Vector3();\n  var bbdims = this.dimensions();\n  var a = rng.random() * bbdims.x + this.min.x;\n  var b = rng.random() * bbdims.y + this.min.y;\n  var c = rng.random() * bbdims.z + this.min.z;\n  out.set(a,b,c);\n  return out;\n};\n\nBBox.prototype.clearCache = function () {\n  delete this.corners;\n  delete this.faceCenters;\n};\n\nBBox.prototype.__updateCorners = function (force) {\n  var compute = force;\n  if (!this.corners) {\n    this.corners = [];\n    for (var i = 0; i < 8; i++) {\n      this.corners[i] = new THREE.Vector3();\n    }\n    compute = true;\n  }\n\n  if (compute) {\n    this.corners[0].x = this.min.x;\n    this.corners[0].y = this.min.y;\n    this.corners[0].z = this.min.z;\n    this.corners[1].x = this.min.x;\n    this.corners[1].y = this.min.y;\n    this.corners[1].z = this.max.z;\n    this.corners[2].x = this.min.x;\n    this.corners[2].y = this.max.y;\n    this.corners[2].z = this.min.z;\n    this.corners[3].x = this.min.x;\n    this.corners[3].y = this.max.y;\n    this.corners[3].z = this.max.z;\n    this.corners[4].x = this.max.x;\n    this.corners[4].y = this.min.y;\n    this.corners[4].z = this.min.z;\n    this.corners[5].x = this.max.x;\n    this.corners[5].y = this.min.y;\n    this.corners[5].z = this.max.z;\n    this.corners[6].x = this.max.x;\n    this.corners[6].y = this.max.y;\n    this.corners[6].z = this.min.z;\n    this.corners[7].x = this.max.x;\n    this.corners[7].y = this.max.y;\n    this.corners[7].z = this.max.z;\n  }\n};\n\nBBox.prototype.getCorners = function (force) {\n  this.__updateCorners(force);\n  return this.corners;\n};\n\nBBox.prototype.__updateFaceCenters = function (force) {\n  var compute = force;\n  if (!this.faceCenters) {\n    this.faceCenters = [];\n    for (var i = 0; i < 6; i++) {\n      this.faceCenters[i] = new THREE.Vector3();\n    }\n    compute = true;\n  }\n  if (compute) {\n    var centroid = this.centroid();\n    for (var i = 0; i < 6; i++) {\n      this.faceCenters[i].copy(centroid);\n    }\n    this.faceCenters[0].x = this.min.x;\n    this.faceCenters[1].x = this.max.x;\n    this.faceCenters[2].y = this.min.y;\n    this.faceCenters[3].y = this.max.y;\n    this.faceCenters[4].z = this.min.z;\n    this.faceCenters[5].z = this.max.z;\n  }\n};\n\nBBox.prototype.getFaceCenters = function (force, copy) {\n  this.__updateFaceCenters(force);\n  if (!copy) {\n    return this.faceCenters;\n  } else {\n    // Returns copy of face centers (in case it gets mutated...)\n    var faceCentersCopy = [];\n    for (var i = 0; i < this.faceCenters.length; i++) {\n      faceCentersCopy[i] = this.faceCenters[i].clone();\n    }\n    return faceCentersCopy;\n  }\n};\n\nBBox.prototype.getFaceDims = function () {\n  var dims = this.dimensions();\n  return BBox.getFaceDims(dims);\n};\n\nBBox.prototype.closestCorner = function (point) {\n  this.__updateCorners();\n  var mindist = Infinity;\n  var minpointi = -1;\n  for (var i = 0; i < 8; i++) {\n    var dist = this.corners[i].distanceTo(point);\n    if (dist < mindist) {\n      mindist = dist;\n      minpointi = i;\n    }\n  }\n  return this.corners[minpointi];\n};\n\nBBox.prototype.surfaceArea = function () {\n  // this is the surfaceArea of the BOX, not the\n  // mesh surface\n  var dx = this.max.x - this.min.x;\n  var dy = this.max.y - this.min.y;\n  var dz = this.max.z - this.min.z;\n  var area = 2 * (dx * dy + dx * dz + dy * dz);\n  return area;\n};\n\nBBox.prototype.isEq = function (box2) {\n  // Tests if two BBoxes are (approximately) equal\n  // and returns a boolean answer\n  var epsilon = 10;\n  var differences = [];\n  differences.push(this.max.x - box2.max.x);\n  differences.push(this.max.y - box2.max.y);\n  differences.push(this.max.z - box2.max.z);\n  differences.push(this.min.x - box2.min.x);\n  differences.push(this.min.y - box2.min.y);\n  differences.push(this.min.z - box2.min.z);\n  for (var i in differences) {\n    if (Math.abs(differences[i]) > epsilon) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Tests whether this BBox intersects BBox b\nBBox.prototype.intersects = function (b) {\n  var ca = this.max.clone().add(this.min).multiplyScalar(0.5);\n  var cb = b.max.clone().add(b.min).multiplyScalar(0.5);\n  var d = new THREE.Vector3();\n  d.subVectors(ca, cb);  // delta vector\n  var ha = this.max.clone().sub(this.min).multiplyScalar(0.5);\n  var hb = b.max.clone().sub(b.min).multiplyScalar(0.5);\n  var h = new THREE.Vector3();\n  h.addVectors(ha, hb);  // sum of half-widths\n\n  if (Math.abs(d.x) > h.x) return false;\n  if (Math.abs(d.y) > h.y) return false;\n  if (Math.abs(d.z) > h.z) return false;\n  return true; // boxes overlap\n};\n\n// Intersection of this BBox with BBox b or null if none\nBBox.prototype.intersection = function (b) {\n  var min = this.min.clone().max(b.min);\n  var max = this.max.clone().min(b.max);\n  var intersection = new BBox(min, max);\n  if (intersection.valid()) {\n    return intersection;\n  } else {\n    return null;\n  }\n};\n\nBBox.prototype.intersection2 = function (a,b) {\n  this.min.copy(a.min).max(b.min);\n  this.max.copy(a.max).min(b.max);\n  if (this.valid()) return this;\n  else return null;\n};\n\n// Union of this BBox with BBox b\nBBox.prototype.union = function (b) {\n  var min = this.min.clone().min(b.min);\n  var max = this.max.clone().max(b.max);\n  return new BBox(min, max);\n};\n\nBBox.prototype.union2 = function(a,b) {\n  this.min.copy(a.min).min(b.min);\n  this.max.copy(a.max).max(b.max);\n  return this;\n};\n\nBBox.prototype.toBox2 = function (axisToRemove) {\n  if (!axisToRemove) {\n    console.error('[BBox.toBox2] specify axisToRemove');\n    return null;\n  }\n  var min = THREE.Vector2();\n  var max = THREE.Vector2();\n  switch (axisToRemove) {\n    case 'z':\n      min.x = this.min.x;  min.y = this.min.y;\n      max.x = this.max.x;  max.y = this.max.y;\n      break;\n    case 'y':\n      min.x = this.min.x;  min.z = this.min.z;\n      max.x = this.max.x;  max.z = this.max.z;\n      break;\n    case 'x':\n      min.y = this.min.y;  min.z = this.min.z;\n      max.y = this.max.y;  max.z = this.max.z;\n      break;\n  }\n  return new THREE.Box2(min, max);\n};\n\n// Return isoperimetric quotient (IQ) of BBox: 0 <= IQ <= 1 (cube)\n// measures closeness of BBox to perfect cube\nBBox.prototype.isoperimetricQuotient = function () {\n  var dims = this.dimensions();\n  var S = this.surfaceArea();\n  var V = dims.x * dims.y * dims.z;\n  return 216.0 * V * V / Math.pow(S, 3);\n};\n\nBBox.prototype.isAxisAligned = function() {\n  return true;\n};\n\nBBox.prototype.toString = function() {\n  function vtoString(v) {\n    return '[' + v.x + ',' + v.y + ',' + v.z + ']';\n  }\n  return '{ min: ' + vtoString(this.min) + ', max: ' + vtoString(this.max) +\n    ', dims: ' + vtoString(this.dimensions()) + ', centroid: ' + vtoString(this.centroid()) + '}';\n};\n\nBBox.prototype.toJSON = function (name) {\n  var json = {};\n  if (name) {\n    json.name = name;\n  }\n  json.min = [this.min.x, this.min.y, this.min.z];\n  json.max = [this.max.x, this.max.y, this.max.z];\n  return json;\n};\n\nBBox.getVolume = function(bb) {\n  return bb? bb.volume() : 0;\n};\n\nBBox.getIntersectionMeasure = (function() {\n  var tmp = new BBox();\n  return function(bb1, bb2, opts) {\n    opts = opts || {};\n    var measureFn = opts.measure || BBox.getVolume;\n    var intersection = tmp.intersection2(bb1, bb2);\n    if (intersection) {\n      return measureFn(intersection);\n    } else {\n      return 0;\n    }\n  };\n})();\n\nBBox.getUnionMeasure = (function() {\n  var tmp = new BBox();\n  return function(bb1, bb2, opts) {\n    opts = opts || {};\n    var measureFn = opts.measure || BBox.getVolume;\n    var union = tmp.union2(bb1, bb2);\n    if (union) {\n      return measureFn(union);\n    } else {\n      return 0;\n    }\n  };\n})();\n\nBBox.getOverlapRatio = function(bb1, bb2, opts) {\n  opts = opts || {};\n  var measureFn = opts.measure || BBox.getVolume;\n  var intersectValue = BBox.getIntersectionMeasure(bb1, bb2, opts);\n  var bb1Value = measureFn(bb1);\n  return _.safeDivide(intersectValue, bb1Value, 0);\n};\n\nBBox.getJaccardOverlapRatio = function(bb1, bb2, opts) {\n  opts = opts || {};\n  var intersectValue = BBox.getIntersectionMeasure(bb1, bb2, opts);\n  var unionValue = BBox.getUnionMeasure(bb1, bb2, opts);\n  return _.safeDivide(intersectValue, unionValue, 0);\n};\n\nBBox.getFaceDims = function(dims) {\n  var faceDims = [];\n  faceDims[0] = new THREE.Vector2(dims.y, dims.z);\n  faceDims[1] = faceDims[0];\n  faceDims[2] = new THREE.Vector2(dims.x, dims.z);\n  faceDims[3] = faceDims[2];\n  faceDims[4] = new THREE.Vector2(dims.x, dims.y);\n  faceDims[5] = faceDims[4];\n  return faceDims;\n};\n\n// Exports\nmodule.exports = BBox;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/BBox.js?");

/***/ }),

/***/ "./js/lib/geo/BVH.js":
/*!***************************!*\
  !*** ./js/lib/geo/BVH.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar BVHNode = function (objects, params, parent) {\n  this.id = _.uniqueId();\n  this.parent = parent ? parent : null;\n  this.depth = parent ? parent.depth + 1 : 0;\n  if (!objects) { return; }\n  this.objects = objects;\n  var maxDepth = params.maxDepth;\n  var maxObjects = params.maxObjects || 1;\n  if (objects.length <= maxObjects || (maxDepth != null && this.depth >= maxDepth)) {  // base case\n    var getBBox = params.getBoundingBox || getBoundingBox;\n    this.bbox = getBBox(objects);\n  } else {  // split according to strategy\n    var split = doSplit(objects, params);\n    this.splitAxis = params.splitAxis;  // save split axis\n    this.left = new BVHNode(split.left, params, this);\n    this.right = new BVHNode(split.right, params, this);\n    this.bbox = this.left.bbox.union(this.right.bbox);\n  }\n};\nBVHNode.prototype.constructor = BVHNode;\n\nObject.defineProperty(BVHNode.prototype, 'isLeaf', {\n  get: function () { return !this.left && !this.right; }\n});\n\nObject.defineProperty(BVHNode.prototype, 'children', {\n  get: function () {\n    var children = [];\n    if (this.left) { children.push(this.left); }\n    if (this.right) { children.push(this.right); }\n    return children;\n  }\n});\n\nBVHNode.fromChildren = function (left, right) {\n  var parent = new BVHNode();\n  parent.left = left;\n  parent.right = right;\n  left.parent = parent;\n  right.parent = parent;\n  parent.objects = left.objects.concat(right.objects);\n  parent.bbox = new BBox();\n  parent.bbox.includeBBox(left.bbox);\n  parent.bbox.includeBBox(right.bbox);\n  //parent.bbox = getBoundingBox(parent.objects);\n  return parent;\n};\n\n// TODO: Provide well defined interface for intersectObject and intersectBBox\n// TODO: Allow for other types of intersectors (other than raycaster)\nBVHNode.prototype.intersects = function(intersector, options) {\n  options = options || {};\n  if (intersector instanceof THREE.Raycaster) {\n    var raycaster = intersector;\n    // Returns list of intersected objects\n    options.intersectObject = options.intersectObject || function(object, recursive) { return raycaster.intersectObject(object, recursive); };\n    // returns if bbox is intersected\n    options.intersectBBox = options.intersectBBox || function(bbox) {\n      var intersectedPoint = raycaster.ray.intersectBox(bbox, new THREE.Vector3());\n      if (intersectedPoint) {\n        var insideBBox = bbox.contains(raycaster.ray.origin);\n        if (!insideBBox) {\n          // TODO: filter based on both near and far\n          // in computation of raycaster.ray.intersectBox - a tmin/tmax is computed\n          // Should use those to filter\n          // For now filter just based on far since we only get back tmin\n          var distance = raycaster.ray.origin.distanceTo(intersectedPoint);\n          return (distance <= raycaster.far);\n        } else {\n          return true;\n        }\n      }\n    };\n  }\n  if (options.checkHasIntersectionOnly) {\n    return this.__hasIntersected(options);\n  } else {\n    return this.__intersectsSorted(options);\n  }\n};\n\nBVHNode.prototype.__intersectsSorted = function(options) {\n  var filter = options.filter;\n  var recursive = options.recursive;\n  var limit = options.limit; // Limit to this number of intersections\n  var intersectObjects = options.intersectObjects;\n  var intersectObject = options.intersectObject;\n  var intersectBBox = options.intersectBBox;\n\n  function descSort(a, b) {\n    return a.distance - b.distance;\n  }\n\n  var intersects = options.intersects || [];\n  if (limit) {\n    var BoundedBinaryHeap = __webpack_require__(/*! ds/BoundedBinaryHeap */ \"./js/lib/ds/BoundedBinaryHeap.js\");\n    intersects = new BoundedBinaryHeap({\n      maxSize: limit,\n      scoreFunc: function (x) {\n        return -x.distance;\n      }\n    });\n  }\n  this.traverse(function (bvhNode) {\n    var nodeIntersected = intersectBBox(bvhNode.bbox);\n    if (nodeIntersected && bvhNode.isLeaf) {\n      if (intersectObjects) {\n        var filteredObjects = filter? _.filter(bvhNode.objects, filter) : bvhNode.objects;\n        intersectObjects(filteredObjects, recursive, intersects);\n      } else {\n        for (var i = 0; i < bvhNode.objects.length; i++) {\n          var object = bvhNode.objects[i];\n          if (!filter || filter(object)) {\n            var objectIntersections = intersectObject(object, recursive);\n            if (objectIntersections && objectIntersections.length) {\n              intersects.push.apply(intersects, objectIntersections);\n            }\n          }\n        }\n      }\n    }\n    return nodeIntersected;\n  }, null, true);\n  if (limit) {\n    intersects = intersects.getSorted().reverse();\n  } else {\n    intersects.sort(descSort);\n  }\n  return intersects;\n};\n\nBVHNode.prototype.__hasIntersected = function(options) {\n  var filter = options.filter;\n  var recursive = options.recursive;\n  var intersectObjects = options.intersectObjects;\n  var intersectObject = options.intersectObject;\n  var intersectBBox = options.intersectBBox;\n\n  // We only care if there is any intersection (not in identifying the specific intersection)\n  var intersects = [];\n  var isIntersected = false;\n  this.traverse(function (bvhNode) {\n    var nodeIntersected = intersectBBox(bvhNode.bbox);\n    if (nodeIntersected && bvhNode.isLeaf) {\n      if (intersectObjects) {\n        var filteredObjects = filter ? _.filter(bvhNode.objects, filter) : bvhNode.objects;\n        intersectObjects(filteredObjects, recursive, intersects);\n        if (intersects.length) {\n          isIntersected = true;\n        }\n      } else {\n        for (var i = 0; i < bvhNode.objects.length; i++) {\n          var object = bvhNode.objects[i];\n          if (!filter || filter(object)) {\n            var objectIntersections = intersectObject(object, recursive);\n            if (objectIntersections && objectIntersections.length) {\n              isIntersected = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n    return !isIntersected && nodeIntersected;\n  }, null, true);\n  return isIntersected;\n};\n\nBVHNode.prototype.traverse = function (cbPre, cbPost, checkPre) {\n  if (cbPre) {\n    var traverseMore = cbPre(this);\n    if (checkPre && !traverseMore) {\n      return; // Stop traversal\n    }\n  }\n  if (this.left)  {\n    this.left.traverse(cbPre, cbPost, checkPre);\n  }\n  if (this.right) {\n    this.right.traverse(cbPre, cbPost, checkPre);\n  }\n  if (cbPost) {\n    cbPost(this);\n  }\n};\n\nBVHNode.prototype.compute = function (accum, checkPre) {\n  if (checkPre) {\n    var traverseMore = checkPre(this);\n    if (!traverseMore) {\n      return; // Stop traversal\n    }\n  }\n  var rs = [];\n  if (this.left)  {\n    rs.push(this.left.compute(accum, checkPre));\n  }\n  if (this.right) {\n    rs.push(this.right.compute(accum, checkPre));\n  }\n  return accum(this, rs);\n};\n\nBVHNode.prototype.getTotalDepth = function() {\n  return this.compute(function(node, childValues) {\n    if (node.isLeaf) {\n      return 1;\n    } else {\n      return 1 + (childValues.length? _.max(childValues) : 0);\n    }\n  });\n};\n\nBVHNode.prototype.getNumLeaves = function() {\n  return this.compute(function(node, childValues) {\n    if (node.isLeaf) {\n      return 1;\n    } else {\n      return _.sum(childValues);\n    }\n  });\n};\n\nBVHNode.prototype.getNumNodes = function() {\n  return this.compute(function(node, childValues) {\n    return 1 + _.sum(childValues);\n  });\n};\n\n\n/**\n * Simple bounding volume hierarchy\n * @param objects\n * @param params Options for how to construct the BVH\n * @param [params.splitStrategy] {string|int} Strategy to use for splitting the BVH\n *   (`'AXIS_MIDPOINT'=0, 'AXIS_MEDIAN'=1, '  SURFACE_AREA_HEURISTIC'=2, 'CUBICITY_HEURISTIC'=3`, 'HAC'=4`)\n * @param [params.axisChoiceStrategy] {string|int} Strategy to use for selecting the axis to split along (`'FIXED'=0, 'LONGEST'=1, 'RANDOM'=2, 'OPTIMAL'=3`)\n * @param [params.splitAxis] {string} Must be provided if `axisChoiceStrategy` is `FIXED`.  Ignored otherwise.\n * @param [params.splittableAxes] {string[]} Which axes to consider for splitting (default is all axes `['x', 'y', 'z']`)\n * @param [params.maxDepth] {int} Max depth of BVH tree\n * @param [params.maxObjects=1] {int} Max number of objects per BVH node\n * @param [params.obstacles] {THREE.Object3D[]} Set of obstacles (used for `splitStrategy` of `HAC`) to penalize combining nodes with obstacles together.\n * @param [params.getBoundingBox] {function(THREE.Object3D[]): BBox} Function returning the bounding of objects in a node\n * @constructor\n * @memberOf geo\n */\nvar BVH = function (objects, params) {\n  if (objects && Array.isArray(objects)) {\n    objects = objects.filter(function(x) {\n      if (x == null) {\n        console.warn('Null object passed to BVH');\n      }\n      return x != null;\n    });\n  }\n  // Parse parameters\n  var p = params || {};\n  p = _.defaults(p, BVH.DefaultOptions);\n  if (typeof(p.splitStrategy) === 'string') {\n    p.splitStrategy = _.getEnumValue(p.splitStrategy.toUpperCase(), 'splitStrategy', BVH.SplitStrategy);\n  }\n  if (typeof(p.axisChoiceStrategy) === 'string') {\n    p.axisChoiceStrategy = _.getEnumValue(p.axisChoiceStrategy.toUpperCase(), 'axisChoiceStrategy', BVH.AxisChoiceStrategy);\n  }\n  if (objects && objects.length && (objects[0] instanceof THREE.Object3D || params.getBoundingBox)) {\n    //console.log('BVH params', p);\n    this.params = p;\n    if (p.splitStrategy === BVH.SplitStrategy.HAC) {\n      console.time('HAC');\n      this.root = constructWithHAC(objects, p);\n      console.timeEnd('HAC');\n    } else {\n      this.root = new BVHNode(objects, p);\n    }\n  } else if (!objects || objects.length === 0) {\n    throw 'BVH requires some objects to be specified';\n  } else {\n    throw 'BVH requires objects = [THREE.Object3D] or getBoundingBox to be specified';\n  }\n};\nBVH.prototype.constructor = BVH;\n\nBVH.AxisChoiceStrategy = Object.freeze({\n  FIXED: 0,\n  LONGEST: 1,\n  RANDOM: 2,\n  OPTIMAL: 3\n});\n\nBVH.SplitStrategy = Object.freeze({\n  AXIS_MIDPOINT: 0,\n  AXIS_MEDIAN: 1,\n  SURFACE_AREA_HEURISTIC: 2,\n  CUBICITY_HEURISTIC: 3,\n  HAC: 4\n});\n\nBVH.DefaultOptions = Object.freeze({\n  axisChoiceStrategy: BVH.AxisChoiceStrategy.LONGEST,\n  splitStrategy: BVH.SplitStrategy.HAC,\n  splitAxis: 'x',\n  splittableAxes: ['x', 'y', 'z']\n});\n\nfunction constructWithHAC(objects, params) {\n  var f = function (bbox) {\n    if (!bbox) return 0;\n    var d = bbox.dimensions();\n    var vol = d.x * d.z + d.y;\n    if (!isFinite(vol)) { return 0; }\n    return vol;\n  };\n  var raycaster = new THREE.Raycaster();\n  var bvhnodes = new Set(objects.map(function (o) { return new BVHNode([o], params); }));\n\n  var cachedDistances = {};\n  var tempBB = new BBox();\n\n  function combineBest(active) {\n    // Find best and combine\n    var bestD = Infinity;\n    var left = null, right = null;\n    active.forEach(function (a) {\n      active.forEach(function (b) {\n        if (a.id >= b.id) return; // Ignore these\n        var dAB = cachedDistances[a.id + '-' + b.id];\n        if (dAB == undefined) {\n          var fa = f(a.bbox);\n          var fb = f(b.bbox);\n          var fu = f(tempBB.union2(a.bbox, b.bbox));\n          var fi = f(tempBB.intersection2(a.bbox, b.bbox));\n          dAB = fu + fi - (fa + fb);\n          //var dist = a.bbox.distanceTo(b.bbox);\n          //dAB = (1.0 + dist)*dAB;\n          if (params.obstacles) {\n            var ca = a.bbox.centroid();\n            var aToB = b.bbox.centroid().sub(ca);\n            var distAtoB = aToB.length();\n            aToB.normalize();\n            raycaster.set(ca, aToB);\n            raycaster.far = distAtoB;\n            var intersects = raycaster.intersectObjects(params.obstacles, true);\n            if (intersects.length) {\n              dAB += 1000000;\n            }\n          }\n          cachedDistances[a.id + '-' + b.id] = dAB;\n        }\n        if ((a.id !== b.id) && dAB < bestD) {\n          bestD = dAB;\n          left = a;\n          right = b;\n        }\n      });\n    });\n    //console.log(bestD);\n    if (left && right) {\n      var combined = BVHNode.fromChildren(left, right);\n      return combined;\n    } else {\n      console.error('Missing left or right', left, right, active, cachedDistances);\n    }\n  }\n\n  function constructFromBVHNodes(active) {\n    //console.log('processing: ', active);\n    while (active.size > 1) {\n      var combined = combineBest(active);\n\n      if (combined) {\n        // Add combined into active and remove left/right\n        var left = combined.left;\n        var right = combined.right;\n        active.forEach(function (a) {\n          var key1 = a.id < left.id ? a.id + '-' + left.id : left.id + '-' + a.id;\n          delete cachedDistances[key1];\n          var key2 = a.id < right.id ? a.id + '-' + right.id : right.id + '-' + a.id;\n          delete cachedDistances[key2];\n        });\n        active.delete(left);\n        active.delete(right);\n        active.add(combined);\n        //console.log('combined ' + left.id + ', ' + right.id, combined);\n      } else {\n        break;\n      }\n    }\n    var r = active.entries().next().value[0];  // only element is root\n    return r;\n  }\n\n  var root = constructFromBVHNodes(bvhnodes);\n  root.depth = 0;\n  root.traverse(function (n) {\n    if (n.parent) { n.depth = n.parent.depth + 1; }\n  });\n  return root;\n}\n\nfunction doSplit(objects, params) {\n  var getBBox = params.getBoundingBox || getBoundingBox;\n  // select axis\n  switch (params.axisChoiceStrategy) {\n    case BVH.AxisChoiceStrategy.FIXED:\n      if (!params.splitAxis) { console.error('[BVH] splitAxis not specified'); }\n      break;\n    case BVH.AxisChoiceStrategy.LONGEST:\n      params.splitAxis = getBBox(objects).maxDimAxisName();\n      break;\n    case BVH.AxisChoiceStrategy.RANDOM:\n      params.splitAxis = _.sample(params.splittableAxes);\n      break;\n  }\n  // select split strategy\n  switch (params.splitStrategy) {\n    case BVH.SplitStrategy.AXIS_MIDPOINT:\n      return splitAxisMidpoint(objects, params);\n    case BVH.SplitStrategy.AXIS_MEDIAN:\n      return splitAxisMedian(objects, params);\n    case BVH.SplitStrategy.SURFACE_AREA_HEURISTIC:\n      return splitAxisSAH(objects, params);\n    case BVH.SplitStrategy.CUBICITY_HEURISTIC:\n      return splitAxisCubicity(objects, params);\n  }\n}\n\nfunction getBoundingBox(objects) {\n  var bbox;\n  if (Array.isArray(objects)) {\n    bbox = new BBox();\n    objects.forEach(function (o) {\n      var oBBox = getBoundingBox(o);\n      if (oBBox && oBBox.valid()) {\n        bbox.includeBBox(oBBox);\n      }\n    });\n  } else if (objects instanceof THREE.Object3D) {\n    bbox = Object3DUtil.getBoundingBox(objects);\n  } else if (objects instanceof BBox) {\n    bbox = objects;\n  } else if (objects instanceof THREE.Box3) {\n    bbox = new BBox(objects.min, objects.max);\n  } else {\n    console.error('Cannot compute bounding box for no objects!');\n  }\n  if (!bbox.valid()) {\n    console.warn('Invalid bounding box for objects', bbox, objects);\n  }\n  return bbox;\n}\n\nfunction getLeftRightSplit(lr) {\n  // handle degenerate splits by arbitrarily pushing element to other side\n  if (lr[0].length === 0) {\n    lr[0] = lr[1].slice(0,1);\n    lr[1] = lr[1].slice(1);\n  } else if (lr[1].length === 0) {\n    lr[1] = lr[0].slice(0,1);\n    lr[0] = lr[0].slice(1);\n  }\n  if (!lr[0].length || !lr[1].length) {\n    console.error('Degenerate split: ', lr);\n  }\n  return { left: lr[0], right: lr[1] };\n}\n\nfunction splitAxisMedian(objects, params) {\n  var getBBox = params.getBoundingBox || getBoundingBox;\n  var sorted = _.sortBy(objects, function (o) {\n    return getBBox(o).centroid()[params.splitAxis];\n  });\n  var mi = Math.floor(objects.length / 2);\n  var lr = [sorted.slice(0, mi), sorted.slice(mi)];\n  return getLeftRightSplit(lr);\n}\n\nfunction splitAxisMidpoint(objects, params) {\n  var getBBox = params.getBoundingBox || getBoundingBox;\n  var bbox = getBBox(objects);\n  var mid = bbox.centroid()[params.splitAxis];\n  var lr = _.partition(objects, function (o) {\n    return getBBox(o).centroid()[params.splitAxis] <= mid;\n  });\n  return getLeftRightSplit(lr);\n}\n\nfunction calculateMinCostSplitAxis(objects, params, costFunction) {\n  var getBBox = params.getBoundingBox || getBoundingBox;\n  var bbox = getBBox(objects);\n  var saNorm = 1 / bbox.surfaceArea();\n  var sorted = _.sortBy(objects, function (o) {\n    return getBBox(o).centroid()[params.splitAxis];\n  });\n  var sortedBBoxen = _.map(sorted, function (o) {\n    return getBBox(o);\n  });\n\n  // compute cost for splitting after each object\n  var i, j, cost = [];\n  for (i = 0; i < sorted.length - 1; ++i) {\n    var b0 = new BBox(), b1 = new BBox();\n    var cnt0 = 0, cnt1 = 0;\n    for (j = 0; j <= i; ++j) {\n      b0 = b0.union(sortedBBoxen[j]);\n      cnt0++;\n    }\n    for (j = i + 1; j < sorted.length; ++j) {\n      b1 = b1.union(sortedBBoxen[j]);\n      cnt1++;\n    }\n    cost[i] = costFunction(b0, b1, cnt0, cnt1, saNorm);\n  }\n\n  // find split that minimizes SAH metric\n  var minCost = cost[0];\n  var mi = 0;\n  for (i = 1; i < sorted.length - 1; ++i) {\n    if (cost[i] < minCost) {\n      minCost = cost[i];\n      mi = i;\n    }\n  }\n\n  return {minCost: minCost, minIndex: mi, sorted: sorted, splitAxis: params.splitAxis};\n}\n\nfunction minCostSplitAxis(objects, params, costFunction) {\n  var minCostInfo;\n  if (params.axisChoiceStrategy === BVH.AxisChoiceStrategy.OPTIMAL) {\n    var costInfos = _.map(params.splittableAxes, function(splitAxis) {\n      params.splitAxis = splitAxis;\n      return calculateMinCostSplitAxis(objects, params, costFunction);\n    });\n    minCostInfo = _.minBy(costInfos, 'minCost');\n    params.splitAxis = minCostInfo.splitAxis;\n  } else {\n    minCostInfo = calculateMinCostSplitAxis(objects, params, costFunction);\n  }\n  // return split\n  var mi = minCostInfo.minIndex;\n  var sorted = minCostInfo.sorted;\n  var lr = [sorted.slice(0, mi + 1), sorted.slice(mi + 1)];\n  return getLeftRightSplit(lr);\n}\n\nfunction splitAxisSAH(objects, params) {\n  function costSAH(bbox0, bbox1, count0, count1, normalization) {\n    normalization = normalization || 1;\n    return 1 + (count0 * bbox0.surfaceArea() + count1 * bbox1.surfaceArea()) * normalization;\n  }\n  return minCostSplitAxis(objects, params, costSAH);\n}\n\nfunction splitAxisCubicity(objects, params) {\n  function costCubicity(bbox0, bbox1, count0, count1, normalization) {\n    normalization = normalization || 1;\n    var cost0 = count0 * (1 - bbox0.isoperimetricQuotient()) * bbox0.surfaceArea();\n    var cost1 = count1 * (1 - bbox1.isoperimetricQuotient()) * bbox1.surfaceArea();\n    var cost = (cost0 + cost1) * normalization;\n    return cost;\n  }\n  return minCostSplitAxis(objects, params, costCubicity);\n}\n\nBVH.prototype.traverse = function (cbPre, cbPost, checkPre) {\n  this.root.traverse(cbPre, cbPost, checkPre);\n};\n\nBVH.prototype.intersects = function(intersector, options) {\n  return this.root.intersects(intersector, options);\n};\n\nBVH.prototype.getNodeArray = function () {\n  var nodes = [];\n  this.root.traverse(function (node) {\n    nodes.push(node);\n  });\n  return nodes;\n};\n\nBVH.prototype.getTotalDepth = function() {\n  return this.root.getTotalDepth();\n};\n\nBVH.prototype.getNumLeaves = function() {\n  return this.root.getNumLeaves();\n};\n\nBVH.prototype.getNumNodes = function() {\n  return this.root.getNumNodes();\n};\n\nBVH.prototype.getStats = function() {\n  return {\n    depth: this.getTotalDepth(),\n    nodes: this.getNumNodes(),\n    leaves: this.getNumLeaves()\n  }\n};\n\nBVH.prototype.getInternalNodes = function () {\n  var nodes = [];\n  this.root.traverse(function (node) {\n    if (!node.isLeaf) {\n      nodes.push(node);\n    }\n  });\n  return nodes;\n};\n\nBVH.prototype.getLeaves = function () {\n  var nodes = [];\n  this.root.traverse(function (node) {\n    if (node.isLeaf) {\n      nodes.push(node);\n    }\n  });\n  return nodes;\n};\n\nBVH.buildForChildObjects = function(object3D, opts) {\n  // Build bvh for object3D, while respecting children\n  object3D.traverse(function(node) {\n    if (node.children && node.children.length > 1) {\n      node.childrenBvh = new BVH(node.children, opts);\n    }\n  });\n};\n\nBVH.buildFromMeshes = function(object3D, opts) {\n  var meshes = Object3DUtil.getMeshList(object3D);\n  return new BVH(meshes, opts);\n};\n\nBVH.buildFromTriangles = function(mesh, opts) {\n  opts = opts || {};\n  var nFaces = GeometryUtil.getGeometryFaceCount(mesh.geometry);\n  var indices = _.range(nFaces);\n  var v = new THREE.Vector3();\n  mesh.updateMatrixWorld();\n  var toWorld = mesh.matrixWorld;\n  var bvh = new BVH(indices, _.defaults(opts, {\n    splitStrategy: BVH.SplitStrategy.AXIS_MEDIAN,\n    getBoundingBox: function(triIndices) {\n      var bbox = new BBox();\n      for (var i = 0; i < triIndices.length; i++) {\n        var triIndex = triIndices[i];\n        var faceVertexIndices = GeometryUtil.getFaceVertexIndices(mesh.geometry, triIndex);\n        for (var j = 0; j < faceVertexIndices.length; j++) {\n          GeometryUtil.getGeometryVertex(mesh.geometry, faceVertexIndices[j], toWorld, v);\n          bbox.includePoint(v);\n        }\n      }\n      return bbox;\n    },\n    maxDepth: 50, // Try not to have depth beyond 50\n    maxObjects: 50 // Can have up to 50 triangles in leaf\n  }));\n  return bvh;\n};\n\nmodule.exports = BVH;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/BVH.js?");

/***/ }),

/***/ "./js/lib/geo/BoundingBoxHelper.js":
/*!*****************************************!*\
  !*** ./js/lib/geo/BoundingBoxHelper.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\n// My bounding box helper!!!  Just like THREE.BoundingBoxHelper except that\n//   we use our cached bounding box, and have more functions!\nvar BoundingBoxHelper = function (object, materialOrColor) {\n  this.object = object;\n  this.box = new THREE.Box3();\n\n  var material;\n  if (materialOrColor instanceof THREE.Material || materialOrColor instanceof THREE.MultiMaterial) {\n    material = materialOrColor;\n  } else if (materialOrColor instanceof THREE.Color) {\n    material = new THREE.MeshBasicMaterial({ color: materialOrColor, wireframe: true });\n  } else {\n    var hex = materialOrColor;\n    var color = (hex !== undefined) ? hex : 0x888888;\n    material = new THREE.MeshBasicMaterial({ color: color, wireframe: true });\n  }\n  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), material);\n};\n\nBoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);\nBoundingBoxHelper.prototype.constructor = BoundingBoxHelper;\n\nBoundingBoxHelper.prototype.update = function (force) {\n  if (this.object) {\n    var bb = Object3DUtil.getBoundingBox(this.object, force);\n    this.box.set(bb.min, bb.max);\n    //this.box.setFromObject( this.object );\n    this.box.size(this.scale);\n    this.box.center(this.position);\n  } else {\n    this.box.makeEmpty();\n  }\n};\n\nBoundingBoxHelper.prototype.attach = function (object) {\n  this.object = object;\n  this.update();\n};\n\nBoundingBoxHelper.prototype.detach = function () {\n  this.object = null;\n  this.update();\n};\n\nmodule.exports = BoundingBoxHelper;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/BoundingBoxHelper.js?");

/***/ }),

/***/ "./js/lib/geo/ColorGrid.js":
/*!*********************************!*\
  !*** ./js/lib/geo/ColorGrid.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Grid = __webpack_require__(/*! geo/Grid */ \"./js/lib/geo/Grid.js\");\n\n/**\n * ColorGrid with voxels stored as 4 bytes\n * @constructor\n * @memberof geo\n * @extends geo.Grid\n */\nvar ColorGrid = function (params) {\n  params = params || {};\n  Grid.call(this, params);\n  this.type = 'colorgrid';\n  this.dataType = 'uint8';   // Basic unit of a voxel element  (what typed array to use)\n  this.bitsPerElement = 8*Grid.Types[this.dataType].bytes;     // Number of bits used per element\n  this.elementsPerVoxel = 4;        // Number of elements per voxel\n  this.voxels = null;\n  this.minThreshold = params.minThreshold || 0;\n  // this.properties = [\n  //   { name: 'kinds', value: 'RGB-color space space space' }\n  // ];\n};\nColorGrid.prototype = Object.create(Grid.prototype);\nColorGrid.prototype.constructor = ColorGrid;\n\nColorGrid.prototype.isVoxelSet = function(x, y, z) {\n  var voxel = this.getRawVoxel(x, y, z);\n  return (voxel && (voxel[3] > this.minThreshold*255));\n};\n\nColorGrid.prototype.setColor = function (x, y, z, c) {\n  return this.setVoxel(x,y,z,c);\n};\n\nColorGrid.prototype.setOpacity = function (x, y, z, opacity) {\n  var vi = this.__indexOf(x, y, z);\n  var i = this.elementsPerVoxel*vi + 3;\n  if (i >= 0 && i < this.__voxelsBuffer.length) {\n    this.__voxelsBuffer[i] = Math.floor(opacity*255);\n  }\n};\n\n/**\n * Returns voxel as THREE.Color\n * @param x {int}\n * @param y {int}\n * @param z {int}\n * @returns {THREE.Color}\n */\nColorGrid.prototype.getColor = function (x, y, z) {\n  var voxel = this.getRawVoxel(x, y, z);\n  if (voxel && (voxel[3] > this.minThreshold*255)) {\n    var c = new THREE.Color();\n    c.setRGB(voxel[0]/255, voxel[1]/255, voxel[2]/255);\n    return c;\n  }\n};\n\nColorGrid.prototype.setVoxel = function (x, y, z, c) {\n  var alpha = c ? ((c.a != undefined) ? c.a : 1): 0;\n  var v = c ? [Math.floor(c.r * 255), Math.floor(c.g * 255), Math.floor(c.b * 255), alpha * 255] : null;\n  return this.setRawVoxel(x, y, z, v);\n};\n\nColorGrid.prototype.getVoxel = function (x, y, z) {\n  var voxel = this.getRawVoxel(x, y, z);\n  if (voxel && (voxel[3] > this.minThreshold*255)) {\n    //return  ( voxel[0] & 255 ) << 16 ^ ( voxel[1] & 255 ) << 8 ^ ( voxel[2] & 255 ) << 0;\n    return ( voxel[3] & 255 ) << 24 ^ ( voxel[0] & 255 ) << 16 ^ ( voxel[1] & 255 ) << 8 ^ ( voxel[2] & 255 ) << 0;\n  }\n};\n\nmodule.exports = ColorGrid;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/ColorGrid.js?");

/***/ }),

/***/ "./js/lib/geo/ConnectivityGraph2.js":
/*!******************************************!*\
  !*** ./js/lib/geo/ConnectivityGraph2.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Index = __webpack_require__(/*! ds/Index */ \"./js/lib/ds/Index.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\n\n// NOTE: This ConnectivityGraph is very naive, faces are connected only if they share the exact same vertex.\nfunction ConnectivityGraph(geometry, remapVertices) {\n  this.__vertexIndex = remapVertices? this.__buildVerticesIndex(geometry) : undefined;\n  this.geometry = geometry;\n\n  // Mapping of face index to neighboring face indices\n  // neighbors are those faces that share a vertex\n  this.faceNeighbors = null;\n\n  // Mapping of face index to faces that are reverse faces\n  this.reverseFaceMapping = null;\n\n  // Mapping of faceIndex1-faceIndex2 to type of neighbor\n  this.faceNeighborTypes = null;\n\n  // Populate basic faceNeighbors\n  this.build(geometry);\n}\n\nvar NeighborTypes = {\n  REVERSE: { index: 0, name: 'REVERSE'},\n  SHARED_EDGE: { index: 1, name: 'SHARED_EDGE'},\n  PARTIAL_EDGE: { index: 2, name: 'PARTIAL_EDGE'},\n  SHARED_VERTEX: { index: 3, name: 'SHARED_VERTEX'}\n};\n\nConnectivityGraph.NeighborTypes = NeighborTypes;\n\n/**\n * Builds a mapping of the vertices to a collapsed set of vertices\n *   where vertices at the same position are mapped to the same index\n * @return a pair of index of vertex locations (Vector3f) to Int,\n *                   map of original vertex index to remapped vertex index\n */\nConnectivityGraph.prototype.__buildVerticesIndex = function(geometry) {\n  var verticesIndex = new Index({\n    id: function(v) { return v.x.toString() + ',' + v.y.toString() + ',' + v.z.toString(); }\n  });\n  var mappedIndices = [];\n  var position = new THREE.Vector3();\n  var nVertices = GeometryUtil.getGeometryVertexCount(geometry);\n  for (var i = 0; i < nVertices; i++) {\n    GeometryUtil.copyGeometryVertex(position, geometry, i);\n    var mappedIndex = verticesIndex.indexOf(position, true);\n    mappedIndices[i] = mappedIndex;\n  }\n  return {\n    verticesIndex: verticesIndex,\n    mappedIndices: mappedIndices,\n    toMapped: function(vis) {\n      if (vis.length) {\n        return vis.map(function (vi) {\n          return mappedIndices[vi];\n        });\n      } else {\n        return mappedIndices[vis];\n      }\n    }\n  };\n};\n\nConnectivityGraph.prototype.build = function(geometry) {\n  var nVertices = GeometryUtil.getGeometryVertexCount(geometry);\n  var vertexToFaces = new Array(nVertices);\n  var remapping = this.__vertexIndex? this.__vertexIndex.mappedIndices : null;\n  GeometryUtil.forFaceVertexIndices(geometry, function(faceIndex, vertexIndices) {\n    for (var i = 0; i < vertexIndices.length; i++) {\n      var rawvi = vertexIndices[i];\n      var vi = remapping? remapping[rawvi] : rawvi;\n      var vtof = vertexToFaces[vi];\n      if (!vtof) {\n        vtof = [faceIndex];\n        vertexToFaces[vi] = vtof;\n      } else {\n        vtof.push(faceIndex);\n      }\n    }\n  });\n\n  var nFaces = GeometryUtil.getGeometryFaceCount(geometry);\n  var faceNeighbors = new Array(nFaces);\n  GeometryUtil.forFaceVertexIndices(geometry, function(faceIndex, vertexIndices) {\n    var neighbors = faceNeighbors[faceIndex];\n    if (!neighbors) {\n      neighbors = [];\n      faceNeighbors[faceIndex] = neighbors;\n    }\n\n    for (var i = 0; i < vertexIndices.length; i++) {\n      var rawvi = vertexIndices[i];\n      var vi = remapping? remapping[rawvi] : rawvi;\n      var vtof = vertexToFaces[vi];\n      for (var j = 0; j < vtof.length; j++) {\n        var iFaceOther = vtof[j];\n        if (iFaceOther !== faceIndex && neighbors.indexOf(iFaceOther) < 0) {\n          neighbors.push(iFaceOther);\n        }\n      }\n    }\n  });\n  this.faceNeighbors = faceNeighbors;\n};\n\nfunction hasSharedEdge(a1, a2) {\n  for (var i = 0; i < a1.length; i++) {\n    var v11 = a1[i];\n    var v12 = a1[(i+1)%a1.length];\n    for (var j = 0; j < a2.length; j++) {\n      var v21 = a2[j];\n      var v22 = a2[(j+1)%a2.length];\n      if (v11 === v21 && v12 === v22) {\n        return true;\n      } else if (v11 === v22 && v12 === v21) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nConnectivityGraph.prototype.__getFaceNeighborTypes = function() {\n  if (this.faceNeighborTypes) {\n    return this.faceNeighborTypes;\n  }\n\n  var neighborTypes = {};\n  var remapping = this.__vertexIndex? this.__vertexIndex.mappedIndices : null;\n  var faceNeighbors = this.faceNeighbors;\n  var geometry = this.geometry;\n  var t1 = new THREE.Triangle();\n  var t2 = new THREE.Triangle();\n\n  GeometryUtil.forFaceVertexIndices(geometry, function(fi1, rawVertexIndices1) {\n    var neighbors = faceNeighbors[fi1];\n    var vertexIndices1 = remapping? rawVertexIndices1.map(function(rawvi) { return remapping[rawvi]; }): rawVertexIndices1;\n    if (neighbors && neighbors.length) {\n      GeometryUtil.getTriangle(geometry, fi1, t1);\n      for (var i = 0; i < neighbors.length; i++) {\n        var fi2 = neighbors[i];\n        var rawVertexIndices2 = GeometryUtil.getFaceVertexIndices(geometry, fi2);\n        var vertexIndices2 = remapping? rawVertexIndices2.map(function(rawvi) { return remapping[rawvi]; }): rawVertexIndices2;\n\n        var k = fi1 + '-' + fi2;\n        var isReversed = _.isReversed(vertexIndices1, vertexIndices2);\n        if (isReversed) {\n          neighborTypes[k] = NeighborTypes.REVERSE;\n        } else if (hasSharedEdge(vertexIndices1, vertexIndices2)) {\n          neighborTypes[k] = NeighborTypes.SHARED_EDGE;\n        } else {\n          GeometryUtil.getTriangle(geometry, fi2, t2);\n          if (GeometryUtil.trianglesShareEdge(t1, t2)) {\n            neighborTypes[k] = NeighborTypes.PARTIAL_EDGE;\n          } else {\n            neighborTypes[k] = NeighborTypes.SHARED_VERTEX;\n          }\n        }\n      }\n    }\n  });\n\n  this.faceNeighborTypes = neighborTypes;\n  return this.faceNeighborTypes;\n};\n\nConnectivityGraph.prototype.getReverseFaceMappings = function() {\n  if (this.reverseFaceMapping) {\n    return this.reverseFaceMapping;\n  }\n  var remapping = this.__vertexIndex? this.__vertexIndex.mappedIndices : null;\n  var reverseFaceMapping = [];\n  var faceNeighbors = this.faceNeighbors;\n  var geometry = this.geometry;\n  GeometryUtil.forFaceVertexIndices(geometry, function(faceIndex, rawVertexIndices) {\n    var neighbors = faceNeighbors[faceIndex];\n    var vertexIndices = remapping? rawVertexIndices.map(function(rawvi) { return remapping[rawvi]; }): rawVertexIndices;\n    if (neighbors && neighbors.length) {\n      for (var i = 0; i < neighbors.length; i++) {\n        var iFaceOther = neighbors[i];\n        var rawOtherVertexIndices = GeometryUtil.getFaceVertexIndices(geometry, iFaceOther);\n        var otherVertexIndices = remapping? rawOtherVertexIndices.map(function(rawvi) { return remapping[rawvi]; }): rawOtherVertexIndices;\n        var isReversed = _.isReversed(vertexIndices, otherVertexIndices);\n        if (isReversed) {\n          if (!reverseFaceMapping[faceIndex]) {\n            reverseFaceMapping[faceIndex] = [];\n          }\n          reverseFaceMapping[faceIndex].push(iFaceOther);\n        }\n      }\n    }\n  });\n  this.reverseFaceMapping = reverseFaceMapping;\n  return reverseFaceMapping;\n};\n\nConnectivityGraph.prototype.getFaceNeighbors = function(faceIndex) {\n  return this.faceNeighbors[faceIndex];\n};\n\nConnectivityGraph.prototype.getFaceNeighborTypes = function(fi1) {\n  var neighborTypes = this.__getFaceNeighborTypes();\n  if (fi1 == null) {\n    return neighborTypes;\n  } else {\n    var faceNeighbors = this.faceNeighbors[fi1];\n    if (faceNeighbors && faceNeighbors.length) {\n      return _.map(faceNeighbors, fi2 => {\n        var key = fi1 + '-' + fi2;\n        return { faceIndex: fi2, neighborType: neighborTypes[key] };\n      });\n    }\n  }\n};\n\nConnectivityGraph.prototype.gatherFaces = function(mainFaceIndex, maxLengthSq, normSimThreshold, point) {\n  var geometry = this.geometry;\n  var mainFaceVertexIndices = GeometryUtil.getFaceVertexIndices(geometry, mainFaceIndex);\n  var mainFaceVertexPositions = mainFaceVertexIndices.map( function(vi) {\n    return GeometryUtil.getGeometryVertex(geometry, vi);\n  });\n  var mainFaceNormal = GeometryUtil.computeFaceNormal.apply(null, mainFaceVertexPositions);\n\n  if (!point) {\n    var positions = mainFaceVertexPositions;\n    var tri = new THREE.Triangle(positions[0], positions[1], positions[2]);\n    point = tri.getMidpoint(new THREE.Vector3());\n  }\n  var maxRadiusSq = maxLengthSq/4;\n\n  var cg = this.faceNeighbors;\n\n  var faceIndices = [];\n  var todo = [mainFaceIndex];\n  var visited = {};\n  visited[mainFaceIndex] = 1;\n  var currentRadiusSq = 0;\n  while (todo.length > 0) {\n    var fi = todo.shift();\n    var faceVertexIndices = GeometryUtil.getFaceVertexIndices(geometry, fi);\n    var faceVertexPositions = faceVertexIndices.map( function(vi) {\n      return GeometryUtil.getGeometryVertex(geometry, vi);\n    });\n    if (normSimThreshold) {\n      var faceNormal = GeometryUtil.computeFaceNormal.apply(null, faceVertexPositions);\n      var normSim = mainFaceNormal.dot(faceNormal);\n      if (normSim < normSimThreshold) {\n        continue;\n      }\n    }\n\n    var distancesToFaceVertices = faceVertexPositions.map(function(p) {\n      return point.distanceToSquared(p);\n    });\n    var dmax = Math.max.apply(null, distancesToFaceVertices);\n    var dmin = Math.min.apply(null, distancesToFaceVertices);\n    if (currentRadiusSq === 0 || dmax < maxRadiusSq || dmax <= currentRadiusSq) {\n      faceIndices.push(fi);\n      currentRadiusSq = Math.max(currentRadiusSq, dmax);\n    }\n    if (dmin < maxRadiusSq || dmax <= currentRadiusSq) {\n      // Let's try to grow this!\n      var neighbors = cg[fi];\n      if (neighbors) {\n        for (var j = 0; j < neighbors.length; j++) {\n          var ni = neighbors[j];\n          if (!visited[ni]) {\n            visited[ni] = 1;\n            todo.push(ni);\n          }\n        }\n      }\n    }\n  }\n  //console.log('gathered: r=' + currentRadiusSq + ', max=' + maxRadiusSq, faceIndices);\n  return { faceIndices: faceIndices, radiusSq: currentRadiusSq };\n};\n\nmodule.exports = ConnectivityGraph;\n\n//# sourceURL=webpack://STK/./js/lib/geo/ConnectivityGraph2.js?");

/***/ }),

/***/ "./js/lib/geo/Distances.js":
/*!*********************************!*\
  !*** ./js/lib/geo/Distances.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var TriangleAccessor = __webpack_require__(/*! geo/TriangleAccessor */ \"./js/lib/geo/TriangleAccessor.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Utility functions to compute distances\n * Taken from http://www.geometrictools.com/LibMathematics/Distance/Distance.html\n * NOTE: Distances between sets of points do not have to satisfy the triangle inequality\n *    -----   A\n *   |     |\n *   |  C  |     d(A,B) > d(A,C) + d(B,C)\n *   |     |\n *    -----   B\n *\n * @author Angel Chang\n * @private\n */\n\nvar ZERO_TOLERANCE = 0.0000000001;\n\nfunction swapFields(object, fieldsPairs) {\n  for (var i = 0; i < fieldsPairs.length; i++) {\n    var f1 = fieldsPairs[i][0];\n    var f2 = fieldsPairs[i][1];\n    var tmp = object[f1];\n    object[f1] = object[f2];\n    object[f2] = tmp;\n  }\n}\n\nfunction renameFields(object, fieldsPairs) {\n  for (var i = 0; i < fieldsPairs.length; i++) {\n    var f1 = fieldsPairs[i][0];\n    var f2 = fieldsPairs[i][1];\n    object[f2] = object[f1];\n    delete object[f1];\n  }\n}\n\nfunction PointPointDistanceSquared(point1, point2, opts) {\n  var distanceSq = point1.distanceToSquared(point2);\n  if (opts.all) {\n    return {\n      distanceSq: distanceSq,\n      closestPoint0: point1,\n      closestPoint1: point2\n    };\n  } else {\n    return {\n      distanceSq: distanceSq\n    };\n  }\n}\n\n/**\n * Computes the distance between a line and a line segment\n * @param line {{origin: THREE.Vector3, direction: THREE.Vector3}}\n * @param segment {{origin: THREE.Vector3, direction: THREE.Vector3, extent: number}}\n * @param opts {{all: boolean, debug: boolean}} Additional options.\n *   Use `all` to indicate that all fields should be returned (otherwise, just return `distanceSq`).\n * @returns {{distanceSq: number}}\n * @private\n */\nfunction LineSegmentDistanceSquared(line, segment, opts) {\n  function computeDistanceSquared() {\n    var diff = new THREE.Vector3();\n    diff.subVectors(line.origin, segment.origin);\n    var a01 = -line.direction.dot(segment.direction);\n    var b0 = diff.dot(line.direction);\n    var c = diff.lengthSq();\n    var det = Math.abs(1.0 - a01 * a01);\n\n    var sqrDist;\n    var s0;\n    var s1;\n    if (det >= ZERO_TOLERANCE) {\n      // The line and segment are not parallel.\n      var b1 = -diff.dot(segment.direction);\n      s1 = a01 * b0 - b1;\n      var extDet = segment.extent * det;\n\n      if (s1 >= -extDet) {\n        if (s1 <= extDet) {\n          // Two interior points are closest, one on the line and one\n          // on the segment.\n          var invDet = 1.0 / det;\n          s0 = (a01 * b1 - b0) * invDet;\n          s1 *= invDet;\n          sqrDist = s0 * (s0 + a01 * s1 + 2.0 * b0) + s1 * (a01 * s0 + s1 + 2.0 * b1) + c;\n        } else {\n          // The endpoint e1 of the segment and an interior point of\n          // the line are closest.\n          s1 = segment.extent;\n          s0 = -(a01 * s1 + b0);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\n        }\n      } else {\n        // The end point e0 of the segment and an interior point of the\n        // line are closest.\n        s1 = -segment.extent;\n        s0 = -(a01 * s1 + b0);\n        sqrDist = -s0 * s0 + s1 * (s1 + 2.0 * b1) + c;\n      }\n    } else {\n      // The line and segment are parallel.  Choose the closest pair so that\n      // one point is at segment center.\n      s1 = 0.0;\n      s0 = -b0;\n      sqrDist = b0 * s0 + c;\n    }\n\n    // Account for numerical round-off errors.\n    if (sqrDist < ZERO_TOLERANCE) {\n      sqrDist = 0.0;\n    }\n\n    if (opts && opts.all) {\n      var closestPoint0 = line.origin.clone();\n      closestPoint0.addScaledVector(line.direction, s0);\n      var closestPoint1 = segment.origin.clone();\n      closestPoint1.addScaledVector(segment.direction, s1);\n\n      return {\n        distanceSq: sqrDist,\n        closestPoint0: closestPoint0,\n        closestPoint1: closestPoint1,\n        lineParameter: s0,\n        segmentParameter: s1\n      };\n    } else {\n      return {\n        distanceSq: sqrDist\n      };\n    }\n  }\n\n  return computeDistanceSquared();\n}\n\nfunction SegmentLineDistanceSquared(segment, line, opts) {\n  var result = LineSegmentDistanceSquared(line, segment, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\n/**\n * Computes the distance between a point and a triangle\n * @param point {THREE.Vector3}\n * @param triangle {THREE.Triangle}\n * @param opts {{all: boolean, debug: boolean}} Additional options.\n *   Use `all` to indicate that all fields should be returned (otherwise, just return `distanceSq`).\n *   Use `debug` to output extra debug messages\n * @returns {{distanceSq: number}}\n * @private\n */\nfunction PointTriangleDistanceSquared(point, triangle, opts) {\n  var v1 = triangle.a;\n  var v2 = triangle.b;\n  var v3 = triangle.c;\n  var edge0 = new THREE.Vector3();\n  edge0.subVectors(v2,v1);\n  var edge1 = new THREE.Vector3();\n  edge1.subVectors(v3,v1);\n  var normal = new THREE.Vector3();\n\n  function computeDistanceSquareNonDegenerate() {\n    // This algorithm assumes that the norm is not 0 (i.e. triangle is not degenerate)\n    var diff = new THREE.Vector3();\n    diff.subVectors(v1, point);\n    var a00 = edge0.lengthSq();\n    var a01 = edge0.dot(edge1);\n    var a11 = edge1.lengthSq();\n    var b0 = diff.dot(edge0);\n    var b1 = diff.dot(edge1);\n    var c = diff.lengthSq();\n    var det = Math.abs(a00*a11 - a01*a01);\n\n    var s = a01*b1 - a11*b0;\n    var t = a01*b0 - a00*b1;\n\n    var sqrDistance;\n    if (s + t <= det) {\n      if (s < 0.0) {\n        if (t < 0.0) {\n          // region 4\n          if (b0 < 0.0) {\n            t = 0.0;\n            if (-b0 >= a00) {\n              s = 1.0;\n              sqrDistance = a00 + 2.0*b0 + c;\n            } else {\n              s = -b0/a00;\n              sqrDistance = b0*s + c;\n            }\n          } else {\n            s = 0.0;\n            if (b1 >= 0.0) {\n              t = 0.0;\n              sqrDistance = c;\n            } else if (-b1 >= a11) {\n              t = 1.0;\n              sqrDistance = a11 + 2.0*b1 + c;\n            } else {\n              t = -b1/a11;\n              sqrDistance = b1*t + c;\n            }\n          }\n        } else {\n          // region 3\n          s = 0.0;\n          if (b1 >= 0.0) {\n            t = 0.0;\n            sqrDistance = c;\n          } else if (-b1 >= a11) {\n            t = 1.0;\n            sqrDistance = a11 + 2.0*b1 + c;\n          } else {\n            t = -b1/a11;\n            sqrDistance = b1*t + c;\n          }\n        }\n      } else if (t < 0.0) {\n        // region 5\n        t = 0.0;\n        if (b0 >= 0.0) {\n          s = 0.0;\n          sqrDistance = c;\n        } else if (-b0 >= a00) {\n          s = 1.0;\n          sqrDistance = a00 + 2.0*b0 + c;\n        } else {\n          s = -b0/a00;\n          sqrDistance = b0*s + c;\n        }\n      } else {\n        // region 0\n        // minimum at interior point\n        var invDet = 1.0/det;\n        s *= invDet;\n        t *= invDet;\n        sqrDistance = s*(a00*s + a01*t + 2.0*b0) + t*(a01*s + a11*t + 2.0*b1) + c;\n      }\n    } else {\n      if (s < 0.0) {\n        // region 2\n        var tmp0 = a01 + b0;\n        var tmp1 = a11 + b1;\n        if (tmp1 > tmp0) {\n          var numer = tmp1 - tmp0;\n          var denom = a00 - 2.0*a01 + a11;\n          if (numer >= denom)\n          {\n            s = 1.0;\n            t = 0.0;\n            sqrDistance = a00 + 2.0*b0 + c;\n          } else {\n            s = numer/denom;\n            t = 1.0 - s;\n            sqrDistance = s*(a00*s + a01*t + 2.0*b0) + t*(a01*s + a11*t + 2.0*b1) + c;\n          }\n        } else {\n          s = 0.0;\n          if (tmp1 <= 0.0) {\n            t = 1.0;\n            sqrDistance = a11 + 2.0*b1 + c;\n          } else if (b1 >= 0.0) {\n            t = 0.0;\n            sqrDistance = c;\n          } else {\n            t = -b1/a11;\n            sqrDistance = b1*t + c;\n          }\n        }\n      } else if (t < 0.0) {\n        // region 6\n        var tmp0 = a01 + b1;\n        var tmp1 = a00 + b0;\n        if (tmp1 > tmp0) {\n          var numer = tmp1 - tmp0;\n          var denom = a00 - 2.0*a01 + a11;\n          if (numer >= denom) {\n            t = 1.0;\n            s = 0.0;\n            sqrDistance = a11 + 2.0*b1 + c;\n          } else {\n            t = numer/denom;\n            s = 1.0 - t;\n            sqrDistance = s*(a00*s + a01*t + 2.0*b0) + t*(a01*s + a11*t + 2.0*b1) + c;\n          }\n        } else {\n          t = 0.0;\n          if (tmp1 <= 0.0) {\n            s = 1.0;\n            sqrDistance = a00 + 2.0*b0 + c;\n          } else if (b0 >= 0.0) {\n            s = 0.0;\n            sqrDistance = c;\n          } else {\n            s = -b0/a00;\n            sqrDistance = b0*s + c;\n          }\n        }\n      } else {\n        // region 1\n        var numer = a11 + b1 - a01 - b0;\n        if (numer <= 0.0) {\n          s = 0.0;\n          t = 1.0;\n          sqrDistance = a11 + 2.0*b1 + c;\n        } else {\n          var denom = a00 - 2.0*a01 + a11;\n          if (numer >= denom) {\n            s = 1.0;\n            t = 0.0;\n            sqrDistance = a00 + 2.0*b0 + c;\n          } else {\n            s = numer/denom;\n            t = 1.0 - s;\n            sqrDistance = s*(a00*s + a01*t + 2.0*b0) + t*(a01*s + a11*t + 2.0*b1) + c;\n          }\n        }\n      }\n    }\n\n    // Account for numerical round-off error.\n    if (sqrDistance < ZERO_TOLERANCE) {\n      sqrDistance = 0.0;\n    }\n\n    return { s: s, t: t, distanceSq: sqrDistance };\n  }\n\n  function computeDistanceSquared() {\n    // TODO: Check if triangle is degenerate and do something else if needed\n    var computedDist = computeDistanceSquareNonDegenerate();\n\n    var sqrDistance = computedDist.distanceSq;\n    var s = computedDist.s;\n    var t = computedDist.t;\n    // Check distances if from each vertex\n    var ds = [v1.distanceToSquared(point), v2.distanceToSquared(point), v3.distanceToSquared(point)];\n    var dsMin = Math.min.apply(null, ds);\n    if (dsMin*1.01 < sqrDistance) {\n      var cross = edge0.cross(edge1);\n      if (opts && opts.debug && cross.lengthSq() > 0.0001) {\n        console.log(\"Distance from vertex to point smaller than computed distance: \" + dsMin + \", \" + sqrDistance);\n        console.log(\"Distances from vertices are: \" + ds.join(\",\"));\n        console.log(\"Point is \" + point);\n        console.log(\"Triangle is \" + v1 + \", \" + v2 + \", \" + v3);\n        console.log(\"Triangle normal is \" + triangle.getNormal(normal));\n        console.log(\"edge0 cross edge1 is \" + cross);\n      }\n      sqrDistance = dsMin;\n      var i = ds.indexOf(sqrDistance);\n      var ss = [0,1,0];\n      var ts = [0,0,1];\n      s = ss[i];\n      t = ts[i];\n    }\n\n    if (opts && opts.all) {\n      var closestPoint0 = point;\n      var closestPoint1 = v1.clone();\n      closestPoint1.addScaledVector(edge0, s);\n      closestPoint1.addScaledVector(edge1, t);\n      var triangleBary = new THREE.Vector3(1.0 - s - t, s, t);\n\n      return {\n        distanceSq: sqrDistance,\n        closestPoint0: closestPoint0,\n        closestPoint1: closestPoint1,\n        triangleBary: triangleBary\n      };\n    } else {\n      return {\n        distanceSq: sqrDistance\n      };\n    }\n  }\n\n  return computeDistanceSquared();\n}\n\nfunction TrianglePointDistanceSquared(triangle, point, opts) {\n  var result = PointTriangleDistanceSquared(point, triangle, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\nfunction generateComplementBasis(u, v, w) {\n  if (Math.abs(w.x) >= Math.abs(w.y)) {\n    // w.x or w.z is the largest magnitude component, swap them\n    var fInvLength = 1.0/Math.sqrt(w.x * w.x + w.z * w.z);\n    u.x = -w.z * fInvLength;\n    u.y = 0.0;\n    u.z = +w.x * fInvLength;\n    v.x = w.y * u.z;\n    v.y = w.z * u.x - w.x * u.z;\n    v.z = -w.y * u.x;\n  } else {\n    // w.y or w.z is the largest magnitude component, swap them\n    var fInvLength = 1.0/Math.sqrt(w.y * w.y + w.z * w.z);\n    u.x = 0.0;\n    u.y = +w.z * fInvLength;\n    u.z = -w.y * fInvLength;\n    v.x = w.y * u.z - w.z * u.y;\n    v.y = -w.x * u.z;\n    v.z = w.x * u.y;\n  }\n}\n\n/**\n * Computes the distance between a line and a triangle\n * @param line {{origin: THREE.Vector3, direction: THREE.Vector3}}\n * @param triangle {THREE.Triangle}\n * @param opts {{all: boolean, debug: boolean}} Additional options.\n *   Use `all` to indicate that all fields should be returned (otherwise, just return `distanceSq`).\n *   Use `debug` to output extra debug messages\n * @returns {{distanceSq: number}}\n * @private\n */\nfunction LineTriangleDistanceSquared(line, triangle, opts) {\n  var lineParameter;\n  var triangleBary;\n  var closestPoint0;\n  var closestPoint1;\n\n  // The intersection point closestPoint0 is inside or on the triangle.\n\n  //----------------------------------------------------------------------------\n  function computeDistanceSquared() {\n    // Test if line intersects triangle.  If so, the squared distance is zero.\n    var v1 = triangle.a;\n    var v2 = triangle.b;\n    var v3 = triangle.c;\n    var edge0 = new THREE.Vector3();\n    edge0.subVectors(v2,v1);\n    var edge1 = new THREE.Vector3();\n    edge1.subVectors(v3,v1);\n    var normal = new THREE.Vector3();\n    normal.crossVectors(edge0,edge1).normalize();\n    var ndd = normal.dot(line.direction);\n    if (Math.abs(ndd) > ZERO_TOLERANCE) {\n      // The line and triangle are not parallel, so the line intersects\n      // the plane of the triangle.\n      var diff = new THREE.Vector3();\n      diff.subVectors(line.origin, v1);\n      var u = new THREE.Vector3();\n      var v = new THREE.Vector3();\n      generateComplementBasis(u, v, line.direction);\n      var udE0 = u.dot(edge0);\n      var udE1 = u.dot(edge1);\n      var udDiff = u.dot(diff);\n      var vdE0 = v.dot(edge0);\n      var vdE1 = v.dot(edge1);\n      var vdDiff = v.dot(diff);\n      var invDet = 1.0/(udE0*vdE1 - udE1*vdE0);\n\n      // Barycentric coordinates for the point of intersection.\n      var b1 = (vdE1*udDiff - udE1*vdDiff)*invDet;\n      var b2 = (udE0*vdDiff - vdE0*udDiff)*invDet;\n      var b0 = 1.0 - b1 - b2;\n\n      if (b0 >= 0.0 && b1 >= 0.0 && b2 >= 0.0) {\n        if (opts && opts.all) {\n          // Line parameter for the point of intersection.\n          var ddE0 = line.direction.dot(edge0);\n          var ddE1 = line.direction.dot(edge1);\n          var ddDiff = line.direction.dot(diff);\n          lineParameter = b1 * ddE0 + b2 * ddE1 - ddDiff;\n\n          // Barycentric coordinates for the point of intersection.\n          triangleBary = new THREE.Vector3(b0, b1, b2);\n          // The intersection point is inside or on the triangle.\n          closestPoint0 = line.origin.clone();\n          closestPoint0.addScaledVector(line.direction, lineParameter);\n          closestPoint1 = v1.clone();\n          closestPoint1.addScaledVector(edge0, b1);\n          closestPoint1.addScaledVector(edge1, b2);\n          return {\n            distanceSq: 0.0,\n            closestPoint0: closestPoint0,\n            closestPoint1: closestPoint1,\n            lineParameter: lineParameter,\n            triangleBary: triangleBary\n          };\n        } else {\n          return { distanceSq: 0.0 };\n        }\n      }\n    }\n\n    // Either (1) the line is not parallel to the triangle and the point of\n    // intersection of the line and the plane of the triangle is outside the\n    // triangle or (2) the line and triangle are parallel.  Regardless, the\n    // closest point on the triangle is on an edge of the triangle.  Compare\n    // the line to all three edges of the triangle.\n    var sqrDist = Infinity;\n    if (opts && opts.all) {\n      triangleBary = new THREE.Vector3();\n      for (var i1 = 0; i1 < 3; i1++) {\n        var i0 = (i1 + 2) % 3;\n\n        var segment = getEdgeSegment(triangle, i0, i1);\n        var queryLS = LineSegmentDistanceSquared(line, segment, opts);\n\n        var sqrDistTmp = queryLS.distanceSq;\n        if (sqrDistTmp < sqrDist) {\n          sqrDist = sqrDistTmp;\n\n          closestPoint0 = queryLS.closestPoint0;\n          closestPoint1 = queryLS.closestPoint1;\n\n          lineParameter = queryLS.lineParameter;\n          var ratio = queryLS.segmentParameter / segment.extent;\n          triangleBary.setComponent(i0, 0.5 * (1.0 - ratio));\n          triangleBary.setComponent(i1, 1.0 - triangleBary.getComponent(i0));\n          triangleBary.setComponent(3 - i0 - i1, 0.0);\n        }\n      }\n      return {\n        distanceSq: sqrDist,\n        closestPoint0: closestPoint0,\n        closestPoint1: closestPoint1,\n        lineParameter: lineParameter,\n        triangleBary: triangleBary\n      };\n    } else {\n      for (var i1 = 0; i1 < 3; i1++) {\n        var i0 = (i1 + 2) % 3;\n\n        var segment = getEdgeSegment(triangle, i0, i1);\n        var sqrDistTmp = LineSegmentDistanceSquared(line, segment, opts);\n        if (sqrDistTmp.distanceSq < sqrDist) {\n          sqrDist = sqrDistTmp.distanceSq;\n        }\n      }\n      return { distanceSq: sqrDist };\n    }\n  }\n\n  return computeDistanceSquared();\n}\n\nfunction TriangleLineDistanceSquared(triangle, line, opts) {\n  var result = LineTriangleDistanceSquared(line, triangle, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\n/**\n * Computes the distance between a line segment and a triangle\n * @param segment {{origin: THREE.Vector3, direction: THREE.Vector3, extent: number}}\n * @param triangle {THREE.Triangle}\n * @param opts {{all: boolean, debug: boolean}} Additional options.\n *   Use `all` to indicate that all fields should be returned (otherwise, just return `distanceSq`).\n *   Use `debug` to output extra debug messages\n * @private\n */\nfunction LineSegmentTriangleDistanceSquared(segment, triangle, opts) {\n  function computeDistanceSquared() {\n    var queryLT = LineTriangleDistanceSquared(segment, triangle, { all: true });\n\n    var sqrDist = queryLT.distanceSq;\n    var segmentParameter = queryLT.lineParameter;\n\n    var closestPoint0;\n    var closestPoint1;\n    var triangleBary;\n\n    if (segmentParameter < -segment.extent) {\n      closestPoint0 = segment.origin.clone();\n      closestPoint0.addScaledVector(segment.direction, -segment.extent);\n      segmentParameter = segment.extent;\n    } else if (segmentParameter > segment.extent) {\n      closestPoint0 = segment.origin.clone();\n      closestPoint0.addScaledVector(segment.direction, segment.extent);\n      segmentParameter = segment.extent;\n    } else {\n      closestPoint0 = queryLT.closestPoint0;\n      closestPoint1 = queryLT.closestPoint1;\n      triangleBary = queryLT.triangleBary;\n    }\n\n    if (opts && opts.all) {\n      if (!closestPoint1) {\n        var queryPT = PointTriangleDistanceSquared(closestPoint0, triangle, opts);\n        sqrDist = queryPT.distanceSq;\n        closestPoint1 = queryPT.closestPoint1;\n        triangleBary = queryPT.triangleBary;\n      }\n      return {\n        distanceSq: sqrDist,\n        closestPoint0: closestPoint0,\n        closestPoint1: closestPoint1,\n        triangleBary: triangleBary,\n        segmentParameter: segmentParameter\n      };\n    } else {\n      if (!closestPoint1) {\n        return PointTriangleDistanceSquared(closestPoint0, triangle, opts);\n      } else {\n        return {distanceSq: sqrDist};\n      }\n    }\n  }\n  return computeDistanceSquared();\n}\n\nfunction TriangleLineSegmentDistanceSquared(triangle, segment, opts) {\n  var result = LineSegmentTriangleDistanceSquared(segment, triangle, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\n\n\nfunction getEdgeSegment(t, i0, i1) {\n  var vs = [t.a, t.b, t.c];\n  var v0 = vs[i0];\n  var v1 = vs[i1];\n  var d = new THREE.Vector3();\n  d.subVectors(v1, v0);\n  var extent = d.length();\n  d.normalize();\n  var origin = new THREE.Vector3();\n  origin.addVectors(v0,v1).multiplyScalar(0.5);\n  return { origin: origin, direction: d, extent:  0.5*extent };\n}\n\n/**\n * Computes the distance between two triangles\n * @param triangle0 {THREE.Triangle}\n * @param triangle1 {THREE.Triangle}\n * @param opts {{all: boolean, debug: boolean}} Additional options.\n *   Use `all` to indicate that all fields should be returned (otherwise, just return `distanceSq`).\n *   Use `debug` to output extra debug messages\n * @private\n */\nfunction TriangleTriangleDistanceSquared(triangle0, triangle1, opts) {\n  var closestPoint0;\n  var closestPoint1;\n  var triangleBary0;\n  var triangleBary1;\n\n  function getResult(distSq) {\n    if (opts && opts.all) {\n      return {\n        distanceSq: distSq,\n        closestPoint0: closestPoint0,\n        closestPoint1: closestPoint1,\n        triangleBary0: triangleBary0,\n        triangleBary1: triangleBary1\n      };\n    } else {\n      return {\n        distanceSq: distSq\n      };\n    }\n  }\n\n  function computeDistanceSquared() {\n    // Compare edges of triangle0 to the interior of triangle1.\n    var t0 = triangle0;\n    var t1 = triangle1;\n\n    var sqrDist = Infinity;\n    triangleBary0 = new THREE.Vector3();\n    for (var i1 = 0; i1 < 3; i1++) {\n      var i0 = (i1+2)%3;\n\n      var edge = getEdgeSegment(t0, i0, i1);\n\n      var queryST = LineSegmentTriangleDistanceSquared(edge, t1, opts);\n      var sqrDistTmp = queryST.distanceSq;\n      if (sqrDistTmp < sqrDist) {\n        closestPoint0 = queryST.closestPoint0;\n        closestPoint1 = queryST.closestPoint1;\n\n        sqrDist = sqrDistTmp;\n\n        if (opts && opts.all) {\n          var ratio = queryST.segmentParameter / edge.extent;\n          triangleBary0.setComponent(i0, 0.5 * (1.0 - ratio));\n          triangleBary0.setComponent(i1, 1.0 - triangleBary0.getComponent(i0));\n          triangleBary0.setComponent(3 - i0 - i1, 0.0);\n          triangleBary1 = queryST.triangleBary;\n        }\n\n        if (sqrDist <= ZERO_TOLERANCE){\n          return getResult(0.0);\n        }\n      }\n    }\n\n    // Compare edges of triangle1 to the interior of triangle0.\n    triangleBary1 = new THREE.Vector3();\n    for (var i1 = 0; i1 < 3; i1++) {\n      var i0 = (i1+2)%3;\n      var edge = getEdgeSegment(t1, i0, i1);\n\n      var queryST = LineSegmentTriangleDistanceSquared(edge, t0, opts);\n      var sqrDistTmp = queryST.distanceSq;\n      if (sqrDistTmp < sqrDist) {\n        closestPoint0 = queryST.closestPoint1;\n        closestPoint1 = queryST.closestPoint0;\n\n        sqrDist = sqrDistTmp;\n\n        if (opts && opts.all) {\n          var ratio = queryST.segmentParameter / edge.extent;\n          triangleBary1.setComponent(i0, 0.5 * (1.0 - ratio));\n          triangleBary1.setComponent(i1, 1.0 - triangleBary1.getComponent(i0));\n          triangleBary1.setComponent(3 - i0 - i1, 0.0);\n          triangleBary0 = queryST.triangleBary;\n        }\n\n        if (sqrDist <= ZERO_TOLERANCE) {\n          return getResult(0.0);\n        }\n      }\n    }\n\n    return getResult(sqrDist);\n  }\n\n  return computeDistanceSquared();\n}\n\nfunction PointsPointsMinDistanceSquared(points1, points2, opts) {\n  var result;\n  var done = false;\n  for (var i = 0; i < points1.length && !done; i++) {\n    var p1 = points1[i];\n    for (var j = 0; j < points2.length && !done; j++) {\n      var p2 = points2[j];\n      var sqrDist = p1.distanceToSquared(p2);\n      if (!result || sqrDist < result.distanceSq) {\n        if (opts.all) {\n          result = {\n            distanceSq: sqrDist,\n            closestPoint0: p1,\n            closestPoint1: p2\n          };\n        } else {\n          result = {\n            distanceSq: sqrDist\n          };\n        }\n        if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n          if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n            result.upperDistanceSq = result.distanceSq;\n            done = true;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfunction PointsPointsMaxDistanceSquared(points1, points2, opts) {\n  var result;\n  for (var i = 0; i < points1.length; i++) {\n    var p1 = points1[i];\n    for (var j = 0; j < points2.length; j++) {\n      var p2 = points2[j];\n      var sqrDist = p1.distanceToSquared(p2);\n      if (!result || sqrDist > result.distanceSq) {\n        if (opts.all) {\n          result = {\n            distanceSq: sqrDist,\n            farthestPoint0: p1,\n            farthestPoint1: p2\n          };\n        } else {\n          result = {\n            distanceSq: sqrDist\n          };\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfunction PointsPointsHausdorffDirectedDistanceSquared(points1, points2, opts) {\n  var result;\n  var done = false;\n  var innerOpts = _.clone(opts);\n  innerOpts.shortCircuit = { minDistSq: 0 };\n  for (var i = 0; i < points1.length && !done; i++) {\n    var p1 = points1[i];\n    var r = PointsPointsMinDistanceSquared([p1], points2, innerOpts);\n    if (!result || r.distanceSq > result.distanceSq) {\n      result = r;\n      innerOpts.shortCircuit.minDistSq = result.distanceSq;\n      if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n        if (result.distanceSq > opts.shortCircuit.maxDistSq) {\n          result.lowerDistanceSq = result.distanceSq;\n          done = true;\n        }\n      }\n    }\n  }\n  if (result && opts.all) {\n    renameFields(result, [['closestPoint0', 'point0'], ['closestPoint1', 'point1']]);\n  }\n  return result;\n}\n\nfunction PointsPointsHausdorffDistanceSquared(points1, points2, opts) {\n  var r1 = PointsPointsHausdorffDirectedDistanceSquared(points1, points2, opts);\n  var r2 = PointsPointsHausdorffDirectedDistanceSquared(points2, points1, opts);\n  if (r2.distanceSq > r1.distanceSq) {\n    swapFields(r2, [['closestPoint0', 'closestPoint1']]);\n    return r2;\n  } else {\n    return r1;\n  }\n}\n\nfunction PointMeshDistanceSquaredBVH(point, mesh, opts) {\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n\n  var BVH = __webpack_require__(/*! geo/BVH */ \"./js/lib/geo/BVH.js\");\n  if (!mesh.bvh) {\n    //console.time('buildBVH.Mesh1');\n    mesh.bvh = BVH.buildFromTriangles(mesh, { maxObjects: 50 });\n    //console.timeEnd('buildBVH.Mesh1');\n  }\n\n  function bvhTriDistanceSq(point, bvh) {\n    return PointPartialMeshDistanceSquared(point, mesh, bvh.objects, opts);\n  }\n\n  function selectBetterResult(r1, r2) {\n    if (!r1) return r2;\n    else if (!r2) return r1;\n    if (r1.distanceSq <= r2.distanceSq) {\n      return r1;\n    } else if (r2.distanceSq <= r1.distanceSq) {\n      return r2;\n    } else if (r1.lowerDistanceSq <= r2.lowerDistanceSq) {\n      return r1;\n    } else {\n      return r2;\n    }\n  }\n  function bvhDistanceSq(point, bvh, bbcheckThreshold) {\n    var distToBBox = Math.max(bvh.bbox.distanceToPoint(point, 'clamped'), 0);\n    var distLowerSq = distToBBox*distToBBox;\n    if (distLowerSq <= bbcheckThreshold + ZERO_TOLERANCE) {\n      if (bvh.isLeaf) {\n        return bvhTriDistanceSq(point, bvh);\n      } else {\n        var dist1 = bvhDistanceSq(point, bvh.left, bbcheckThreshold);\n        if (dist1.distanceSq <= checkDistSqMin) {\n          return dist1;\n        }\n        bbcheckThreshold = Math.min(dist1.distanceSq, bbcheckThreshold);\n        var dist2 = bvhDistanceSq(point, bvh.right, bbcheckThreshold);\n        if (dist2.distanceSq <= checkDistSqMin) {\n          return dist2;\n        }\n        return selectBetterResult(dist1,dist2);\n      }\n    } else {\n      return {\n        distanceSq: Infinity,\n        lowerDistanceSq: distLowerSq\n      };\n    }\n  }\n  var result = bvhDistanceSq(point, mesh.bvh.root, checkDistSqMax);\n  return result;\n}\n\n\nfunction PointMeshDistanceSquaredSimple(point, mesh, opts) {\n  var triAccessor = new TriangleAccessor(mesh);\n  var nTris = triAccessor.numTriangles();\n  var result;\n  var tmpTriangle = new THREE.Triangle();\n  var savedTriangle = new THREE.Triangle();\n  var done = false;\n  for (var i = 0; i < nTris && !done; i++) {\n    triAccessor.getTriangle(i, tmpTriangle, mesh.matrixWorld);\n    var r = PointTriangleDistanceSquared(point, tmpTriangle, opts);\n    if (!result || r.distanceSq < result.distanceSq) {\n      result = r;\n      if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n        if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n          result.upperDistanceSq = result.distanceSq;\n          done = true;\n        }\n      }\n      if (opts.all) {\n        savedTriangle.copy(tmpTriangle);\n        result.closestFaceIndex = i;\n        result.closestTriangle = savedTriangle;\n      }\n    }\n  }\n  return result;\n}\n\nfunction PointMeshDistanceSquared(point, mesh, opts) {\n  if (opts.profile) {\n    console.time('PointMeshDistanceSquared');\n  }\n  var triAccessor = new TriangleAccessor(mesh);\n  var nTris = triAccessor.numTriangles();\n  var result;\n  if (nTris === 0) {\n    result ={ distanceSq: Infinity };\n  } else if (nTris < 1000) {\n    result = PointMeshDistanceSquaredSimple(point, mesh, opts);\n  } else {\n    result = PointMeshDistanceSquaredBVH(point, mesh, opts);\n  }\n\n  if (opts.profile) {\n    console.timeEnd('PointMeshDistanceSquared');\n  }\n  return result;\n}\n\n\nfunction PointPartialMeshDistanceSquared(point, mesh, faceIndices, opts) {\n  var triAccessor = new TriangleAccessor(mesh);\n  var result;\n  var done = false;\n  var tmpTriangle = new THREE.Triangle();\n  var savedTriangle = new THREE.Triangle();\n  for (var i = 0; i < faceIndices.length && !done; i++) {\n    var iTri = faceIndices[i];\n    triAccessor.getTriangle(iTri, tmpTriangle, mesh.matrixWorld);\n    var r = PointTriangleDistanceSquared(point, tmpTriangle, opts);\n    if (!result || r.distanceSq < result.distanceSq) {\n      result = r;\n      if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n        if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n          result.upperDistanceSq = result.distanceSq;\n          done = true;\n        }\n      }\n      if (opts.all) {\n        savedTriangle.copy(tmpTriangle);\n        result.closestFaceIndex = iTri;\n        result.closestTriangle = savedTriangle;\n      }\n    }\n  }\n  return result;\n}\n\nfunction MeshPointDistanceSquared(mesh, point, opts) {\n  var result = PointMeshDistanceSquared(point, mesh, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\nfunction PartialMeshPointDistanceSquared(mesh, point, opts) {\n  var result = PointPartialMeshDistanceSquared(point, mesh, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\nfunction MeshMeshDistanceSquaredSimple(mesh1, mesh2, opts) {\n  var triAccessor1 = new TriangleAccessor(mesh1);\n  var triAccessor2 = new TriangleAccessor(mesh2);\n  var nTris1 = triAccessor1.numTriangles();\n  var nTris2 = triAccessor2.numTriangles();\n  var result;\n  var tmpTriangle1 = new THREE.Triangle();\n  var savedTriangle1 = new THREE.Triangle();\n  var tmpTriangle2 = new THREE.Triangle();\n  var savedTriangle2 = new THREE.Triangle();\n  for (var i = 0; i < nTris1; i++) {\n    triAccessor1.getTriangle(i, tmpTriangle1, mesh1.matrixWorld);\n    for (var j = 0; j < nTris2; j++) {\n      triAccessor2.getTriangle(j, tmpTriangle2, mesh2.matrixWorld);\n      var r = TriangleTriangleDistanceSquared(tmpTriangle1, tmpTriangle2, opts);\n      if (!result || r.distanceSq < result.distanceSq) {\n        result = r;\n        if (opts.all) {\n          savedTriangle1.copy(tmpTriangle1);\n          savedTriangle2.copy(tmpTriangle2);\n          result.closestFaceIndex0 = i;\n          result.closestFaceIndex1 = j;\n          result.closestTriangle0 = savedTriangle1;\n          result.closestTriangle1 = savedTriangle2;\n        }\n        if (result.distanceSq <= ZERO_TOLERANCE) {\n          return result;\n        }\n        if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n          if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n            result.upperDistanceSq = result.distanceSq;\n            return result;\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n\nfunction MeshMeshDistanceSquaredBVH(mesh1, mesh2, opts) {\n  var triAccessor1 = new TriangleAccessor(mesh1);\n  var triAccessor2 = new TriangleAccessor(mesh2);\n  if (triAccessor1.numTriangles() === 0 || triAccessor2.numTriangles() === 0) {\n    return { distanceSq: Infinity };\n  }\n\n  var BVH = __webpack_require__(/*! geo/BVH */ \"./js/lib/geo/BVH.js\");\n  if (!mesh1.bvh) {\n    //console.time('buildBVH.Mesh1');\n    mesh1.bvh = BVH.buildFromTriangles(mesh1, { maxObjects: 10 });\n    //console.timeEnd('buildBVH.Mesh1');\n  }\n  if (!mesh2.bvh) {\n    //console.time('buildBVH.Mesh2');\n    mesh2.bvh = BVH.buildFromTriangles(mesh2, { maxObjects: 10 });\n    //console.timeEnd('buildBVH.Mesh2');\n  }\n\n  var tmpTriangle1 = new THREE.Triangle();\n  var tmpTriangle2 = new THREE.Triangle();\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n  //var nTris1 = triAccessor1.numTriangles();\n  //var nTris2 = triAccessor2.numTriangles();\n  //console.log('compare ' + nTris1 + ' to ' + nTris2, checkDistSqMin, checkDistSqMax);\n\n  function bvhTriDistanceSq(bvh1, bvh2) {\n    var result;\n    var savedTriangle1 = new THREE.Triangle();\n    var savedTriangle2 = new THREE.Triangle();\n    for (var i = 0; i < bvh1.objects.length; i++) {\n      triAccessor1.getTriangle(bvh1.objects[i], tmpTriangle1, mesh1.matrixWorld);\n      for (var j = 0; j < bvh2.objects.length; j++) {\n        triAccessor2.getTriangle(bvh2.objects[j], tmpTriangle2, mesh2.matrixWorld);\n        var r = TriangleTriangleDistanceSquared(tmpTriangle1, tmpTriangle2, opts);\n        if (!result || r.distanceSq < result.distanceSq) {\n          result = r;\n          if (opts.all) {\n            savedTriangle1.copy(tmpTriangle1);\n            savedTriangle2.copy(tmpTriangle2);\n            result.closestFaceIndex0 = bvh1.objects[i];\n            result.closestFaceIndex1 = bvh2.objects[j];\n            result.closestTriangle0 = savedTriangle1;\n            result.closestTriangle1 = savedTriangle2;\n          }\n          if (result.distanceSq <= ZERO_TOLERANCE) {\n            return result;\n          }\n          if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n            if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n              result.upperDistanceSq = result.distanceSq;\n              return result;\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  function selectBetterResult(r1, r2) {\n    if (!r1) return r2;\n    else if (!r2) return r1;\n    if (r1.distanceSq <= r2.distanceSq) {\n      return r1;\n    } else if (r2.distanceSq <= r1.distanceSq) {\n      return r2;\n    } else if (r1.lowerDistanceSq <= r2.lowerDistanceSq) {\n      return r1;\n    } else {\n      return r2;\n    }\n  }\n  function bvhDistanceSq(bvh1, bvh2, bbcheckThreshold) {\n    var distLower = bvh1.bbox.distanceTo(bvh2.bbox);\n    var distLowerSq = distLower*distLower;\n    if (distLowerSq <= bbcheckThreshold + ZERO_TOLERANCE) {\n      if (bvh1.isLeaf) {\n        if (bvh2.isLeaf) {\n          return bvhTriDistanceSq(bvh1, bvh2);\n        } else {\n          var dist1 = bvhDistanceSq(bvh1, bvh2.left, bbcheckThreshold);\n          if (dist1.distanceSq <= checkDistSqMin) {\n            return dist1;\n          }\n          bbcheckThreshold = Math.min(dist1.distanceSq, bbcheckThreshold);\n          var dist2 = bvhDistanceSq(bvh1, bvh2.right, bbcheckThreshold);\n          if (dist2.distanceSq <= checkDistSqMin) {\n            return dist2;\n          }\n          return selectBetterResult(dist1,dist2);\n        }\n      } else {\n        if (bvh2.isLeaf) {\n          var dist1 = bvhDistanceSq(bvh1.left, bvh2, bbcheckThreshold);\n          if (dist1.distanceSq <= checkDistSqMin) {\n            return dist1;\n          }\n          bbcheckThreshold = Math.min(dist1.distanceSq, bbcheckThreshold);\n          var dist2 = bvhDistanceSq(bvh1.right, bvh2, bbcheckThreshold);\n          if (dist2.distanceSq <= checkDistSqMin) {\n            return dist2;\n          }\n          return selectBetterResult(dist1,dist2);\n        } else {\n          var dist1 = bvhDistanceSq(bvh1.left, bvh2.left, bbcheckThreshold);\n          if (dist1.distanceSq <= checkDistSqMin) {\n            return dist1;\n          }\n          bbcheckThreshold = Math.min(dist1.distanceSq, bbcheckThreshold);\n          var dist2 = bvhDistanceSq(bvh1.left, bvh2.right, bbcheckThreshold);\n          if (dist2.distanceSq <= checkDistSqMin) {\n            return dist2;\n          }\n          var d = selectBetterResult(dist1, dist2);\n          bbcheckThreshold = Math.min(d.distanceSq, bbcheckThreshold);\n          var dist3 = bvhDistanceSq(bvh1.right, bvh2.left, bbcheckThreshold);\n          if (dist3.distanceSq <= checkDistSqMin) {\n            return dist3;\n          }\n          d = selectBetterResult(d, dist3);\n          bbcheckThreshold = Math.min(d.distanceSq, bbcheckThreshold);\n          var dist4 = bvhDistanceSq(bvh1.right, bvh2.right, bbcheckThreshold);\n          if (dist4.distanceSq <= checkDistSqMin) {\n            return dist4;\n          }\n          return selectBetterResult(d,dist4);\n        }\n      }\n    } else {\n      return {\n        distanceSq: Infinity,\n        lowerDistanceSq: distLowerSq\n      };\n    }\n  }\n  var result = bvhDistanceSq(mesh1.bvh.root, mesh2.bvh.root, checkDistSqMax);\n  return result;\n}\n\nfunction MeshMeshDistanceSquared(mesh1, mesh2, opts) {\n  if (opts.profile) {\n    console.time('MeshMeshDistanceSquared');\n  }\n  var r = MeshMeshDistanceSquaredBVH(mesh1, mesh2, opts);\n  if (opts.profile) {\n    console.timeEnd('MeshMeshDistanceSquared');\n  }\n  return r;\n}\n\n/**\n * Computes the directed hausdorff distance\n * @param mesh1 {THREE.Mesh}\n * @param mesh2 {THREE.Mesh}\n * @param opts\n * @param opts.shortCircuit {{maxDistSq: number}} Options for shortcircuiting the full distance computation\n * @param opts.sampler {{sampleMeshes: function(Array<THREE.Mesh|geo.PartialMesh>, int)}} Sampler for sampling meshes\n * @param opts.nsamples {int}: Number of samples to produce\n * @param [opts.all] Whether all fields should be returned (otherwise, just return `distanceSq`).\n * @param [opts.debug] Whether to output extra debug messages\n * @returns {*}\n * @constructor\n */\nfunction MeshMeshHausdorffDirectedDistanceSquared(mesh1, mesh2, opts) {\n  var result;\n  var innerOpts = _.clone(opts);\n  innerOpts.shortCircuit = { minDistSq: 0 };\n  var done = false;\n  var savedPoint = new THREE.Vector3();\n  GeometryUtil.forMeshVertices(mesh1, function (v) {\n        var r = PointMeshDistanceSquared(v, mesh2, innerOpts);\n        if (!result || r.distanceSq > result.distanceSq) {\n          result = r;\n          innerOpts.shortCircuit.minDistSq = result.distanceSq;\n          if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n            if (result.distanceSq >= opts.shortCircuit.maxDistSq) {\n              result.lowerDistanceSq = result.distanceSq;\n              done = true;\n            }\n          }\n          if (opts.all) {\n            savedPoint.copy(result.closestPoint0);\n            result.closestPoint0 = savedPoint;\n          }\n        }\n      },\n      null, function() { return done; }\n  );\n  // Sample more points on surfaces to test\n  if (!done && opts.sampler && opts.nsamples) {\n    // Let's try to sample some points and check them\n    var samples = opts.sampler.sampleMeshes([mesh1], opts.nsamples);\n    samples = _.flatten(samples);\n    for (var i = 0; i < samples.length && !done; i++) {\n      var r = PointMeshDistanceSquared(samples[i].worldPoint, mesh2, innerOpts);\n      if (!result || r.distanceSq > result.distanceSq) {\n        result = r;\n        innerOpts.shortCircuit.minDistSq = result.distanceSq;\n        if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n          if (result.distanceSq >= opts.shortCircuit.maxDistSq) {\n            result.lowerDistanceSq = result.distanceSq;\n            done = true;\n          }\n        }\n        if (opts.all) {\n          savedPoint.copy(result.closestPoint0);\n          result.closestPoint0 = savedPoint;\n        }\n      }\n    }\n  }\n  if (result && opts.all) {\n    renameFields(result, [['closestPoint0', 'point0'], ['closestPoint1', 'point1'],\n      ['triangleBary', 'triangleBary1'],\n      ['closestFaceIndex', 'faceIndex1'], ['closestTriangle', 'triangle1']]);\n  }\n  return result;\n}\n\n/**\n * Computes the hausdorff distance\n * @param mesh1 {THREE.Mesh}\n * @param mesh2 {THREE.Mesh}\n * @param opts\n * @param opts.shortCircuit {{maxDistSq: number}} Options for shortcircuiting the full distance computation\n * @param opts.sampler {{sampleMeshes: function(Array<THREE.Mesh|geo.PartialMesh>, int)}} Sampler for sampling meshes\n * @param opts.nsamples {int}: Number of samples to produce\n * @param [opts.all] Whether all fields should be returned (otherwise, just return `distanceSq`).\n * @param [opts.debug] Whether to output extra debug messages\n * @returns {*}\n * @constructor\n */\nfunction MeshMeshHausdorffDistanceSquared(mesh1, mesh2, opts) {\n  var r1 = MeshMeshHausdorffDirectedDistanceSquared(mesh1, mesh2, opts);\n  var r2 = MeshMeshHausdorffDirectedDistanceSquared(mesh2, mesh1, opts);\n  if (r2.distanceSq > r1.distanceSq) {\n    swapFields(r2, [['point0', 'point1'], ['faceIndex0', 'faceIndex1'],\n      ['triangle0', 'triangle1'], ['triangleBary0', 'triangleBary1']]);\n    return r2;\n  } else {\n    return r1;\n  }\n}\n\nfunction PointMeshesDistanceSquared(point, meshes, opts) {\n  if (opts.profile) {\n    console.time('PointMeshesDistanceSquared');\n  }\n  var result;\n  var done = false;\n  for (var i = 0; i < meshes.length && !done; i++) {\n    var mesh = meshes[i];\n    if (result) {\n      // check if this mesh is worth comparing against\n      var bbox = Object3DUtil.getBoundingBox(mesh.mesh || mesh);\n      var distToBBox = bbox.distanceToPoint(point, 'clamped');\n      var distSqToBBox = distToBBox*distToBBox;\n      if (distToBBox > 0 && distSqToBBox > result.distanceSq) {\n        // mesh too far from point\n        // console.log('skipping mesh', i);\n        continue;\n      }\n    }\n    if (mesh instanceof THREE.Mesh) {\n      var r = PointMeshDistanceSquared(point, mesh, opts);\n      if (!result || r.distanceSq < result.distanceSq) {\n        result = r;\n        if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n          if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n            result.upperDistanceSq = result.distanceSq;\n            done = true;\n          }\n        }\n        if (opts.all) {\n          r.meshIndex = i;\n        }\n      }\n    } else if (mesh.mesh && mesh.faceIndices) {\n      var r = PointPartialMeshDistanceSquared(point, mesh.mesh, mesh.faceIndices, opts);\n      if (!result || r.distanceSq < result.distanceSq) {\n        result = r;\n        if (opts.shortCircuit && opts.shortCircuit.minDistSq != undefined) {\n          if (result.distanceSq <= opts.shortCircuit.minDistSq) {\n            result.upperDistanceSq = result.distanceSq;\n            done = true;\n          }\n        }\n        if (opts.all) {\n          r.meshIndex = i;\n        }\n      }\n    } else {\n      throw \"Unsupported mesh type\";\n    }\n  }\n  if (opts.profile) {\n    console.timeEnd('PointMeshesDistanceSquared');\n  }\n  return result;\n}\n\nfunction MeshesPointDistanceSquared(meshes, point, opts) {\n  var result = PointMeshesDistanceSquared(point, meshes, opts);\n  if (opts.all) {\n    swapFields(result, [['closestPoint0', 'closestPoint1']]);\n  }\n  return result;\n}\n\nfunction PointObject3DDistanceSquared(object3D, point, opts) {\n  var filter = opts? opts.filter : null;\n  var meshes = filter? Object3DUtil.getFilteredMeshList(object3D, filter) : Object3DUtil.getMeshList(object3D);\n  return PointMeshesDistanceSquared(point, meshes, opts);\n}\n\nfunction Object3DPointDistanceSquared(object3D, point, opts) {\n  var filter = opts? opts.filter : null;\n  var meshes = filter? Object3DUtil.getFilteredMeshList(object3D, filter) : Object3DUtil.getMeshList(object3D);\n  return MeshesPointDistanceSquared(meshes, point, opts);\n}\n\nfunction MeshesMeshesDistanceSquared(meshes1, meshes2, opts) {\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n  var copts = _.clone(opts || {});\n  copts.shortCircuit = copts.shortCircuit || {};\n  copts.shortCircuit.maxDistSq = checkDistSqMax;\n  var result;\n  for (var i = 0; i < meshes1.length; i++) {\n    var mesh1 = meshes1[i];\n    for (var j = 0; j < meshes2.length; j++) {\n      var mesh2 = meshes2[j];\n\n      var r = MeshMeshDistanceSquared(mesh1, mesh2, copts);\n      if (!result || r.distanceSq < result.distanceSq) {\n        result = r;\n        if (opts.all) {\n          result.meshIndex1 = i;\n          result.meshIndex2 = j;\n        }\n\n        if (result.distanceSq < checkDistSqMin) {\n          result.upperDistanceSq = result.distanceSq;\n          return result;\n        }\n        copts.shortCircuit.maxDistSq = Math.min(result.distanceSq, copts.shortCircuit.maxDistSq)\n      }\n    }\n  }\n}\n\n/**\n * Computes the directed hausdorff distance\n * @param meshes1 {Array<THREE.Mesh|geo.PartialMesh>}\n * @param meshes2 {Array<THREE.Mesh|geo.PartialMesh>}\n * @param opts\n * @param opts.shortCircuit {{maxDistSq: number}} Options for shortcircuiting the full distance computation\n * @param opts.sampler {{sampleMeshes: function(Array<THREE.Mesh|geo.PartialMesh>, int)}} Sampler for sampling meshes\n * @param opts.nsamples {int}: Number of samples to produce\n * @returns {*}\n * @constructor\n */\nfunction MeshesMeshesHausdorffDirectedDistanceSquared(meshes1, meshes2, opts) {\n  // TODO: Add more candidate points that is at the vertex of meshes1\n  console.time('MeshesMeshesHausdorffDirectedDistanceSquared');\n  var innerOpts = _.clone(opts);\n  innerOpts.shortCircuit = { minDistSq: 0 };\n  var result;\n  var tmpPoint = new THREE.Vector3();\n  var savedPoint = new THREE.Vector3();\n  var done = false;\n  for (var i = 0; i < meshes1.length && !done; i++) {\n    var mesh1 = meshes1[i];\n    if (mesh1 instanceof THREE.Mesh) {\n      GeometryUtil.forMeshVertices(mesh1, function (v) {\n            var r = PointMeshesDistanceSquared(v, meshes2, innerOpts);\n            if (!result || r.distanceSq > result.distanceSq) {\n              result = r;\n              innerOpts.shortCircuit.minDistSq = result.distanceSq;\n              if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n                if (result.distanceSq > opts.shortCircuit.maxDistSq) {\n                  result.lowerDistanceSq = result.distanceSq;\n                  done = true;\n                }\n              }\n              if (opts.all) {\n                savedPoint.copy(result.closestPoint0);\n                result.closestPoint0 = savedPoint;\n                result.meshIndex0 = i;\n              }\n            }\n          },\n          null, function() { return done; });\n    } else if (mesh1.mesh && mesh1.faceIndices) {\n      var transform = mesh1.mesh.matrixWorld;\n      var checkedIVerts = new Set();\n      for (var k = 0; k < mesh1.faceIndices.length && !done; k++) {\n        var iTri = mesh1.faceIndices[k];\n        var iVerts = GeometryUtil.getFaceVertexIndices(mesh1.mesh.geometry, iTri);\n        for (var j = 0; j < iVerts.length && !done; j++) {\n          var iVert = iVerts[j];\n          if (checkedIVerts.has(iVert)) {\n            continue;\n          }\n          checkedIVerts.add(iVert);\n          GeometryUtil.getGeometryVertex(mesh1.mesh.geometry, iVert, transform, tmpPoint);\n          // TODO: check vertices directly\n          // var vertCheck = findVertexInMeshes(meshes2, mesh1, iVert);\n          // _.defaults({ mesh: mesh1, iVert: iVert }, innerOpts);\n          // var tmp = _.filter(meshes2, function(x) { return x.mesh? x.mesh.uuid === mesh1.mesh.uuid : x.uuid === mesh1.mesh.uuid; });\n          // var compare = tmp.length? tmp : meshes2;\n          var r = PointMeshesDistanceSquared(tmpPoint, meshes2, innerOpts);\n          if (!result || r.distanceSq > result.distanceSq) {\n            result = r;\n            innerOpts.shortCircuit.minDistSq = result.distanceSq;\n            // TODO: better name  for short circuit distance\n            if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n              if (result.distanceSq > opts.shortCircuit.maxDistSq) {\n                result.lowerDistanceSq = result.distanceSq;\n                done = true;\n              }\n            }\n            if (opts.all) {\n              savedPoint.copy(result.closestPoint0);\n              result.closestPoint0 = savedPoint;\n              result.meshIndex0 = i;\n              result.faceIndex0 = iTri;\n            }\n          }\n        }\n      }\n    } else {\n      throw \"Unsupported mesh type\";\n    }\n  }\n  // Sample more points on surfaces to test\n  if (!done && opts.sampler && opts.nsamples) {\n    // Let's try to sample some points and check them\n    var samples = opts.sampler.sampleMeshes(meshes1, opts.nsamples);\n    samples = _.flatten(samples);\n    for (var i = 0; i < samples.length && !done; i++) {\n      var r = PointMeshesDistanceSquared(samples[i].worldPoint, meshes2, innerOpts);\n      if (!result || r.distanceSq > result.distanceSq) {\n        result = r;\n        innerOpts.shortCircuit.minDistSq = result.distanceSq;\n        if (opts.shortCircuit && opts.shortCircuit.maxDistSq != undefined) {\n          if (result.distanceSq >= opts.shortCircuit.maxDistSq) {\n            result.lowerDistanceSq = result.distanceSq;\n            done = true;\n          }\n        }\n        if (opts.all) {\n          savedPoint.copy(result.closestPoint0);\n          result.closestPoint0 = savedPoint;\n          result.meshIndex0 = samples[i].meshIndex;\n          result.faceIndex0 = samples[i].face;\n        }\n      }\n    }\n  }\n  if (result && opts.all) {\n    renameFields(result, [['closestPoint0', 'point0'], ['closestPoint1', 'point1'],\n      ['meshIndex', 'meshIndex1'], ['triangleBary', 'triangleBary1'],\n      ['closestFaceIndex', 'faceIndex1'], ['closestTriangle', 'triangle1']]);\n  }\n  console.timeEnd('MeshesMeshesHausdorffDirectedDistanceSquared');\n  return result;\n}\n\nfunction MeshesMeshesHausdorffDistanceSquared(meshes1, meshes2, opts) {\n  var r1 = MeshesMeshesHausdorffDirectedDistanceSquared(meshes1, meshes2, opts);\n  var r2 = MeshesMeshesHausdorffDirectedDistanceSquared(meshes2, meshes1, opts);\n  if (r2.distanceSq > r1.distanceSq) {\n    swapFields(r2, [['point0', 'point1'], ['meshIndex0', 'meshIndex1'], ['faceIndex0', 'faceIndex1'],\n      ['triangle0', 'triangle1'], ['triangleBary0', 'triangleBary1']]);\n    return r2;\n  } else {\n    return r1;\n  }\n}\n\nfunction Object3DObject3DMinDistanceSquaredSimple(obj1, obj2, opts) {\n  var meshes1 = Object3DUtil.getMeshList(obj1);\n  var meshes2 = Object3DUtil.getMeshList(obj2);\n  if (meshes1.length > 0 && meshes2.length > 0) {\n    return MeshesMeshesDistanceSquared(meshes1, meshes2, opts);\n  } else {\n    return { distanceSq: Infinity };\n  }\n}\n\nfunction MeshObject3DMinDistanceSquaredHelper(mesh, obj, opts) {\n  // console.log('check mesh object3d', mesh, obj);\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n\n  var bbox1 = Object3DUtil.getBoundingBox(mesh);\n  var bbox2 = Object3DUtil.getBoundingBox(obj);\n  var distLower = bbox1.distanceTo(bbox2);\n  var distLowerSq = distLower * distLower;\n\n  var result;\n  if (distLowerSq <= checkDistSqMax) {\n    if (obj instanceof THREE.Mesh) {\n      var r = MeshMeshDistanceSquared(mesh, obj, opts);\n      if (r && (!result || r.distanceSq < result.distanceSq)) {\n        result = r;\n        if (opts.all) {\n          result.meshId1 = mesh.id;\n          result.meshId2 = obj.id;\n        }\n        if (result.distanceSq < checkDistSqMin) {\n          result.upperDistanceSq = result.distanceSq;\n          return result;\n        }\n        opts.shortCircuit.maxDistSq = Math.min(result.distanceSq, opts.shortCircuit.maxDistSq);\n      }\n    }\n    for (var i = 0; i < obj.children.length; i++) {\n      var r = MeshObject3DMinDistanceSquaredHelper(mesh, obj.children[i], opts);\n      if (r && (!result || r.distanceSq < result.distanceSq)) {\n        result = r;\n\n        if (result.distanceSq < checkDistSqMin) {\n          result.upperDistanceSq = result.distanceSq;\n          return result;\n        }\n        opts.shortCircuit.maxDistSq = Math.min(result.distanceSq, opts.shortCircuit.maxDistSq);\n      }\n    }\n    return result;\n  } else {\n    return { distanceSq: Infinity,  lowerDistanceSq: distLowerSq };\n  }\n}\n\nfunction Object3DMeshMinDistanceSquaredHelper(obj, mesh, opts) {\n  // console.log('check object3d mesh', obj, mesh);\n  var r = MeshObject3DMinDistanceSquaredHelper(mesh, obj, opts);\n  if (r) {\n    swapFields(r, [['point0', 'point1'], ['meshId0', 'meshId1'], ['faceIndex0', 'faceIndex1'],\n      ['triangle0', 'triangle1'], ['triangleBary0', 'triangleBary1']]);\n  }\n  return r;\n}\n\nfunction MeshObject3DMinDistanceSquared(mesh, obj, opts) {\n  Object3DUtil.cacheWorldBoundingBoxes(obj);\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n  var copts = _.clone(opts || {});\n  copts.shortCircuit = copts.shortCircuit || {};\n  copts.shortCircuit.maxDistSq = checkDistSqMax;\n  copts.shortCircuit.minDistSq = checkDistSqMin;\n  return MeshObject3DMinDistanceSquaredHelper(mesh, obj, copts);\n}\n\nfunction Object3DMeshMinDistanceSquared(obj, mesh, opts) {\n  Object3DUtil.cacheWorldBoundingBoxes(obj);\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n  var copts = _.clone(opts || {});\n  copts.shortCircuit = copts.shortCircuit || {};\n  copts.shortCircuit.maxDistSq = checkDistSqMax;\n  copts.shortCircuit.minDistSq = checkDistSqMin;\n  return Object3DMeshMinDistanceSquaredHelper(obj, mesh, copts);\n}\n\n\nfunction Object3DObject3DMinDistanceSquaredHelper(obj1, obj2, opts) {\n  //console.log('check object3d object3d', obj1, obj2);\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n\n  var bbox1 = Object3DUtil.getBoundingBox(obj1);\n  var bbox2 = Object3DUtil.getBoundingBox(obj2);\n  var distLower = bbox1.distanceTo(bbox2);\n  var distLowerSq = distLower * distLower;\n\n  var result;\n  if (distLowerSq <= checkDistSqMax) {\n    if (obj1 instanceof THREE.Mesh) {\n      var r = MeshObject3DMinDistanceSquaredHelper(obj1, obj2, opts);\n      if (r && (!result || r.distanceSq < result.distanceSq)) {\n        result = r;\n\n        if (result.distanceSq < checkDistSqMin) {\n          result.upperDistanceSq = result.distanceSq;\n          return result;\n        }\n        opts.shortCircuit.maxDistSq = Math.min(result.distanceSq, opts.shortCircuit.maxDistSq);\n      }\n    } else if (obj2 instanceof THREE.Mesh) {\n      var r = Object3DMeshMinDistanceSquaredHelper(obj1, obj2, opts);\n      if (r && (!result || r.distanceSq < result.distanceSq)) {\n        result = r;\n\n        if (result.distanceSq < checkDistSqMin) {\n          result.upperDistanceSq = result.distanceSq;\n          return result;\n        }\n        opts.shortCircuit.maxDistSq = Math.min(result.distanceSq, opts.shortCircuit.maxDistSq);\n      }\n    }\n\n    // Check children\n    for (var i = 0; i < obj1.children.length; i++) {\n      for (var j = 0; j < obj2.children.length; j++) {\n        var r = Object3DObject3DMinDistanceSquaredHelper(obj1.children[i], obj2.children[j], opts);\n        if (r && (!result || r.distanceSq < result.distanceSq)) {\n          result = r;\n\n          if (result.distanceSq < checkDistSqMin) {\n            result.upperDistanceSq = result.distanceSq;\n            return result;\n          }\n          opts.shortCircuit.maxDistSq = Math.min(result.distanceSq, opts.shortCircuit.maxDistSq);\n        }\n      }\n    }\n    return result;\n  } else {\n    return { distanceSq: Infinity,  lowerDistanceSq: distLowerSq };\n  }\n}\n\nfunction Object3DObject3DMinDistanceSquared(obj1, obj2, opts) {\n  Object3DUtil.cacheWorldBoundingBoxes(obj1);\n  Object3DUtil.cacheWorldBoundingBoxes(obj2);\n  var checkDistSqMax = Infinity;\n  if (opts && opts.shortCircuit && opts.shortCircuit.maxDistSq) {\n    checkDistSqMax = opts.shortCircuit.maxDistSq;\n  }\n  var checkDistSqMin = ZERO_TOLERANCE;\n  if (opts && opts.shortCircuit && opts.shortCircuit.minDistSq) {\n    checkDistSqMin = opts.shortCircuit.minDistSq;\n  }\n  var copts = _.clone(opts || {});\n  copts.shortCircuit = copts.shortCircuit || {};\n  copts.shortCircuit.maxDistSq = checkDistSqMax;\n  copts.shortCircuit.minDistSq = checkDistSqMin;\n  return Object3DObject3DMinDistanceSquaredHelper(obj1, obj2, copts);\n}\n\nfunction BBoxBBoxDistanceSquared(bbox1, bbox2, opts) {\n  var dist = bbox1.distanceTo(bbox2);\n  return {\n    distanceSq: dist*dist\n  };\n}\n\nfunction ObbObbDistanceSquared(obb1, obb2, opts) {\n  var MeshHelpers = __webpack_require__(/*! geo/MeshHelpers */ \"./js/lib/geo/MeshHelpers.js\");\n  var mesh1 = new MeshHelpers.OBB(obb1, 'white');\n  var mesh2 = new MeshHelpers.OBB(obb2, 'white');\n  var dist = MeshMeshDistanceSquaredSimple(mesh1, mesh2, opts);\n  return dist;\n}\n\nvar distanceFnMapping = {\n  'BBox-BBox': BBoxBBoxDistanceSquared,\n  'OBB-OBB': ObbObbDistanceSquared,\n  'point-point': PointPointDistanceSquared,\n  'point-line': null,\n  'point-segment': null,\n  'point-triangle': PointTriangleDistanceSquared,\n  'point-mesh': PointMeshDistanceSquared,\n  'line-point': null,\n  'line-line': null,\n  'line-segment': LineSegmentDistanceSquared,\n  'line-triangle': LineTriangleDistanceSquared,\n  'line-mesh': null,\n  'segment-point': null,\n  'segment-line': SegmentLineDistanceSquared,\n  'segment-segment': null,\n  'segment-triangle': LineSegmentTriangleDistanceSquared,\n  'segment-mesh': null,\n  'triangle-point': TrianglePointDistanceSquared,\n  'triangle-line': TriangleLineDistanceSquared,\n  'triangle-segment': TriangleLineSegmentDistanceSquared,\n  'triangle-triangle': TriangleTriangleDistanceSquared,\n  'triangle-mesh': null,\n  'points-points': PointsPointsMinDistanceSquared,\n  'mesh-point': MeshPointDistanceSquared,\n  'mesh-line': null,\n  'mesh-segment': null,\n  'mesh-triangle': null,\n  'mesh-mesh': MeshMeshDistanceSquared,\n  'point-meshes': PointMeshesDistanceSquared,\n  'meshes-point': MeshesPointDistanceSquared,\n  'meshes-meshes': MeshesMeshesDistanceSquared,\n  'point-object3d': PointObject3DDistanceSquared,\n  'object3d-point': Object3DPointDistanceSquared,\n  'mesh-object3d': MeshObject3DMinDistanceSquared,\n  'object3d-mesh': Object3DMeshMinDistanceSquared,\n  'object3d-object3d': Object3DObject3DMinDistanceSquared\n};\n\nfunction computeDistance(object1, object2, opts) {\n  opts = opts || {};\n  function getType(obj) {\n    if (Array.isArray(obj)) {\n      var t = getType(obj[0]);\n      if (t.endsWith('sh') || t.endsWith('ch') || t.endsWith('s') || t.endsWith('x')) {\n        t = t + 'es';\n      } else {\n        t = t + 's';\n      }\n      return t;\n    }\n    if (obj instanceof THREE.Vector3) { return 'point'; }\n    if (obj instanceof THREE.Triangle) { return 'triangle'; }\n    if (obj instanceof THREE.Mesh) { return 'mesh'; }\n    if (obj instanceof THREE.Object3D) { return 'object3d'; }\n    if (obj.type) { return obj.type.toLowerCase(); }\n\n    var t = typeof obj;\n    if (t === 'object' && obj.constructor) {\n      return obj.constructor.name || t;\n    } else {\n      return t;\n    }\n  }\n  var type1 = getType(object1);\n  var type2 = getType(object2);\n  var fn = distanceFnMapping[type1 + '-' + type2];\n  if (fn) {\n    return fn(object1, object2, opts);\n  } else {\n    throw \"Unsupported distance computation \" + type1 + \" and \" + type2;\n  }\n}\n\nmodule.exports = {\n  PointPointDistanceSquared: PointPointDistanceSquared,\n  PointTriangleDistanceSquared: PointTriangleDistanceSquared,\n  PointMeshDistanceSquared: PointMeshDistanceSquared,\n  PointMeshesDistanceSquared: PointMeshesDistanceSquared,\n  LineSegmentDistanceSquared: LineSegmentDistanceSquared,\n  LineSegmentTriangleDistanceSquared: LineSegmentTriangleDistanceSquared,\n  LineTriangleDistanceSquared: LineTriangleDistanceSquared,\n  TriangleTriangleDistanceSquared: TriangleTriangleDistanceSquared,\n  // Hausdorff distance\n  PointsPointsHausdorffDirectedDistanceSquared: PointsPointsHausdorffDirectedDistanceSquared,\n  PointsPointsHausdorffDistanceSquared: PointsPointsHausdorffDistanceSquared,\n  MeshMeshHausdorffDirectedDistanceSquared: MeshMeshHausdorffDirectedDistanceSquared,\n  MeshMeshHausdorffDistanceSquared: MeshMeshHausdorffDistanceSquared,\n  MeshesMeshesHausdorffDirectedDistanceSquared: MeshesMeshesHausdorffDirectedDistanceSquared,\n  MeshesMeshesHausdorffDistanceSquared: MeshesMeshesHausdorffDistanceSquared,\n  // Generic compute distance\n  computeDistance: computeDistance\n};\n\n//# sourceURL=webpack://STK/./js/lib/geo/Distances.js?");

/***/ }),

/***/ "./js/lib/geo/GeometryUtil.js":
/*!************************************!*\
  !*** ./js/lib/geo/GeometryUtil.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// Patch THREE.Triangle with convenience function\nif (!_.isFunction(THREE.Triangle.prototype.getVertex)) {\n  THREE.Triangle.prototype.getVertex = function (i) {\n    if (i === 0) { return this.a; }\n    else if (i === 1) { return this.b; }\n    else if (i === 2) { return this.c; }\n  };\n}\n\n/**\n * Utility functions for geometry processing\n * @memberOf geo\n */\nvar GeometryUtil = {};\n\n// GeometryUtil.saveGeometryVertices = function (object3D) {\n//   // Save vertices away (used to compute bounding boxes)\n//   object3D.traverse(function (node) {\n//     if (node instanceof THREE.Mesh) {\n//       if (node.geometry instanceof THREE.BufferGeometry) {\n//         node.geometry.verticesArray = node.geometry.attributes['position'].array;\n//       }\n//     }\n//   });\n// };\n\nGeometryUtil.triangleNormal = (function () {\n  var edge1 = new THREE.Vector3();\n  var edge2 = new THREE.Vector3();\n  return function (va, vb, vc, normal) {\n    normal = normal || new THREE.Vector3();\n    edge1.subVectors(vb, va).normalize();\n    edge2.subVectors(vc, va).normalize();\n    normal.crossVectors(edge1, edge2).normalize();\n    return normal;\n  };\n}());\n\nGeometryUtil.triangleArea = (function () {\n  var vector1 = new THREE.Vector3();\n  var vector2 = new THREE.Vector3();\n  return function (va, vb, vc) {\n    vector1.subVectors(vb, va);\n    vector2.subVectors(vc, va);\n    vector1.cross(vector2);\n    return 0.5 * vector1.length();\n  };\n}());\n\nGeometryUtil.triangleAreaWithTransform = (function () {\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var v3 = new THREE.Vector3();\n  var vector1 = new THREE.Vector3();\n  var vector2 = new THREE.Vector3();\n  return function (va, vb, vc, transform) {\n    va = v1.copy(va).applyMatrix4(transform);\n    vb = v2.copy(vb).applyMatrix4(transform);\n    vc = v3.copy(vc).applyMatrix4(transform);\n    vector1.subVectors(vb, va);\n    vector2.subVectors(vc, va);\n    vector1.cross(vector2);\n    return 0.5 * vector1.length();\n  };\n}());\n\n/**\n * Colors vertices\n * @param geometry {THREE.Geometry|THREE.BufferGeometry} Geometry to color\n * @param color {THREE.Color} Color to given vertices\n * @param [vertices] {int[]} Array of vertex indices (all vertices are recolored if not specified)\n */\nGeometryUtil.colorVertices = function(geometry, color, vertices) {\n  if (geometry instanceof THREE.Geometry) {\n    if (vertices) {\n      console.error('colorVertices for a specific subset of vertices not supported for THREE.Geometry');\n    } else {\n      var nfaces = GeometryUtil.getGeometryFaceCount(geometry);\n      for (var i = 0; i < nfaces; i++) {\n        var face = geometry.faces[i];\n        face.vertexColors = [color, color, color];\n      }\n      geometry.colorsNeedUpdate = true;\n    }\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    var vcolors = geometry.attributes.color.array;\n    // A set\n    if (vertices) {\n      for (var v = 0; v < vertices.length; v++) {\n        var vi = vertices[v];\n        var i = vi*3;\n        vcolors[i] = color.r;\n        vcolors[i+1] = color.g;\n        vcolors[i+2] = color.b;\n      }\n    } else {\n      for (var i = 0; i < vcolors.length; i+=3) {\n        vcolors[i] = color.r;\n        vcolors[i+1] = color.g;\n        vcolors[i+2] = color.b;\n      }\n    }\n    geometry.attributes.color.needsUpdate = true;\n  } else {\n    console.error('colorVertices not supported for geometry', geometry);\n  }\n};\n\n/**\n * Grays out vertices that are maxRadius away from the center point\n * @param mesh {THREE.Mesh} Mesh to color (requires mesh.geometry be THREE.BufferGeometry)\n * @param center {THREE.Vector3} - Center point (not grayed out)\n * @param maxRadius {number} - Distance from center at which everything is grayed out\n * @param [grayColor=gray] {THREE.Color} Color to use for gray out\n */\nGeometryUtil.grayOutVertices = function(mesh, center, maxRadius, grayColor) {\n  if (!(mesh.geometry instanceof THREE.BufferGeometry)) {\n    console.error('grayOutVertices not supported if not BufferGeometry', mesh.geometry);\n    return;\n  }\n  if (grayColor == undefined) { grayColor = 'gray'; }\n  grayColor = Colors.toColor(grayColor);\n  var currColor = new THREE.Color();\n  var rSq = maxRadius*maxRadius;\n  var geometry = mesh.geometry;\n  var vcolors = geometry.attributes.color.array;\n  GeometryUtil.forMeshVertices(mesh, function(p, attributes) {\n    var distanceSq = center.distanceToSquared(p);\n    var grayRatio = _.clamp(distanceSq/rSq, 0, 1);\n    currColor.fromArray(attributes[0]);\n    var c = Colors.interpolateColor(currColor, grayColor, { weight: grayRatio });\n    var vi = attributes[1];\n    var i = vi*3;\n    vcolors[i] = c.r;\n    vcolors[i+1] = c.g;\n    vcolors[i+2] = c.b;\n  }, [{name: 'color', stride: 3}, {name: 'index'}]);\n  geometry.attributes.color.needsUpdate = true;\n};\n\nGeometryUtil.colorCylinderVertices = function(geometry, color1, color2) {\n  if (geometry instanceof THREE.Geometry) {\n    var nfaces = GeometryUtil.getGeometryFaceCount(geometry);\n    var verts = geometry.vertices;\n    for (var i = 0; i < nfaces; i++) {\n      var face = geometry.faces[i];\n      var ys = [verts[face.a].y, verts[face.b].y, verts[face.c].y];\n      face.vertexColors = ys.map(function(x) { return x < 0? color1 : color2; });\n    }\n    geometry.colorsNeedUpdate = true;\n  } else {\n    console.log('colorCylinderVertices not supported for geometry', geometry);\n  }\n};\n\nGeometryUtil.getGeometryVertexCount = function (geometry) {\n  var verts = geometry.vertices;\n  if (verts) {\n    return verts.length;\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    var pos = geometry.attributes['position'].array;\n    if (pos) {\n      return pos.length / 3;\n    } else {\n      console.warn('No vertices for BufferedGeometry');\n    }\n  } else {\n    //console.warn('No vertices for geometry');\n  }\n  return 0;\n};\n\nGeometryUtil.copyGeometryVertex = function (vertex, geometry, index) {\n  var verts = geometry.vertices;\n  if (verts) {\n    vertex.copy(verts[index]);\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    var pos = geometry.attributes['position'].array;\n    if (pos) {\n      var s = index * 3;\n      vertex.set(pos[s], pos[s + 1], pos[s + 2]);\n    } else {\n      console.warn('No vertices for BufferedGeometry');\n    }\n  } else {\n    //console.warn('No vertices for geometry');\n  }\n};\n\nGeometryUtil.getGeometryVertex = function (geometry, index, transform, out) {\n  var v = out || new THREE.Vector3();\n  GeometryUtil.copyGeometryVertex(v, geometry, index);\n  if (transform) {\n    v.applyMatrix4(transform);\n  }\n  return v;\n};\n\n// Convert vertices to world coordinates\nGeometryUtil.forMeshVertices = function (mesh, callback, attributes, checkExit) {\n  var transform = mesh.matrixWorld;\n  return GeometryUtil.forMeshVerticesWithTransform(mesh, callback, transform, attributes, checkExit);\n};\n\nGeometryUtil.forMeshVerticesWithTransform = function (mesh, callback, transform, attributes, checkExit) {\n  //Basic logic (rolled out for performance)\n  //var v = new THREE.Vector3();\n  //var nVerts = GeometryUtil.getGeometryVertexCount(mesh.geometry);\n  //for(var i=0; i<nVerts; i++) {\n  //   GeometryUtil.copyGeometryVertex(v, mesh.geometry, i);\n  //   v.applyMatrix4(mesh.matrixWorld);\n  //   callback(v);\n  //}\n\n  var v = new THREE.Vector3();\n  var normal = new THREE.Vector3();\n  var normalMatrix;\n  if (transform) {\n    normalMatrix = new THREE.Matrix3().getNormalMatrix(transform);\n  }\n\n  function getMaterialOrVertexColor(material, vc) {\n    // TODO: Figure out color here...\n    if (material.vertexColors === THREE.VertexColors && vc) {\n      return vc;\n    } else if (material.color) {\n      var v = material.color;\n      return [v.r, v.g, v.b];\n    } else {\n      return null;\n    }\n  }\n\n  var geometry = mesh.geometry;\n  //console.log(geometry);\n  if (geometry) {\n    var verts = geometry.vertices;\n    if (verts) {\n      for (var i = 0; i < verts.length; i++) {\n        v.copy(verts[i]);\n        if (transform) {\n          v.applyMatrix4(transform);\n        }\n        if (attributes) {\n          var values = [];\n          for (var j = 0; j < attributes.length; j++) {\n            var a = attributes[j];\n            var attrValue = null;\n            if (a.name === 'color') {\n              attrValue = getMaterialOrVertexColor(mesh.material, attrValue);\n            } else if (a.name === 'index') {\n              attrValue = i;\n            }\n            if (attrValue == undefined) {\n              if (mesh.userData.vertexAttributes && mesh.userData.vertexAttributes[a.name]) {\n                attrValue = mesh.userData.vertexAttributes[a.name][i];\n              }\n            }\n            if (attrValue == undefined) {\n              if (mesh.userData.attributes) {\n                attrValue = mesh.userData.attributes[a.name];\n              }\n            }\n            values.push(attrValue);\n          }\n          callback(v, values);\n        } else {\n          callback(v);\n        }\n        if (checkExit && checkExit()) {\n          break;\n        }\n      }\n    } else if (geometry instanceof THREE.BufferGeometry) {\n      var pos = geometry.attributes['position'].array;\n      if (pos) {\n        for (var s = 0, vi = 0; s < pos.length; s += 3, vi++) {\n          v.set(pos[s], pos[s + 1], pos[s + 2]);\n          if (transform) {\n            v.applyMatrix4(transform);\n          }\n          if (attributes) {\n            var values = [];\n            for (var j = 0; j < attributes.length; j++) {\n              var a = attributes[j];\n              var attr = geometry.attributes[a.name];\n              var attrValue = null;\n              if (attr) {\n                attrValue = attr.array.slice(vi * a.stride, (vi + 1) * a.stride);\n                if (a.name === 'normal' && transform) {  // apply rotation to normal\n                  var n = attrValue;\n                  normal.set(n[0], n[1], n[2]);\n                  normal.applyMatrix3(normalMatrix);\n                  normal.normalize();\n                  attrValue = [normal.x, normal.y, normal.z];\n                }\n              }\n              if (a.name === 'color') {\n                attrValue = getMaterialOrVertexColor(mesh.material, attrValue);\n              } else if (a.name === 'index') {\n                attrValue = vi;\n              }\n              if (attrValue == undefined) {\n                if (mesh.userData.vertexAttributes && mesh.userData.vertexAttributes[a.name]) {\n                  attrValue = mesh.userData.vertexAttributes[a.name][vi];\n                }\n              }\n              if (attrValue == undefined) {\n                if (mesh.userData.attributes) {\n                  attrValue = mesh.userData.attributes[a.name];\n                }\n              }\n              values.push(attrValue);\n            }\n            callback(v, values);\n          } else {\n            callback(v);\n          }\n          if (checkExit && checkExit()) {\n            break;\n          }\n        }\n      } else {\n        console.warn('No vertices for BufferedGeometry');\n      }\n    } else {\n      //console.warn('No vertices for geometry');\n    }\n  }\n};\n\nGeometryUtil.forFaceVerticesWithTransform = function (geometry, transform, callback) {\n  GeometryUtil.forFaceVertexIndices(geometry, function (iFace, vIndices) {\n    var v0 = GeometryUtil.getGeometryVertex(geometry, vIndices[0], transform);\n    var v1 = GeometryUtil.getGeometryVertex(geometry, vIndices[1], transform);\n    var v2 = GeometryUtil.getGeometryVertex(geometry, vIndices[2], transform);\n    callback(v0, v1, v2, iFace);\n  });\n};\n\nGeometryUtil.getVertices = function (root, verts) {\n  var result = verts || [];\n  root.updateMatrixWorld();\n  if (root instanceof THREE.Mesh || root instanceof THREE.Line) {\n    GeometryUtil.forMeshVertices(root, function (v) {\n      result.push(v.clone());\n    });\n  }\n  if (root.children) {\n    for (var i = 0; i < root.children.length; i++) {\n      GeometryUtil.getVertices(root.children[i], result);\n    }\n  }\n  return result;\n};\n\nGeometryUtil.getGeometryFaceCount = function (geometry) {\n  var faces = geometry.faces;\n  if (faces) {\n    return faces.length;\n  } else {\n    // No faces - assume triangles, divide number of vertices by 3\n    var nVerts = GeometryUtil.getGeometryVertexCount(geometry);\n    // Get actual number of vertices (indices)\n    if (geometry.indices) {\n      nVerts = geometry.indices.length;\n    } else if (geometry instanceof THREE.BufferGeometry && geometry.index) {\n      nVerts = geometry.index.array.length;\n     }\n    return nVerts / 3;\n  }\n};\n\nGeometryUtil.getMaterialGroups = function(geometry) {\n  if (geometry.groups) {\n    return geometry.groups;\n  } else if (geometry instanceof THREE.Geometry) {\n    var groups = [];\n    for (var i = 0; i < geometry.faces.length; i++) {\n      var materialIndex = geometry.faces[i].materialIndex;\n      groups[materialIndex] = groups[materialIndex] || { count: 0, materialIndex: materialIndex };\n      groups[materialIndex].count+=3;\n    }\n    return groups;\n  } else {\n    return null;\n  }\n};\n\n// TODO: dedup with triangleNormal\nGeometryUtil.computeFaceNormal = function (vA, vB, vC) {\n  var cb = new THREE.Vector3(), ab = new THREE.Vector3();\n  cb.subVectors( vC, vB );\n  ab.subVectors( vA, vB );\n  cb.cross( ab );\n  cb.normalize();\n  return cb;\n};\n\nGeometryUtil.getSurfaceArea = function (geometry, transform) {\n  var area = 0;\n  GeometryUtil.forFaceVerticesWithTransform(geometry, transform, function (v0, v1, v2, iFace) {\n    area += GeometryUtil.triangleArea(v0, v1, v2);\n  });\n  return area;\n};\n\nGeometryUtil.getSurfaceAreaFiltered = function (geometry, transform, filter) {\n  var area = 0;\n  GeometryUtil.forFaceVerticesWithTransform(geometry, transform, function (v0, v1, v2, iFace) {\n    if (!filter || filter(v0, v1, v2, iFace)) {\n      area += GeometryUtil.triangleArea(v0, v1, v2);\n    }\n  });\n  return area;\n};\n\nGeometryUtil.getFaceMaterialIndex = function (geometry, iface) {\n  // Assumes faces are basically triangles\n  if (geometry.faces) {\n    return geometry.faces[iface].materialIndex;\n  } else if (geometry.groups) {\n    var iv = iface*3;\n    var group = _.find(geometry.groups, function (g) {\n      return (iv >= g.start) && (iv < g.start + g.count);\n    });\n    return group? group.materialIndex : 0;\n  } else {\n    return 0;\n  }\n};\n\nGeometryUtil.getFaceVertexIndices = function (geometry, iface) {\n  // Assumes faces are basically triangles\n  var faces = geometry.faces;\n  if (faces) {\n    var face = faces[iface];\n    if (face instanceof THREE.Face3) {\n      return [face.a, face.b, face.c];\n    } else if (face instanceof THREE.Face4) {\n      return [face.a, face.b, face.c, face.d];\n    }\n  } else if (geometry.indices) {\n    var j = iface*3;\n    var indices = geometry.indices;\n    return [indices[j], indices[j + 1], indices[j + 2]];\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    if (geometry.index) {\n      var j = iface*3;\n      var indices = geometry.index.array;\n      return [indices[j], indices[j + 1], indices[j + 2]];\n    } else if (geometry.attributes['position']) {\n      var j = iface * 3;\n      return [j, j + 1, j + 2];\n    }\n  }\n};\n\nGeometryUtil.forFaceVertexIndices = function (geometry, callback) {\n  // Assumes faces are basically triangles\n  var nfaces = GeometryUtil.getGeometryFaceCount(geometry);\n  if (nfaces == 0) {\n    console.warn('No faces found for geometry', geometry);\n    return;\n  }\n  var faces = geometry.faces;\n  if (faces) {\n    for (var i = 0; i < nfaces; i++) {\n      var face = faces[i];\n      if (face instanceof THREE.Face3) {\n        callback(i, [face.a, face.b, face.c]);\n      } else if (face instanceof THREE.Face4) {\n        callback(i, [face.a, face.b, face.c, face.d]);\n      }\n    }\n  } else if (geometry.indices) {\n    var indices = geometry.indices;\n    for (var i=0, j=0; i < nfaces; i++, j+=3) {\n      callback(i, [indices[j], indices[j + 1], indices[j + 2]]);\n    }\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    if (geometry.index) {\n      var indices = geometry.index.array;\n      for (var i=0, j=0; i < nfaces; i++, j+=3) {\n        callback(i, [indices[j], indices[j + 1], indices[j + 2]]);\n      }\n    } else if (geometry.attributes['position']) {\n      for (var i=0, j=0; i < nfaces; i++, j+=3) {\n        callback(i, [j, j+1, j+2]);\n      }\n    }\n  }\n};\n// Utility functions\nfunction createCropped(arrayType, nVerts, croppedToOrigIndex, origArray, stride) {\n  var attrs = new arrayType(nVerts * stride);\n  // Crops all entries unrelated to cropped\n  var k = 0;\n  for (var vi = 0; vi < nVerts; vi++) {\n    var ovi = croppedToOrigIndex[vi];\n    var start = stride * ovi;\n    for (var j = 0; j < stride; j++) {\n      if (start + j >= origArray.length) {\n        console.warn('Invalid access of index at ' + (start+j));\n      }\n      attrs[k] = origArray[start + j];\n      k++;\n    }\n  }\n  return attrs;\n}\n\nfunction createCroppedFloat32(nVerts, croppedToOrigIndex, origArray, itemSize) {\n  var attrs = createCropped(Float32Array, nVerts, croppedToOrigIndex, origArray, itemSize);\n  return new THREE.BufferAttribute(attrs, itemSize);\n}\n\nfunction buildIndexMap(triIndices, origVertIndices) {\n  // build up map of cropped vertex index to original vertex index and vs\n  var nCropped = 0;\n  var croppedToOrig = {}; //new Uint32Array(triIndices.length*3);\n  var origToCropped = {}; //new Uint32Array(origVertIndices.length);\n  for (var i in triIndices) {\n    if (triIndices.hasOwnProperty(i)) {\n      var s = triIndices[i]*3;\n      for (var j = 0; j < 3; j++) {\n        var ovi = origVertIndices ? origVertIndices[s + j] : (s + j);\n        if (origToCropped[ovi] == undefined) {\n          origToCropped[ovi] = nCropped;\n          croppedToOrig[nCropped] = ovi;\n          nCropped++;\n        }\n      }\n    }\n  }\n  return {croppedToOrig: croppedToOrig, origToCropped: origToCropped, nCropped: nCropped};\n}\n\nfunction createCroppedIndexBuffer(triIndices, origVertIndices, map) {\n  // Allocate\n  var itemSize = 1;\n  var nVerts = map.nCropped;\n  var indexSize = triIndices.length * 3 * itemSize;\n  var index = (nVerts < 65536) ?\n      new Uint16Array(indexSize) : new Uint32Array(indexSize);\n  // Populate\n  var origToCroppedIndex = map.origToCropped;\n  var k = 0;\n  for (var i in triIndices) {\n    if (triIndices.hasOwnProperty(i)) {\n      var s = triIndices[i]*3;\n      for (var j = 0; j < 3; j++) {\n        var ovi = origVertIndices ? origVertIndices[s + j] : (s + j);\n        index[k] = origToCroppedIndex[ovi];\n        k++;\n      }\n    }\n  }\n  return new THREE.BufferAttribute(index, itemSize);\n}\n\nGeometryUtil.extractMesh = function (mesh, triIndices, keepMaterialGroups) {\n  triIndices = _.sortBy(triIndices, x => x);\n  //console.log('extractMesh ' + mesh.name + ' with ' + triIndices.length + ' triangles')\n  //console.time('extractMesh');\n  // Remesh with specific triangles\n  var origGeom = mesh.__bufferGeometry || GeometryUtil.toBufferGeometry(mesh.geometry);\n  mesh.__bufferGeometry = origGeom;\n  var myGeometry = new THREE.BufferGeometry();\n  myGeometry.dynamic = origGeom.dynamic;\n\n  // Set attributes for the new geometry to only include\n  // triangles from surface.triIndex\n  var origAttrs = origGeom.attributes;\n  // If undefined, index is consecutive\n  var origIndexArray = (origGeom.index) ? origGeom.index.array : undefined;\n\n  //console.time('buildIndexMap');\n  var indexMap = buildIndexMap(triIndices, origIndexArray);\n  //console.timeEnd('buildIndexMap');\n  myGeometry.setIndex(createCroppedIndexBuffer(triIndices, origIndexArray, indexMap));\n  var attrs = [\n    { name: 'position', size: 3 },\n    { name: 'normal', size: 3 },\n    { name: 'uv', size: 2 },\n    { name: 'uv2', size: 2 },\n    { name: 'color', size: 3 }\n  ];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (origAttrs[attr.name]) {\n      myGeometry.setAttribute(attr.name, createCroppedFloat32(\n        indexMap.nCropped, indexMap.croppedToOrig,\n        origAttrs[attr.name].array, attr.size));\n    }\n  }\n\n  // Set non-attributes for new geometry\n  var newIndexLength = myGeometry.index.array.length;\n  var myMaterial = null;\n  //console.log('keepMaterialGroups', keepMaterialGroups);\n  if (keepMaterialGroups && origGeom.groups.length > 1) {\n    var groups = _.cloneDeep(origGeom.groups);\n    //console.log('groups1', groups);\n    _.forEach(groups, function(g) { g.count = 0; });\n    for (var i = 0; i < triIndices.length; i++) {\n      var iv = triIndices[i]*3;\n      var gi = origGeom.groups.findIndex(function (g) {\n        return (iv >= g.start) && (iv < g.start + g.count);\n      });\n      if (gi < 0) {\n        gi = 0;\n      }\n      groups[gi].count+=3;\n    }\n    var hasExtraMaterials = false;\n    var start = 0;\n    for (var i = 0; i < groups.length; i++) {\n      var group = groups[i];\n      group.start = start;\n      start += group.count;\n      if (group.count === 0) {\n        hasExtraMaterials = true;\n      }\n    }\n\n    if (hasExtraMaterials) {\n      // Trim extra materials\n      var trimmedGroups = [];\n      var materials = [];\n      var origMaterial  = (mesh.material instanceof THREE.MultiMaterial)?\n        mesh.material.materials : mesh.material;\n      for (var i = 0; i < groups.length; i++) {\n        var group = groups[i];\n        if (group.count > 0) {\n          group.materialIndex = materials.length;\n          trimmedGroups.push(group);\n          if (Array.isArray(origMaterial)) {\n            materials.push(origMaterial[i]);\n          } else {\n            materials.push(origMaterial);\n          }\n        }\n      }\n      groups = trimmedGroups;\n      myMaterial = new THREE.MultiMaterial(materials);\n      //console.log('Trimmed materials')\n    }\n\n    myGeometry.groups = groups;\n    //console.log('groups2', groups);\n  } else {\n    myGeometry.groups[0] = {start: 0, count: newIndexLength, materialIndex: 0};   //very important!\n  }\n  //myGeometry.verticesArray = myGeometry.attributes['position'].array;\n  myGeometry.computeBoundingSphere();\n\n  // Make new mesh\n  var myMesh = mesh.clone();\n  myMesh.geometry = myGeometry;\n  if (myMaterial) {\n    myMesh.material = myMaterial;\n  }\n  //console.timeEnd('extractMesh');\n  return myMesh;\n};\n\nGeometryUtil.vertIndicesToTriIndices = function (mesh, vertIndices) {\n  // NOTE: maybe buggy...\n  // Make vertIndices to be a set\n  var vertIndicesSet = {};\n  for (var i = 0; i < vertIndices.length; i++) {\n    vertIndicesSet[vertIndices[i]] = 1;\n  }\n\n  function vertIncludes(a, b, c) {\n    return vertIndicesSet[a] || vertIndicesSet[b] || vertIndicesSet[c];\n  }\n\n  // Convert from vertIndices to triIndices\n  var triIndices = [];\n\n  // Get triangle indices\n  var origGeom = mesh.geometry;\n  if (origGeom instanceof THREE.BufferGeometry) {\n    var indexArray = (origGeom.index) ? origGeom.index.array : undefined;\n    if (indexArray) {\n      var nTris = 0;\n      for (var i = 0; i < indexArray.length; i += 3) {\n        // Check if all indices are in our vertIndices, if so add triIndex\n        if (vertIncludes(indexArray[i], indexArray[i + 1], indexArray[i + 2])) {\n          triIndices.push(nTris);\n        }\n        nTris++;\n      }\n    } else {\n      var nVerts = GeometryUtil.getGeometryVertexCount(origGeom);\n      var nTris = 0;\n      for (var i = 0; i < nVerts; i += 3) {\n        // Check if all indices are in our vertIndices, if so add triIndex\n        if (vertIncludes(i, i + 1, i + 2)) {\n          triIndices.push(nTris);\n        }\n        nTris++;\n      }\n    }\n  } else {\n    for (var nTri = 0; nTri < origGeom.faces.length; nTri++) {\n      var tri = origGeom.faces[nTri];\n      if (vertIncludes(tri.a, tri.b, tri.c)) {\n        triIndices.push(nTri);\n      }\n    }\n  }\n  //console.log(vertIndices);\n  //console.log(triIndices);\n  return triIndices;\n};\n\nGeometryUtil.extractMeshVertIndices = function (mesh, vertIndices, keepMaterialGroups) {\n  var triIndices = GeometryUtil.vertIndicesToTriIndices(mesh, vertIndices);\n  var extracted = GeometryUtil.extractMesh(mesh, triIndices, keepMaterialGroups);\n  return extracted;\n};\n\n// Convert segToVertIndices to segToTriIndices\nGeometryUtil.segVertIndicesToSegTriIndices = function (mesh, vertToSegIndices) {\n  // NOTE: maybe buggy...\n  // Convert from vertIndices to triIndices\n  var segToTriIndices = [];\n\n  function add(iTri, a) {\n    var iSeg = vertToSegIndices[a];\n    if (iSeg != undefined) {\n      if (!segToTriIndices[iSeg]) {\n        segToTriIndices[iSeg] = [iTri];\n      } else {\n        segToTriIndices[iSeg].push(iTri);\n      }\n    }\n  }\n\n  function addTri(iTri, a, b, c) {\n    add(iTri, a);\n    add(iTri, b);\n    add(iTri, c);\n  }\n\n  // Get triangle indices\n  var origGeom = mesh.geometry;\n  if (origGeom instanceof THREE.BufferGeometry) {\n    var indexArray = (origGeom.index) ? origGeom.index.array : undefined;\n    if (indexArray) {\n      var nTris = 0;\n      for (var i = 0; i < indexArray.length; i += 3) {\n        // Check if all indices are in our vertIndices, if so add triIndex\n        addTri(nTris, indexArray[i], indexArray[i + 1], indexArray[i + 2]);\n        nTris++;\n      }\n    } else {\n      var nVerts = GeometryUtil.getGeometryVertexCount(origGeom);\n      var nTris = 0;\n      for (var i = 0; i < nVerts; i += 3) {\n        // Check if all indices are in our vertIndices, if so add triIndex\n        addTri(nTris, i, i+1, i+2);\n        nTris++;\n      }\n    }\n  } else {\n    for (var nTri = 0; nTri < origGeom.faces.length; nTri++) {\n      var tri = origGeom.faces[nTri];\n      addTri(nTri, tri.a, tri.b, tri.c);\n    }\n  }\n  for (var i in segToTriIndices) {\n    if (segToTriIndices.hasOwnProperty(i)) {\n      segToTriIndices[i] = _.uniq(segToTriIndices[i]);\n    }\n  }\n  return segToTriIndices;\n};\n\nGeometryUtil.extractParts = function(geometry, segmentation, parts) {\n  var partSegmentation = _.find(segmentation.segmentation, function(x) { return x.name === parts.name; });\n  var partIndices = new Set();\n  if (parts.indices) {\n    for (var i = 0; i < parts.indices.length; i++) {\n      partIndices.add(parts.indices[i]);\n    }\n  } else if (parts.labels) {\n    for (var i = 0; i < partSegmentation.labels.length; i++) {\n      var label = partSegmentation.labels[i];\n      var li = parts.labels.indexOf(label);\n      //console.log('label', label, i);\n      if (li >= 0) {\n        partIndices.add(i);\n      }\n    }\n  }\n  var elementOffset = parts.elementOffset || 0;\n\n  var extracted = new THREE.Geometry();\n  extracted.name = geometry.name;\n  var vertexRemap = {};\n  function getVertex(vi) {\n    var vj = vertexRemap[vi];\n    if (vj == undefined) {\n      vj = extracted.vertices.length;\n      extracted.vertices.push(geometry.vertices[vi]);\n      vertexRemap[vi] = vj;\n    }\n    return vj;\n  }\n\n  var nuvs = geometry.faceVertexUvs? geometry.faceVertexUvs.length : 0;\n  for (var i = 0; i < partSegmentation.index.length; i++) {\n    var partIndex = partSegmentation.index[i];\n    if (partIndices.has(partIndex)) {\n      var iFace = elementOffset + i;\n      var face = geometry.faces[iFace].clone();\n      face.a = getVertex(face.a);\n      face.b = getVertex(face.b);\n      face.c = getVertex(face.c);\n      extracted.faces.push(face);\n      //console.log('material', face.materialIndex, partIndex, partSegmentation.labels[partIndex]);\n      for (var j = 0; j < nuvs; j++) {\n        extracted.faceVertexUvs[j].push(geometry.faceVertexUvs[j][iFace]);\n      }\n    }\n  }\n  return extracted;\n};\n\nGeometryUtil.getMaterials = function(material) {\n  var materials;\n  if (material instanceof THREE.MultiMaterial) {\n    materials = material.materials;\n  } else if (_.isArray(material)) {\n    materials = material;\n  } else {\n    materials = [material];\n  }\n  return materials;\n};\n\nGeometryUtil.splitByMaterial = function(mesh, opts) {\n  opts = opts || {};\n  var geometry = mesh.geometry;\n  var materials = GeometryUtil.getMaterials(mesh.material);\n\n  function createSplitMesh(mesh, faceIndices, i) {\n    var newMesh = GeometryUtil.extractMesh(mesh, faceIndices, true);\n    if (mesh.userData.sceneGraphPath) {\n      newMesh.userData.sceneGraphPath = mesh.userData.sceneGraphPath + '/material[' + i + ']';\n    }\n    newMesh.name = mesh.name + '/material_' + i;\n    newMesh.userData.splitInfo = _.clone(mesh.userData.splitInfo || []);\n    newMesh.userData.splitInfo.push({ type: 'byMaterial', meshId: mesh.userData.id, materialIndex: i });\n    return newMesh;\n  }\n\n  //console.log('splitByMaterial ' + mesh.name);\n  //console.time('splitByMaterial');\n  if (materials.length > 1) {\n    var splitInfos = [];\n    if (geometry.faces) {\n      for (var i = 0; i < materials.length; i++) {\n        //console.log('processing material ' + (i+1) + '/' + materials.length);\n        var triIndices = [];\n        for (var iface = 0; iface < geometry.faces.length; iface++) {\n          if (geometry.faces[iface].materialIndex === i) {\n            triIndices.push(iface);\n          }\n        }\n        splitInfos.push({ triIndices: triIndices, materialIndex: i });\n      }\n    } else {\n      for (var i = 0; i < geometry.groups.length; i++) {\n        //console.log('processing material ' + (i+1) + '/' + geometry.groups.length);\n        var group = geometry.groups[i];\n        var triIndices = (group && group.count)?\n          _.range(group.start/3, group.start/3 + group.count/3) : [];\n        splitInfos.push({ triIndices: triIndices, materialIndex: i });\n      }\n    }\n\n    if (opts.keepDoubleFacesTogether) {\n      var sorted = _.sortBy(splitInfos, function(info) { return info.triIndices.length; });\n      var ConnectivityGraph = __webpack_require__(/*! geo/ConnectivityGraph2 */ \"./js/lib/geo/ConnectivityGraph2.js\");\n      var connectivityGraph = new ConnectivityGraph(mesh.geometry, true);\n      var reverseFaceMappings = connectivityGraph.getReverseFaceMappings(true);\n      var faceToGroupMapping = [];\n      for (var i=0; i < sorted.length; i++) {\n        var splitInfo = sorted[i];\n        //console.log('Initially got ' + splitInfo.triIndices.length + ' for material ' + (splitInfo.materialIndex+1));\n        for (var j=0; j < splitInfo.triIndices.length; j++) {\n          faceToGroupMapping[splitInfo.triIndices[j]] = i;\n        }\n      }\n      for (var i = 0; i < sorted.length; i++) {\n        var splitInfo = sorted[i];\n        var addToSplit = [];\n        for (var j = 0; j < splitInfo.triIndices.length; j++) {\n          var ti = splitInfo.triIndices[j];\n          var reverseFaces = reverseFaceMappings[ti];\n          if (reverseFaces) {\n            for (var k = 0; k < reverseFaces.length; k++) {\n              var rfi = reverseFaces[k];\n              var rfiGroup = faceToGroupMapping[rfi];\n              if (rfiGroup > i) {\n                addToSplit.push(rfi);\n                _.pull(sorted[rfiGroup].triIndices, rfi);\n              }\n            }\n          }\n        }\n        if (addToSplit.length > 0) {\n          //console.log('adding', addToSplit.length, splitInfo.triIndices.length);\n          splitInfo.triIndices.push(...addToSplit);\n          splitInfo.triIndices = _.uniq(splitInfo.triIndices);\n          //console.log('got', splitInfo.triIndices.length);\n        }\n      }\n    }\n\n    var splitNodes = [];\n    for (var i=0; i < splitInfos.length; i++) {\n      var splitInfo = splitInfos[i];\n      var mi = splitInfo.materialIndex;\n      //console.log('Got ' + splitInfo.triIndices.length + ' for material ' + (mi+1));\n      if (splitInfo.triIndices.length > 0) {\n        var newMesh = createSplitMesh(mesh,  splitInfo.triIndices, mi);\n        //console.log('extracted vertices ' + newMesh.geometry.index.array.length + ' for material ' + (mi+1));\n        splitNodes.push(newMesh);\n      } else if (!opts.validOnly) {\n        splitNodes.push(null);\n      }\n    }\n\n    //console.timeEnd('splitByMaterial');\n    return splitNodes;\n  } else {\n    //console.timeEnd('splitByMaterial');\n    return [mesh];\n  }\n};\n\nGeometryUtil.splitByConnectivity = function(mesh, opts) {\n  opts = opts || {};\n\n  function createSplitMesh(mesh, faceIndices, i) {\n    var newMesh = GeometryUtil.extractMesh(mesh, faceIndices, true);\n    if (mesh.userData.sceneGraphPath) {\n      newMesh.userData.sceneGraphPath = mesh.userData.sceneGraphPath + '/component[' + i + ']';\n    }\n    newMesh.name = mesh.name + '/component_' + i;\n    newMesh.userData.splitInfo = _.clone(mesh.userData.splitInfo || []);\n    newMesh.userData.splitInfo.push({ type: 'byConnectivity', meshId: mesh.userData.id });\n    return newMesh;\n  }\n\n  var MeshSegmentator = __webpack_require__(/*! geo/MeshSegmentator */ \"./js/lib/geo/MeshSegmentator.js\");\n  var meshSegmentator = new MeshSegmentator();\n  var segmentedList = meshSegmentator.segmentByConnectivity(mesh, {});\n  if (segmentedList.length > 1) {\n    var splitNodes = [];\n    for (var i = 0; i < segmentedList.length; i++) {\n      var segmented = segmentedList[i];\n      if (segmented.faceIndices.length > 0) {\n        var newMesh = createSplitMesh(segmented.mesh, segmented.faceIndices, i);\n        splitNodes.push(newMesh);\n      } else if (!opts.validOnly) {\n        splitNodes.push(null);\n      }\n    }\n    return splitNodes;\n  } else {\n    return [mesh];\n  }\n};\n\nGeometryUtil.mergeMeshes = function (input) {\n  if (input instanceof THREE.Mesh) {\n    return input;\n  } else if (input instanceof THREE.Object3D) {\n    return GeometryUtil.mergeMeshes(input.children);\n  } else if (Array.isArray(input)) {\n    if (input.length > 1) {\n      var mergedGeometry = new THREE.Geometry();\n      var meshFaceMaterials = [];\n      for (var i = 0; i < input.length; i++) {\n        var mesh = GeometryUtil.mergeMeshes(input[i]);\n        if (mesh instanceof THREE.Mesh) {\n          var materials = GeometryUtil.getMaterials(mesh.material);\n          var materialIndex = meshFaceMaterials.length;\n          var geom = GeometryUtil.toGeometry(mesh.geometry);\n          mergedGeometry.merge(geom, mesh.matrix, materialIndex);\n          for (var j = 0; j < materials.length; j++) {\n            meshFaceMaterials.push(materials[j]);\n          }\n        }\n      }\n      return new THREE.Mesh(mergedGeometry, new THREE.MultiMaterial(meshFaceMaterials));\n    } else {\n      return GeometryUtil.mergeMeshes(input[0]);\n    }\n  } else {\n    console.warn('Cannot merge meshes for input');\n    console.log(input);\n  }\n};\n\n// TODO: Improved merge meshes (WIP, not yet working)\nGeometryUtil.mergeMeshesWithTransform = function (input, opts) {\n  opts = opts || {};\n  var transform = opts.transform;\n  if (!transform && !opts.clone) {\n    if (input instanceof THREE.Mesh) {\n      return input;\n    } else if (Array.isArray(input) && input.length === 1 && input[0] instanceof THREE.Mesh) {\n      return input[0];\n    }\n  }\n\n  var toMerge = input;\n  if (!Array.isArray(input)) {\n    toMerge = [input];\n  }\n  var mergedGeometry = new THREE.Geometry();\n  var meshFaceMaterials = [];\n  //console.log('merging ', toMerge.length);\n  for (var i = 0; i < toMerge.length; i++) {\n    var m = toMerge[i];\n    m.updateMatrixWorld();\n    m.traverse(function(node) {\n      if (node instanceof THREE.Mesh) {\n        var materialIndex = meshFaceMaterials.length;\n        var geom = GeometryUtil.toGeometry(node.geometry);\n        var t = node.matrixWorld;\n        if (transform) {\n          t = node.transform.clone();\n          t.multiply(node.matrixWorld);\n        }\n        mergedGeometry.merge(geom, t, materialIndex);\n        if (Array.isArray(node.material)) {\n          for (var j = 0; j < node.material.length; j++) {\n            meshFaceMaterials.push(node.material[j]);\n          }\n        } else if (node.material instanceof THREE.MultiMaterial) {\n          for (var j = 0; j < node.material.materials.length; j++) {\n            meshFaceMaterials.push(node.material.materials[j]);\n          }\n        } else {\n          meshFaceMaterials.push(node.material);\n        }\n      }\n    });\n  }\n  //console.log('merged mesh', mergedGeometry, meshFaceMaterials);\n  return new THREE.Mesh(mergedGeometry, new THREE.MultiMaterial(meshFaceMaterials));\n};\n\n// Flattens and merged nested objects into one mesh\nGeometryUtil.flattenAndMergeMeshes = function (node) {\n  var newNode = GeometryUtil.flatten(node);\n  return GeometryUtil.mergeMeshes(newNode);\n};\n\n// Flattens nested objects into one layer of children with transforms\nGeometryUtil.flatten = function (node, result) {\n  var newNode = node.clone(result, false);\n  GeometryUtil.__flatten(newNode, node, node.matrix);\n  newNode.rotation.set(0, 0, 0);\n  newNode.position.set(0, 0, 0);\n  newNode.scale.set(1, 1, 1);\n  newNode.updateMatrix();\n  return newNode;\n};\n\nGeometryUtil.__flatten = function (root, node, matrix) {\n  if (node.children && node.children.length > 0) {\n    for (var i = 0; i < node.children.length; i++) {\n      var m = new THREE.Matrix4();\n      m.multiplyMatrices(matrix, node.children[i].matrix);\n      GeometryUtil.__flatten(root, node.children[i], m);\n    }\n  } else {\n    var newNode = node.clone(undefined, false);\n    newNode.matrix.identity();\n    newNode.applyMatrix(matrix);\n    root.add(newNode);\n  }\n};\n\nGeometryUtil.toBufferGeometry = function (geom) {\n  if (geom instanceof THREE.Geometry) {\n    var newGeom = new THREE.BufferGeometry();\n    newGeom.fromGeometry(geom);\n    newGeom.dynamic = geom.dynamic;\n    //newGeom.verticesArray = newGeom.attributes['position'].array;\n    return newGeom;\n  } else if (geom instanceof THREE.BufferGeometry) {\n    return geom;\n  } else {\n    console.error('Cannot convert ' + geom + ' to BufferGeometry');\n  }\n};\n\nGeometryUtil.toGeometry = function (geom) {\n  if (geom instanceof THREE.Geometry) {\n    return geom;\n  } else if (geom instanceof THREE.BufferGeometry) {\n    var newGeom = new THREE.Geometry();\n    newGeom.fromBufferGeometry(geom);\n    newGeom.dynamic = geom.dynamic;\n    return newGeom;\n  } else {\n    console.error('Cannot convert ' + geom + ' to BufferGeometry');\n  }\n};\n\nGeometryUtil.createBufferedGeometry = function(params) {\n  var geom = new THREE.BufferGeometry();\n  geom.dynamic = true;\n  if (params.positions.length/3 < 65536) {\n    geom.setIndex(new THREE.BufferAttribute(new Uint16Array(params.indices), 1));\n  } else {\n    geom.setIndex(new THREE.BufferAttribute(new Uint32Array(params.indices), 1));\n  }\n  geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(params.positions), 3));\n  geom.groups[0] = { start: 0, count: params.indices.length, index: 0 };   //very important!\n  geom.computeFaceNormals();\n  geom.computeVertexNormals();\n  geom.computeBoundingSphere();\n  return geom;\n};\n\nGeometryUtil.clone = function(geometry) {\n  var geom = geometry.clone();\n  geom.isFlipped = geometry.isFlipped;\n  return geom;\n};\n\nGeometryUtil.flipForMirroring = function(geometry) {\n  GeometryUtil.__flipFaceVertices(geometry);\n  geometry.isFlipped = !geometry.isFlipped;\n  //GeometryUtil.__flipNormals(geometry);\n  //geometry.computeFaceNormals();\n  //geometry.computeVertexNormals();\n  geometry.verticesNeedUpdate = false;\n  geometry.elementsNeedUpdate = false;\n  geometry.uvsNeedUpdate = false;\n  geometry.normalsNeedUpdate = false;\n  geometry.colorsNeedUpdate = false;\n};\n\nGeometryUtil.__flipNormals = function (geo) {\n  if (geo instanceof THREE.Geometry) {\n    geo.dynamic = true;\n    geo.verticesNeedUpdate = true;\n    geo.normalsNeedUpdate = true;\n    for (var i = 0; i < geo.faces.length; i++) {\n      var face = geo.faces[i];\n      face.normal.negate();\n      if (face.vertexNormals && face.vertexNormals.length) {\n        face.vertexNormals[0].negate();\n        face.vertexNormals[1].negate();\n        face.vertexNormals[2].negate();\n      }\n    }\n    //geo.computeFaceNormals();\n    //geo.computeVertexNormals();\n  } else {\n    console.error('GeometryUtil.__flipNormals: Unsupported geometry ', geo);\n  }\n};\n\nGeometryUtil.__flipFaceVertices = function(geometry) {\n  if (geometry instanceof THREE.Geometry) {\n    //console.log(geometry);\n    for (var i = 0; i < geometry.faces.length; i++) {\n      var face = geometry.faces[i];\n      // Swap b and c\n      var tmp = face.b;\n      face.b = face.c;\n      face.c = tmp;\n      // Swap vertex normals and vertex colors\n      if (face.vertexColors && face.vertexColors.length) {\n        tmp = face.vertexColors[1];\n        face.vertexColors[1] = face.vertexColors[2];\n        face.vertexColors[2] = tmp;\n      }\n      if (face.vertexNormals && face.vertexNormals.length) {\n        tmp = face.vertexNormals[1];\n        face.vertexNormals[1] = face.vertexNormals[2];\n        face.vertexNormals[2] = tmp;\n      }\n    }\n    if (geometry.faceVertexUvs) {\n      for (var j = 0; j < geometry.faceVertexUvs.length; j++) {\n        var fuvs = geometry.faceVertexUvs[j];\n        for (var i = 0; i < fuvs.length; i++) {\n          var uvs = fuvs[i];\n          if (uvs) {\n            var tmp = uvs[1];\n            uvs[1] = uvs[2];\n            uvs[2] = tmp;\n          }\n        }\n      }\n    }\n  } else if (geometry instanceof THREE.BufferGeometry) {\n    if (!geometry.index) {\n      // Make sure it is indexed\n      var pos = geometry.attributes['position'].array;\n      var nVerts = pos.length / 3;\n      var indexSize = nVerts;\n      var index = (nVerts < 65536) ?\n        new Uint16Array(indexSize) : new Uint32Array(indexSize);\n      for (var i = 0; i < indexSize; i++) {\n        index[i] = i;\n      }\n      geometry.setIndex(new THREE.BufferAttribute(index, 1));\n    }\n    // Swap every 2nd/3rd index\n    var indices = geometry.index.array;\n    for (var i = 0; i < indices.length; i+=3) {\n      var tmp = indices[i+1];\n      indices[i+1] = indices[i+2];\n      indices[i+2] = tmp;\n    }\n  } else {\n    console.error('GeometryUtil.__flipFaceVertices: Unsupported geometry ', geometry);\n  }\n};\n\nGeometryUtil.createVPTreeVertex = function (geometry, transform) {\n  var VPTreeFactory = __webpack_require__(/*! ds/VPTree */ \"./js/lib/ds/VPTree.js\");\n  return VPTreeFactory.build(GeometryUtil.getGeometryVertexCount(geometry), function(a,b) {\n    var v1 = GeometryUtil.getGeometryVertex(geometry, a, transform);\n    var v2 = GeometryUtil.getGeometryVertex(geometry, b, transform);\n    return v1.distanceTo(v2);\n  });\n};\n\nGeometryUtil.getVertexMapping = function (srcGeo, tgtGeo, maxDist) {\n  maxDist = maxDist || 1e-2;\n\n  var tgtVPtree = GeometryUtil.createVPTreeVertex(tgtGeo);\n  var distFun = function(q, v) {\n    var v1 = GeometryUtil.getGeometryVertex(srcGeo, q);\n    var v2 = GeometryUtil.getGeometryVertex(tgtGeo, v);\n    return v1.distanceTo(v2);\n  };\n\n  var srcNumVerts = GeometryUtil.getGeometryVertexCount(srcGeo);\n  var vertexMapping = [];\n  for (var i = 0; i < srcNumVerts; i++) {\n    var results = tgtVPtree.search(i, 1, maxDist, distFun);\n    if (results.length) {\n      vertexMapping[i] = results[0].i;\n    }\n  }\n  return vertexMapping;\n};\n\nGeometryUtil.isMeshInOBB = function(mesh, obb) {\n  var nVerts = GeometryUtil.getGeometryVertexCount(mesh.geometry);\n  //console.log('check mesh in obb', mesh, obb, nVerts);\n  if (nVerts) {\n    var vert = new THREE.Vector3();\n    var transform = mesh.matrixWorld;\n    for (var i = 0; i < nVerts; i++) {\n      GeometryUtil.getGeometryVertex(mesh.geometry, i, transform, vert);\n      if (!obb.isPointContained(vert)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    return false;\n  }\n};\n\nfunction getClosestVertexSimple(mesh, point) {\n  // Let's just do raw lookup for now\n  var nVerts = GeometryUtil.getGeometryVertexCount(mesh.geometry);\n  var vert = new THREE.Vector3();\n  var closestVertIndex = -1;\n  var closestDistSq = Infinity;\n  for (var i = 0; i < nVerts; i++) {\n    GeometryUtil.getGeometryVertex(mesh.geometry, i, null, vert);\n    var distSq = point.distanceToSquared(vert);\n    //console.log('distSq', distSq, closestDistSq);\n    if (distSq < closestDistSq) {\n      closestVertIndex = i;\n      closestDistSq = distSq;\n    }\n  }\n  if (closestVertIndex >= 0) {\n    GeometryUtil.getGeometryVertex(mesh.geometry, closestVertIndex, null, vert);\n    return { index: closestVertIndex, position: vert };\n  }\n}\n\nGeometryUtil.getClosestVertexLocal = function(mesh, point) {\n  return getClosestVertexSimple(mesh, point);\n};\n\nGeometryUtil.getClosestVertexWorld = function(mesh, point) {\n  var localPoint = point.clone();\n  mesh.worldToLocal(localPoint);\n  var vertex = GeometryUtil.getClosestVertexLocal(mesh, localPoint);\n  if (vertex) {\n    mesh.localToWorld(vertex.position);\n  }\n  return vertex;\n};\n\nvar ZERO_TOLERANCE = 0.0000000001;\n\nGeometryUtil.trianglesShareEdge = (function() {\n  var t1Edge = new THREE.Vector3();\n  var t2Edge = new THREE.Vector3();\n  return function(t1, t2, opts) {\n    opts = opts || {};\n    // TODO: can compare vertex distance\n    function vertexSame(v1, v2) {\n      return v1.equals(v2);\n    }\n    var edges = [[0,1], [1,2], [2,0]];\n    for (var ei1 = 0; ei1 < edges.length; ei1++) {\n      var t1e = edges[ei1];\n      for (var ei2 = 0; ei2 < edges.length; ei2++) {\n        var t2e = edges[ei2];\n        // check if any of the vertices are the same\n        var v11 = t1.getVertex(t1e[0]);\n        var v12 = t1.getVertex(t1e[1]);\n        var v21 = t2.getVertex(t2e[0]);\n        var v22 = t2.getVertex(t2e[1]);\n        if (vertexSame(v11,v21) || vertexSame(v11,v22) || vertexSame(v12, v21) || vertexSame(v12, v22)) {\n          // See if any two overlaps\n          t1Edge.subVectors(v12, v11).normalize();\n          t2Edge.subVectors(v22, v21).normalize();\n          if (Math.abs(t1Edge.dot(t2Edge)) > 1.0 - ZERO_TOLERANCE) {\n            // Check for overlap (to handle |><| cases )\n            // project vertices on to edge and see if there is an overlap (other than just at the vertex)\n            var pv11 = t1Edge.dot(v11);\n            var pv12 = t1Edge.dot(v12);\n            var pv21 = t1Edge.dot(v21);\n            var pv22 = t1Edge.dot(v22);\n            var t1range = (pv11 < pv12)? [pv11,pv12] : [pv12, pv11];\n            var t2range = (pv21 < pv22)? [pv21,pv22] : [pv22, pv21];\n            if (t2range[0] >= t1range[1] || t1range[0] >= t2range[1]) {\n              // No overlap\n            } else {\n              // close enough\n              // |-------------|\n              // |----------------|\n              if (opts.debug) {\n                var omin = Math.max(t1range[0], t2range[0]);\n                var omax = Math.min(t1range[1], t2range[1]);\n                console.log(\"Overlap is \" + (omax - omin) + \", intervals are \" + (t2max-t2min) + \" and \" + (t1max-t1min));\n              }\n              return true;\n            }\n          }\n        }\n        // TODO: check if there are shared edge without exact shared vertex\n      }\n    }\n    return false;\n  };\n}());\n\nGeometryUtil.getTriangle = function(geo, i, triangle, transform) {\n  triangle = triangle || new THREE.Triangle();\n\n  var vidxs = GeometryUtil.getFaceVertexIndices(geo, i);\n  GeometryUtil.getGeometryVertex(geo, vidxs[0], transform, triangle.a);\n  GeometryUtil.getGeometryVertex(geo, vidxs[1], transform, triangle.b);\n  GeometryUtil.getGeometryVertex(geo, vidxs[2], transform, triangle.c);\n  return triangle;\n};\n\n\nmodule.exports = GeometryUtil;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/GeometryUtil.js?");

/***/ }),

/***/ "./js/lib/geo/Grid.js":
/*!****************************!*\
  !*** ./js/lib/geo/Grid.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//var BinaryView = require('util/BinaryView');\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n//require('bitview');\n\n/**\n * Grid - represents a voxel grid\n * @params [params.dataType='uchar'] {string} type of an element of the grid\n * @params [params.elementsPerVoxel=1] {int} number of element per voxel\n * @property type {string} type of the grid\n * @property dataType {string} type of an element of the grid\n * @constructor\n * @memberOf geo\n */\nvar Grid = function (params) {\n  params = params || {};\n  this.type = 'grid';\n  this.worldToGrid = new THREE.Matrix4();\n  this.gridToWorld = new THREE.Matrix4();\n  this.labels = [];\n  this.voxelSize = 1;\n  this.__depth = 0;\n  this.__width = 0;\n  this.__height = 0;\n  this.__size = 0;\n  this.dataType = params.dataType || 'uchar';   // Basic unit of a voxel element  (what typed array to use)\n  this.bitsPerElement = 8*Grid.Types[this.dataType].bytes;     // Number of bits used per element\n  this.elementsPerVoxel = params.elementsPerVoxel || 1;        // Number of elements per voxel\n};\nGrid.prototype.constructor = Grid;\n\n// Mapping of type to bytes\nGrid.Types = Object.freeze({\n  'int8': { bytes: 1, array: Int8Array },\n  'uint8': { bytes: 1, array: Uint8Array },\n  'uchar': { bytes: 1, array: Uint8Array },\n  'int16': { bytes: 2, array: Int16Array },\n  'uint16': { bytes: 2, array: Uint16Array },\n  'int32': { bytes: 4, array: Int32Array },\n  'uint32': { bytes: 4, array: Uint32Array },\n  'int64': { bytes: 8 },\n  'uint64': { bytes: 8 },\n  'float32': { bytes: 4, array: Float32Array },\n  'float64': { bytes: 8, array: Float64Array }\n});\n\nGrid.prototype.init = function (params) {\n  if (params.dims) {\n    this.__depth = params.dims[0];\n    this.__width = params.dims[1];\n    this.__height = params.dims[2];\n  } else if (params.orderedDims) {\n    this.__width = params.orderedDims[0];\n    this.__height = params.orderedDims[1];\n    this.__depth = params.orderedDims[2];\n  }\n  this.__size = this.__width * this.__height * this.__depth;\n  this.labels = params.labels || [];\n  this.voxelSize = 1;\n  var nbytes = Math.ceil(this.sizeInBits / 8);\n  var arrayBuffer = params.data? params.data : new ArrayBuffer(nbytes);\n  if (!(arrayBuffer instanceof ArrayBuffer)) {\n    console.warn('Grid data not ArrayBuffer');\n  }\n  if (arrayBuffer.length < nbytes) {\n    console.warn('Grid data should be ' + nbytes + ' bytes, but only ' + arrayBuffer.length);\n  }\n  var typeInfo = Grid.Types[this.dataType];\n  if (typeInfo && typeInfo.array) {\n    this.__voxelsBuffer = new typeInfo.array(arrayBuffer);\n  } else {\n    this.__voxelsBuffer = new Uint8Array(arrayBuffer);\n  }\n};\n\n/* Read only properties */\nObject.defineProperty(Grid.prototype, 'size', {\n  get: function () { return this.__size; }\n});\n\n/* Size in bits */\nObject.defineProperty(Grid.prototype, 'sizeInBits', {\n  get: function() { return this.size * this.elementsPerVoxel * this.bitsPerElement; }\n});\n\n// Dimensions corresponding to x,y,z\nObject.defineProperty(Grid.prototype, 'dims', {\n  get: function () { return [this.__depth, this.__width, this.__height]; }\n});\n\n// Dimensions ordered from fasted varying to slowest (from the voxelBuffer)\nObject.defineProperty(Grid.prototype, 'orderedDims', {\n  get: function() {\n    // Strange ordering: y, z, x\n    if (this.elementsPerVoxel > 1) {\n      return [this.elementsPerVoxel, this.__width, this.__height, this.__depth];\n    } else {\n      return [this.__width, this.__height, this.__depth];\n    }\n  }\n});\n\nGrid.prototype.isVoxelSet = function (x, y, z) {\n  return this.getVoxel(x,y,z);\n};\n\nGrid.prototype.getVoxel = function (x, y, z) {\n  return this.getRawVoxel(x,y,z);\n};\n\nGrid.prototype.getRawVoxel = function (x, y, z) {\n  var vi = this.__indexOf(x, y, z);\n  if (this.elementsPerVoxel > 1) {\n    var start = this.elementsPerVoxel*vi;\n    var end = start + this.elementsPerVoxel;\n    return (start >= 0 && end < this.__voxelsBuffer.length) ?\n      this.__voxelsBuffer.subarray(start, end) : null;\n  } else {\n    return (vi >= 0 && vi < this.__voxelsBuffer.length) ? this.__voxelsBuffer[vi] : null;\n  }\n};\n\nGrid.prototype.countSetVoxels = function() {\n  var nVoxelsSet = 0;\n  for (var i = 0; i < this.dims[0]; i++) {\n    for (var j = 0; j < this.dims[1]; j++) {\n      for (var k = 0; k < this.dims[2]; k++) {\n        if (this.isVoxelSet(i,j,k)) {\n          nVoxelsSet++;\n        }\n      }\n    }\n  }\n  return nVoxelsSet;\n};\n\nGrid.prototype.getSetVoxelsBoundingBox = function() {\n  var bbox = new BBox();\n  for (var i = 0; i < this.dims[0]; i++) {\n    for (var j = 0; j < this.dims[1]; j++) {\n      for (var k = 0; k < this.dims[2]; k++) {\n        if (this.isVoxelSet(i,j,k)) {\n          bbox.includePoint(new THREE.Vector3(i, j, k));\n        }\n      }\n    }\n  }\n  return bbox;\n};\n\nGrid.prototype.setVoxel = function (x, y, z, value) {\n  return this.setRawVoxel(x,y,z, value);\n};\n\nGrid.prototype.setRawVoxel = function (x, y, z, value) {\n  var vi = this.__indexOf(x, y, z);\n  if (this.elementsPerVoxel > 1) {\n    var start = this.elementsPerVoxel*vi;\n    var end = start + this.elementsPerVoxel;\n    if (start >= 0 && end < this.__voxelsBuffer.length) {\n      for (var i = 0; i < this.elementsPerVoxel; i++) {\n        this.__voxelsBuffer[start+i] = value? value[i] : 0;\n      }\n    }\n  } else {\n    if (vi >= 0 && vi < this.__voxelsBuffer.length) {\n      this.__voxelsBuffer[vi] = value? value : 0;\n    }\n  }\n};\n\nGrid.prototype.getRawData = function() {\n  return this.__voxelsBuffer;\n};\n\nGrid.prototype.__indexOf = function (x, y, z) {\n  if (x < 0 || x >= this.__depth || y < 0 || y >= this.__width || z < 0 || z >= this.__height) {\n    return -1;\n  }\n  return x * this.__width * this.__height + z * this.__width + y;\n};\n\nGrid.prototype.copy = function(g) {\n  // TODO: double check grids are compatible\n  this.copyTransform(g);\n  this.__voxelsBuffer.set(g.__voxelsBuffer);\n};\n\n/**\n * Copies transfrom from input grid to this grid\n * @param g {geo.Grid}\n * @param scaleFactor {number}\n */\nGrid.prototype.copyTransform = function(g, scaleFactor) {\n  this.worldToGrid.copy(g.worldToGrid);\n  this.gridToWorld.copy(g.gridToWorld);\n  this.voxelSize = g.voxelSize;\n  if (scaleFactor && scaleFactor != 1) {\n    var S = new THREE.Matrix4();\n    S.makeScale(scaleFactor, scaleFactor, scaleFactor);\n    this.gridToWorld.multiply(S);\n    this.worldToGrid.getInverse(this.gridToWorld);\n    this.voxelSize *= scaleFactor;\n  }\n};\n\n/**\n * Copies values from input grid to this grid (assumes the two grids are the same dimensions)\n * @param g {geo.Grid}\n * @param convert {function(*, Array):*} Converts a voxel value from input grid to this grid\n */\nGrid.prototype.copyValues = function(g, convert) {\n  // TODO: Ensure grids are the same size\n  for (var i = 0; i < g.dims[0]; i++) {\n    for (var j = 0; j < g.dims[1]; j++) {\n      for (var k = 0; k < g.dims[2]; k++) {\n        this.setVoxel(i,j,k, convert(g.getVoxel(i,j,k), [i,j,k]));\n      }\n    }\n  }\n};\n\n/**\n * Copies values from input grid with larger dimensions to this grid\n * @param g {geo.Grid}\n * @param convert {function(Array, Array):*} Converts an array of voxel values from input grid to this grid\n * @param reduceBy {int} Factor to reduce by\n */\nGrid.prototype.copyReducedValues = function(g, convert, reduceBy) {\n  // TODO: Ensure grids are the same size\n  for (var i = 0, i2=0; i < g.dims[0]; i+=reduceBy, i2++) {\n    for (var j = 0, j2=0; j < g.dims[1]; j+=reduceBy, j2++) {\n      for (var k = 0, k2=0; k < g.dims[2]; k+=reduceBy, k2++) {\n        var chunk = [];\n        for (var a = 0; a < reduceBy; a++) {\n          for (var b = 0; b < reduceBy; b++) {\n            for (var c = 0; c < reduceBy; c++) {\n              chunk.push(g.getVoxel(i+a, j+b, k+c));\n            }\n          }\n        }\n        this.setVoxel(i2,j2,k2, convert(chunk, [i2,j2,k2]));\n      }\n    }\n  }\n};\n\nGrid.prototype.__compare = function(g) {\n  var dims1 = this.dims;\n  var dims2 = g.dims;\n  if (!_.isEqual(dims1, dims2)) {\n    console.log('dimension mismatch: ', dims1, dims2);\n    return false;\n  }\n  var matched = true;\n  if (!this.__compareBytes(g)) { matched = false; }\n  if (!this.__compareValues(g)) { matched = false; }\n  return matched;\n};\n\nGrid.prototype.__compareBytes = function(g) {\n  // TODO: Ensure grids are the same size\n  console.log('compareBytes', this, g);\n  var matched = true;\n  for (var i = 0; i < this.__voxelsBuffer.length; i++) {\n    if (this.__voxelsBuffer[i] !== g.__voxelsBuffer[i]) {\n      console.log('different at ' + i + ': ' + this.__voxelsBuffer[i] + ' vs ' + g.__voxelsBuffer[i]);\n      matched = false;\n    }\n  }\n  return matched;\n};\n\nGrid.prototype.__compareValues = function(g) {\n  var matched = true;\n  // TODO: Ensure grids are the same size\n  console.log('compareValues', this, g);\n  for (var i = 0; i < this.dims[0]; i++) {\n    for (var j = 0; j < this.dims[1]; j++) {\n      for (var k = 0; k < this.dims[2]; k++) {\n        var v1 = this.getRawVoxel(i,j,k);\n        var v2 = g.getRawVoxel(i,j,k);\n        var diff = (!!v1 !== !!v2) || (v1 && v2 && v1.length !== v2.length);\n        if (!diff && v1 && v2) {\n          for (var vi = 0; vi < v1.length; vi++) {\n            if (v1[vi] !== v2[vi]) {\n              diff = true;\n              break;\n            }\n          }\n        }\n        if (diff) {\n          console.log('different at ' + JSON.stringify([i,j,k])\n            + ', index ' + this.__indexOf(i,j,k) + ' vs ' + g.__indexOf(i,j,k)\n            + ': ' + JSON.stringify(v1) + ' vs ' + JSON.stringify(v2));\n          matched  = false;\n        }\n      }\n    }\n  }\n  return matched;\n};\n\n// Similar to copy values except that values are not\n// set if convert returns undefined or null\nGrid.prototype.copyValuesPartial = function(g, convert) {\n  // TODO: Ensure grids are the same size\n  for (var i = 0; i < g.dims[0]; i++) {\n    for (var j = 0; j < g.dims[1]; j++) {\n      for (var k = 0; k < g.dims[2]; k++) {\n        var v = convert(g.getVoxel(i,j,k), [i,j,k]);\n        if (v != undefined) {\n          this.setVoxel(i, j, k, v);\n        }\n      }\n    }\n  }\n};\n\nGrid.prototype.iterate = function(process) {\n  var g = this;\n  for (var i = 0; i < g.dims[0]; i++) {\n    for (var j = 0; j < g.dims[1]; j++) {\n      for (var k = 0; k < g.dims[2]; k++) {\n        process(g.getRawVoxel(i,j,k), [i,j,k]);\n      }\n    }\n  }\n};\n\nGrid.prototype.getOrigin = function() {\n  var origin = new THREE.Vector3();\n  origin.setFromMatrixPosition(this.gridToWorld);\n  return origin;\n};\n\nGrid.prototype.getGridToWorldBasisOrdered = function() {\n  var xAxis = new THREE.Vector3();\n  var yAxis = new THREE.Vector3();\n  var zAxis = new THREE.Vector3();\n  this.gridToWorld.extractBasis(xAxis, yAxis, zAxis);\n  // From fastest to slowest (y, z, x)\n  return [yAxis, zAxis, xAxis];\n};\n\nvar directions = [\n  new THREE.Vector3(-1, 0, 0),\n  new THREE.Vector3(+1, 0, 0),\n  new THREE.Vector3(0, -1, 0),\n  new THREE.Vector3(0, +1, 0),\n  new THREE.Vector3(0, 0, -1),\n  new THREE.Vector3(0, 0, +1)\n];\n\nGrid.prototype.getNeighborOccupancy = function(i,j,k) {\n  var scope = this;\n  function getOccupancy(d) {\n    return !!scope.isVoxelSet(i + d.x, j + d.y, k + d.z);\n  }\n  return _.map(directions, function(d) {\n    return getOccupancy(d);\n  });\n};\n\nGrid.prototype.getNeighborDirections = function(transform) {\n  if (transform) {\n    return _.map(directions, function(d) {\n      if (transform instanceof THREE.Matrix4) {\n        return d.clone().applyMatrix4(transform);\n      } else if (_.isFunction(transform)) {\n        return transform(d);\n      }\n    });\n  } else {\n    return directions;\n  }\n};\n\nGrid.prototype.iterateNeighborsCoords = function(i,j,k, process) {\n  return _.map(directions, function(d) {\n    process(i+d.x, j + d.y, k + d.z);\n  });\n};\n\nGrid.prototype.toGrid = function(p, out, opts) {\n  opts = opts || {};\n  out = out || new THREE.Vector3();\n  var transform = opts.transform || this.worldToGrid;\n  p = p.clone();\n  p.applyMatrix4(transform);\n  // we take the floor - is that the good thing?\n  out.x = Math.floor(p.x);\n  out.y = Math.floor(p.y);\n  out.z = Math.floor(p.z);\n  if (opts.clamp) {\n    var dims = this.dims;\n    out.x = _.clamp(out.x, 0, dims[0]);\n    out.y = _.clamp(out.y, 0, dims[1]);\n    out.z = _.clamp(out.z, 0, dims[2]);\n  }\n  return out;\n};\n\nGrid.prototype.toWorld = function(p, out, opts) {\n  opts = opts || {};\n  out = out || new THREE.Vector3();\n  var transform = opts.transform || this.gridToWorld;\n  out.copy(p);\n  out.applyMatrix4(transform);\n  return out;\n};\n\nmodule.exports = Grid;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/Grid.js?");

/***/ }),

/***/ "./js/lib/geo/IndexedSegmentation.js":
/*!*******************************************!*\
  !*** ./js/lib/geo/IndexedSegmentation.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AssetLoader = __webpack_require__(/*! assets/AssetLoader */ \"./js/lib/assets/AssetLoader.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Create a segmented mesh using index faces or vertices\n * @param params\n * @param params.filename {string} Filename\n * @constructor\n */\nfunction IndexedSegmentation(params) {\n  this.__options = params;\n}\n\n/**\n * Create segmentation using one mesh with multiple materials\n * @param opts\n * @param opts.segmentName {string} segment name to use\n * @param opts.segmentType {string} segmentation type\n * @param opts.object3D {THREE.Object3D} Object to segment\n * @param [opts.useOriginalMaterial] {boolean} whether to use original material\n * @param [opts.getMaterial] {function(THREE.Object3D, {})}\n * @param [opts.callback] If provided, will attempt to load the segmentation file.  Otherwise creates segmentaiton from this.data\n * @returns {THREE.Mesh}\n */\nIndexedSegmentation.prototype.getSegments = function(opts) {\n  var scope = this;\n  if (opts.callback) {\n    this.load({\n      filename: this.__options.filename,\n      callback: function (err, data) {\n        if (data) {\n          var segments = scope.__makeSegments(opts);\n          opts.callback(null, segments);\n        } else {\n          opts.callback(err, null);\n        }\n      }\n    });\n  } else {\n    var segments = scope.__makeSegments(opts);\n    return segments;\n  }\n};\n\n// Copied from Segments\nfunction createMeshIndicesFromMeshes(meshes) {\n  var meshIndex = [];      // triangle index to mesh index\n  var meshTriCounts = [];  // mesh index to number of triangles in mesh\n  var meshTriIndex = [];   // triangle index to triangle index for mesh\n  var totalTris = 0;\n  for (var mi = 0; mi < meshes.length; mi++) {\n    var mesh = meshes[mi];\n    var ntris = GeometryUtil.getGeometryFaceCount(mesh.geometry);\n    meshTriCounts[mi] = ntris;\n    for (var i = 0; i < ntris; i++) {\n      meshTriIndex.push(i);\n      meshIndex.push(mi)\n    }\n    totalTris += ntris;\n  }\n  return { meshIndex: meshIndex, meshTriIndex: meshTriIndex, meshTriCounts: meshTriCounts };\n}\n\n// Copied from Segments\nfunction __indexedSegmentationToSegmentsWithTriMesh(index, meshIndex, meshTriIndex) {\n  var segmentsByKey = {};\n  var segments = [];\n  for (var i = 0; i < index.length; i++) {\n    var sIndex = index[i];\n    var mIndex = meshIndex? meshIndex[i] : 0;\n    var triIndex = meshTriIndex? meshTriIndex[i] : i;\n    var key = mIndex + '-' + sIndex;\n    if (!segmentsByKey[key]) {\n      segmentsByKey[key] = { id: sIndex, surfaceIndex: segments.length, meshIndex: mIndex, triIndex: [triIndex]};\n      segments.push(segmentsByKey[key]);\n    } else {\n      segmentsByKey[key].triIndex.push(triIndex);\n    }\n  }\n  return segments;\n}\n\n/**\n * Creates segmentation with individual meshes per part\n * @param opts\n */\nIndexedSegmentation.prototype.getSegmentedMeshes = function(opts) {\n  if (this.data.elementType === 'triangles') {\n    var object3D = opts.object3D;\n    var segmentationsByName = _.keyBy(this.data.segmentation, 'name');\n    var segmentation = segmentationsByName[opts.segmentName];\n\n    if (segmentation) {\n      const meshes = Object3DUtil.getMeshList(object3D);\n      let converted;\n      if (meshes.length > 1) {\n        // Need to create new mesh to tri indices (whatever is saved is not necessarily how our loader separated into meshes)\n        const  meshIndices = createMeshIndicesFromMeshes(meshes);\n        converted = __indexedSegmentationToSegmentsWithTriMesh(segmentation.index, meshIndices.meshIndex, meshIndices.meshTriIndex);\n      } else {\n        converted = __indexedSegmentationToSegmentsWithTriMesh(segmentation.index);\n      }\n      const segmented = Object3DUtil.remeshObject(object3D, converted);\n      return segmented;\n    } else {\n      // Leaving object unsegmented\n      console.warn('No ' + opts.segmentType + '.' + opts.segmentName + ' segmentation for ' + this.data.id, segmentationsByName);\n      return object3D;\n    }\n  } else {\n    throw \"Unsupported elementType \" + this.data.elementType;\n  }\n};\n\n\nIndexedSegmentation.prototype.load = function(opts) {\n  if (!this.data) {\n    this.__load(_.defaults(Object.create(null), opts, this.__options));\n  } else {\n    opts.callback(null, this.data);\n  }\n};\n\n/**\n * Segments mesh based on indexed segmentation\n * @param opts\n * @param opts.segmentName {string} segment name to use\n * @param opts.segmentType {string} segmentation type\n * @param opts.object3D {THREE.Object3D} Object to segment\n * @param [opts.useOriginalMaterial] {boolean} whether to use original material\n * @param [opts.getMaterial] {function(THREE.Object3D, {})}\n * @returns {THREE.Mesh}\n * @private\n */\nIndexedSegmentation.prototype.__makeSegments = function(opts) {\n  if (!this.data) {\n    throw 'Segmentation not loaded';\n  }\n  if (this.data.elementType === 'triangles') {\n    var object3D = opts.object3D;\n    var segmentationsByName = _.keyBy(this.data.segmentation, 'name');\n    var segmented = object3D.clone();\n    //console.log('segmented', this.data.id, segmented);\n    var mesh = GeometryUtil.mergeMeshesWithTransform(Object3DUtil.getMeshList(segmented), { clone: true });\n    mesh.name = object3D.name + '-segmented';\n    _.merge(mesh.userData, object3D.userData, { segmentType: opts.segmentType, segmentName: opts.segmentName });\n    var segmentation = segmentationsByName[opts.segmentName];\n    var mats = (mesh.material instanceof THREE.MultiMaterial)? mesh.material.materials :\n      (Array.isArray(mesh.material)? mesh.material : [mesh.material]);\n    var segMatToSegInfoIndex = {};\n    if (segmentation) {\n      var maxIndex = -1;\n      if (mesh.geometry.faces.length !== segmentation.index.length) {\n        console.warn('mismatch between number of faces and segmentation index');\n      }\n      var labels = segmentation.labels || [];\n      var nFaces = mesh.geometry.faces.length;\n      var segInfos = [];\n      if (opts.useOriginalMaterial) {\n        for (var i = 0; i < nFaces; i++) {\n          var mi = mesh.geometry.faces[i].materialIndex;\n          var bsi = segmentation.index[i] || 0;\n          var segMat = bsi + '-' + mi;\n          var si = segMatToSegInfoIndex[segMat];\n          if (si == undefined) {\n            si = segInfos.length;\n            segMatToSegInfoIndex[segMat] = si;\n            segInfos[si] = { partIndex: bsi, label: labels[bsi], material: mats[mi] };\n          }\n          mesh.geometry.faces[i].materialIndex = si;\n          if (si > maxIndex) {\n            maxIndex = si;\n          }\n        }\n      } else {\n        for (var i = 0; i < nFaces; i++) {\n          var si = segmentation.index[i] || 0;\n          mesh.geometry.faces[i].materialIndex = si;\n          if (si > maxIndex) {\n            maxIndex = si;\n          }\n        }\n        for (var i = 0; i < maxIndex+1; i++) {\n          segInfos[i] = {partIndex: i, label: labels[i]};\n        }\n      }\n\n      //console.log('Make segments: ', this.data.id, mesh, mats, segInfos, segMatToSegInfoIndex);\n      var materials = _.range(maxIndex + 1).map(function (i) {\n        return opts.getMaterial(object3D, segInfos[i]);\n      });\n      //console.log('maxIndex ' + maxIndex + ', materials', materials);\n      mesh.material = new THREE.MultiMaterial(materials);\n    } else {\n      console.warn('No ' + opts.segmentType + '.' + opts.segmentName + ' segmentation for ' + this.data.id, segmentationsByName);\n      if (opts.useOriginalMaterial) {\n        var materials = mats.map(function (m, i) {\n          return opts.getMaterial(object3D, { partIndex: 0, material: m });\n        });\n        mesh.material = new THREE.MultiMaterial(materials);\n      } else {\n        mesh.material = opts.getMaterial(object3D, { partIndex: 0 });\n      }\n    }\n    //console.log(mesh);\n    return mesh;\n  } else {\n    throw \"Unsupported elementType \" + this.data.elementType;\n  }\n};\n\nIndexedSegmentation.prototype.__load = function(opts) {\n  var assetLoader = new AssetLoader();\n  var callback = opts.callback;\n  var scope = this;\n  console.log('loading segmentation ' + opts.filename);\n  assetLoader.load(opts.filename, 'json', function(data) {\n    scope.data = data;\n    callback(null, data);\n  }, null, function(err) {\n    callback(err, null);\n  });\n};\n\nmodule.exports = IndexedSegmentation;\n\n//# sourceURL=webpack://STK/./js/lib/geo/IndexedSegmentation.js?");

/***/ }),

/***/ "./js/lib/geo/Intersections.js":
/*!*************************************!*\
  !*** ./js/lib/geo/Intersections.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Intersections = {};\n\n// Line clipping algorithm\n// https://en.wikipedia.org/wiki/Liang%E2%80%93Barsky_algorithm\n\nfunction isZero(a) {\n  return a < 0.000001 && a > -0.000001;\n}\n\nfunction pointInside(min, max, a) {\n  return a.x >= min.x && a.x <= max.x && a.y >= min.y && a.y <= max.y;\n}\n\nfunction clipT(num, denom, ts) {\n  if (isZero(denom)) { return (num <= 0.0); }\n  var t = num / denom;\n  if (denom > 0) {\n    if (t > ts.L) { return false; }\n    if (t > ts.E) { ts.E = t; }\n  } else {\n    if (t < ts.E) { return false; }\n    if (t < ts.L) { ts.L = t; }\n  }\n  return true;\n}\n\n// For line(a, b) and bbox(min, max) Return {E: t(entry), L: t(leave), intersects: true/false}\n// by clipping line against bbox.\nfunction clipLine(min, max, line) {\n  var dx = line.b.x - line.a.x;  var dy = line.b.y - line.a.y;\n  var ts = { E: 0, L: 1, intersects: false, clippedLine: { a: line.a.clone(), b: line.b.clone() } };\n  if (isZero(dx) && isZero(dy) && pointInside(min, max, line.a)) {\n    ts.intersects = true;\n    return ts;\n  }\n  // NOTE: ordering of clipT is important due to mutations of ts\n  if (clipT(min.x - line.a.x,  dx, ts) && clipT(line.a.x - max.x, -dx, ts) &&\n      clipT(min.y - line.a.y,  dy, ts) && clipT(line.a.y - max.y, -dy, ts)) {\n    if (ts.L < 1) {\n      ts.clippedLine.b.x = line.a.x + ts.L * dx;\n      ts.clippedLine.b.y = line.a.y + ts.L * dy;\n    }\n    if (ts.E > 0) {\n      ts.clippedLine.a.x += ts.E * dx;\n      ts.clippedLine.a.y += ts.E * dy;\n    }\n    ts.intersects = ts.E >= 0 && ts.L <= 1 && ts.E <= ts.L;\n  }\n  return ts;\n}\n\nIntersections.clipLine = clipLine;\n\nfunction projectPoints(line, points) {\n  var dx = line.b.x - line.a.x;  var dy = line.b.y - line.a.y;\n  var d2 = dx*dx + dy*dy;\n  return points.map(function(p) {\n    var pdx = p.x - line.a.x; var pdy = p.y - line.a.y;\n    var d = pdx*dx + pdy*dy;\n    return new THREE.Vector2(line.a.x + dx*d/d2, line.a.y + dy*d/d2);\n  });\n}\n\nIntersections.projectPoints = projectPoints;\n\nfunction projectPointsToRatio(line, points) {\n  var dx = line.b.x - line.a.x;  var dy = line.b.y - line.a.y;\n  var d2 = dx*dx + dy*dy;\n  return points.map(function(p) {\n    var pdx = p.x - line.a.x; var pdy = p.y - line.a.y;\n    var d = pdx*dx + pdy*dy;\n    return d/d2;\n  });\n}\n\nIntersections.projectPointsToRatio = projectPointsToRatio;\n\n// Exports\nmodule.exports = Intersections;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/Intersections.js?");

/***/ }),

/***/ "./js/lib/geo/MeshFaces.js":
/*!*********************************!*\
  !*** ./js/lib/geo/MeshFaces.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nconst OBBFitter = __webpack_require__(/*! geo/OBBFitter */ \"./js/lib/geo/OBBFitter.js\");\nconst TriangleAccessor = __webpack_require__(/*! geo/TriangleAccessor */ \"./js/lib/geo/TriangleAccessor.js\");\n\nclass MeshFaces {\n  constructor(mesh, faceIndices) {\n    this.mesh = mesh;\n    this.faceIndices = faceIndices || [];\n    this.__triAccessor = new TriangleAccessor(mesh);\n  }\n\n  isCompatible(triangle) {\n    return true;\n  }\n\n  add(faceIndex) {\n    this.faceIndices.push(faceIndex);\n  }\n\n  area(transform) {\n    _.sum(this.faceIndices, faceIndex => this.__triAccessor.getTriangleArea(faceIndex, transform));\n  }\n\n  obb(opts) {\n    // TODO: Check Mesh.findOBB2D_Meshes actually accepts partial meshes\n    return OBBFitter.fitMeshOBB(this, opts);\n  }\n\n  toMesh() {\n    const extractedMesh = GeometryUtil.extractMesh(this.mesh, this.faceIndices, true);\n    return extractedMesh;\n  }\n}\n\nmodule.exports = MeshFaces;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/MeshFaces.js?");

/***/ }),

/***/ "./js/lib/geo/MeshHelpers.js":
/*!***********************************!*\
  !*** ./js/lib/geo/MeshHelpers.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar OBB = __webpack_require__(/*! geo/OBB */ \"./js/lib/geo/OBB.js\");\n\nfunction lineWidthToUnit(lineWidth) {\n  return lineWidth/100 * Constants.metersToVirtualUnit;\n}\n\nvar BoxMinMaxHelper = function (min, max, materialOrColor) {\n  this.min = new THREE.Vector3();\n  this.max = new THREE.Vector3();\n  this.min.copy(min);\n  this.max.copy(max);\n  // NOTE: the min/max of the box is tied directly to the min and max\n  this.box = new THREE.Box3(this.min, this.max);\n\n  var material = Object3DUtil.getBasicMaterial(materialOrColor);\n  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), material);\n  this.box.getSize(this.scale);\n  this.box.getCenter(this.position);\n};\n\nBoxMinMaxHelper.prototype = Object.create(THREE.Mesh.prototype);\nBoxMinMaxHelper.prototype.constructor = BoxMinMaxHelper;\n\nBoxMinMaxHelper.prototype.update = function (min, max) {\n  if (min && max) {\n    this.box.set(min,max);\n  }\n  this.box.getSize(this.scale);\n  this.box.getCenter(this.position);\n};\n\nvar OBBHelper = function (obb, materialOrColor) {\n  var material = Object3DUtil.getBasicMaterial(materialOrColor);\n  THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), material);\n  this.update(obb);\n};\n\nOBBHelper.prototype = Object.create(THREE.Mesh.prototype);\nOBBHelper.prototype.constructor = OBBHelper;\n\nOBBHelper.prototype.update = function (obb) {\n  if (obb instanceof OBB) {\n    this._updateFromOBB(obb);\n  } else if (obb.centroid && obb.axesLengths && obb.normalizedAxes) {\n    this._updateFromJson(obb);\n  } else {\n    console.error(\"Invalid OBB: \" + obb);\n  }\n};\n\nOBBHelper.prototype._updateFromOBB = function (obb) {\n  this.obb = obb;\n  this.dominantNormal = obb.dominantNormal();\n  this.position.copy(obb.position);\n  this.scale.copy(obb.halfSizes).multiplyScalar(2);\n  this.quaternion.setFromRotationMatrix(obb.basis);\n  this.updateMatrix();\n  this.updateMatrixWorld();\n};\n\nOBBHelper.prototype._updateFromJson = function (obb) {\n  this.obb = obb;\n  var dn = obb.dominantNormal;\n  this.dominantNormal = dn? new THREE.Vector3(dn[0], dn[1], dn[2]) : undefined;\n  this.position.set(obb.centroid[0], obb.centroid[1], obb.centroid[2]);\n  this.scale.set(obb.axesLengths[0], obb.axesLengths[1], obb.axesLengths[2]);\n  var m = this.obb.normalizedAxes;\n  var matrix = new THREE.Matrix4();\n  if (obb.matrixIsRowMajor) {\n    matrix.set(\n      m[0], m[1], m[2], 0,\n      m[3], m[4], m[5], 0,\n      m[6], m[7], m[8], 0,\n      0, 0, 0, 1);\n  } else {\n    matrix.set(\n      m[0], m[3], m[6], 0,\n      m[1], m[4], m[7], 0,\n      m[2], m[5], m[8], 0,\n      0, 0, 0, 1);\n  }\n  this.quaternion.setFromRotationMatrix(matrix);\n  this.updateMatrix();\n  this.updateMatrixWorld();\n};\n\nOBBHelper.prototype.toWireFrame = function(linewidth, showNormal, materialOrColor) {\n  materialOrColor = materialOrColor || this.material;\n  var boxwf = new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), Object3DUtil.getBasicMaterial(materialOrColor)));\n  boxwf.position.copy(this.position);\n  boxwf.scale.copy(this.scale);\n  boxwf.quaternion.copy(this.quaternion);\n  boxwf.updateMatrix();\n  if (linewidth > 0) {\n    var boxwffat = new FatLinesHelper(boxwf, linewidth, materialOrColor);\n    if (showNormal) {\n      var normal = this.dominantNormal;\n      if (normal) {\n        var boxWithNormal = new THREE.Object3D();\n        var fatArrow = new FatArrowHelper(normal, this.position, linewidth * 5, linewidth, undefined, undefined, materialOrColor);\n        boxWithNormal.add(boxwffat);\n        boxWithNormal.add(fatArrow);\n        return boxWithNormal;\n      }\n    }\n    return boxwffat;\n  } else {\n    if (showNormal) {\n      var normal = this.dominantNormal;\n      if (normal) {\n        var boxWithNormal = new THREE.Object3D();\n        var arrow = new THREE.ArrowHelper(normal, this.position, 0.05*Constants.metersToVirtualUnit, undefined, undefined, materialOrColor);\n        boxWithNormal.add(boxwf);\n        boxWithNormal.add(arrow);\n        return boxWithNormal;\n      }\n    }\n    return boxwf;\n  }\n};\n\nvar LinesHelper = function (lines, materialOrColor) {\n  this.lines = null;\n  var material = (materialOrColor instanceof THREE.Material)? materialOrColor : new THREE.LineBasicMaterial( { color: materialOrColor });\n  var geometry = new THREE.Geometry();\n  THREE.LineSegments.call(this, geometry, material);\n  this.__update(lines);\n};\n\nLinesHelper.prototype = Object.create(THREE.LineSegments.prototype);\nLinesHelper.prototype.constructor = LinesHelper;\n\nLinesHelper.prototype.__update = function (input) {\n  if (input) {\n    this.lines = null;\n    if (input.length) {\n      if (input[0] instanceof THREE.Vector3) {\n        // Bunch of points in line\n        this.lines = [input];\n      } else if (input[0].length && input[0][0] instanceof THREE.Vector3) {\n        // Bunch of line segments\n        this.lines = input;\n      }\n    }\n    if (!this.lines) {\n      console.error('Unsupported input');\n    }\n  }\n\n  // Add lines\n  var geometry = this.geometry;\n  if (this.lines && this.lines.length) {\n    for (var i = 0; i < this.lines.length; i++) {\n      for (var j = 1; j < this.lines[i].length; j++) {\n        geometry.vertices.push(this.lines[i][j - 1]);\n        geometry.vertices.push(this.lines[i][j]);\n      }\n    }\n  }\n};\n\n\nvar FatLinesHelper = function (lines, width, materialOrColor, opts) {\n  opts = opts || {};\n  THREE.Group.call(this);\n  this.lines = null;\n  this.width = width;\n  if (Array.isArray(materialOrColor)) {\n    this.material = new THREE.MeshBasicMaterial({ vertexColors: THREE.VertexColors });\n    this.getColor = Colors.getColorFunction({\n      type: 'interpolate',\n      minWeight: 0,\n      maxWeight: 1,\n      colors: materialOrColor,\n      space: 'hsl'\n    });\n  } else {\n    this.material = Object3DUtil.getBasicMaterial(materialOrColor);\n  }\n  this.getWeight = opts.getWeight;\n  this.update(lines);\n};\n\nFatLinesHelper.prototype = Object.create(THREE.Group.prototype);\nFatLinesHelper.prototype.constructor = FatLinesHelper;\n\nFatLinesHelper.prototype.setFromObject = function(input) {\n  this.lines = null;\n  if (input instanceof THREE.Line) {\n    // Lets make these into our fat lines!!!\n    var verts = GeometryUtil.getVertices(input);\n    if (input.geometry.index) {\n      var index = input.geometry.index.array;\n      this.lines = [];\n      for (var i = 0; i < index.length; i += 2) {\n        var a = verts[index[i]];\n        var b = verts[index[i + 1]];\n        this.lines.push([a,b]);\n      }\n    } else {\n      this.lines = [];\n      for (var i = 0; i < verts.length; i += 2) {\n        var a = verts[i];\n        var b = verts[i + 1];\n        this.lines.push([a,b]);\n      }\n    }\n\n  } else if (input.length) {\n    if (input[0] instanceof THREE.Vector3) {\n      // Bunch of points in line\n      this.lines = [input];\n    } else if (input[0].length && input[0][0] instanceof THREE.Vector3) {\n      // Bunch of line segments\n      this.lines = input;\n    }\n  }\n  if (!this.lines) {\n    console.error('Unsupported input');\n  }\n  //if (input.matrix) {\n  // Object3DUtil.setMatrix(this, input.matrix);\n  //}\n};\n\nFatLinesHelper.prototype.update = function (input) {\n  // Create big fat cylinders connecting everything\n  // Remove everything\n  var objects = this.children.slice(0);\n  for (var i = 0; i < objects.length; i++) {\n    objects[i].parent.remove(objects[i]);\n  }\n\n  if (input) {\n    this.setFromObject(input);\n  }\n\n  // Add lines\n  if (this.lines && this.lines.length) {\n    for (var i = 0; i < this.lines.length; i++) {\n      var totalPoints = this.lines[i].length;\n      for (var j = 1; j < this.lines[i].length; j++) {\n        var cylinder = Object3DUtil.makeCylinder(this.lines[i][j - 1], this.lines[i][j],\n          this.width / 2, this.material);\n        if (this.getColor) {\n          var colors = this.getWeight?\n            [this.getColor(this.getWeight(i, j-1)), this.getColor(this.getWeight(i, j))]\n            : [this.getColor((j-1)/totalPoints), this.getColor(j/totalPoints)];\n          GeometryUtil.colorCylinderVertices(cylinder.geometry, colors[0], colors[1]);\n        }\n        this.add(cylinder);\n      }\n    }\n  }\n};\n\n\nvar FatArrowHelper = function (dir, origin, length, lineWidth, headLength, headWidth, materialOrColor) {\n  THREE.Group.call(this);\n  this.name = 'Arrow';\n\n  if (length === undefined) length = 1;\n  if (lineWidth === undefined) lineWidth = 1;\n  if (headLength === undefined) headLength = 0.2 * length;\n  if (headWidth === undefined) headWidth = lineWidth + 0.2 * headLength;\n  if (materialOrColor === undefined) materialOrColor = 0xffff00;\n\n  this.start = origin.clone();\n  this.dir = dir.clone();\n  this.length = length;\n\n  this.material = Object3DUtil.getBasicMaterial(materialOrColor);\n  this.line = Object3DUtil.makeColumn(this.start, this.dir, this.length - headLength,\n    lineWidthToUnit(lineWidth) / 2, this.material);\n  this.add(this.line);\n\n  var coneGeometry = new THREE.CylinderGeometry(0, 0.5, 1, 5, 1);\n  coneGeometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.5, 0));\n\n  this.cone = new THREE.Mesh(coneGeometry, this.material);\n  this.cone.matrixAutoUpdate = false;\n  Object3DUtil.setCylinderDirection(this.cone, dir);\n  this.cone.scale.set(headWidth, headLength, headWidth);\n  var end = this.start.clone().add(this.dir.clone().multiplyScalar(this.length));\n  this.cone.position.copy(end);\n  this.cone.updateMatrix();\n\n  this.add(this.cone);\n\n};\n\nFatArrowHelper.prototype = Object.create(THREE.Group.prototype);\nFatArrowHelper.prototype.constructor = FatArrowHelper;\n\nFatArrowHelper.prototype.setOrigin = function (start) {\n  var delta = new THREE.Vector3();\n  delta.subVectors(start, this.start);\n  this.line.position.addVectors(this.line.position, delta);\n  this.cone.position.addVectors(this.cone.position, delta);\n};\n\nFatArrowHelper.prototype.setDirection = function (dir) {\n  this.dir = dir.clone();\n  Object3DUtil.setCylinderDirection(this.line, dir);\n  Object3DUtil.setCylinderDirection(this.cone, dir);\n};\n\nFatArrowHelper.prototype.setLength = function (length, lineWidth, headLength, headWidth) {\n\n  if (lineWidth === undefined) lineWidth = 1;\n  if (headLength === undefined) headLength = 0.2 * length;\n  if (headWidth === undefined) headWidth = lineWidth + 0.2 * headLength;\n\n  this.remove(this.line);\n  this.length = length;\n  this.line = Object3DUtil.makeColumn(this.start, this.dir, this.length - headLength,\n    lineWidthToUnit(lineWidth) / 2, this.material);\n  this.add(this.line);\n\n  this.cone.scale.set(headWidth, headLength, headWidth);\n  var end = this.start.clone().add(this.dir.clone().multiplyScalar(this.length));\n  this.cone.position.copy(end);\n  this.cone.updateMatrix();\n};\n\nvar AxesDirs = [ new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)];\nvar AxesColors = [ new THREE.Color(0xff0000), new THREE.Color(0x00ff00), new THREE.Color(0x0000ff) ];\nvar FatAxesHelper = function (length, lineWidth, origin, quaternion) {\n  THREE.Group.call(this);\n  this.name = 'Axes';\n\n  if (origin) {\n    this.position.copy(origin);\n  }\n  if (quaternion) {\n    this.quaternion.copy(quaternion);\n  }\n  this.length = length || 1;\n  this.lineWidth = lineWidth || 1;\n  this.axes = [];\n  for (var i = 0; i < AxesDirs.length; i++) {\n    this.axes[i] = new FatArrowHelper(AxesDirs[i], new THREE.Vector3(), this.length, this.lineWidth, undefined, undefined, AxesColors[i]);\n    this.add(this.axes[i]);\n  }\n};\n\nFatAxesHelper.prototype = Object.create(THREE.Group.prototype);\nFatAxesHelper.prototype.constructor = FatAxesHelper;\n\nFatAxesHelper.prototype.update = function () {\n  if (this.object) {\n    this.object.updateMatrixWorld();\n    this.position.setFromMatrixPosition(this.object.matrixWorld);\n    this.object.getWorldQuaternion(this.quaternion);\n  }\n};\n\nFatAxesHelper.prototype.attach = function (object) {\n  this.object = object;\n  this.update();\n};\n\nFatAxesHelper.prototype.detach = function () {\n  this.object = null;\n  this.update();\n};\n\nmodule.exports = { BoxMinMax: BoxMinMaxHelper, OBB: OBBHelper, Lines: LinesHelper, FatLines: FatLinesHelper, FatArrow: FatArrowHelper, FatAxes: FatAxesHelper };\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/MeshHelpers.js?");

/***/ }),

/***/ "./js/lib/geo/MeshSampling.js":
/*!************************************!*\
  !*** ./js/lib/geo/MeshSampling.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar ConnectivityGraph = __webpack_require__(/*! geo/ConnectivityGraph2 */ \"./js/lib/geo/ConnectivityGraph2.js\");\nvar Distances = __webpack_require__(/*! geo/Distances */ \"./js/lib/geo/Distances.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar TriangleAccessor = __webpack_require__(/*! geo/TriangleAccessor */ \"./js/lib/geo/TriangleAccessor.js\");\nvar MaterialHelper = __webpack_require__(/*! gfx/MaterialHelper */ \"./js/lib/gfx/MaterialHelper.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar ViewUtils = __webpack_require__(/*! gfx/ViewUtils */ \"./js/lib/gfx/ViewUtils.js\");\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Utility functions for sampling meshes\n * @module MeshSampling\n * @memberOf geo\n */\nvar MeshSampling = {};\n\nfunction findMatchingMesh(meshes, mesh, face) {\n  return _.find(meshes, function(candidateMesh) {\n    if (candidateMesh instanceof THREE.Mesh) {\n      return mesh.uuid === candidateMesh.uuid;\n    } else if (candidateMesh.mesh && candidateMesh.faceIndices) {\n      return mesh.uuid === candidateMesh.mesh.uuid && _.indexOf(candidateMesh.faceIndices, face.index) >= 0;\n    }\n  });\n}\n\nfunction identifyInnerRedundantSurfaces(object3D, visible, opts) {\n  opts = opts || {};\n  _.defaults(opts, { ignoreAllLowScoringMaterials: false, minMaterialScore: 0.1, nsamples: 0,\n    restrictRedundantToWhiteMaterial: false, checkReverseFaces: false });\n  console.log('got opts for identifyInnerRedundantSurfaces', opts);\n  Object3DUtil.getBoundingBox(object3D);\n  // Identify white surfaces that are inner and not too useful (appears in models from trimble 3d warehouse)\n  // Consider white material with no transparency or textures\n  var checkHausdorffDistance = !opts.ignoreAllLowScoringMaterials;\n  var threshold = opts.minMaterialScore;\n  var epsilon = opts.epsilon || 0;\n  var checkReverseFaces = opts.checkReverseFaces;\n  console.time('identifyInnerRedundantSurfaces');\n  function isWhiteMat(material) {\n    var isOpaque = !material.transparent || material.opacity === 1;\n    var hasTexture = material.map || material.bumpMap || material.normalMap || material.specularMap || material.envMap;\n    var isWhite = (material.color.r === 1) && (material.color.g === 1) && (material.color.b === 1);\n    return isOpaque && !hasTexture && isWhite;\n  }\n  var materials = Object3DUtil.getMaterialsMap(object3D);\n  if (checkReverseFaces) {\n    var connectivityGraphs = {};\n    _.each(materials, function (material, k) {\n      if (material.type === 'material') {\n        if (material.meshes) {\n          _.each(material.meshes, function (m, i) {\n            if (m.mesh && m.faceIndices) {\n              var mesh = m.mesh;\n              if (!connectivityGraphs[mesh.geometry.id]) {\n                connectivityGraphs[mesh.geometry.id] = new ConnectivityGraph(mesh.geometry, true);\n              }\n              var faceReversals = connectivityGraphs[mesh.geometry.id].getReverseFaceMappings();\n              var facesByReversalMaterial = _.groupBy(m.faceIndices, function (fi) {\n                if (faceReversals[fi] && faceReversals[fi].length) {\n                  var materialIndices = _.uniq(_.map(faceReversals[fi], function (fi2) {\n                    return GeometryUtil.getFaceMaterialIndex(mesh.geometry, fi2);\n                  }));\n                  return materialIndices[0];\n                } else {\n                  return -1;\n                }\n              });\n              m.facesIndicesByReversalMaterial = facesByReversalMaterial;\n            }\n          });\n        }\n      }\n    });\n  }\n  var materialScores = computeMaterialScores(object3D, visible);\n  _.each(materialScores, function(v,k) {\n    var material = materials[k];\n    if (material) {\n      material.score = v;\n      material.isWhite = isWhiteMat(material.material);\n      //console.log('material', material.material.id, material.material.name, material.score, material.isWhite);\n    } else {\n      console.log('Cannot find material', k);\n    }\n  });\n  var possibleRedundantMaterials = [];\n  var keepMeshes = [];\n  _.each(materials, function(material,k) {\n    if (material.type === 'material') {\n      if ((!opts.restrictRedundantToWhiteMaterial || material.isWhite) && material.score < threshold) {\n        possibleRedundantMaterials.push(material);\n      } else if (material.meshes) {\n        Array.prototype.push.apply(keepMeshes, material.meshes);\n      }\n    }\n  });\n  possibleRedundantMaterials = _.sortBy(possibleRedundantMaterials, function(m) { return [m.isWhite? 1 : 0, -m.score]; });\n  var redundantMaterials = [];\n  var notReallyRedundantMaterials = [];\n  var redundantMeshes = [];\n  var partlyRedundantMaterials = [];\n  //console.log(possibleRedundantMaterials);\n  var sampler = {\n    sampleMeshes: function(meshes, nsamples) {\n      var samples = MeshSampling.getMeshesSurfaceSamples(meshes, nsamples, {\n        rng: opts.rng,\n        skipUVColors: true\n      });\n      _.each(samples, function(meshSamples,index) {\n        _.each(meshSamples, function(s,index) {\n          s.meshIndex = index;\n        });\n      });\n      return samples;\n    }\n  };\n  for (var i = 0; i < possibleRedundantMaterials.length; i++) {\n    var material = possibleRedundantMaterials[i];\n    console.log('Testing material', material.material.name, material.isWhite, material.score);\n    if (material.meshes && material.meshes.length) {\n        // compute directed hausdorff distance from meshes with this material to meshes with other materials\n      var okayMatMeshes = [];\n      var redundantMatMeshes = [];\n      var meshesToConsider = [];\n      for (var j = 0; j < material.meshes.length; j++) {\n        var mesh = material.meshes[j];\n        if (mesh.facesIndicesByReversalMaterial) {\n          _.each(mesh.facesIndicesByReversalMaterial, function(faceIndices, mid) {\n            var split = {\n              mesh: mesh.mesh,\n              faceIndices: faceIndices,\n              materialIndex: mesh.mesh.materialIndex\n            };\n            console.log('considering split', material.material.name, mesh.mesh.userData.id, faceIndices.length, mid);\n            if (mid >= 0) {\n              var isReverseOfKeepMesh = _.find(keepMeshes, function(km) {\n                if (km.mesh && km.faceIndices) {\n                  return km.mesh.id === mesh.mesh.id && mid == km.materialIndex;\n                }\n              });\n              if (isReverseOfKeepMesh) {\n                redundantMatMeshes.push(split);\n                redundantMeshes.push(split);\n                console.log('redundant split', material.material.name, mesh.mesh.userData.id, faceIndices.length, mid);\n              } else {\n                meshesToConsider.push(split);\n              }\n            } else {\n              meshesToConsider.push(split);\n            }\n          });\n        } else {\n          meshesToConsider.push(mesh);\n        }\n      }\n      for (var j = 0; j < meshesToConsider.length; j++) {\n        var mesh = meshesToConsider[j];\n        var opts = { all: true, shortCircuit: { maxDistSq: epsilon*2 }, sampler: sampler, nsamples: opts.nsamples };\n        var distSq = checkHausdorffDistance? Distances.MeshesMeshesHausdorffDirectedDistanceSquared([mesh],\n          keepMeshes, opts) : null;\n        if (distSq && opts.all) {\n          distSq.meshIndex0 = j;\n        }\n        //console.log('got distSq', distSq);\n        if (!distSq || distSq.distanceSq < epsilon) {\n          redundantMeshes.push(mesh);\n          redundantMatMeshes.push(mesh);\n        } else {\n          // TODO: consider more intelligent updating of keepMeshes\n          // console.log('got distSq', distSq, distSq.point0.distanceToSquared(distSq.point1), epsilon);\n          keepMeshes.push(mesh);\n          okayMatMeshes.push(mesh);\n        }\n      }\n      if (okayMatMeshes.length === 0) {\n        console.log('Rejecting material', material.material.name);\n        redundantMaterials.push(material);\n      } else if (redundantMatMeshes.length === 0) {\n        console.log('Keeping material', material.material.name);\n        notReallyRedundantMaterials.push(material);\n      } else {\n        // There is mix of keep and reject\n        console.log('Mixed material', material.material.name);\n        console.log('Rejecting meshes', _.map(redundantMatMeshes, function(x) {\n          if (x instanceof THREE.Mesh) {\n            return x.userData.id;\n          } else if (x.mesh && x.faceIndices) {\n            return x.mesh.userData.id + ':' + x.faceIndices.length;\n          }\n        }));\n        partlyRedundantMaterials.push(material);\n      }\n\n    }\n  }\n  console.timeEnd('identifyInnerRedundantSurfaces');\n  return {\n    redundantMeshes: redundantMeshes,\n    redundantMaterials: redundantMaterials,\n    partlyRedundantMaterials: partlyRedundantMaterials,\n    keepMeshes: keepMeshes,\n    isRedundant: function(mesh, face) {\n      return findMatchingMesh(redundantMeshes, mesh, face);\n    },\n    isKeep: function(mesh, face) {\n      return findMatchingMesh(keepMeshes , mesh, face);\n    }\n  };\n}\n\nfunction computeMaterialScores(object3D, visible) {\n  var visibleMaterialCounts = {};\n  var materialAreas = {};\n  //var meshTriCounts = {};\n  Object3DUtil.traverseMeshes(object3D, false, function(m) {\n    var T = new TriangleAccessor(m);\n    var numTris = T.numTriangles();\n    //meshTriCounts[m.id] = numTris;\n    m.updateMatrixWorld();\n    var meshMaterials = (m.material instanceof THREE.MultiMaterial)?  m.material.materials : (Array.isArray(m.material)? m.material : [m.material]);\n    for (var i = 0; i < numTris; i++) {\n      var face = T.get(i);\n      var faceArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, m.matrixWorld);\n      var matIndex = face.materialIndex || 0;\n      var material = meshMaterials[matIndex];\n      materialAreas[material.id] = (materialAreas[material.id] || 0) + faceArea;\n      visibleMaterialCounts[material.id] = (visibleMaterialCounts[material.id] || 0) + (_.get(visible, [m.id, face.index]) || 0);\n    }\n  });\n  //var totalTris = _.sum(_.values(meshTriCounts));\n  var totalVisible = _.sum(_.values(visibleMaterialCounts));\n  var nMaterials = _.size(visibleMaterialCounts);\n  var sumArea = _.sum(_.values(materialAreas));\n  var materialScores = _.mapValues(materialAreas, function(c,mid) {\n    var areaFraction = c/sumArea;\n    var vc = visibleMaterialCounts[mid] || 0;\n    var materialVisibility = (vc+1)/(totalVisible+nMaterials);\n    return _.clamp(materialVisibility/areaFraction, 0, 1);\n  });\n  return materialScores;\n}\n\nfunction getMaterialScore(materialScores, mesh, face) {\n  var meshMaterials = (mesh.material instanceof THREE.MultiMaterial)?  mesh.material.materials : (Array.isArray(mesh.material)? mesh.material : [mesh.material]);\n  var matIndex = face.materialIndex || 0;\n  var material = meshMaterials[matIndex];\n  return materialScores[material.id];\n}\n\n// Predefined face weighing functions\nMeshSampling.WeightFns = [\n  {\n    name: 'area',\n    description: 'Weight each face by surface area (in world)',\n    create: function () {\n      return function (mesh, face) {\n        var faceArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, mesh.matrixWorld);\n        return faceArea;\n      };\n    }\n  },\n  {\n    name: 'areaWithoutInnerRedundantMaterials',\n    description: 'Weight each face by surface area (in world) and discounting inner redundant meshes with white materials',\n    /**\n     * Create sampling function that weights each face by visibility (ignoring inner redundant surfaces)\n     * @param opts\n     * @param [opts.visibleTriangles] {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n     * @param [opts.width] {int} Width of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.height] {int} Height of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.scene] {THREE.Object3D} Scene to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.checkReverseFaces] {boolean} Whether to explicitly check and align reversed faces\n     * @param [opts.restrictRedundantToWhiteMaterial] {boolean} Whether to restrict redundant materials to just white materials\n     * @param [opts.ignoreAllLowScoringMaterials] {boolean} Whether material with low scores should be ignored\n     * @param [opts.minMaterialScore] {number} Threshold for low visibility material\n     * @param [opts.nsamples] {int} If not `ignoreAllLowScoringMaterials`, sample this many points for hausdorff distance computation.\n     * @param [opts.epsilon] {number} Epsilon distance threshold for considering a mesh to be redundant\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function (opts) {\n      var visible = opts.visibleTriangles || ViewUtils.identifyVisibleTriangles(opts);\n      var redundantInfo = identifyInnerRedundantSurfaces(opts.scene, visible,\n        _.pick(opts, ['restrictRedundantToWhiteMaterial', 'ignoreAllLowScoringMaterials', 'checkReverseFaces',\n          'minMaterialScore', 'nsamples', 'rng', 'epsilon']));\n      return function (mesh, face) {\n        var faceArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, mesh.matrixWorld);\n        var isRedundant = redundantInfo.isRedundant(mesh, face);\n        return (!isRedundant) ? faceArea : 0;\n      };\n    }\n  },\n  {\n    name: 'visibleWithArea',\n    description: 'Weight each face by visible surface area (in world)',\n    /**\n     * Create sampling function that weights each face by visibility\n     * @param opts\n     * @param [opts.visibleTriangles] {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n     * @param [opts.width] {int} Width of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.height] {int} Height of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.scene] {THREE.Object3D} Scene to render (required if `opts.visibleTriangles` is not specified)\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function (opts) {\n      //console.log('identifyVisibleTriangles', opts);\n      var visible = opts.visibleTriangles || ViewUtils.identifyVisibleTriangles(opts);\n      return function (mesh, face) {\n        var faceArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, mesh.matrixWorld);\n        var isVisible = (visible[mesh.id] && visible[mesh.id][face.index]) ? 1 : 0;\n        return (isVisible) ? faceArea : 0;\n      };\n    }\n  },\n  {\n    name: 'areaWithVisibleMaterial',\n    description: 'Weight each face by visibility (taking into account material visibility)',\n    /**\n     * Create sampling function that weights each face by visibility\n     * @param opts\n     * @param [opts.visibleTriangles] {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n     * @param [opts.width] {int} Width of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.height] {int} Height of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.scene] {THREE.Object3D} Scene to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.ignoreMaterialWithMinScore] {boolean} Whether material with low scores should be ignored\n     * @param [opts.minMaterialScoreRange] {number[]} Min and max (as array) of low and high material score\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function (opts) {\n      //console.log('identifyVisibleTriangles', opts);\n      var visible = opts.visibleTriangles || ViewUtils.identifyVisibleTriangles(opts);\n      //var meshCounts = _.mapValues(visible, function(mv, mid) {\n      //  return _.sum(_.values(mv));\n      //});\n      //var totalVisible = _.sum(_.values(meshCounts));\n      var materialScores = computeMaterialScores(opts.scene, visible);\n      var minMaterialScore = _.min(_.values(materialScores));\n      var materialScoreThreshold = (_.size(materialScores) > 1 && opts.ignoreMaterialWithMinScore)? minMaterialScore : 0;\n      if (opts.minMaterialScoreRange) {\n        materialScoreThreshold = _.clamp(materialScoreThreshold, opts.minMaterialScoreRange[0], opts.minMaterialScoreRange[1]);\n      }\n      console.log('minMaterialScore=' + minMaterialScore + ', materialScoreThreshold=' + materialScoreThreshold);\n      //console.log('materialScores', materialScores, materialAreas, visibleMaterialCounts, sumArea, totalVisible, nMaterials);\n      return function (mesh, face) {\n        var materialScore = getMaterialScore(materialScores, mesh, face);\n        var faceArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, mesh.matrixWorld);\n        //var isVisible = (visible[mesh.id] && visible[mesh.id][face.index]) ? 1 : 0;\n        return (materialScore > materialScoreThreshold)? faceArea : 0;\n\n        //var visibility = (totalVisible && visible[mesh.id] && visible[mesh.id][face.index])? visible[mesh.id][face.index]/totalVisible : 0;\n        //return materialScore*visibility;\n      };\n    }\n  },\n  {\n    name: 'visibility',\n    description: 'Weight each face by visibility',\n    /**\n     * Create sampling function that weights each face by visibility\n     * @param opts\n     * @param [opts.visibleTriangles] {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n     * @param [opts.width] {int} Width of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.height] {int} Height of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.scene] {THREE.Object3D} Scene to render (required if `opts.visibleTriangles` is not specified)\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function (opts) {\n      //console.log('identifyVisibleTriangles', opts);\n      var visible = opts.visibleTriangles || ViewUtils.identifyVisibleTriangles(opts);\n      var meshCounts = _.mapValues(visible, function(mv, mid) {\n        return _.sum(_.values(mv));\n      });\n      var totalVisible = _.sum(_.values(meshCounts));\n      return function (mesh, face) {\n        var visibility = (totalVisible && visible[mesh.id] && visible[mesh.id][face.index])? visible[mesh.id][face.index]/totalVisible : 0;\n        return visibility;\n      };\n    }\n  },\n  {\n    name: 'smoothedVisibility',\n    description: 'Weight each face by visibility (with add one smoothing)',\n    /**\n     * Create sampling function that weights each face by visibility\n     * @param opts\n     * @param [opts.visibleTriangles] {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n     * @param [opts.width] {int} Width of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.height] {int} Height of image to render (required if `opts.visibleTriangles` is not specified)\n     * @param [opts.scene] {THREE.Object3D} Scene to render (required if `opts.visibleTriangles` is not specified)\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function (opts) {\n      //console.log('identifyVisibleTriangles', opts);\n      var visible = opts.visibleTriangles || ViewUtils.identifyVisibleTriangles(opts);\n      var meshCounts = _.mapValues(visible, function(mv, mid) {\n        return _.sum(_.values(mv));\n      });\n      var meshTriCounts = {};\n      Object3DUtil.traverseMeshes(opts.scene, false, function(m) {\n        meshTriCounts[m.id] = GeometryUtil.getGeometryFaceCount(m);\n      });\n      var totalVisible = _.sum(_.values(meshCounts)) + _.sum(_.values(meshTriCounts));\n      return function (mesh, face) {\n        var visibility = (totalVisible && visible[mesh.id] && visible[mesh.id][face.index])? (1+visible[mesh.id][face.index])/totalVisible : 1/totalVisible;\n        return visibility;\n      };\n    }\n  },\n  {\n    name: 'areaWithNormal',\n    description: 'Weight each face by surface area and similarity to target normal',\n    /**\n     * Create sampling function that weights each face by visibility\n     * @param opts\n     * @param [opts.targetNormal] {THREE.Vector3} Target normal to be similar to\n     * @returns {function(THREE.Mesh, MeshSampling.Face): number}\n     */\n    create: function(opts) {\n      return function(mesh, face) {\n        var targetNormal = opts.targetNormal;\n        var triArea = GeometryUtil.triangleAreaWithTransform(face.va, face.vb, face.vc, mesh.matrixWorld);\n        if (targetNormal) {\n          if (!mesh.__cachedTargetVector) {\n            mesh.updateMatrixWorld();\n            var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n            var normalMatrixInverse = new THREE.Matrix3().getInverse(normalMatrix);\n            mesh.__cachedTargetVector = targetNormal.clone().applyMatrix3(normalMatrixInverse).normalize();\n          }\n          var triNormal = GeometryUtil.triangleNormal(face.va, face.vb, face.vc);\n          var weight = mesh.__cachedTargetVector.dot(triNormal);\n          weight = Math.max(weight, 0);\n          return weight * triArea;\n        } else {\n          return triArea;\n        }\n      };\n    },\n    dispose: function(mesh) {\n      delete mesh.__cachedTargetVector;\n    }\n  }\n];\n\nMeshSampling.WeightFnsByName = _.keyBy(MeshSampling.WeightFns, 'name');\n\n/**\n * Helper function for sampling mesh points from a object3D\n * @param object3D {THREE.Object3D} Object to sample from\n * @param nsamples {int} Number of samples to take\n * @param opts Additional sampling options\n * @param [opts.weightFn] {function(THREE.Mesh,MeshSampling.Face): number|{name:string, args:{}}|string} Function for weighted scoring of mesh faces\n * @param [opts.scoreFn] {function(THREE.Mesh,MeshSampling.Face): number|{name:string, args:{}}|string} Function for scoring final sample\n * @param [opts.recursive=false] {boolean} Whether to sample from child model instances as well\n * @param [opts.rng] {math.RNG} Random number generator\n * @param [opts.skipUVColors] {boolean} Whether to skip color sampling\n * @param [opts.handleMaterialSide] {boolean} Whether to negate normal based on material side\n * @param [opts.userDataFields] {string[]} Array of mesh user data fields to include\n * @returns {Array.<MeshSampling.PointSample>|*}\n */\nMeshSampling.sampleObject = function(object3D, nsamples, opts) {\n  var weightFn, scoreFn;\n  object3D.updateMatrixWorld(); // Make sure matrix world updated\n  if (opts.weightFn) {\n    if (_.isPlainObject(opts.weightFn)) {\n      weightFn = MeshSampling.WeightFnsByName[opts.weightFn.name];\n      opts = _.defaults({\n        weightFn: weightFn.create(opts.weightFn.args)\n      }, opts);\n    } else if (_.isString(opts.weightFn)) {\n      weightFn = MeshSampling.WeightFnsByName[opts.weightFn];\n      opts = _.defaults({\n        weightFn: weightFn.create()\n      }, opts);\n    }\n  }\n  if (opts.scoreFn) {\n    if (_.isPlainObject(opts.scoreFn)) {\n      scoreFn = MeshSampling.WeightFnsByName[opts.scoreFn.name];\n      opts = _.defaults({\n        scoreFn: scoreFn.create(opts.scoreFn.args)\n      }, opts);\n    } else if (_.isString(opts.scoreFn)) {\n      scoreFn = MeshSampling.WeightFnsByName[opts.scoreFn];\n      opts = _.defaults({\n        scoreFn: scoreFn.create()\n      }, opts);\n    }\n  }\n  var meshes;\n  if (Array.isArray(object3D)) {\n    meshes = [];\n    for (var i = 0; i < object3D.length; i++) {\n      meshes = Object3DUtil.getVisibleMeshList(object3D[i], opts.recursive, meshes);\n    }\n  } else {\n    meshes = Object3DUtil.getVisibleMeshList(object3D, opts.recursive);\n  }\n  var samples = MeshSampling.getMeshesSurfaceSamples(meshes, nsamples, opts);\n  if (weightFn && weightFn.dispose) {\n    for (var i = 0; i < meshes.length; i++) {\n      weightFn.dispose(meshes[i]);\n    }\n  }\n  if (scoreFn && scoreFn.dispose) {\n    for (var i = 0; i < meshes.length; i++) {\n      scoreFn.dispose(meshes[i]);\n    }\n  }\n  return samples;\n};\n\n/**\n * Sampled point from a mesh (normals, uv, color are interpolated from vertices)\n * @typedef {object} PointSample\n * @property face\n * @property point {THREE.Vector3} Position of sample in local coordinates\n * @property worldPoint {THREE.Vector3} Position of sample in world coordinates\n * @property normal {THREE.Vector3} Normal of sample in local coordinates\n * @property worldNormal {THREE.Vector3} Normal of sample in world coordinates\n * @property uv {THREE.Vector2} UV of sample\n * @property color {THREE.Color} Color of sample (combined material and actual color)\n * @property opacity {float} Opacity of sample (from 0 to 1)\n * @property vertexColor {THREE.Color} Basic color of sample\n * @static\n */\n\n/**\n * Samples point on mesh surfaces from an array of meshes\n * @param meshes {Array<THREE.Mesh>} Meshes to sample from\n * @param numSamples {int} Number of samples to draw\n * @param [opts] {{rng: math.RNG, skipUVColors: boolean, handleMaterialSide}}\n * @returns {Array<MeshSampling.PointSample>}\n * @static\n */\nfunction getMeshesSurfaceSamples(meshes, numSamples, opts) {\n  opts = opts || {};\n  var meshWeights = _.map(meshes, function (meshOrPartial) {\n    var mesh;\n    var faceIndices;\n    if (meshOrPartial instanceof THREE.Mesh) {\n      mesh = meshOrPartial;\n    } else if (meshOrPartial.mesh && meshOrPartial.faceIndices) {\n      mesh = meshOrPartial.mesh;\n      faceIndices = meshOrPartial.faceIndices;\n    } else {\n      throw \"Unsupported mesh type\";\n    }\n    if (opts.weightFn) {\n      if (!_.isFunction(opts.weightFn)) {\n        console.error('Invalid weightFn specification', opts);\n      }\n      // Custom weight function\n      var T = new TriangleAccessor(mesh);\n      var numTris = faceIndices? faceIndices.length : T.numTriangles();\n      var meshWeight = 0;\n      for (var i = 0; i < numTris; i++) {\n        var iTri = faceIndices? faceIndices[i] : i;\n        var face = T.get(iTri);\n        meshWeight += opts.weightFn(mesh, face); // NOTE: face is not transformed\n      }\n      return meshWeight;\n    } else {\n      if (faceIndices) {\n        return Object3DUtil.getSurfaceArea(mesh, {\n          triFilter: function(v0,v1,v2,iFace) {\n            return faceIndices.indexOf(iFace) >= 0;\n          }\n        });\n      } else {\n        return Object3DUtil.getSurfaceArea(mesh);\n      }\n    }\n  });\n  var totalWeight = _.sum(meshWeights);\n  //console.log('meshWeights', meshWeights);\n  var samplesPerMesh = _.map(meshWeights, function (a) {\n    return Math.max(0, Math.ceil(a / totalWeight * numSamples));\n  });\n  var samples = _.map(meshes, function (m, i) {\n    return MeshSampling.getMeshSurfaceSamples(m, samplesPerMesh[i], opts);\n  });\n  return samples;\n}\nMeshSampling.getMeshesSurfaceSamples = getMeshesSurfaceSamples;\n\n/**\n * Samples a single mesh\n * @param mesh {THREE.Mesh|geo.PartialMesh} Mesh to sample from\n * @param numSamples {int} Number of samples to draw\n * @param [opts] {{rng: math.RNG, skipUVColors: boolean, handleMaterialSide: boolean, userDataFields: string[]}}\n * @returns {Array<MeshSampling.PointSample>}\n * @static\n */\nfunction getMeshSurfaceSamples(mesh, numSamples, opts) {\n  opts = opts || {};\n  var faceIndices;\n  if (mesh instanceof THREE.Mesh) {\n    // use mesh as is;\n  } else if (mesh.mesh && mesh.faceIndices) {\n    faceIndices = mesh.faceIndices;\n    mesh = mesh.mesh;\n  } else {\n    throw \"Unsupported mesh type\";\n  }\n\n  var rng = opts.rng || RNG.global;\n  var face, i;\n  var T = new TriangleAccessor(mesh);\n  var numTris = faceIndices? faceIndices.length : T.numTriangles();\n  var result = [];\n  if (numTris < 1) {\n    return result;\n  }\n\n  // precompute face areas\n  var totalWeight = 0;\n  var cumulativeWeights = [];\n  for (i = 0; i < numTris; i++) {\n    var iTri = faceIndices? faceIndices[i] : i;\n    face = T.get(iTri);\n    if (opts.weightFn) {\n      totalWeight += opts.weightFn(mesh, face);\n    } else {\n      var triArea = GeometryUtil.triangleArea(face.va, face.vb, face.vc);\n      totalWeight += triArea;\n    }\n    cumulativeWeights.push(totalWeight);\n  }\n\n  // pick random face weighted by face area\n  mesh.updateMatrixWorld();\n  var normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);\n  for (i = 0; i < numSamples; i++) {\n    var r = rng.random() * totalWeight;\n    var index = _.sortedIndex(cumulativeWeights, r);\n    var iTri = faceIndices? faceIndices[index] : index;\n    face = T.get(iTri);\n    face.sampleWeight = cumulativeWeights[index] - (cumulativeWeights[index-1] || 0);\n    if (opts.scoreFn) {\n      face.score = opts.scoreFn(mesh, face);\n    }\n    var ruv = randomBarycentricCoords(rng);\n    var p  = baryCentricInterpolation(ruv, face.va, face.vb, face.vc);\n    var n  = face.hasNormals ? baryCentricInterpolation(ruv, face.na, face.nb, face.nc).normalize() : null;\n    var uv  = face.hasUVs ? baryCentricInterpolation(ruv, face.uva, face.uvb, face.uvc) : null;\n    var c  = face.hasVertexColors ? baryCentricInterpolation(ruv, face.ca, face.cb, face.cc) : null;\n    if (opts.handleMaterialSide) {\n      var material = getMaterial(mesh, face.materialIndex);\n      if (material.side === THREE.DoubleSide) {\n        if (rng.random() > 0.5) {\n          n.negate();\n        }\n      } else if (material.side === THREE.BackSide) {\n        n.negate();\n      }\n    }\n    var sample = { /*mesh: mesh, */face: face,\n      point: p, worldPoint: p.clone().applyMatrix4(mesh.matrixWorld),\n      normal: n, worldNormal: n? n.clone().applyMatrix3(normalMatrix).normalize() : null,\n      uv: uv, vertexColor: c\n    };\n    if (opts.userDataFields) {\n      _.merge(sample, _.pick(mesh.userData, opts.userDataFields));\n    }\n    if (opts.convertSample) {\n      result[i] = opts.convertSample(sample);\n    } else {\n      result[i] = sample;\n    }\n  }\n\n  if (!opts.skipUVColors) {\n    populateUVColors(mesh, result);\n  }\n  return result;\n}\nMeshSampling.getMeshSurfaceSamples = getMeshSurfaceSamples;\n\n/**\n * @typedef MeshSampling.Face\n * @type {object}\n * @property {int} index\n * @property {THREE.Vector3} va - Vertex position\n * @property {THREE.Vector3} vb - Vertex position\n * @property {THREE.Vector3} vc - Vertex position\n * @property {THREE.Vector3} [na] - Vertex normal\n * @property {THREE.Vector3} [nb] - Vertex normal\n * @property {THREE.Vector3} [nc] - Vertex normal\n * @property {THREE.Color} [ca] - Vertex color\n * @property {THREE.Color} [cb] - Vertex color\n * @property {THREE.Color} [cc] - Vertex color\n * @property {THREE.Vector2} [uva] - Vertex uv\n * @property {THREE.Vector2} [uvb] - Vertex uv\n * @property {THREE.Vector2} [uvc] - Vertex uv\n */\n\nfunction randomBarycentricCoords(rng) {\n  rng = rng || RNG.global;\n  var u = rng.random();\n  var v = rng.random();\n  if ((u + v) > 1) {\n    u = 1 - u;\n    v = 1 - v;\n  }\n  return { u: u, v: v };\n}\n\nfunction baryCentricInterpolation(uv, a, b, c) {\n  var x = a.clone();\n  x.multiplyScalar(uv.u);\n  var y = b.clone();\n  y.multiplyScalar(uv.v);\n  x.add(y);\n  y.copy(c);\n  y.multiplyScalar(1 - uv.u - uv.v);\n  x.add(y);\n  return x;\n}\n\nfunction getMaterial(mesh, materialIndex) {\n  var material = mesh.material;\n  if (Array.isArray(material)) {\n    material = material[materialIndex];\n  } else if (material instanceof THREE.MultiMaterial) {\n    material = material.materials[materialIndex];\n  }\n  return material;\n}\n\n/**\n * Populate each sample with color and opacity\n * @param mesh {THREE.Mesh}\n * @param samples {Array<{uv: THREE.Vector2, face: {materialIndex: int}>}\n * @private\n */\nfunction populateUVColors (mesh, samples) {\n  var texuv = new THREE.Vector2();\n  var warned = {};\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    var material = mesh.material;\n    if (Array.isArray(material)) {\n      var materialIndex = sample.face.materialIndex;\n      material = material[materialIndex];\n    } else if (material instanceof THREE.MultiMaterial) {\n      var materialIndex = sample.face.materialIndex;\n      material = material.materials[materialIndex];\n    }\n\n    if (material.transparent) {\n      sample.opacity = material.opacity;\n    } else {\n      sample.opacity = 1;\n    }\n\n    if (material.vertexColors === THREE.VertexColors) {\n      sample.color = sample.vertexColor;\n    }\n\n    var textureOpacity = 1;\n    if (material.map && sample.uv) {\n      if (!material.map.imageData) {\n        material.map.imageData = MaterialHelper.getImageData(material.map.image);\n      }\n      if (material.map.imageData) {\n        texuv.copy(sample.uv);\n        material.map.transformUv(texuv);\n        var pix = MaterialHelper.getPixelAtUV(material.map.imageData, texuv.x, texuv.y);\n        if (Colors.isValidColor(pix)) {\n          sample.color = new THREE.Color(pix.r / 255, pix.g / 255, pix.b / 255);  // overwrites color\n          // Handle alpha from transparent PNGs\n          textureOpacity = pix.a/255;\n        } else {\n          console.log('MeshSampling: Invalid color from material map', material.map, sample, texuv);\n        }\n      } else {\n        if (!warned[material.map.name]) {\n          console.warn('MeshSampling: Cannot get image data for texture', material.map.name);\n          warned[material.map.name] = 1;\n        }\n      }\n    }\n\n    if (textureOpacity < 1 && material.transparent) {\n      sample.opacity = textureOpacity;\n    }\n    if (material.color) {\n      if (!sample.color) {  // just copy material color\n        sample.color = material.color;\n      } else {\n        // TODO: Combine material.color with sampled texture color\n        if (textureOpacity < 1) {\n          // Handles when texture is a bit transparent\n          var matWeight = 1 - textureOpacity;\n          var sampleWeight = textureOpacity;\n          sample.color.setRGB(sample.color.r*sampleWeight + material.color.r*matWeight,\n            sample.color.g*sampleWeight + material.color.g*matWeight,\n            sample.color.b*sampleWeight + material.color.b*matWeight);\n        }\n      }\n    }\n  }\n}\n\nMeshSampling.getDefaultSampler = function(rng) {\n  rng = rng || RNG.global;\n  return {\n    sampleMeshes: function(meshes, nsamples) {\n      var samples = MeshSampling.getMeshesSurfaceSamples(meshes, nsamples, {\n        rng: rng,\n        skipUVColors: true\n      });\n      _.each(samples, function(meshSamples,index) {\n        _.each(meshSamples, function(s,index) {\n          s.meshIndex = index;\n        });\n      });\n      return samples;\n    }\n  };\n}\n\nmodule.exports = MeshSampling;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/MeshSampling.js?");

/***/ }),

/***/ "./js/lib/geo/MeshSegmentator.js":
/*!***************************************!*\
  !*** ./js/lib/geo/MeshSegmentator.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const ConnectivityGraph = __webpack_require__(/*! geo/ConnectivityGraph2 */ \"./js/lib/geo/ConnectivityGraph2.js\");\nconst BinaryHeap = __webpack_require__(/*! ds/BinaryHeap */ \"./js/lib/ds/BinaryHeap.js\");\nconst MeshFaces = __webpack_require__(/*! geo/MeshFaces */ \"./js/lib/geo/MeshFaces.js\");\nconst TriangleAccessor = __webpack_require__(/*! geo/TriangleAccessor */ \"./js/lib/geo/TriangleAccessor.js\");\nconst DSUtil = __webpack_require__(/*! ds/util */ \"./js/lib/ds/util.js\");\n\nclass PlanarMeshSegment extends MeshFaces {\n  constructor(mesh, faceIndices, normal, normSimThreshold = 0) {\n    super(mesh, faceIndices);\n    this.normal = normal;\n    this.normSimThreshold = normSimThreshold;\n  }\n}\n\nObject.assign(PlanarMeshSegment.prototype, {\n  isCompatible: (function() {\n    const triNormal = new THREE.Vector3();\n    return function(triangle) {\n      triangle.getNormal(triNormal);\n      return this.normal.dot(triNormal) >= this.normSimThreshold;\n    };\n  }())\n});\n\nclass MeshSegmentator {\n  constructor() {\n  }\n\n  segment(mesh, opts) {\n    opts = opts || {};\n    if (opts.method === 'connectivity') {\n      return this.segmentByConnectivity(mesh, opts);\n    } else if (opts.method === 'clustering') {\n      return this.segmentByClustering(mesh, opts);\n    } else {\n      throw 'Unsupported segmentation method: ' + opts.method;\n    }\n  }\n\n  segmentByConnectivity(mesh, opts) {\n    const connectivityGraph = new ConnectivityGraph(mesh.geometry, true);\n    const triAccessor = new TriangleAccessor(mesh);\n    const nTris = triAccessor.numTriangles();\n    const indices = _.range(nTris);\n    const components = DSUtil.identifyConnectedComponents(indices, (ti1, ti2) => {\n      const neighbors = connectivityGraph.getFaceNeighbors(ti1);\n      return neighbors.indexOf(ti2) >= 0;\n    });\n    return components.map(component => new MeshFaces(mesh, component));\n  }\n\n  segmentByClustering(mesh, opts) {\n    // Greedy clustering\n    // iterate through unclustered faces and grow each segment\n    opts = opts || {};\n    const adjFaceNormSimThreshold = opts.adjFaceNormSimThreshold || 0;\n    const connectivityGraph = new ConnectivityGraph(mesh.geometry, true);\n    const unclustered = new BinaryHeap({ scoreFunc: x => { return x.area; }});\n\n    const triAccessor = new TriangleAccessor(mesh);\n    const nTris = triAccessor.numTriangles();\n    const tmpTriangle = new THREE.Triangle();\n    const faceInfos = [];\n    for (let i = 0; i < nTris; i++) {\n      triAccessor.getTriangle(i, tmpTriangle);\n      const area = tmpTriangle.getArea();\n      const normal = new THREE.Vector3();\n      tmpTriangle.getNormal(normal);\n      const faceInfo = { index: i, area:  area, normal: normal };\n      unclustered.add(faceInfo);\n      faceInfos[i] = faceInfo;\n    }\n    const clustered = new Set();   // List of clustered triangle indices\n    const surfaces = [];\n    //console.log(connectivityGraph);\n    while (!unclustered.isEmpty) {\n      // Start by grouping triangles with shared edges that have similar normals\n      const baseTriInfo = unclustered.pop();\n      if (opts.debug) {\n        console.log(\"Cluster for \" + baseTriInfo.index);\n      }\n      const baseTriNormal = baseTriInfo.normal;\n      triAccessor.getTriangle(baseTriInfo.index, tmpTriangle);\n      // TODO: surfaceId, parentSurfaceId, meshIndex\n      const surface = (opts.restrictToPlanarSurfaces)?\n        new PlanarMeshSegment(mesh, [], baseTriNormal.clone()) : new MeshFaces(mesh);\n      surfaces.push(surface);\n      const enqueued = new Set();   // List of triangle indices enqueued for processing\n      const todo = [];\n      todo.push(baseTriInfo.index);\n      enqueued.add(baseTriInfo.index);\n      while (todo.length > 0) {\n        const triIndex = todo.shift();\n        //const triVertexIndices = triAccessor.getTriangleVertexIndices(triIndex);\n        triAccessor.getTriangle(triIndex, tmpTriangle);\n        //if (opts.debug) {\n        //  console.log(\"Consider \" + triIndex + \", size=\" + JmeUtils.area(triangle) + \", normal=\" + triangle.getNormal)\n        //}\n        if (surface.isCompatible(tmpTriangle)) {\n          surface.add(triIndex);\n          clustered.add(triIndex);\n          const removed = unclustered.removeWhere(info => info.index === triIndex);\n          const currentTriNormal = faceInfos[triIndex].normal;\n\n          // look at neighbors\n          let adjacentFaces = connectivityGraph.getFaceNeighborTypes(triIndex);\n          //console.log('a1', triIndex, adjacentFaces);\n          adjacentFaces = _.filter(adjacentFaces,\n              t => !enqueued.has(t.faceIndex) && !clustered.has(t.faceIndex)  &&\n                  t.neighborType.index !== ConnectivityGraph.NeighborTypes.SHARED_VERTEX.index &&\n                  currentTriNormal.dot(faceInfos[t.faceIndex].normal) >= adjFaceNormSimThreshold);\n          adjacentFaces = _.sortBy(adjacentFaces, t => [t.neighborType.index, -faceInfos[t.faceIndex].area]);\n          //console.log('a3', adjacentFaces);\n          for (let f of adjacentFaces) {\n            todo.push(f.faceIndex);\n            enqueued.add(f.faceIndex);\n          }\n        }\n      }\n    }\n    //console.log(surfaces);\n    return surfaces;\n  }\n}\n\nmodule.exports = MeshSegmentator;\n\n//# sourceURL=webpack://STK/./js/lib/geo/MeshSegmentator.js?");

/***/ }),

/***/ "./js/lib/geo/OBB.js":
/*!***************************!*\
  !*** ./js/lib/geo/OBB.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Oriented bounding box\n * @constructor\n * @memberOf geo\n */\nvar OBB = __webpack_require__(/*! three-OBB */ \"./js/vendor/three/geo/OBB.js\");\n\n/**\n * Initializes OBB from JSON\n * @param obb {object} JSON representation\n * @param obb.centroid\n * @param obb.axesLengths\n * @param obb.normalizedAxes\n * @param [obb.dominantNormal]\n * @param [obb.metadata] Metadata about the obb\n * @returns {OBB}\n */\nOBB.prototype.fromJSON = function (obb) {\n  this.position.set(obb.centroid[0], obb.centroid[1], obb.centroid[2]);\n  this.halfSizes.set(obb.axesLengths[0], obb.axesLengths[1], obb.axesLengths[2]);\n  this.halfSizes.multiplyScalar(0.5);\n  var m = obb.normalizedAxes;\n  this.basis.set(\n    m[0], m[3], m[6], 0,\n    m[1], m[4], m[7], 0,\n    m[2], m[5], m[8], 0,\n    0, 0, 0, 1);\n  if (obb.dominantNormal) {\n    this.__dominantNormal = new THREE.Vector3(obb.dominantNormal[0], obb.dominantNormal[1], obb.dominantNormal[2]);\n  } else {\n    this.__dominantNormal = undefined;\n  }\n  this.metadata = obb.metadata;\n  this.clearCache();\n  return this;\n};\n\n/**\n * Returns serializable JSON representation\n * @returns {{centroid: number[], axesLengths: number[], normalizedAxes: number[]}}\n */\nOBB.prototype.toJSON = function () {\n  var json = {};\n  json.centroid = [this.position.x, this.position.y, this.position.z];\n  json.axesLengths = [this.halfSizes.x * 2,this.halfSizes.y * 2,this.halfSizes.z * 2];\n  var m = this.basis.elements;\n  json.normalizedAxes = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];\n  json.metadata = this.metadata;\n  var mm = this.getMinMax();\n  json.min = [mm.min.x, mm.min.y, mm.min.z];\n  json.max = [mm.max.x, mm.max.y, mm.max.z];\n  return json;\n};\n\n/**\n * Converts the OBB to a Mesh object with BoxGeometry\n */\nOBB.prototype.toMesh = function() {\n  var mesh = new THREE.Mesh(new THREE.BoxGeometry(this.halfSizes.x, this.halfSizes.y, this.halfSizes.z));\n  mesh.applyMatrix(this.basis);\n  var p = this.position;\n  mesh.applyMatrix(new THREE.Matrix4().makeTranslation(p.x, p.y, p.z));\n  return mesh;\n}\n\nOBB.prototype.dominantNormal = function () {\n  if (!this.__dominantNormal) {\n    this.__dominantNormal = this.__extractDominantNormal();\n  }\n  return this.__dominantNormal;\n};\n\nOBB.prototype.__getSmallestIndex = function() {\n  // Pick the R col with the smallest length\n  var smallestIdx = 1;\n  var r = [this.halfSizes.x, this.halfSizes.y, this.halfSizes.z];\n  if (r[0] < r[smallestIdx]) smallestIdx = 0;\n  if (r[2] < r[smallestIdx]) smallestIdx = 2;\n  return smallestIdx;\n};\n\nOBB.prototype.__extractDominantNormal = function () {\n  var smallestIdx = this.__getSmallestIndex();\n  var m = this.basis.elements;\n  var si = smallestIdx * 4;\n  return new THREE.Vector3(m[si], m[si + 1], m[si + 2]);\n};\n\nOBB.prototype.applyMatrix = function (matrix) {\n  var temp = new THREE.Matrix4();\n  temp.extractRotation(matrix);\n  this.__dominantNormal = this.__extractDominantNormal();\n  this.__dominantNormal.applyMatrix4(temp);\n\n  this.position.applyMatrix4(matrix);\n  temp.multiplyMatrices(matrix, this.basis);\n  this.basis.extractRotation(temp);\n  var v1 = new THREE.Vector3();\n  var v2 = new THREE.Vector3();\n  var v3 = new THREE.Vector3();\n  temp.extractBasis(v1,v2,v3);\n  this.halfSizes.multiply(new THREE.Vector3(v1.length(), v2.length(), v3.length()));\n  this.clearCache();\n  return this;\n};\n\nOBB.prototype.expandLengths = function (halfLengthDeltas) {\n  this.halfSizes.add(halfLengthDeltas);\n  this.clearCache();\n  return this;\n};\n\nOBB.prototype.clearCache = function () {\n  delete this.corners;\n};\n\n// Return world position given relative point, center is (0.5,0.5,0.5)\nOBB.prototype.getWorldPosition = function (relPoint, out) {\n  if (relPoint) {\n    var v = out || new THREE.Vector3();\n    v.set(relPoint.x - 0.5, relPoint.y - 0.5, relPoint.z - 0.5);\n    v.multiplyScalar(2);\n    v.multiply(this.halfSizes);\n    v.applyMatrix4(this.basis);\n    v.add(this.position);\n    return v;\n  } else {\n    return this.centroid();\n  }\n};\n\nOBB.prototype.centroid = function(out) {\n  if (out) {\n    out.copy(this.position);\n    return out;\n  } else {\n    return this.position.clone();\n  }\n};\n\nOBB.prototype.volume = function() {\n  var h = this.halfSizes;\n  return h.x * h.y * h.z * 8;\n};\n\nOBB.prototype.surfaceArea = function() {\n  var h = this.halfSizes;\n  return 8*(h.x * h.y + h.z * h.x + h.x * h.y);\n};\n\nOBB.prototype.diagonalLength = (function() {\n  var i0 = new THREE.Vector3(0, 0, 0);\n  var i1 = new THREE.Vector3(1, 1, 1);\n  var c0 = new THREE.Vector3();\n  var c1 = new THREE.Vector3();\n  return function() {\n    this.getWorldPosition(i0, c0);\n    this.getWorldPosition(i1, c1);\n    return c0.distanceTo(c1);\n  };\n})();\n\n/**\n * Aspect ratio is two numbers: shortest/longest, shortest/middle\n */\nOBB.prototype.aspectRatios = function() {\n  dims = this.halfSizes;\n  short = Math.min(Math.min(dims.x, dims.y), dims.z);\n  long = Math.max(Math.max(dims.x, dims.y), dims.z);\n  var mid;\n  if (dims.x != short && dims.x != long) {\n    mid = dims.x;\n  } else if (dims.y != short && dims.y != long) {\n    mid = dims.y;\n  } else {\n    mid = dims.z;\n  }\n  return new THREE.Vector2(short/long, short/mid);\n};\n\nOBB.prototype.__updateCorners = function (force) {\n  var compute = force;\n  if (!this.corners) {\n    this.corners = [];\n    for (var i = 0; i < 8; i++) {\n      this.corners[i] = new THREE.Vector3();\n    }\n    compute = true;\n  }\n\n  if (compute) {\n    for (var i = 0; i < 8; i++) {\n      this.corners[i].set( (i>>2)%2, (i>>1)%2, i%2);\n      this.getWorldPosition(this.corners[i], this.corners[i]);\n    }\n    //console.log(this.corners);\n  }\n};\n\nOBB.prototype.isOBBContained = function(obb) {\n  var corners = obb.getCorners();\n  for ( var index = 0; index < 8; ++index ) {\n    // check each point\n    if ( this.isPointContained( corners[ index ] ) === false ) {\n      // as soon as one point is outside the OBB, return false\n      return false;\n    }\n  }\n  return true;\n};\n\nOBB.prototype.getCorners = function (force) {\n  // TODO: make sure to clear cache when OBB is changed (need to update original three-OBB.js)\n  this.__updateCorners(force);\n  return this.corners;\n};\n\nOBB.prototype.getMinMax = function() {\n  var corners = this.getCorners(true);\n  var box = new THREE.Box3();\n  box.setFromPoints(corners);\n  return { min: box.min, max: box.max };\n};\n\nOBB.prototype.getRotationQuaternion = function(quaternion) {\n  quaternion = quaternion || new THREE.Quaternion();\n  quaternion.setFromRotationMatrix(this.basis);\n  return quaternion;\n};\n\n// Return transform that converts world to local position\n// zeroCenter flag true indicates that local position center is (0,0,0) (extents from -0.5 to 0.5)\n//                       otherwise,    local position center is (0.5, 0.5, 0.5)\nOBB.prototype.getWorldToLocalMatrix4 = function (zeroCenter) {\n  var matrix = this.getLocalToWorldMatrix4(zeroCenter);\n  matrix.getInverse();\n  return matrix;\n};\n\n// Return transform that converts local position to world,\n// zeroCenter flag true indicates that local position center is (0,0,0) (extents from -0.5 to 0.5)\n//                       otherwise,    local position center is (0.5, 0.5, 0.5)\nOBB.prototype.getLocalToWorldMatrix4 = function (zeroCenter) {\n  var matrix = new THREE.Matrix4();\n  matrix.copy(this.basis);\n  matrix.scale(this.halfSizes); // acts as if scale input vector, and then rotate with basis\n  matrix.setPosition(this.position);\n  if (!zeroCenter) {\n    var centerMatrix = new THREE.Matrix4();\n    centerMatrix.setPosition(new THREE.Vector3(-0.5, -0.5, -0.5));\n    matrix.multiply(centerMatrix);\n  }\n  return matrix;\n};\n\nOBB.prototype.isAxisAligned = (function() {\n  var a = new THREE.Vector3();\n  var b = new THREE.Vector3();\n  var c = new THREE.Vector3();\n  function isSingleOne(v) {\n    return (v.x === 1 && v.y === 0 && v.z === 0)\n        || (v.x === 0 && v.y === 1 && v.z === 0)\n        || (v.x === 0 && v.y === 0 && v.z === 1);\n  }\n  return function() {\n    this.basis.extractBasis(a,b,c);\n    return isSingleOne(a) && isSingleOne(b) && isSingleOne(c);\n  };\n}());\n\nOBB.prototype.extractBasis = function(a,b,c) {\n  return this.basis.extractBasis(a,b,c);\n};\n\nOBB.prototype.dimensions = function (out) {\n  var dims = out || new THREE.Vector3();\n  dims.copy(this.halfSizes);\n  dims.multiplyScalar(2);\n  return dims;\n};\nOBB.prototype.getSize = OBB.prototype.dimensions;\n\nOBB.prototype.maxDim = function () {\n  var dims = this.dimensions();\n  var maxDim = Math.max(dims.x, dims.y, dims.z);\n  return maxDim;\n};\n\nOBB.prototype.maxDimAxisIndex = function () {\n  var dims = this.dimensions();\n  var dimsWithIndices = [[0, dims.x], [1, dims.y], [2, dims.z]];\n  var maxDim = _.maxBy(dimsWithIndices, function (d) { return d[1]; });\n  return maxDim[0];\n};\n\nOBB.prototype.maxDimAxis = function (out) {\n  out = out || new THREE.Vector3();\n  var i = this.maxDimAxisIndex();\n  out.setFromMatrixColumn(this.basis, i);\n  return out;\n};\n\nOBB.prototype.minDim = function () {\n  var dims = this.dimensions();\n  var minDim = Math.min(dims.x, dims.y, dims.z);\n  return minDim;\n};\n\nOBB.prototype.minDimAxisIndex = function () {\n  var dims = this.dimensions();\n  var dimsWithIndices = [[0, dims.x], [1, dims.y], [2, dims.z]];\n  var maxDim = _.minBy(dimsWithIndices, function (d) { return d[1]; });\n  return maxDim[0];\n};\n\nOBB.prototype.minDimAxis = function (out) {\n  out = out || new THREE.Vector3();\n  var i = this.minDimAxisIndex();\n  out.setFromMatrixColumn(this.basis, i);\n  return out;\n};\n\nOBB.prototype.getNumValidDimensions = function(min) {\n  min = min || 0;\n  var dims = this.dimensions();\n  var okayDims = _.filter(['x','y','z'], function(d) { return dims[d] > min; });\n  return okayDims.length;\n};\n\nOBB.prototype.reverseNormal = function() {\n  // Reverse the dominant normal\n  var smallestIdx = this.__getSmallestIndex();\n  var m = this.basis.elements;\n  var si = smallestIdx * 4;\n  m[si] = -m[si];\n  m[si+1] = -m[si+1];\n  m[si+2] = -m[si+2];\n  var si2 = (smallestIdx === 0)? 2 : (smallestIdx+1)%3;\n  m[si2] = -m[si2];\n  m[si2+1] = -m[si2+1];\n  m[si2+2] = -m[si2+2];\n  this.__dominantNormal = this.__extractDominantNormal();\n  this.clearCache();\n};\n\nObject.defineProperty(OBB.prototype, 'min', {\n  get: function () { return this.getMinMax().min; }\n});\n\nObject.defineProperty(OBB.prototype, 'max', {\n  get: function () { return this.getMinMax().max; }\n});\n\nmodule.exports = OBB;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/OBB.js?");

/***/ }),

/***/ "./js/lib/geo/OBBFitter.js":
/*!*********************************!*\
  !*** ./js/lib/geo/OBBFitter.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar OBB = __webpack_require__(/*! geo/OBB */ \"./js/lib/geo/OBB.js\");\nvar numeric = __webpack_require__(/*! numeric */ \"../node_modules/numeric/numeric-1.2.6.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar self = {};\n\n// NOTE: Currently we assume Y-Up and we return OBBs in world coordinates\n// TODO: Add options for specifying transform for OBBs\nvar defaults = {\n  debug: false,\n  checkAABB: false,\n  constrainVertical: false,\n  upAxis: 'y',\n  tolerance: 0.01,\n  minWidth: 1e-6\n};\n\nfunction fitPointsOBB(points, opts) {\n  opts = opts || {};\n  opts = _.defaults(opts, defaults);\n\n  if (points.length === 1) {\n    // Return obb at center and 0 halfLength\n    return new OBB(points[0].clone());\n  }\n\n  var obb;\n  var res2d = findOBB2D_Points3D(points, opts.upAxis);\n  var obbConstrained = findOBB3DVertical(res2d.obb2d, res2d.minV, res2d.maxV);\n  if (opts.checkAABB) {\n    var aabb = new OBB().setFromAABB(new BBox().includePoints(points));\n    aabb.metadata = { constrainedVertical: true, isAABB: true };\n    if (opts.debug) {\n      console.log('aabb vs obb', aabb.volume(), obbConstrained.volume());\n    }\n    if (obbConstrained.volume() * (1 + opts.tolerance) >= aabb.volume()) {\n      if (opts.debug) {\n        console.log('using obb constrained to aabb');\n      }\n      obbConstrained = aabb;\n    }\n  }\n  if (opts.constrainVertical) {\n    if (opts.debug) {\n      console.log('Using obb constrained to up');\n    }\n    obb = obbConstrained;\n  } else {\n    var obbUnconstrained = findOBB3DUnconstrained_Points3D(points);\n    if (obbUnconstrained.volume()*(1+opts.tolerance) < obbConstrained.volume()) {\n      if (opts.debug) {\n        console.log('Using unconstrained obb', obbUnconstrained.volume(), obbConstrained.volume());\n      }\n      obb = obbUnconstrained;\n    } else {\n      if (opts.debug) {\n        console.log('Using obb constrained to up');\n      }\n      obb = obbConstrained;\n    }\n  }\n\n  if (obb) {\n    ensureNotDegenerate(obb, opts.minWidth);\n  }\n  return obb;\n}\nself.fitPointsOBB = fitPointsOBB;\n\nfunction fitMeshOBB(meshes, opts) {\n  opts = opts || {};\n  opts = _.defaults(opts, defaults);\n\n  var obb;\n  var res2d = findOBB2D_Meshes(meshes, opts.upAxis);\n  var obbConstrained = findOBB3DVertical(res2d.obb2d, res2d.minV, res2d.maxV);\n  if (opts.checkAABB) {\n    var aabb = new OBB().setFromAABB(new BBox().includeMeshes(meshes));\n    aabb.metadata = { constrainedVertical: true, isAABB: true };\n    if (opts.debug) {\n      console.log('aabb vs obb', aabb.volume(), obbConstrained.volume());\n    }\n    if (obbConstrained.volume() * (1 + opts.tolerance) >= aabb.volume()) {\n      if (opts.debug) {\n        console.log('using obb constrained to aabb');\n      }\n      obbConstrained = aabb;\n    }\n  }\n  if (opts.constrainVertical) {\n    //console.log('Using obb constrained to up');\n    obb = obbConstrained;\n  } else {\n    var obbUnconstrained = findOBB3DUnconstrained_Meshes(meshes);\n    if (obbUnconstrained.volume()*(1+opts.tolerance)  < obbConstrained.volume()) {\n      if (opts.debug) {\n        console.log('Using unconstrained obb', obbUnconstrained.volume(), obbConstrained.volume());\n      }\n      obb = obbUnconstrained;\n    } else {\n      if (opts.debug) {\n        console.log('Using obb constrained to up');\n      }\n      obb = obbConstrained;\n    }\n  }\n\n  if (obb) {\n    ensureNotDegenerate(obb, opts.minWidth);\n  }\n  return obb;\n}\nself.fitMeshOBB = fitMeshOBB;\n\nfunction fitObjectOBB(objects, opts) {\n  opts = opts || {};\n  if (!_.isArray(objects)) {\n    objects = [objects];\n  }\n  var meshes = [];\n  for (var i = 0; i < objects.length; i++) {\n    var object = objects[i];\n    Object3DUtil.getMeshList(object, opts.recursive, meshes);\n  }\n  if (meshes.length) {\n    return fitMeshOBB(meshes, opts);\n  }\n}\nself.fitObjectOBB = fitObjectOBB;\nself.fitOBB = fitObjectOBB;\n\nfunction ensureNotDegenerate(obb, minWidth) {\n  // TODO: Avoid degenerate boxes by enforcing non-zero width along all dimensions\n  minWidth = minWidth || 0;\n  if (obb.halfSizes.x < minWidth) { obb.halfSizes.x = minWidth; }\n  if (obb.halfSizes.y < minWidth) { obb.halfSizes.y = minWidth; }\n  if (obb.halfSizes.z < minWidth) { obb.halfSizes.z = minWidth; }\n}\n\nfunction makeBasis(a0, a1) {\n  var v0 = (a0 instanceof THREE.Vector3)? a0 : new THREE.Vector3(a0[0], a0[1], a0[2]);\n  var v1 = (a1 instanceof THREE.Vector3)? a1 : new THREE.Vector3(a1[0], a1[1], a1[2]);\n  var v2 = v0.clone();\n  v2.cross(v1).normalize();\n\n  var basis = new THREE.Matrix4();\n  //basis.makeBasis(v0, v1, v2);\n  basis.set(\n      v0.x, v1.x, v2.x, 0,\n      v0.y, v1.y, v2.y, 0,\n      v0.z, v1.z, v2.z, 0,\n      0, 0, 0, 1\n  );\n  //console.log(a0, a1, v0, v1, v2);\n  return basis;\n}\n\nfunction findOBB3DVertical(obb2D, minV, maxV) {\n  // Set x and y bbox axes from 2D rectangle axes\n  var center2D = obb2D.center;\n  var position = new THREE.Vector3(center2D[0], 0.5*(minV + maxV), center2D[1]);\n  var halfSizes = new THREE.Vector3(obb2D.extent[0], maxV - minV, obb2D.extent[1]).multiplyScalar(0.5);\n\n  var v0n = obb2D.axes[0];\n  var basis = makeBasis([v0n[0], 0, v0n[1]], [0, 1, 0]);\n  var obb = new OBB(position, halfSizes, basis);\n  obb.metadata = { constrainVertical: true };\n  return obb;\n}\n\nfunction findOBB2D_Points3D(points, upAxis) {\n  upAxis = (upAxis == undefined)? 'y' : upAxis;\n  var otherAxes = ['x','y','z'].filter(function(a) { return a !== upAxis; });\n  var minV = Infinity;\n  var maxV = -Infinity;\n  var xyArray = [];\n  for (var i = 0; i < points.length; i++) {\n    // Assumes y up\n    var p = points[i];\n    if (p[upAxis] < minV) { minV = p[upAxis]; } else if (p[upAxis] > maxV) { maxV = p[upAxis]; }\n    xyArray.push(otherAxes.map(function(a) { return p[a]; }));\n  }\n\n  // Find minimum rectangle in x-z plane and vertical range\n  return { obb2d: findOBB2D(xyArray), minV: minV, maxV: maxV };\n}\n\nfunction findOBB2D_Meshes(meshes, upAxis) {\n  upAxis = (upAxis == undefined)? 'y' : upAxis;\n  var otherAxes = ['x','y','z'].filter(function(a) { return a !== upAxis; });\n  if (!Array.isArray(meshes)) {\n    meshes = [meshes];\n  }\n  var minV = Infinity;\n  var maxV = -Infinity;\n  var xyArray = [];\n  for (var i = 0; i < meshes.length; i++) {\n    // NOTE: Assumes y up\n    GeometryUtil.forMeshVertices(meshes[i], function (p) {\n      if (p[upAxis] < minV) { minV = p[upAxis]; }\n      else if (p[upAxis] > maxV) { maxV = p[upAxis]; }\n      xyArray.push(otherAxes.map(function(a) { return p[a]; }));\n    });\n  }\n  // Find minimum rectangle in x-z plane and vertical range\n  return { obb2d: findOBB2D(xyArray), minV: minV, maxV: maxV };\n}\n\nfunction cross2D(a, b, o) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n}\n\nfunction dot2D(p1, p2) {\n  return p1[0]*p2[0] + p1[1]*p2[1];\n}\n\n/**\n * https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n * @param points An array of [X, Y] coordinates (at least 3 points)\n * @private\n */\nfunction findConvexHull2D(points) {\n  // Sort by x, then y\n  points.sort(function(a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n\n  // lower hull (smallest to largest x)\n  var lower = [];\n  for (var i = 0; i < points.length; i++) {\n    // remove points that will cause counter-clock turn\n    while (lower.length >= 2 && cross2D(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n    lower.push(points[i]);\n  }\n\n  // upper hull (largest to smallest x)\n  var upper = [];\n  for (var i = points.length - 1; i >= 0; i--) {\n    // remove points that will cause counter-clock turn\n    while (upper.length >= 2 && cross2D(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  return lower.concat(upper);\n}\n\nfunction minAreaRectangle2DOfHull(convexHull) {\n  var minRect = { area: Infinity };\n  var xyArray = convexHull;\n  // TODO: make more efficient\n  for (var i1 = 0; i1 < xyArray.length; i1++) {\n    var i2 = (i1+1) % xyArray.length;\n    var p1 = xyArray[i1];\n    var p2 = xyArray[i2];\n    var e = [p2[0] - p1[0], p2[1] - p1[1]];\n    var en = Math.sqrt(e[0]*e[0] + e[1]*e[1]);\n    var u0 = [e[0]/en, e[1]/en];\n    var u1 = [-u0[1], u0[0]];\n\n    // go through and project onto this line and find best bounding box\n    var min = [Infinity, 0];\n    var max = [-Infinity, -Infinity];\n    for (var j = 0; j < xyArray.length; j++) {\n      var p = xyArray[j];\n      var pd = [p[0] - p1[0], p[1] - p1[1]];\n      var d = dot2D(u0, pd);\n      if (d < min[0]) {\n        min[0] = d;\n      }\n      if (d > max[0]) {\n        max[0] = d;\n      }\n      d = dot2D(u1, pd);\n      if (d > max[1]) {\n        max[1] = d;\n      }\n    }\n    var extent = [max[0] - min[0], max[1] - min[1]];\n    var area = extent[0] * extent[1];\n    if (area < minRect.area) {\n      var f0 = (min[0] + max[0])/2;\n      var f1 = (min[1] + max[1])/2;\n      minRect.center = [p1[0] + f0*u0[0] + f1*u1[0], p1[1] + f0*u0[1] + f1*u1[1]];\n      minRect.axes = [u0,u1];\n      minRect.extent = extent;\n      minRect.area = area;\n      minRect.range = [\n        [min[0], max[0]],\n        [min[1], max[1]]\n      ];\n\n      if (extent[1] > extent[0]) {\n        // swap\n        minRect.extent = [extent[1], extent[0]];\n        minRect.axes = [u1, u0];\n        minRect.range = [minRect.range[1], minRect.range[0]];\n      }\n    }\n  }\n  return minRect;\n}\n\nfunction findOBB2D(xyArray) {\n  if (xyArray.length >= 3) {\n    var convexHull = findConvexHull2D(xyArray);\n    if (convexHull.length >= 3) {\n      var rect = minAreaRectangle2DOfHull(convexHull);\n      return rect;\n    } else {\n      xyArray = convexHull;\n    }\n  }\n\n  if (xyArray.length === 2) {\n    var p1 = xyArray[0];\n    var p2 = xyArray[1];\n    var e = [p2[0] - p1[0], p2[1] - p1[1]];\n    var en = Math.sqrt(e[0]*e[0] + e[1]*e[1]);\n    var u0 = [e[0]/en, e[1]/en];\n    var u1 = [-u0[1], u0[0]];\n\n    return {\n      center: [(p1[0]+p2[0])/2, (p1[1]+p2[1])/2],\n      axes: [u0, u1],\n      extent: [en,0],\n      area: 0\n    };\n  } else if (xyArray.length === 1) {\n    return {\n      center: xyArray[0],\n      axes: [[0,1], [-1,0]],\n      extent: [0,0],\n      area: 0\n    };\n  }\n}\n\nfunction findOBB3DUnconstrained_Points3D(points) {\n  if (points.length >= 8) {\n    __webpack_require__(/*! three-quickhull */ \"./js/vendor/three/geo/QuickHull.js\");\n    __webpack_require__(/*! three-convexgeo */ \"./js/vendor/three/geo/ConvexGeometry.js\");\n    //console.log('points', points.length);\n    // TODO: FIXME - there is some bug with the convex hull sometimes\n    //               see p5d.225 - try to label a rectangular region\n    var convex = new THREE.ConvexBufferGeometry(points);\n    return findOBB3DUnconstrained_Geometry(convex);\n  } else {\n    var pointsSet = new Set();\n    var pointsArray = [];\n    for (var vi = 0; vi < points.length; vi++) {\n      var p = points[vi];\n      var p2 = [p.x, p.y, p.z];\n      var p2str = p2.join(\"_\");\n      if (!pointsSet.has(p2str)) {\n        pointsArray.push(p2);\n        pointsSet.add(p2str);\n      }\n    }\n    return findOBB3DUnconstrained_PointsArray(pointsArray);\n  }\n}\n\nfunction findOBB3DUnconstrained_Meshes(meshes) {\n  if (!Array.isArray(meshes)) {\n    meshes = [meshes];\n  }\n  var points = [];\n  for (var i = 0; i < meshes.length; i++) {\n    var mesh = meshes[i];\n    var nverts = GeometryUtil.getGeometryVertexCount(mesh.geometry);\n    for (var vi = 0; vi < nverts; vi++) {\n      var p = GeometryUtil.getGeometryVertex(mesh.geometry, vi, mesh.matrixWorld);\n      points.push(p);\n    }\n  }\n  return findOBB3DUnconstrained_Points3D(points);\n}\n\nfunction findOBB3DUnconstrained_Geometry(geo) {\n  var pointsSet = new Set();\n  var points = [];\n  var nverts = GeometryUtil.getGeometryVertexCount(geo);\n  var p = new THREE.Vector3();\n  for (var vi = 0; vi < nverts; vi++) {\n    GeometryUtil.getGeometryVertex(geo, vi, null, p);\n    var p2 = [p.x, p.y, p.z];\n    var p2str = p2.join(\"_\");\n    if (!pointsSet.has(p2str)) {\n      points.push(p2);\n      pointsSet.add(p2str);\n    }\n  }\n  //console.log('nverts', nverts, 'points', points.length);\n  return findOBB3DUnconstrained_PointsArray(points);\n}\n\nfunction findOBB3DUnconstrained_PointsArray(points) {\n  var pcaOBB3D = findOBB3D_PCA(points);\n  var obb = createOBB3D(pcaOBB3D);\n  obb.metadata = { constrainVertical: false };\n  //obb.convexHull = geo;\n  return obb;\n}\n\nfunction createOBB3D(pcaOBB3D) {\n  var center = pcaOBB3D.center;\n  var extent = pcaOBB3D.extent;\n  var axes = pcaOBB3D.axes;\n  var position = new THREE.Vector3(center[0], center[1], center[2]);\n  var halfSizes = new THREE.Vector3(extent[0], extent[1], extent[2]).multiplyScalar(0.5);\n  var basis = makeBasis(axes[0], axes[1]);\n  return new OBB(position, halfSizes, basis);\n}\n\n// Code for doing PCA\n\nfunction findExtrema(points, dim) {\n  var min = new Array(dim);\n  var max = new Array(dim);\n\n  for (var j = 0; j < dim; j++) {\n    min[j] = Infinity;\n    max[j] = -Infinity;\n  }\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < dim; j++) {\n      if (points[i][j] < min[j]) min[j] = points[i][j];\n      if (points[i][j] > max[j]) max[j] = points[i][j];\n    }\n  }\n\n  var mid = new Array(dim);\n  for (var j = 0; j < dim; j++) {\n    mid[j] = (min[j] + max[j])/2;\n  }\n\n  return { min: min, max: max, mid: mid };\n}\n\nfunction centerPoints(points, dim) {\n  // find mean\n  var mean = new Array(dim);\n  for (var j = 0; j < dim; j++) {\n    mean[j] = 0;\n  }\n\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < dim; j++) {\n      mean[j] += points[i][j];\n    }\n  }\n\n  for (var j = 0; j < mean.length; j++) {\n    mean[j] /= points.length;\n  }\n\n  // adjust data\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < dim; j++) {\n      points[i][j] -= mean[j];\n    }\n  }\n\n  return mean;\n}\n\nfunction getCovariance(points, dim) {\n  // covariance matrix\n  var cM = new Array(dim);\n  for (var j = 0; j < dim; j++) {\n    cM[j] = new Array(dim);\n    for (var k = 0; k < dim; k++) {\n      cM[j][k] = 0;\n    }\n  }\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < dim; j++) {\n      for (var k = 0; k < dim; k++) {\n        cM[j][k] += points[i][j] * points[i][k];\n      }\n    }\n  }\n  for (var j = 0; j < dim; j++) {\n    for (var k = 0; k < dim; k++) {\n      cM[j][k] = cM[j][k]/(points.length-1);\n    }\n  }\n  return cM;\n}\n\nfunction changeBasis(points, basis) {\n  var tmp = new Array(basis.length);\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < basis.length; j++) {\n      tmp[j] = numeric.dot(points[i], basis[j]);\n    }\n    for (var j = 0; j < basis.length; j++) {\n      points[i][j] = tmp[j];\n    }\n  }\n}\n\nfunction findOBB3D_PCA(points) {\n  var numeric = __webpack_require__(/*! numeric */ \"../node_modules/numeric/numeric-1.2.6.js\");\n\n  var mean = centerPoints(points, 3);\n  var cM = getCovariance(points, 3);\n\n  // solve eigenvectors\n  var ev = numeric.eig(cM);\n\n  var PC0 = [ev.E.x[0][0], ev.E.x[1][0], ev.E.x[2][0]];\n  var PC1 = [ev.E.x[0][1], ev.E.x[1][1], ev.E.x[2][1]];\n  var PC2 = [ev.E.x[0][2], ev.E.x[1][2], ev.E.x[2][2]];\n\n  // change basis\n  var basis = [ PC0, PC1, PC2 ];\n  changeBasis(points, basis);\n\n  // find xy extreme values\n  var extrema = findExtrema(points, 3);\n  var min = extrema.min;\n  var max = extrema.max;\n\n  // recover world-space centroid\n  var m = extrema.mid;\n  var centroid = [\n    m[0]*PC0[0] + m[1]*PC1[0] + m[2]*PC2[0] + mean[0],\n    m[0]*PC0[1] + m[1]*PC1[1] + m[2]*PC2[1] + mean[1],\n    m[0]*PC0[2] + m[1]*PC1[2] + m[2]*PC2[2] + mean[2]];\n\n  // get 8 corners\n  return {\n    mean: mean,\n    center: centroid,\n    axes: basis,\n    extent: [max[0]-min[0], max[1]-min[1], max[2]-min[2]],\n    range: [\n      [min[0], max[0]],\n      [min[1], max[1]],\n      [min[2], max[2]]\n    ]\n  };\n}\n\n/*\n\nfunction findOBB2D_PCA(xyArray) {\n  // mean and covariance matrix\n  var mean = centerPoints(xyArray, 2);\n  var cM = getCovariance(xyArray, 2);\n\n  // solve eigenvectors\n  var ev = numeric.eig(cM);\n\n  // pick PC0 as +x\n  var PC0 = [ev.E.x[0][0], ev.E.x[1][0]];\n\n  // rotate 90 CCW as +y}\n  var PC1 = [-PC1[1], PC1[0]];\n\n  // change basis\n  var basis = [ PC0, PC1 ];\n  changeBasis(xyArray, basis);\n\n  // find xy extreme values\n  var extrema = findExtrema(xyArray, 2);\n  var min = extrema.min;\n  var max = extrema.max;\n\n  // recover world-space centroid\n  var m = extrema.mid;\n  var centroid = [m[0]*PC0[0] + m[1]*PC1[0] + mean[0], m[0]*PC0[1] + m[1]*PC1[1] + mean[1]];\n\n  // get 4 corners\n  return {\n    mean: mean,\n    center: centroid,\n    axes: [PC1, PC2],\n    extent: [max[0]-min[0], max[1]-min[1]],\n    range: [\n      [min[0], max[0]],\n      [min[1], max[1]]\n    ]\n  };\n}\n */\n\nmodule.exports = self;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/OBBFitter.js?");

/***/ }),

/***/ "./js/lib/geo/Object3DUtil.js":
/*!************************************!*\
  !*** ./js/lib/geo/Object3DUtil.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar MatrixUtil = __webpack_require__(/*! math/MatrixUtil */ \"./js/lib/math/MatrixUtil.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Lights = __webpack_require__(/*! gfx/Lights */ \"./js/lib/gfx/Lights.js\");\nvar Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar Object3DUtil = {};\nObject3DUtil.MaterialsAll = 1;\nObject3DUtil.MaterialsCompatible = 2;\nObject3DUtil.MaterialsAllNonRecursive = 3;\n\nObject3DUtil.OutNormals = Object.freeze([\n  new THREE.Vector3(-1, 0, 0),\n  new THREE.Vector3(+1, 0, 0),\n  new THREE.Vector3(0, -1, 0),\n  new THREE.Vector3(0, +1, 0),\n  new THREE.Vector3(0, 0, -1),\n  new THREE.Vector3(0, 0, +1)\n]);\nObject3DUtil.InNormals = Object.freeze([\n  new THREE.Vector3(+1, 0, 0),\n  new THREE.Vector3(-1, 0, 0),\n  new THREE.Vector3(0, +1, 0),\n  new THREE.Vector3(0, -1, 0),\n  new THREE.Vector3(0, 0, +1),\n  new THREE.Vector3(0, 0, -1)\n]);\nObject3DUtil.FaceCenters01 = Object.freeze([\n  new THREE.Vector3(0.0, 0.5, 0.5),\n  new THREE.Vector3(1.0, 0.5, 0.5),\n  new THREE.Vector3(0.5, 0.0, 0.5),\n  new THREE.Vector3(0.5, 1.0, 0.5),\n  new THREE.Vector3(0.5, 0.5, 0.0),\n  new THREE.Vector3(0.5, 0.5, 1.0)\n]);\nObject3DUtil.OppositeFaces = Object.freeze([1,0,3,2,5,4]);\n// Rotation\nObject3DUtil.PlaneToFaceRotationParams = Object.freeze([\n  { axis: new THREE.Vector3(0, 1, 0), angle: Math.PI / 2 },\n  { axis: new THREE.Vector3(0, 1, 0), angle: Math.PI / 2 },\n  { axis: new THREE.Vector3(1, 0, 0), angle: Math.PI / 2 },\n  { axis: new THREE.Vector3(1, 0, 0), angle: Math.PI / 2 },\n  null,  // { axis: new THREE.Vector3(0,0,1), angle: 0 },\n  null   //{ axis: new THREE.Vector3(0,0,1), angle: 0 }\n]);\n\n// Set the node material, keeping multimaterial\nfunction setNodeMaterial(node, material, materialIndex) {\n  //if (!node.userData.origMaterial) {\n  //  node.userData.origMaterial = node.material;\n  //}\n  // console.log('setNodeMaterial', node, material, materialIndex);\n  var materials = null;\n  if (material instanceof THREE.MultiMaterial) {\n    materials = material.materials;\n  } else if (Array.isArray(material)) {\n    materials = material;\n  }\n  if (Array.isArray(node.material)) {\n    var oldMaterials = node.material;\n    node.material = [];\n    if (materialIndex !== undefined) {\n      var i = materialIndex;\n      if (i < 0 || i >= oldMaterials.length) {\n        console.warn('Invalid materialIndex ' + materialIndex + ' for node');\n        console.log(node);\n        return false;\n      }\n      for (var i = 0; i < oldMaterials.length; i++) {\n        node.material[i] = oldMaterials[i];\n      }\n      node.material[materialIndex] = materials? materials[materialIndex] : material;\n    } else {\n      for (var i = 0; i < oldMaterials.length; i++) {\n        node.material[i] = materials? materials[i] : material;\n      }\n    }\n  } else if (node.material instanceof THREE.MultiMaterial) {\n    node.material = node.material.clone();\n\n    if (materialIndex !== undefined) {\n      var i = materialIndex;\n      if (i < 0 || i >= node.material.materials.length) {\n        console.warn('Invalid materialIndex ' + materialIndex + ' for node');\n        console.log(node);\n        return false;\n      }\n      node.material.materials[i] = materials? materials[i] : material;\n    } else {\n      for (var i = 0; i < node.material.materials.length; i++) {\n        node.material.materials[i] = materials? materials[i] : material;\n      }\n    }\n  } else {\n    node.material = material;\n  }\n  return true;\n}\n\nObject3DUtil.setMaterial = function (object3D, materialOrMaterialFn, materialsToSet, saveOldMaterial, filterMeshFn) {\n  if (!materialsToSet) {\n    materialsToSet = Object3DUtil.MaterialsCompatible;\n  }\n  var skippedMeshes = 0;\n  var totalMeshes = 0;\n  var nonrecursive = materialsToSet === Object3DUtil.MaterialsAllNonRecursive;\n  Object3DUtil.traverseMeshes(object3D,\n    nonrecursive,\n    function (node) {\n      var material = (typeof materialOrMaterialFn === 'function')?\n        materialOrMaterialFn(node) : materialOrMaterialFn;\n      var applyMaterial = !!material;\n      if (filterMeshFn) {\n        applyMaterial = filterMeshFn(node, material);\n      }\n      if (applyMaterial && materialsToSet === Object3DUtil.MaterialsCompatible) {\n        if (material.map) {\n          if (!node.material.map) {\n            applyMaterial = false;\n          }\n        }\n      }\n      if (applyMaterial) {\n        if (saveOldMaterial) {\n          if (node.origMaterials) {\n            node.origMaterials.push(node.material);\n          } else {\n            node.origMaterials = [node.material];\n          }\n        }\n        //  node.material = material;\n        if (material instanceof THREE.Color) {\n          // copy material and just set color\n          var m = node.material.clone();\n          m.color = material;\n          node.material = m;\n        } else {\n          node.material = material;\n        }\n      } else {\n        skippedMeshes++;\n      }\n      totalMeshes++;\n    });\n  if (skippedMeshes) {\n    // console.log('Material not applied to all meshes: skipped ' + skippedMeshes + '/' + totalMeshes);\n    // console.log('material', materialOrMaterialFn, materialsToSet);\n    // console.log('node', object3D);\n  }\n  return { total: totalMeshes, skipped: skippedMeshes };\n};\n\nObject3DUtil.revertMaterials = function (object3D, nonrecursive, fullRevert) {\n  var skippedMeshes = 0;\n  var totalMeshes = 0;\n  Object3DUtil.traverseMeshes(object3D,\n    nonrecursive,\n    function (node) {\n      if (node.origMaterials && node.origMaterials.length > 0) {\n        node.material = node.origMaterials.pop();\n        if (fullRevert) {\n          while (node.origMaterials.length > 0) {\n            node.material = node.origMaterials.pop();\n          }\n        }\n      } else {\n        skippedMeshes++;\n      }\n      totalMeshes++;\n    });\n  return { total: totalMeshes, skipped: skippedMeshes };\n};\n\nObject3DUtil.setTransparency = function (object3D, transparency) {\n  Object3DUtil.setOpacity(object3D, 1 - transparency);\n};\n\nObject3DUtil.setOpacity = function (object3D, opacity) {\n  object3D.traverse(function (node) {\n    if (node instanceof THREE.Mesh || node instanceof THREE.Line) {\n      if (node.material) {\n        Object3DUtil.setMaterialOpacity(node.material, opacity);\n      }\n    }\n  });\n};\n\nObject3DUtil.setDoubleSided = function (object3D) {\n  object3D.traverse(function (node) {\n    if (node.material) {\n      node.material.side = THREE.DoubleSide;\n      if (node.material.materials) {\n        for (var iMat = 0; iMat < node.material.materials.length; iMat++) {\n          node.material.materials[iMat].side = THREE.DoubleSide;\n        }\n      }\n    }\n  });\n};\n\nObject3DUtil.countMirroringTransforms = function (object3D) {\n  var numFlips = 0;\n  object3D.traverseAncestors(function (node) {\n    var s = node.scale;\n    if (s.x * s.y * s.z < 0) { numFlips++; }\n  });\n  return numFlips;\n};\n\n// Flip normals/face vertices for mirrored geometry\nObject3DUtil.flipForMirroring = function (object3D) {\n  // console.time('flipNormals');\n  object3D.traverse(function (node) {\n    if (node instanceof THREE.Mesh) {\n      if (node.geometry) {\n        var geo = node.geometry;\n        GeometryUtil.flipForMirroring(geo);\n      }\n    }\n  });\n  // console.timeEnd('flipNormals');\n};\n\nObject3DUtil.getMeshMaterials = function(mesh) {\n  return Materials.toMaterialArray(mesh.material);\n};\n\nObject3DUtil.setMaterialOpacity = function (material, opacity) {\n  Materials.setMaterialOpacity(material, opacity);\n};\n\nObject3DUtil.setWireframe = function (object3D, flag) {\n  Object3DUtil.processMaterial(object3D, function (material) {\n    material.wireframe = flag;\n  });\n};\n\nObject3DUtil.setDepthWrite = function (object3D, flag) {\n  Object3DUtil.processMaterial(object3D, function (material) {\n    material.depthWrite = flag;\n  });\n};\n\nObject3DUtil.setDepthTest = function (object3D, flag) {\n  Object3DUtil.processMaterial(object3D, function (material) {\n    material.depthTest = flag;\n  });\n};\n\nObject3DUtil.processMaterial = function (object3D, callback) {\n  if (object3D instanceof THREE.Object3D) {\n    object3D.traverse(function (node) {\n      if (node instanceof THREE.Mesh || node instanceof THREE.Line) {\n        if (node.material) {\n          Object3DUtil.processMaterial(node.material, callback);\n        }\n      }\n    });\n  } else if (Array.isArray(object3D) && object3D.length) {\n    var material = object3D;\n    for (var i = 0; i < material.length; i++) {\n      Object3DUtil.processMaterial(material[i], callback);\n    }\n  } else if (object3D instanceof THREE.MultiMaterial) {\n    var material = object3D;\n    for (var i = 0; i < material.materials.length; i++) {\n      Object3DUtil.processMaterial(material.materials[i], callback);\n    }\n  } else if (object3D instanceof THREE.Material) {\n    callback(object3D);\n  }\n};\n\nObject3DUtil.createMaterial = function (params) {\n  return Materials.createMaterial(params);\n};\n\nObject3DUtil.applyMaterialMappings = function (object3D, materialMappings) {\n  console.log(materialMappings);\n  var materials = {};\n  for (var id in materialMappings.materials) {\n    if (materialMappings.materials.hasOwnProperty(id)) {\n      var mat = materialMappings.materials[id];\n      if (!mat.replaced) {\n        materials[id] = Object3DUtil.createMaterial(mat.material);\n      }\n    }\n  }\n  var meshes = {};\n  for (var id in materialMappings.meshes) {\n    if (materialMappings.meshes.hasOwnProperty(id)) {\n      var mesh = materialMappings.meshes[id];\n      meshes[mesh.name] = materials[mesh.materialId];\n    }\n  }\n  var skippedMeshes = 0;\n  var totalMeshes = 0;\n  object3D.traverse(function (node) {\n    if (node instanceof THREE.Mesh) {\n      if (node.name) {\n        var material = meshes[node.name];\n        if (!material) {\n          // hack to see if we replace the node specific name, we can get a match\n          var newname = node.name.replace(/.*-/, 'mesh');\n          material = meshes[newname];\n        }\n        if (material) {\n          node.material = material;\n        } else {\n          skippedMeshes++;\n        }\n      }\n      totalMeshes++;\n    }\n  });\n  if (skippedMeshes) {\n    console.log('Material not applied to all meshes: skipped ' + skippedMeshes + '/' + totalMeshes);\n  }\n  return { total: totalMeshes, skipped: skippedMeshes };\n};\n\nObject3DUtil.applyRandomMaterials = function (object3D, nonrecursive) {\n  var id = 0;\n  return Object3DUtil.applyMaterials(object3D,\n    function (mesh) {\n      return Object3DUtil.getSimpleFalseColorMaterial(id++);\n    },\n    nonrecursive);\n};\n\nObject3DUtil.applyIndexedMaterials = function (object3D, nonrecursive) {\n  return Object3DUtil.applyMaterials(object3D,\n    function (mesh) {\n      var id = mesh.userData.index;\n      return Object3DUtil.getSimpleFalseColorMaterial(id);\n    },\n    nonrecursive);\n};\n\nObject3DUtil.highlightMeshes = function (object3D, meshIndices, material, useIndexedMaterial) {\n  function getMaterial(i) {\n    if (material) {\n      return material;\n    } else if (useIndexedMaterial) {\n      return Object3DUtil.getSimpleFalseColorMaterial(i);\n    } else {\n      return Object3DUtil.getSimpleFalseColorMaterial(0);\n    }\n  }\n\n  return Object3DUtil.applyMaterials(object3D,\n    function (mesh) {\n      if (meshIndices.length) {\n        for (var j = 0; j < meshIndices.length; j++) {\n          if (mesh.userData.index === meshIndices[j]) {\n            return getMaterial(mesh.userData.index);\n          }\n        }\n        return Object3DUtil.ClearMat;\n      } else if (mesh.userData.index === meshIndices) {\n        return getMaterial(mesh.userData.index);\n      } else {\n        return Object3DUtil.ClearMat;\n      }\n    },\n    true);\n};\n\nObject3DUtil.applyPartMaterial = function (part, materialOrFn, nonrecursive, keepMultiMaterial, filter) {\n  if (filter && !filter(part)) {\n    return; // Don't apply material to this part\n  }\n  if (part instanceof THREE.Object3D) {\n    Object3DUtil.applyMaterial(part, materialOrFn, nonrecursive, keepMultiMaterial, filter);\n  } else if (part instanceof Array) {\n    for (var i = 0; i < part.length; i++) {\n      Object3DUtil.applyPartMaterial(part[i], materialOrFn, nonrecursive, keepMultiMaterial, filter);\n    }\n  } else {\n    var node = part['node'] || part['mesh'];\n    var materialIndex = part['materialIndex'];\n    var materialApplied = true;\n    if (node) {\n      if (materialIndex !== undefined) {\n        if (node instanceof THREE.Mesh) {\n          var material = (_.isFunction(materialOrFn))? materialOrFn(node) : materialOrFn;\n          materialApplied = setNodeMaterial(node, material, materialIndex);\n        }\n      } else {\n        Object3DUtil.applyPartMaterial(node, materialOrFn, nonrecursive, keepMultiMaterial, filter);\n        materialApplied = true;\n      }\n    }\n    if (!materialApplied) {\n      console.warn('Cannot apply material to part');\n      console.log(part);\n    }\n  }\n};\n\nObject3DUtil.applyMaterial = function (object3D, materialOrFn, nonrecursive, keepMultiMaterial, filter) {\n  return Object3DUtil.applyMaterials(object3D,\n    function (mesh) {\n      if (filter && !filter(mesh)) {\n        return;\n      }\n      if (_.isFunction(materialOrFn)) {\n        return materialOrFn(mesh);\n      } else {\n        return materialOrFn;\n      }\n    },\n    nonrecursive, keepMultiMaterial);\n};\n\nObject3DUtil.saveMaterials = function(object3D, nonrecursive) {\n  Object3DUtil.traverseMeshes(object3D,\n    nonrecursive,\n    function (node) {\n      node.cachedData = node.cachedData || {};\n      node.cachedData.origMaterial = node.material;\n    });\n};\n\nObject3DUtil.applyMaterials = function (object3D, getMaterialCallback, nonrecursive, keepMultiMaterial) {\n  var skippedMeshes = 0;\n  var totalMeshes = 0;\n  Object3DUtil.traverseMeshes(object3D,\n    nonrecursive,\n    function (node) {\n      var material = getMaterialCallback(node);\n      if (material) {\n        if (keepMultiMaterial) {\n          setNodeMaterial(node, material);\n        } else {\n          node.material = material;\n        }\n      } else {\n        skippedMeshes++;\n      }\n      totalMeshes++;\n    });\n  if (skippedMeshes) {\n    console.log('Material not applied to all meshes: skipped ' + skippedMeshes + '/' + totalMeshes);\n  }\n  return {total: totalMeshes, skipped: skippedMeshes};\n};\n\nObject3DUtil.replaceChild = function (oldChild, newChild) {\n  if (oldChild.parent) {\n    var parent = oldChild.parent;\n    var iChild = parent.children.indexOf(oldChild);\n    parent.children[iChild] = newChild;\n    newChild.parent = parent;\n    oldChild.parent = null;\n  }\n};\n\nObject3DUtil.detachFromParent = function (object3D, scene) {\n  // Detach from parent while keeping same world transform\n  if (object3D.parent) {\n    Object3DUtil.clearCache(object3D.parent);\n    object3D.parent.updateMatrixWorld();\n    if (scene) {\n      scene.updateMatrixWorld();\n    }\n\n    var objWorldTransform = new THREE.Matrix4();\n    objWorldTransform.copy(object3D.matrixWorld);\n    object3D.parent.remove(object3D);\n\n    var objMinv = new THREE.Matrix4();\n    objMinv.getInverse(object3D.matrix);\n    var matrix = new THREE.Matrix4();\n    matrix.multiplyMatrices(objWorldTransform, objMinv);\n\n    // Add to scene...\n    if (scene) {\n      var sceneMinv = new THREE.Matrix4();\n      sceneMinv.getInverse(scene.matrixWorld);\n      matrix.multiplyMatrices(sceneMinv, matrix);\n      object3D.applyMatrix(matrix);\n      object3D.matrixWorldNeedsUpdate = true;\n      scene.add(object3D);\n    }\n  }\n};\n\nObject3DUtil.attachToParent = function (object3D, parent, scene) {\n  // Attach to parent while keeping same world transform\n  if (object3D.parent === parent) return;\n  if (parent) {\n    parent.updateMatrixWorld();\n    object3D.updateMatrixWorld();\n\n    var objWorldTransform = new THREE.Matrix4();\n    objWorldTransform.copy(object3D.matrixWorld);\n    var parentMinv = new THREE.Matrix4();\n    parentMinv.getInverse(parent.matrixWorld);\n    var objMinv = new THREE.Matrix4();\n    objMinv.getInverse(object3D.matrix);\n\n    var matrix = new THREE.Matrix4();\n    matrix.multiplyMatrices(parentMinv, objWorldTransform);\n    matrix.multiplyMatrices(matrix, objMinv);\n    object3D.applyMatrix(matrix);\n    object3D.matrixWorldNeedsUpdate = true;\n\n    parent.add(object3D);\n    Object3DUtil.clearCache(parent);\n  } else {\n    Object3DUtil.detachFromParent(object3D, scene);\n  }\n};\n\nObject3DUtil.setCastShadow = function (object3D, flag) {\n  object3D.traverse(function (node) {\n    if (node.castShadow != undefined) {\n      //console.log('castShadow');\n      node.castShadow = flag;\n    }\n  });\n};\n\nObject3DUtil.setReceiveShadow = function (object3D, flag) {\n  object3D.traverse(function (node) {\n    if (node.receiveShadow != undefined) {\n      //console.log('receiveShadow');\n      node.receiveShadow = flag;\n    }\n  });\n};\n\nObject3DUtil.computeVertexMeanLocal = function (root, transform) {\n  root.updateMatrixWorld();\n  var modelInverse = new THREE.Matrix4();\n  modelInverse.getInverse(root.matrixWorld);\n  if (transform) {\n    var m = new THREE.Matrix4();\n    m.multiplyMatrices(transform, modelInverse);\n    return Object3DUtil.computeVertexMean(root, m);\n  } else {\n    return Object3DUtil.computeVertexMean(root, modelInverse);\n  }\n};\n\nObject3DUtil.computeVertexMean = function (root, transform) {\n  var agg = new THREE.Vector3();\n  var n = 0;\n  Object3DUtil.traverseMeshes(root, false, function(mesh) {\n    GeometryUtil.forFaceVerticesWithTransform(mesh.geometry, transform, function(v) {\n      agg.add(v);\n      n++;\n    });\n  });\n  if (n > 0) {\n    agg.multiplyScalar(1/n);\n  }\n  console.log('Computed mean vertex: ' + JSON.stringify(agg) + ', nvertices: ' + n);\n  return agg;\n};\n\nObject3DUtil.getOrientedBoundingBox = function (objects, opts, force) {\n  if (Array.isArray(objects)) {\n    for (var i = 0; i < objects.length; i++) {\n      Object3DUtil.__getOrientedBoundingBox(objects[i], opts, force);\n    }\n    return Object3DUtil.__getOrientedBoundingBox(objects, opts, force);\n  } else {\n    return Object3DUtil.__getOrientedBoundingBox(objects, opts, force);\n  }\n};\n\nObject3DUtil.getBoundingBox = function (objects, force) {\n  if (Array.isArray(objects)) {\n    var bbox = new BBox();\n    for (var i = 0; i < objects.length; i++) {\n      bbox.includeBBox(Object3DUtil.__getBoundingBox(objects[i], force));\n    }\n    return bbox;\n  } else {\n    return Object3DUtil.__getBoundingBox(objects, force);\n  }\n};\n\nObject3DUtil.__getBoundingBox = function (root, force) {\n  // Have cached world bounding box\n  if (!root.cached) {\n    root.cached = {};\n  }\n  if (!root.cached.worldBoundingBox || force) {\n    root.cached.worldBoundingBox = Object3DUtil.computeBoundingBox(root);\n    //console.log(root.cached.worldBoundingBox);\n  } else {\n    //console.log(\"Recompute not needed\");\n  }\n  return root.cached.worldBoundingBox;\n};\n\nObject3DUtil.__getOrientedBoundingBox = function (root, opts, force) {\n  // Have cached world bounding box\n  if (!root.cached) {\n    root.cached = {};\n  }\n  if (!root.cached.worldOrientedBoundingBox || force) {\n    var OBBFitter = __webpack_require__(/*! geo/OBBFitter */ \"./js/lib/geo/OBBFitter.js\");\n    root.cached.worldOrientedBoundingBox = OBBFitter.fitObjectOBB(root, opts);\n    //console.log(root.cached.worldOrientedBoundingBox);\n  } else {\n    //console.log(\"Recompute not needed\");\n  }\n  return root.cached.worldOrientedBoundingBox;\n};\n\nObject3DUtil.computeBoundingBoxLocal = function (root, transform) {\n  root.updateMatrixWorld();\n  var modelInverse = new THREE.Matrix4();\n  modelInverse.getInverse(root.matrixWorld);\n  if (transform) {\n    var m = new THREE.Matrix4();\n    m.multiplyMatrices(transform, modelInverse);\n    return Object3DUtil.computeBoundingBox(root, m);\n  } else {\n    return Object3DUtil.computeBoundingBox(root, modelInverse);\n  }\n};\n\nObject3DUtil.computeBoundingBox = function (root, transform, filter) {\n  var bbox = new BBox();\n  //console.time(\"computeBoundingBox\");\n  //var start = Date.now();\n  bbox.includeObject3D(root, transform, filter);\n  //var end = Date.now();\n  //console.log(\"Get bounding box took \" + (end-start) + \" ms\");\n  //console.timeEnd(\"computeBoundingBox\");\n  return bbox;\n};\n\nObject3DUtil.cacheWorldBoundingBoxes = function(root) {\n  root.updateMatrixWorld();\n  Object3DUtil.traverse(root, function(node) {\n    return true;\n  }, function(node) {\n    var bbox = new BBox();\n    var transform = null;\n    if (node instanceof THREE.Mesh) {\n      bbox.includeMesh(node, transform);\n    } else if (node instanceof THREE.Line) {\n      bbox.includeLine(node, transform);\n    } else if (node instanceof THREE.Points) {\n      bbox.includePoints(node, transform);\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        bbox.includeBBox(node.children[i].cached.worldBoundingBox);\n      }\n    }\n    node.cached = node.cached || {};\n    node.cached.worldBoundingBox = bbox;\n  });\n  return root.cached.worldBoundingBox;\n};\n\nObject3DUtil.getBoundingBoxDims = function (model, bb) {\n  if (!bb) bb = Object3DUtil.getBoundingBox(model);\n  var bbSize = new THREE.Vector3();\n  bbSize.subVectors(bb.max, bb.min);\n  return bbSize;\n};\n\nObject3DUtil.getSizeByOptions = function () {\n  return ['height', 'length', 'width', 'max', 'volumeCubeRoot', 'diagonal'];\n};\n\nObject3DUtil.convertBbDimsToSize = function (bbDims, sizeBy) {\n  var size;\n  if (bbDims instanceof THREE.Vector3) {\n  } else if (bbDims instanceof Array) {\n    bbDims = new THREE.Vector3(bbDims[0], bbDims[1], bbDims[2]);\n  } else {\n    console.error('Unsupported bbDims type');\n    return undefined;\n  }\n  switch (sizeBy) {\n    case 'height':\n      size = bbDims.z;\n      break;\n    case 'length':\n      size = bbDims.y;\n      break;\n    case 'width':\n      size = bbDims.x;\n      break;\n    case 'max':\n      size = Math.max(bbDims.x, bbDims.y, bbDims.z);\n      break;\n    case 'diagonal':\n      size = bbDims.length();\n      break;\n    case 'volumeCubeRoot':\n      size = bbDims.x * bbDims.y * bbDims.z;\n      size = Math.pow(size, 1 / 3);\n      break;\n    default:\n      console.error('Unknown sizeBy ' + size);\n  }\n  return size;\n};\n\nObject3DUtil.computeNodeStatistics = function(root, splitOnMaterial) {\n  // Compute number of faces at each node\n  Object3DUtil.traverse(root, function (node) {\n    return true;\n  }, function (node) {\n    var nfaces = 0;\n    var nleafs = 0;\n    var nvertices = 0;\n    if (node instanceof THREE.Mesh) {\n      nfaces = GeometryUtil.getGeometryFaceCount(node.geometry);\n      nvertices = GeometryUtil.getGeometryVertexCount(node.geometry);\n      nleafs = 1;\n      if (splitOnMaterial) {\n        var nmats = (node.material instanceof THREE.MultiMaterial) ? node.material.materials.length :\n          (Array.isArray(node.material) ? node.material.length : 1);\n        nleafs = nmats;\n      }\n    } else if (node instanceof THREE.Line) {\n      nvertices = GeometryUtil.getGeometryVertexCount(node.geometry);\n      nleafs = 1;\n    } else if (node instanceof THREE.Points) {\n      nvertices = GeometryUtil.getGeometryVertexCount(node.geometry);\n      nleafs = 1;\n    } else if (node.children && node.children.length > 0) {\n      for (var i = 0; i < node.children.length; i++) {\n        nfaces += node.children[i].userData.nfaces || 0;\n        nleafs += node.children[i].userData.nleafs || 0;\n        nvertices += node.children[i].userData.nvertices || 0;\n      }\n    }\n    node.userData.nfaces = nfaces;\n    node.userData.nleafs = nleafs;\n    node.userData.nvertices = nvertices;\n  });\n};\n\nObject3DUtil.removeLines = function(root) {\n  return Object3DUtil.removeNodes(root, function(node) { return node instanceof THREE.Line; });\n};\n\nObject3DUtil.removePoints = function(root) {\n  return Object3DUtil.removeNodes(root, function(node) { return node instanceof THREE.Points; });\n};\n\nObject3DUtil.removeEmptyGeometries = function(root, options) {\n  options = _.defaults(Object.create(null), options || {}, {\n    splitOnMaterial: false,\n    minFaces: 1,\n    minVertices: 0\n  });\n\n  Object3DUtil.computeNodeStatistics(root, options.splitOnMaterial);\n  Object3DUtil.traverse(root, function(node) {\n    return node.userData.nfaces > 0;\n  }, function(node) {\n    // Remove any children that doesn't have enough faces or vertices\n    var removeList = [];\n    for (var i = 0; i < node.children.length; i++) {\n      var c = node.children[i].userData;\n      if (c.nfaces < options.minFaces || c.nvertices < options.minVertices) {\n        removeList.push(node.children[i]);\n      }\n    }\n    for (var i = 0; i < removeList.length; i++) {\n      console.log('Removing node ' + removeList[i].id);\n      node.remove(removeList[i]);\n    }\n  });\n  Object3DUtil.clearCache(root);\n};\n\nObject3DUtil.collapseNestedPaths = function(root, options) {\n  // Collapse nodes that have just one child\n  var queue = [root];\n  var newRoot = root;\n  while (queue.length > 0) {\n    var node = queue.pop();\n    if (node instanceof THREE.Group && node.children.length === 1) {\n      var collapseNodes = [node];\n      var n = node;\n      while (n.children.length === 1) {\n        n = n.children[0];\n        collapseNodes.push(n);\n      }\n      var finalNode = collapseNodes[collapseNodes.length-1];\n      // Fold transforms into this node\n      var finalTransform = finalNode.matrix;\n      for (var i = collapseNodes.length-2; i >= 0; i--) {\n        var n = collapseNodes[i];\n        finalTransform.premultiply(n.matrix);\n      }\n      Object3DUtil.setMatrix(finalNode, finalTransform);\n      // Figure out name\n      var labels = _.map(collapseNodes, function(n) { return n.name || (n.userData && n.userData.id) || (\"node\" + n.index); });\n      finalNode.name = labels.join('/');\n      // Replace current node with this node\n      if (node.parent) {\n        //var parent = node.parent;\n        //parent.remove(node);\n        //parent.add(finalNode);\n\n        var index = node.parent.children.indexOf(node);\n        node.parent.children[index] = finalNode;\n        finalNode.parent = node.parent;\n        node.parent = null;\n        if (node === root) {\n          newRoot = finalNode;\n        }\n      }\n      node = finalNode;\n      console.log('Consolidated ' + finalNode.name);\n    }\n    for (var i = 0; i < node.children.length; i++) {\n      queue.push(node.children[i]);\n    }\n  }\n  newRoot.updateMatrixWorld();\n  return newRoot;\n};\n\n\nObject3DUtil.getObjectStats = function(object3D, includeChildModelInstance) {\n  var nverts = 0;\n  var nfaces = 0;\n  var nmeshes = 0;\n  Object3DUtil.traversePrimitives(object3D, !includeChildModelInstance, function(mesh) {\n    nverts += GeometryUtil.getGeometryVertexCount(mesh.geometry);\n    if (mesh instanceof THREE.Mesh) {\n      nfaces += GeometryUtil.getGeometryFaceCount(mesh.geometry);\n    }\n    nmeshes += 1;\n  });\n  return { nverts: nverts, nfaces: nfaces, nmeshes: nmeshes };\n};\n\n/**\n * Returns surfaces area of the object3D\n * @param object3D {THREE.Object3D}\n * @param [opts] Additional options\n * @param [opts.transform] {THREE.Matrix4} Additional transform to apply to vertices\n * @param [opts.meshFilter] {function(THREE.Mesh): boolean} Whether to include mesh in surface area computation\n * @param [opts.triFilter] {function(v0,v1,v2,iFace): boolean} Whether to include triangle in surface area computation\n * @returns {number}\n */\nObject3DUtil.getSurfaceArea = function(object3D, opts) {\n  opts = opts || {};\n  var includeChildModelInstance = opts.includeChildModelInstance;\n  var transform = opts.transform;\n  var meshFilter = opts.meshFilter;\n  var triFilter = opts.triFilter;\n  object3D.updateMatrixWorld();\n  var area = 0;\n  Object3DUtil.traverseMeshes(object3D, !includeChildModelInstance, function(mesh) {\n    if (!meshFilter || meshFilter(mesh)) {\n      var t = mesh.matrixWorld;\n      if (transform) {\n        t = transform.clone();\n        t.multiply(mesh.matrixWorld);\n      }\n      area += GeometryUtil.getSurfaceAreaFiltered(mesh.geometry, t, triFilter);\n    }\n  });\n  return area;\n};\n\n/**\n * Takes an object3D and rotates so that its two vectors front and up align with targetUp and targetFront.\n * Assumptions: objectUp perpendicular to objectFront, targetUp perpendicular to targetFront.\n * @param object3D Object to align\n * @param objectUp Object's semantic up vector\n * @param objectFront Object's semantic front vector\n * @param targetUp Target up vector\n * @param targetFront Target front vector\n */\nObject3DUtil.alignToUpFrontAxes = function (object3D, objectUp, objectFront, targetUp, targetFront) {\n  Object3DUtil.alignAxes(object3D, objectUp, objectFront, targetUp, targetFront);\n};\n\n/**\n * Takes an object3D and rotates so that its two vectors u and v align with u and v.\n * Assumptions: both sets of u and v are perpendicular.\n * @param object3D Object to align\n * @param objU Object's first vector\n * @param objV Object's second vector\n * @param tgtU Target first vector\n * @param tgtV Target second vector\n */\nObject3DUtil.alignAxes = function (object3D, objU, objV, tgtU, tgtV) {\n  // Unapply existing rotations  (does this work? does object position end up not quite what we want...?)\n  object3D.rotation.set(0, 0, 0);\n  object3D.updateMatrix();\n  var transform = Object3DUtil.getAlignmentMatrix(objU, objV, tgtU, tgtV);\n  // Apply this transform to matrix\n  object3D.applyMatrix(transform);\n  object3D.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n  Object3DUtil.clearCache(object3D);\n};\n\nObject3DUtil.getAlignmentMatrix = MatrixUtil.getAlignmentMatrix;\nObject3DUtil.getAlignmentQuaternion = MatrixUtil.getAlignmentQuaternion;\nObject3DUtil.axisPairToOrthoMatrix = MatrixUtil.axisPairToOrthoMatrix;\n\n/**\n * Takes the rotation for a rotated object3D that is aligned with targetUp and targetFront and returns the\n *   objectUp and objectFront that is needed to achieve that alignment\n * Assumptions: targetUp perpendicular to targetFront.\n * @param rotation Rotation of aligned object\n * @param targetUp Target up vector\n * @param targetFront Target front vector\n * @param epsilon Epsilon to use to snap to integers\n * @return \"up\": Object's semantic up vector\n * @return \"front\": Object's semantic front vector\n */\nObject3DUtil.getObjUpFrontAxes = function (rotation, targetUp, targetFront, epsilon) {\n  var targetM = Object3DUtil.axisPairToOrthoMatrix(targetUp, targetFront);\n  var m = new THREE.Matrix4();\n  if (rotation instanceof THREE.Vector3) {\n    m.makeRotationFromEuler(new THREE.Euler(rotation.x, rotation.y, rotation.z));\n  } else if (rotation instanceof THREE.Quaternion) {\n    m.makeRotationFromQuaternion(rotation);\n  }\n  var mInv = new THREE.Matrix4();\n  mInv.getInverse(m);\n  var objM = new THREE.Matrix4();\n  objM.multiplyMatrices(mInv, targetM);\n  var up = new THREE.Vector3();\n  up.setFromMatrixColumn(objM, 0);\n  up = Object3DUtil.snapToInteger(up, epsilon);\n  var front = new THREE.Vector3();\n  front.setFromMatrixColumn(objM, 1);\n  front = Object3DUtil.snapToInteger(front, epsilon);\n  return { 'up': up, 'front': front };\n};\n\nObject3DUtil.getRotationForOrientingBBFace = function (unorientedBbFaceIndex, targetBbfaceIndex) {\n  // Get rotation matrix that takes the unorientedBbFaceIndex to be oriented in world space as the bbfaceIndex\n  var r = new THREE.Matrix3();\n  if (unorientedBbFaceIndex !== targetBbfaceIndex) {\n    if (unorientedBbFaceIndex >= 0 && targetBbfaceIndex >= 0) {\n      console.debug('Need to orient ' + unorientedBbFaceIndex + ' to ' + targetBbfaceIndex);\n      if (targetBbfaceIndex !== Constants.BBoxFaces.BOTTOM && targetBbfaceIndex !== Constants.BBoxFaces.TOP &&\n        unorientedBbFaceIndex !== Constants.BBoxFaces.BOTTOM && unorientedBbFaceIndex !== Constants.BBoxFaces.TOP) {\n        r = Object3DUtil.getAlignmentMatrix(\n          Object3DUtil.OutNormals[Constants.BBoxFaces.TOP],\n          Object3DUtil.OutNormals[unorientedBbFaceIndex],\n          Object3DUtil.OutNormals[Constants.BBoxFaces.TOP],\n          Object3DUtil.OutNormals[targetBbfaceIndex]\n        );\n      } else {\n        r = Object3DUtil.getAlignmentMatrix(\n          Object3DUtil.OutNormals[unorientedBbFaceIndex],\n          Object3DUtil.OutNormals[(unorientedBbFaceIndex + 2) % 6],\n          Object3DUtil.OutNormals[targetBbfaceIndex],\n          Object3DUtil.OutNormals[(targetBbfaceIndex + 2) % 6]\n        );\n      }\n    } else {\n      if (unorientedBbFaceIndex < 0) {\n        console.warn('Invalid unorientedBbFaceIndex: ' + unorientedBbFaceIndex);\n      }\n      if (targetBbfaceIndex < 0) {\n        console.warn('Invalid targetBbfaceIndex: ' + targetBbfaceIndex);\n      }\n    }\n  }\n  return r;\n};\n\nObject3DUtil.clearTransform = function(object3D) {\n  object3D.rotation.set(0, 0, 0);\n  object3D.scale.set(1, 1, 1);\n  object3D.position.set(0, 0, 0);\n  object3D.updateMatrix();\n  Object3DUtil.clearCache(object3D);\n};\n\nObject3DUtil.normalize = function (object3D, alignmentMatrix, scaleVector) {\n  // Unapply existing rotations  (does this work? does object position end up not quite what we want...?)\n  object3D.rotation.set(0, 0, 0);\n  object3D.scale.set(1, 1, 1);\n  object3D.position.set(0, 0, 0);\n  object3D.updateMatrix();\n  var transform = alignmentMatrix;\n  // Apply this transform to matrix\n  object3D.applyMatrix(transform);\n  object3D.updateMatrix();\n  object3D.matrixWorldNeedsUpdate = true;\n\n  // Get bounding box...\n  var parentMatrixWorldInv;\n  if (object3D.parent) {\n    object3D.parent.updateMatrixWorld();\n    parentMatrixWorldInv = new THREE.Matrix4();\n    parentMatrixWorldInv.getInverse(object3D.parent.matrixWorld);\n  }\n\n  if (scaleVector) {\n    object3D.scale.copy(scaleVector);\n  }\n  var bb = Object3DUtil.computeBoundingBox(object3D, parentMatrixWorldInv);\n  // Scale to be unit?\n//  var dims = bb.dimensions();\n//  var maxDim = Math.max( dims.x, dims.y, dims.z );\n//  object3D.scale.multiplyScalar(1.0/maxDim);\n//  bb = Object3DUtil.computeBoundingBox(object3D, parentMatrixWorldInv);\n\n  var shift = new THREE.Vector3();\n  shift.addVectors(bb.min, bb.max);\n  shift.multiplyScalar(-0.5);\n\n  // Place object in center\n  object3D.position.copy(shift);\n\n  object3D.updateMatrix();\n  Object3DUtil.clearCache(object3D);\n};\n\nObject3DUtil.setChildAttachmentPoint = function (parent, child, p, pointCoordFrame) {\n  // Note: We want T1 * T2 = T1' T2' = T3\n  //       So T1' = T1 * T2 * (T2')^-1\n  //       For other child transforms:\n  //         Want T1 * Tc = T1' * Tc'\n  //         =>           = T1 * T2 * (T2')^-1 * Tc'\n  //         =>   Tc' = T2' * (T2)^-1 * Tc\n  var oldModelBaseMatrixInv = new THREE.Matrix4();\n  oldModelBaseMatrixInv.getInverse(child.matrix);\n\n  var matrix = new THREE.Matrix4();\n  matrix.multiplyMatrices(parent.matrix, child.matrix);\n\n  // TODO: Should we be clearing the transform of the child here?\n  if (pointCoordFrame === 'worldBB') {\n    var worldBB = Object3DUtil.computeBoundingBox(child);\n    var wp = worldBB.getWorldPosition(p);\n    var pm = new THREE.Matrix4();\n    pm.getInverse(child.matrixWorld);\n    var cp = wp.applyMatrix4(pm);\n\n    Object3DUtil.clearTransform(child);\n    child.position.set(-cp.x, -cp.y, -cp.z);\n    child.updateMatrix();\n  } else if (pointCoordFrame === 'parentBB') {\n    // NOTE: Unchecked logic!!!\n    var rot = new THREE.Matrix4();\n    rot.makeRotationFromQuaternion(parent.quaternion);\n    var modelBB = Object3DUtil.computeBoundingBoxLocal(child, rot);\n    var cp = modelBB.getWorldPosition(p);\n\n    Object3DUtil.clearTransform(child);\n    child.quaternion.copy(parent.quaternion);\n    child.position.set(-cp.x, -cp.y, -cp.z);\n    child.updateMatrix();\n  } else if (pointCoordFrame === 'childBB') {\n    var modelBB = Object3DUtil.computeBoundingBoxLocal(child);\n    var cp = modelBB.getWorldPosition(p);\n\n    Object3DUtil.clearTransform(child);\n    child.position.set(-cp.x, -cp.y, -cp.z);\n    child.updateMatrix();\n  } else {\n    // Assume world coordinate frame\n    if (pointCoordFrame !== 'child') {\n      console.error('setChildAttachmentPoint invalid coord frame: ' + pointCoordFrame + ', using child');\n      pointCoordFrame = 'child';\n    }\n    var wp = p.clone();\n\n    child.position.set(-wp.x, -wp.y, -wp.z);\n    child.updateMatrix();\n  }\n\n  // Convert this.modelBaseObject3D to use the specified attachmentPoint\n  var modelBaseObject3DInv = new THREE.Matrix4();\n  modelBaseObject3DInv.getInverse(child.matrix);\n  matrix.multiply(modelBaseObject3DInv);\n\n  Object3DUtil.setMatrix(parent, matrix);\n  child.userData['attachmentPoint'] = p;\n  child.userData['attachmentPointCoordFrame'] = pointCoordFrame;\n\n  // Adjust other children of object3D\n  matrix.multiplyMatrices(child.matrix, oldModelBaseMatrixInv);\n  for (var i = 0; i < parent.children.length; i++) {\n    var c = parent.children[i];\n    if (child !== c) {\n      c.applyMatrix(matrix);\n      c.matrixWorldNeedsUpdate = true;\n    }\n  }\n  //parent.updateMatrix();\n  //parent.updateMatrixWorld();\n};\n\nObject3DUtil.setMatrix = function (obj, matrix) {\n  obj.matrix.copy(matrix);\n  obj.matrix.decompose(obj.position, obj.quaternion, obj.scale);\n  obj.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n  Object3DUtil.clearCache(obj);\n};\n\nObject3DUtil.snapToInteger = function (v, epsilon) {\n  if (epsilon) {\n    if (v instanceof THREE.Vector3) {\n      return new THREE.Vector3(\n        Object3DUtil.snapToInteger(v.x, epsilon),\n        Object3DUtil.snapToInteger(v.y, epsilon),\n        Object3DUtil.snapToInteger(v.z, epsilon)\n      );\n    } else if (typeof v === 'number') {\n      var rounded = Math.round(v);\n      return (Math.abs(rounded - v) < epsilon) ? rounded : v;\n    }\n  }\n  return v;\n};\n\nObject3DUtil.getReflectionMatrix = function(component, matrix) {\n  matrix = matrix || new THREE.Matrix4();\n  if (component === 'x' || component === 'yz') {\n    matrix.set(\n      -1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1\n    );\n  } else if (component === 'y' || component == 'xz') {\n    matrix.set(\n      1, 0, 0, 0,\n      0, -1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1\n    );\n  } else if (component === 'z' || component == 'xy') {\n    matrix.set(\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, -1, 0,\n      0, 0, 0, 1\n    );\n  } else {\n    throw \"Invalid reflection parameter: \" + component;\n  }\n  return matrix;\n};\n\nObject3DUtil.reflect = (function() {\n  var transform = new THREE.Matrix4();\n  return function(object3D, component) {\n    Object3DUtil.getReflectionMatrix(component, transform);\n    object3D.applyMatrix4(transform);\n  }\n})();\n\n// Helper functions  for rotating objects\nObject3DUtil.rotateObject3DEuler = function (obj, delta, order, stationaryBbBoxPoint) {\n  obj.updateMatrixWorld();\n  var bb = Object3DUtil.getBoundingBox(obj);\n  var base = bb.getWorldPosition(stationaryBbBoxPoint);\n  Object3DUtil.placeObject3D(obj, new THREE.Vector3(), stationaryBbBoxPoint);\n\n  var q = new THREE.Quaternion();\n  q.setFromEuler(new THREE.Euler(delta.x, delta.y, delta.z, order), true);\n  obj.quaternion.multiply(q);\n  obj.updateMatrix();\n\n  Object3DUtil.clearCache(obj);\n  Object3DUtil.placeObject3D(obj, base, stationaryBbBoxPoint);\n};\n\nObject3DUtil.rotateObject3DAboutAxis = function() {\n  var origin = new THREE.Vector3();\n  var q = new THREE.Quaternion();\n  var v = new THREE.Vector3();\n  return function (obj, axis, delta, stationaryBbBoxPoint) {\n      //console.time('rotateObject3DAboutAxis');\n      obj.updateMatrixWorld();\n      var bb = Object3DUtil.getBoundingBox(obj);\n      var base = bb.getWorldPosition(stationaryBbBoxPoint);\n      Object3DUtil.placeObject3D(obj, origin, stationaryBbBoxPoint);\n\n      var qwi = obj.getWorldQuaternion(q).inverse();\n      v.copy(axis);\n      var localAxis = v.applyQuaternion(qwi);\n      q.setFromAxisAngle(localAxis, delta);\n      obj.quaternion.multiply(q);\n      obj.updateMatrix();\n\n      Object3DUtil.clearCache(obj);\n      Object3DUtil.placeObject3D(obj, base, stationaryBbBoxPoint);\n      //console.timeEnd('rotateObject3DAboutAxis');\n  };\n}();\n\nObject3DUtil.rotateObject3DWrtBBFace = function (obj, axis, delta, bbface) {\n  if (bbface === undefined) {\n    bbface = Constants.BBoxFaceCenters.BOTTOM;\n  }\n  var stationaryBbBoxPoint = Object3DUtil.FaceCenters01[bbface];\n  Object3DUtil.rotateObject3DAboutAxis(obj, axis, delta, stationaryBbBoxPoint);\n};\n\nObject3DUtil.rotateObject3DAboutAxisSimple = function() {\n  var q = new THREE.Quaternion();\n  var v = new THREE.Vector3();\n  return function (obj, axis, delta, isWorld) {\n      //console.time('rotateObject3DAboutAxisSimple');\n      var localAxis = axis;\n      if (isWorld) {\n          var qwi = obj.getWorldQuaternion(q).inverse();\n          v.copy(axis);\n          localAxis = v.applyQuaternion(qwi);\n      }\n\n      q.setFromAxisAngle(localAxis, delta);\n      obj.quaternion.multiplyQuaternions(obj.quaternion, q);\n      obj.updateMatrix();\n      Object3DUtil.clearCache(obj);\n      //console.timeEnd('rotateObject3DAboutAxisSimple');\n  };\n}();\n\nObject3DUtil.alignObjectObbUpFront = (function() {\n  var t1 = new THREE.Vector3();\n  var t2 = new THREE.Vector3();\n  var t3 = new THREE.Vector3();\n  return function(object3D, obb, targetUp, targetFront) {\n    targetUp = targetUp || Constants.worldUp;\n    targetFront = targetFront || Constants.worldFront;\n    if (obb.isAxisAligned()) {\n      console.log('OBB is already axis aligned');\n    } else {\n      // chose minimum change\n      obb.extractBasis(t1, t2, t3);\n      var ts = [t1,t2,t3];\n      var indices = [0,1,2];\n      var upAxisIndex = _.maxBy(indices, function(i) { return Math.abs(ts[i].dot(targetUp)); });\n      indices = indices.filter(function(i) { return i != upAxisIndex; });\n      var frontAxisIndex = _.maxBy(indices, function(i) { return Math.abs(ts[i].dot(targetFront)); });\n      var upAxis = ts[upAxisIndex];\n      var frontAxis = ts[frontAxisIndex];\n      if (upAxis.dot(targetUp) <  0) {\n        upAxis.negate();\n      }\n      if (frontAxis.dot(targetFront) < 0) {\n        frontAxis.negate();\n      }\n      //console.log(upAxis, frontAxis, targetUp, targetFront);\n      // Like Object3DUtil.alignToUpFront but doesn't clear initial rotation\n      var transform = Object3DUtil.getAlignmentMatrix(upAxis, frontAxis, targetUp, targetFront);\n      // Apply this transform to matrix\n      object3D.applyMatrix(transform);\n      object3D.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n      Object3DUtil.clearCache(object3D);\n    }\n  };\n})();\n\n\n// Helper functions  for rotating objects\nObject3DUtil.applyAlignment = function (obj, alignment, stationaryBbBoxPoint) {\n  obj.updateMatrixWorld();\n  var bb = Object3DUtil.getBoundingBox(obj);\n  var base = bb.getWorldPosition(stationaryBbBoxPoint);\n  Object3DUtil.placeObject3D(obj, new THREE.Vector3(), stationaryBbBoxPoint);\n\n  var transform = alignment;\n  // Apply this transform to matrix\n  obj.applyMatrix(transform);\n  obj.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n  Object3DUtil.clearCache(obj);\n\n  Object3DUtil.placeObject3D(obj, base, stationaryBbBoxPoint);\n};\n\n// Helper functions for centering and rescaling object3ds\nObject3DUtil.centerAndRescaleObject3DToWorld = function (obj, targetSize, centerTo, bbBoxPointToCenter) {\n  targetSize = targetSize || 80;\n  var bb = Object3DUtil.getBoundingBox(obj);\n  var bbSize = bb.dimensions();\n  var scale = targetSize / bbSize.length();\n  obj.scale.x = obj.scale.y = obj.scale.z = scale;\n  obj.updateMatrix();\n  centerTo = centerTo || new THREE.Vector3();\n  Object3DUtil.clearCache(obj);\n  Object3DUtil.placeObject3D(obj, centerTo, bbBoxPointToCenter);\n};\n\n\n/* placeObject3D takes a THREE.Object3D, a target position (THREE.Vector3), and relative position\n (THREE.Vector3 in the object3D's world bbox coordinate frame with min = [0,0,0] and max = [1,1,1]) to position.\n The function places the object such that the bbBoxPointToPosition when transformed to world coordinates\n matches the specified position */\nObject3DUtil.placeObject3D = function (obj, targetWorldPosition, bbBoxPointToPosition) {\n  if (!targetWorldPosition) {\n    targetWorldPosition = new THREE.Vector3(0, 0, 0);\n  }\n  if (!bbBoxPointToPosition) {\n    bbBoxPointToPosition = new THREE.Vector3(0.5, 0.5, 0.5);\n  }\n\n  var bb = Object3DUtil.getBoundingBox(obj);\n  var currentWorldPosition = bb.getWorldPosition(bbBoxPointToPosition);\n\n  var shift;\n  if (obj.parent) {\n    obj.parent.updateMatrixWorld();\n    var current = obj.parent.worldToLocal(currentWorldPosition.clone());\n    var target = obj.parent.worldToLocal(targetWorldPosition.clone());\n    shift = target.clone();\n    shift.sub(current);\n  } else {\n    shift = targetWorldPosition.clone();\n    shift.sub(currentWorldPosition);\n  }\n  obj.position.add(shift);\n  obj.updateMatrix();\n  Object3DUtil.clearCache(obj);\n};\n\nObject3DUtil.placeObject3DByOrigin = function (obj, targetWorldPosition) {\n  var shift;\n  if (obj.parent) {\n    obj.parent.updateMatrixWorld();\n  } else {\n    obj.updateMatrixWorld();\n  }\n  var currentWorldPosition = obj.localToWorld(new THREE.Vector3());\n  if (obj.parent) {\n    var current = obj.parent.worldToLocal(currentWorldPosition.clone());\n    var target = obj.parent.worldToLocal(targetWorldPosition.clone());\n    shift = target.clone();\n    shift.sub(current);\n  } else {\n    shift = targetWorldPosition.clone();\n    shift.sub(currentWorldPosition);\n  }\n  obj.position.add(shift);\n  obj.updateMatrix();\n  Object3DUtil.clearCache(obj);\n};\n\n/* placeObject3DByBBFaceCenter takes a THREE.Object3D, a THREE.Vector3, and an int\n demarking the face of which the center will be used as a reference point for placement.\n Appropriate values can be found in the Constants.BBoxFaceCenters enum.  The function\n places the object such that the center of the chosen face is at the given location */\nObject3DUtil.placeObject3DByBBFaceCenter = function (obj, targetWorldPosition, bboxFaceCenterIndex) {\n  var bbBoxPointToPosition = Object3DUtil.FaceCenters01[bboxFaceCenterIndex];\n  Object3DUtil.placeObject3D(obj, targetWorldPosition, bbBoxPointToPosition);\n};\n\nObject3DUtil.getBBoxFaceCenter = function (obj, bboxFaceCenterIndex) {\n  // Clone center so it's okay in case it gets mutated.\n  var centers = Object3DUtil.getBoundingBox(obj).getFaceCenters();\n  return centers[bboxFaceCenterIndex].clone();\n};\n\nObject3DUtil.tumble = function (obj, bboxFaceCenterIndex) {\n  if (!obj.userData) {\n    obj.userData = {};\n  }\n  var tumbleIndex = (obj.userData['tumbleIndex'] + 1) % 3;\n  var transform = Object3DUtil.getAlignmentMatrix(\n    new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 1, 0),\n    new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1));\n  var bboxFaceCenter;\n  if (bboxFaceCenterIndex !== undefined) {\n    bboxFaceCenter = Object3DUtil.FaceCenters01[bboxFaceCenterIndex];\n  } else {\n    // TODO: Should we have this as the default?\n    bboxFaceCenter = Object3DUtil.FaceCenters01[Constants.BBoxFaceCenters.BOTTOM];\n  }\n  Object3DUtil.applyAlignment(obj, transform, bboxFaceCenter);\n  obj.userData['tumbleIndex'] = tumbleIndex;\n};\n\nObject3DUtil.rescaleObject3D = function (obj, scale) {\n  obj.scale.x = obj.scale.y = obj.scale.z = scale;\n  obj.updateMatrix();\n  Object3DUtil.clearCache(obj);\n};\n\nObject3DUtil.rescaleObject3DToFit = function (obj, dim, tolRange) {\n  var bbSize = Object3DUtil.getBoundingBoxDims(obj);\n  var scale;\n  if ((typeof dim) === 'number') {\n    scale = dim / bbSize.length();\n  } else if (dim.rescaleBy) {\n    if (!dim.rescaleTo) {\n      throw \"Missing rescaleTo\";\n    }\n    if (dim.rescaleBy === 'max') {\n      scale = dim.rescaleTo / Math.max(bbSize.x, bbSize.y, bbSize.z);\n    } else if (dim.rescaleBy === 'diagonal') {\n      scale = dim.rescaleTo / bbSize.length();\n    } else {\n      throw \"Unsupported rescaleBy \" + dim.rescaleBy;\n    }\n  } else {\n    var scaleV = new THREE.Vector3();\n    scaleV.copy(dim);\n    scaleV.divide(bbSize);\n    scale = Math.min(scaleV.x, scaleV.y, scaleV.z);\n  }\n  if (tolRange && tolRange[0] <= scale && tolRange[1] >= scale) {\n    return;\n  }\n  obj.scale.multiplyScalar(scale);\n  //obj.scale.x = obj.scale.y = obj.scale.z = scale;\n  obj.updateMatrix();\n  Object3DUtil.clearCache(obj);\n};\n\nObject3DUtil.makeSymmetryPlane = function (bb, planeType, normal, dist, planeColor, transparency) {\n  var c = (planeColor !== undefined) ? planeColor : 0x0000A0;\n  var faceMat = new THREE.MeshPhongMaterial({\n    color: c,\n    specular: c,\n    //ambient:  c,\n    emissive: c,\n    side: THREE.DoubleSide,\n    opacity: 1\n  });\n  if (transparency === undefined) {\n    transparency = 0.6;\n  }\n  if (transparency > 0.0) {\n    faceMat.opacity = 1 - transparency;\n    faceMat.transparent = true;\n  }\n  var dims = bb.dimensions();\n  var width, height, u, v;\n  switch (planeType) {\n    case 'X':\n      width = dims.y;\n      height = dims.z;\n      v = new THREE.Vector3(0, 0, 1);\n      u = new THREE.Vector3(1, 0, 0);\n      break;\n    case 'Y':\n      width = dims.x;\n      height = dims.z;\n      v = new THREE.Vector3(0, 0, 1);\n      u = new THREE.Vector3(0, 1, 0);\n      break;\n    case 'Z':\n      width = dims.x;\n      height = dims.y;\n      v = new THREE.Vector3(0, 1, 0);\n      u = new THREE.Vector3(0, 0, 1);\n      break;\n    case 'nd':\n      // TODO(MS): Unhack\n      width = 10 * dims.x;\n      height = 10 * dims.y;\n      var w = normal.clone();\n      // Get random perpendicular to normal\n      var rand = new THREE.Vector3(RNG.global.random(), RNG.global.random(), RNG.global.random());\n      rand = rand.normalize();\n      var randLengthInNormalDir = rand.dot(normal);\n      var randPartInNormalDir = w.multiplyScalar(randLengthInNormalDir);\n      u = normal;\n      v = rand.clone();\n      v.sub(randPartInNormalDir);\n      v.normalize();\n      //v = new THREE.Vector3();\n      //v = v.crossVectors(normal, u);\n      //console.log(normal);\n      //console.log(u);\n      //console.log(v);\n      break;\n    default:\n      return null;\n  }\n\n  var planeU = new THREE.Vector3(0, 0, 1);\n  var planeV = new THREE.Vector3(0, 1, 0);\n  var geometryPlane = new THREE.PlaneGeometry(width, height, 1, 1);\n  var meshPlane = new THREE.Mesh(geometryPlane, faceMat);\n  Object3DUtil.alignToUpFrontAxes(meshPlane, planeU, planeV, u, v);\n  Object3DUtil.placeObject3D(meshPlane, bb.centroid());\n  return meshPlane;\n};\n\nObject3DUtil.makeGrid = function (width, height, numHGridLines, numVGridLines, faceColor) {\n\n  var c = faceColor;\n  if (!c) c = 0xdadada;\n\n  var MAX_X = width / 2;\n  var MIN_X = 0 - (width / 2);\n  var MAX_Y = height / 2;\n  var MIN_Y = 0 - (height / 2);\n\n  var blockSizeH = height / numHGridLines;\n  var blockSizeV = width / numVGridLines;\n\n  var epsilon = 2;\n\n  var geometryH = new THREE.Geometry();\n  geometryH.vertices.push(new THREE.Vector3(MIN_X, MAX_Y, epsilon));\n  geometryH.vertices.push(new THREE.Vector3(MAX_X, MAX_Y, epsilon));\n\n  var geometryV = new THREE.Geometry();\n  geometryV.vertices.push(new THREE.Vector3(MIN_X, MIN_Y, epsilon));\n  geometryV.vertices.push(new THREE.Vector3(MIN_X, MAX_Y, epsilon));\n\n  var lineMat = new THREE.LineBasicMaterial({\n    color: 0xa0a0a0,\n    opacity: 1\n  });\n\n  var faceMat = new THREE.MeshBasicMaterial({\n    color: c, //0x575145,\n    opacity: 1\n  });\n  var geometryPlane = new THREE.PlaneBufferGeometry(width, height, 1, 1);\n  var meshPlane = new THREE.Mesh(geometryPlane, faceMat);\n\n  var object3D = new THREE.Object3D();\n\n  for (var iy = 0; iy <= numHGridLines; iy++) {\n    var lineX = new THREE.Line(geometryH, lineMat);\n    lineX.position.y = -iy * blockSizeH;\n    object3D.add(lineX);\n  }\n  for (var ix = 0; ix <= numVGridLines; ix++) {\n    var lineY = new THREE.Line(geometryV, lineMat);\n    lineY.position.x = ix * blockSizeV;\n    object3D.add(lineY);\n  }\n\n  object3D.add(meshPlane);\n  object3D.name = 'Grid';\n  object3D.userData.totalWidth = width;\n  object3D.userData.totalHeight = height;\n  object3D.userData.gridWidth = blockSizeV;\n  object3D.userData.gridHeight = blockSizeH;\n  object3D.userData.gridColor = faceColor;\n\n  return object3D;\n};\n\nObject3DUtil.makeAxes = function (axisLength) {\n\n  if (!axisLength) axisLength = 1*Constants.metersToVirtualUnit;\n\n  var axes = new THREE.Object3D();\n\n  //Shorten the vertex function\n  function v(x, y, z) {\n    return new THREE.Vector3(x, y, z);\n  }\n\n  //Create axis (point1, point2, colour)\n  function createAxis(p1, p2, color) {\n    var line, lineGeometry = new THREE.Geometry(),\n      lineMat = new THREE.LineBasicMaterial({color: color, linewidth: 10});\n    lineGeometry.vertices.push(p1, p2);\n    line = new THREE.Line(lineGeometry, lineMat);\n    axes.add(line);\n  }\n\n  createAxis(v(0, 0, 0), v(axisLength, 0, 0), 0xFF0000);\n  createAxis(v(0, 0, 0), v(0, axisLength, 0), 0x00FF00);\n  createAxis(v(0, 0, 0), v(0, 0, axisLength), 0x0000FF);\n\n  return axes;\n};\n\nObject3DUtil.makeGround = function (width, height, color) {\n  var geometry = new THREE.PlaneBufferGeometry(width, height);\n  //geometry.verticesArray = geometry.attributes['position'].array;\n  geometry.computeFaceNormals();\n  var planeMaterial = new THREE.MeshBasicMaterial({ color: color || 0xffffff });\n  //planeMaterial.ambient = planeMaterial.color;\n  //planeMaterial.side = THREE.DoubleSide;\n  var ground = new THREE.Mesh(geometry, planeMaterial);\n  ground.castShadow = false;\n  ground.receiveShadow = true;\n\n  var object3D = new THREE.Object3D();\n  object3D.add(ground);\n\n  Object3DUtil.alignToUpFrontAxes(object3D, new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0), Constants.worldUp, Constants.worldFront);\n\n  return object3D;\n};\n\nObject3DUtil.makePickingPlane = function (width, height) {\n  var geometry = new THREE.PlaneBufferGeometry(width, height);\n  geometry.computeFaceNormals();\n  var planeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide, visible: false });\n  var ground = new THREE.Mesh(geometry, planeMaterial);\n  ground.name = 'PickingPlane';\n  ground.userData.width = width;\n  ground.userData.heigth = height;\n  Object3DUtil.alignToUpFrontAxes(ground, new THREE.Vector3(0, 0, 1), new THREE.Vector3(1, 0, 0), Constants.worldUp, Constants.worldFront);\n  return ground;\n};\n\nObject3DUtil.createGroundAndFog = function (scene) {\n  var geometry = new THREE.PlaneBufferGeometry(100, 100);\n  var planeMaterial = new THREE.MeshPhongMaterial({color: 0xffdd99});\n  planeMaterial.color.offsetHSL(0, 0, 0.9);\n  //planeMaterial.ambient = planeMaterial.color;\n  var ground = new THREE.Mesh(geometry, planeMaterial);\n  ground.scale.set(100, 100, 100);\n  ground.castShadow = false;\n  ground.receiveShadow = true;\n  scene.add(ground);\n\n  scene.fog = new THREE.Fog(0xffaa55, 1000, 3000);\n  scene.fog.color.offsetHSL(0.02, -0.15, -0.65);\n};\n\nObject3DUtil.getBBoxForModelInstanceArray = function (models) {\n  var r = new BBox();\n  for (var i = 0; i < models.length; i++) {\n    r.includeObject3D(models[i].model.object3D);\n  }\n  r.bboxDims = r.dimensions();\n  r.width = r.bboxDims.x;\n  r.height = r.bboxDims.z;\n  r.depth = r.bboxDims.y;\n\n  return r;\n};\n\nObject3DUtil.getColor = function (value) {\n  return Colors.toColor(value);\n};\n\nObject3DUtil.createColor = function (id, palette) {\n  return Colors.createColor(id, palette || Constants.defaultPalette);\n};\n\nObject3DUtil.getBasicMaterial = function (color, alpha) {\n  return Materials.getBasicMaterial(color, alpha);\n};\n\nObject3DUtil.getMaterial = function (mat) {\n  return Materials.toMaterial(mat);\n};\n\nObject3DUtil.getStandardMaterial = function (color, alpha) {\n  return Materials.getStandardMaterial(color, alpha);\n};\n\nObject3DUtil.getSimpleFalseColorMaterial = function (id, color, palette) {\n  return Materials.getSimpleFalseColorMaterial(id, color, palette);\n};\n\nObject3DUtil.addSimple2LightSetup = function (scene, position, doShadowMap) {\n  position = position || new THREE.Vector3(-100, 100, 100);\n  var ambient = new THREE.AmbientLight(0x050505);\n\n  var light0 = new THREE.PointLight(0xdadacd, 0.85);\n  var p0 = new THREE.Vector3();\n  p0.copy(position);\n  light0.position.copy(p0);\n  var light1 = new THREE.PointLight(0x030309, 0.03);\n  var p1 = new THREE.Vector3();\n  p1.copy(position);\n  p1.negate();\n  light1.position.copy(p1);\n\n  if (doShadowMap) {\n    var light = Lights.createSpotLightShadowMapped(1000);\n    light.position.copy(light0.position);\n    light.onlyShadow = true;\n    scene.add(light);\n  }\n\n  scene.add(ambient);\n  scene.add(light0);\n  scene.add(light1);\n};\n\nObject3DUtil.getTotalDims = function (models) {\n\n  var total = new THREE.Vector3(0, 0, 0);\n\n  for (var k = 0; k < models.length; k++) {\n    var dims = models[k].getBBox().dimensions();\n    total.add(dims);\n  }\n\n  return total;\n};\n\nObject3DUtil.getSortedModels = function (models, sizeBy) {\n  if (!sizeBy) sizeBy = 'height';\n\n  var sizes = [];\n  for (var k = 0; k < models.length; k++) {\n    var dims = models[k].getBBox().dimensions();\n    sizes[k] = Object3DUtil.convertBbDimsToSize(dims, sizeBy);\n  }\n  var sortedIndices = _.sortWithIndices(sizes).sortedIndices;\n  var sortedModels = [];\n  for (var i = 0; i < sortedIndices.length; i++) {\n    sortedModels[i] = models[sortedIndices[i]];\n  }\n  return sortedModels;\n};\n\nObject3DUtil.lineup = function (models, params) {\n  params = params || {};\n  var y = params.y || 0;\n  // Spacing between objects\n  var objectSpacing = params.objectSpacing || 0.00;\n  // Ratio for computing spacing between objects (as parameter of total width)\n  var objectSpacingRatio = params.objectSpacingRatio || 0.05;\n\n  // Initialize\n  var l = {};\n  l.nModels = models.length;\n  var bbBoxRefPoint = new THREE.Vector3(0.5, 0.5, 0);\n  l.widths = [];\n  l.heights = [];\n  l.depths = [];\n  l.maxDepth = 0;\n  l.medianHeight = -1;\n  l.sumWidth = 0;\n  l.sumWidthWithGaps = 0;\n\n  // Sort models by height\n  var sizes = [];\n  for (var k = 0; k < models.length; k++) {\n    var dims = models[k].getBBox().dimensions();\n    sizes[k] = dims.z;\n  }\n  l.sortedIndices = _.sortWithIndices(sizes).sortedIndices;\n\n  // Loop over models and save dims\n  for (var i = 0; i < l.nModels; i++) {\n    var bbox = models[l.sortedIndices[i]].getBBox();\n    var w = bbox.dimensions().x;\n    var d = bbox.dimensions().y;\n    var h = bbox.dimensions().z;\n    l.widths[i] = w;\n    l.heights[i] = h;\n    l.depths[i] = d;\n    if (d > l.maxDepth) l.maxDepth = d;\n    l.sumWidth += w;\n  }\n\n  l.medianHeight = _.sortWithIndices(l.heights)[Math.round(models.length / 2)];\n  var gapx = Math.max( l.sumWidth*objectSpacingRatio, objectSpacing );\n  var sumWidthWithGaps = l.sumWidth + (l.nModels - 1)*gapx;\n  var epsilon = l.sumWidth * 0.01;\n  var startX = -sumWidthWithGaps / 2;\n  var currCenter = new THREE.Vector3(startX, y + l.maxDepth / 2, 0);\n\n  // Lineup in order from left to right\n  for (var j = 0; j < l.nModels; j++) {\n    var model = models[l.sortedIndices[j]];\n    var halfWidthPlus = (l.widths[j] + epsilon) / 2;\n    currCenter.x += halfWidthPlus;\n    Object3DUtil.placeObject3D(model.object3D, currCenter, bbBoxRefPoint);\n    currCenter.x += halfWidthPlus;\n  }\n\n  return l;\n};\n\nObject3DUtil.matrix4ToProto = function (m) {\n  var array = [];\n  for (var j = 0; j < 16; j++) {\n    array.push(m.elements[j]);\n  }\n  var transform = {\n    rows: 4,\n    cols: 4,\n    data: array\n  };\n  return transform;\n};\n\nObject3DUtil.vectorToString = function (v) {\n  return v.x + ',' + v.y + ',' + v.z;\n};\n\nObject3DUtil.quaternionToString = function (v) {\n  return v.x + ',' + v.y + ',' + v.z + \",\" + v.w;\n};\n\nObject3DUtil.toVector2 = function (v) {\n  if (v) {\n    if (v instanceof THREE.Vector2) {\n      return v;\n    } else if (typeof v === 'string') {\n      // parse 0,0 into two pieces\n      v = v.trim();\n      if (v) {\n        if ((v.startsWith('[') && v.endsWith(']')) || (v.startsWith('(') && v.endsWith(')'))) {\n          v = v.substring(1, v.length - 1);\n        }\n        v = _.replaceAll(v, '\\\\,', ',');\n        var p = v.split(/\\s*,\\s*/, 2).map( function(x) { return parseFloat(x); });\n        if (p.length === 2) {\n          return new THREE.Vector2(p[0], p[1]);\n        } else {\n          console.error('Cannot convert object to Vector2', v);\n          return null;\n        }\n      }\n    } else if (v.x != undefined && v.y != undefined) {\n      return new THREE.Vector2(v.x, v.y);\n    } else if (v.count || v.length) {\n      v = v.map(function(x) { return typeof x === 'string'? parseFloat(x) : x; });\n      return new THREE.Vector2(v[0], v[1]);\n    } else {\n      console.error('Cannot convert object to Vector2', v);\n      return null;\n    }\n  }\n};\n\nObject3DUtil.toVector3 = function (v) {\n  if (v) {\n    if (v instanceof THREE.Vector3) {\n      return v;\n    } else if (typeof v === 'string') {\n      // parse 0,0,0 into three pieces\n      v = v.trim();\n      if (v) {\n        if ((v.startsWith('[') && v.endsWith(']')) || (v.startsWith('(') && v.endsWith(')'))) {\n          v = v.substring(1, v.length - 1);\n        }\n        v = _.replaceAll(v, '\\\\,', ',');\n        var p = v.split(/\\s*,\\s*/, 3).map( function(x) { return parseFloat(x); });\n        if (p.length === 3) {\n          return new THREE.Vector3(p[0], p[1], p[2]);\n        } else {\n          console.error('Cannot convert object to Vector3', v);\n          return null;\n        }\n      }\n    } else if (v.x != undefined && v.y != undefined && v.z != undefined) {\n      return new THREE.Vector3(v.x, v.y, v.z);\n    } else if (v.count || v.length) {\n      v = v.map(function(x) { return typeof x === 'string'? parseFloat(x) : x; });\n      return new THREE.Vector3(v[0], v[1], v[2]);\n    } else {\n      console.error('Cannot convert object to Vector3', v);\n      return null;\n    }\n  }\n};\n\nObject3DUtil.toQuaternion = function (v) {\n  if (v) {\n    if (v instanceof THREE.Quaternion) {\n      return v;\n    } else if (typeof v === 'string') {\n      // parse 0,0,0,0 into four pieces\n      v = v.trim();\n      if (v) {\n        if ((v.startsWith('[') && v.endsWith(']')) || (v.startsWith('(') && v.endsWith(')'))) {\n          v = v.substring(1, v.length - 1);\n        }\n        v = _.replaceAll(v, '\\\\,', ',');\n        var p = v.split(/\\s*,\\s*/, 4).map( function(x) { return parseFloat(x); });\n        if (p.length === 3) {\n          return new THREE.Quaternion(p[0], p[1], p[2], p[3]);\n        } else {\n          console.error('Cannot convert object to Quaternion', v);\n          return null;\n        }\n      }\n    } else if (v.x != undefined && v.y != undefined && v.z != undefined && v.w != undefined) {\n      return new THREE.Quaternion(v.x, v.y, v.z, v.w);\n    } else if (v.count || v.length) {\n      v = v.map(function(x) { return typeof x === 'string'? parseFloat(x) : x; });\n      return new THREE.Quaternion(v[0], v[1], v[2], v[3]);\n    } else {\n      console.error('Cannot convert object to Quaternion', v);\n      return null;\n    }\n  }\n};\n\nObject3DUtil.toBBox = function(b) {\n  if (b) {\n    if (b instanceof BBox) {\n      return b;\n    } else if (b.min && b.max) {\n      return new BBox(Object3DUtil.toVector3(b.min), Object3DUtil.toVector3(b.max));\n    } else {\n      console.error('Cannot convert object to BBox', b);\n      return null;\n    }\n  }\n};\n\nObject3DUtil.toBox2 = function(b) {\n  if (b) {\n    if (b instanceof THREE.Box2) {\n      return b;\n    } else if (b.min && b.max) {\n      return new BBox(Object3DUtil.toVector3(b.min), Object3DUtil.toVector3(b.max));\n    } else {\n      console.error('Cannot convert object to Box2', b);\n      return null;\n    }\n  }\n};\n\n\nObject3DUtil.toBox3 = function(b) {\n  if (b) {\n    if (b instanceof THREE.Box3) {\n      return b;\n    } else if (b.min && b.max) {\n      return new BBox(Object3DUtil.toVector2(b.min), Object3DUtil.toVector2(b.max));\n    } else {\n      console.error('Cannot convert object to Box3', b);\n      return null;\n    }\n  }\n};\n\nObject3DUtil.arrayToMatrix4 = function(m, isRowMajor) {\n  var matrix = new THREE.Matrix4();\n  if (m.length === 16) {\n    if (isRowMajor) {\n      matrix.set(\n        m[0], m[1], m[2], m[3],\n        m[4], m[5], m[6], m[7],\n        m[8], m[9], m[10], m[11],\n        m[12], m[13], m[14], m[15]);\n    } else {\n      matrix.set(\n        m[0], m[4], m[8], m[12],\n        m[1], m[5], m[9], m[13],\n        m[2], m[6], m[10], m[14],\n        m[3], m[7], m[11], m[15]);\n    }\n  } else if (m.length === 9) {\n    if (isRowMajor) {\n      matrix.set(\n        m[0], m[1], m[2], 0,\n        m[3], m[4], m[5], 0,\n        m[6], m[7], m[8], 0,\n        0, 0, 0, 1);\n    } else {\n      matrix.set(\n        m[0], m[3], m[6], 0,\n        m[1], m[4], m[7], 0,\n        m[2], m[5], m[8], 0,\n        0, 0, 0, 1);\n    }\n  } else {\n    console.warn('Invalid array length: ' + m.length);\n  }\n  return matrix;\n};\n\nObject3DUtil.isColinearVec2 = function(p1,p2,p3) {\n  var a = Math.abs((p1.y - p2.y) * (p1.x - p3.x) - (p1.y - p3.y) * (p1.x - p2.x));\n  return (a < 0.00000001);\n};\n\nObject3DUtil.isColinearVec3 = function(p1,p2,p3) {\n  // Check if cross product is 0\n  var v12 = new THREE.Vector3();\n  v12.subVectors(p1, p2);\n  var v13 = new THREE.Vector3();\n  v13.subVectors(p1, p3);\n  var z = new THREE.Vector3();\n  z.crossVectors(v12, v13);\n  return (z.lengthSq() < 0.00000001);\n};\n\nObject3DUtil.stringifyReplacer = function (key, value) {\n  if (value instanceof THREE.Material) {\n    return Materials.getMaterialParams(value);\n  } else if (value instanceof THREE.Texture) {\n    return Materials.getTextureParams(value);\n  } else if (value instanceof THREE.Color) {\n    return value.getHex().toString(16);\n  } else {\n    return value;\n  }\n};\n\nObject3DUtil.toObjStr = function (prefix, v) {\n  var p = prefix;\n  if (v instanceof THREE.Vector3) {\n    return p + ' ' + v.x + ' ' + v.y + ' ' + v.z;\n  } else if (v instanceof Array) {\n    return p + ' ' + v.join(' ');\n  } else {\n    return null;\n  }\n};\n\n\nObject3DUtil.loadTexture = function (url, mapping, onLoad, onError) {\n  return Materials.loadTexture({ url: url, mapping: mapping, onLoad: onLoad, onError: onError });\n};\n\n// DFS traversal of node\n// callback1 is applied before children are visited (children are visited only if callback1 returns true)\n// callback2 is applied after children are visited\nObject3DUtil.traverse = function (node, callback1, callback2) {\n  var processChildren = callback1(node);\n  if (processChildren) {\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      Object3DUtil.traverse(node.children[i], callback1, callback2);\n    }\n  }\n  if (callback2) {\n    callback2(node);\n  }\n};\n\nObject3DUtil.traversePrimitives = function (object3D, nonrecursive, callback) {\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (node instanceof THREE.Mesh || node instanceof THREE.Line || node instanceof THREE.Points) {\n        callback(node);\n        return true;\n      } else if (node instanceof THREE.Object3D) {\n        if (object3D === node) return true;\n        else if (nonrecursive) {\n          if (typeof(nonrecursive) === 'function') {\n            return nonrecursive(node);\n          } else {\n            // Skip if has modelInstance\n            if ((node.metadata && node.metadata.modelInstance) || (node.userData && node.userData.hasOwnProperty('objectIndex'))) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    });\n};\n\nObject3DUtil.traverseMeshes = function (object3D, nonrecursive, callback) {\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (node instanceof THREE.Mesh) {\n        callback(node);\n        return true;\n      } else if (node instanceof THREE.Object3D) {\n        if (object3D === node) return true;\n        else if (nonrecursive) {\n          if (typeof(nonrecursive) === 'function') {\n            return nonrecursive(node);\n          } else {\n            // Skip if has modelInstance\n            if ((node.metadata && node.metadata.modelInstance) || (node.userData && node.userData.hasOwnProperty('objectIndex'))) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    });\n};\n\nObject3DUtil.traverseVisibleMeshes = function (object3D, nonrecursive, callback) {\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (node instanceof THREE.Mesh) {\n        if (node.visible) {\n          callback(node);\n          return true;\n        }\n      } else if (node instanceof THREE.Object3D) {\n        if (object3D === node) return node.visible;\n        else if (nonrecursive) {\n          if (typeof(nonrecursive) === 'function') {\n            return nonrecursive(node);\n          } else {\n            // Skip if has modelInstance\n            if ((node.metadata && node.metadata.modelInstance) || (node.userData && node.userData.hasOwnProperty('objectIndex'))) {\n              return false;\n            }\n          }\n        }\n      }\n      return node.visible;\n    });\n};\n\nObject3DUtil.existsMesh = function (object3D, nonrecursive, callback) {\n  var exists = false;\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (node instanceof THREE.Mesh) {\n        exists = callback(node);\n        return !exists;\n      } else if (node instanceof THREE.Object3D) {\n        if (object3D === node) return true;\n        else if (nonrecursive) {\n          if (typeof(nonrecursive) === 'function') {\n            return nonrecursive(node);\n          } else {\n            // Skip if has modelInstance\n            if ((node.metadata && node.metadata.modelInstance) || (node.userData && node.userData.hasOwnProperty('objectIndex'))) {\n              return false;\n            }\n          }\n        }\n      }\n      return !exists;\n    });\n  return exists;\n};\n\nObject3DUtil.getIndexedObject3Ds = function (object3D) {\n  var objects = [];\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (node instanceof THREE.Object3D) {\n        if (node.userData && node.userData.hasOwnProperty('objectIndex')) {\n          objects[node.userData['objectIndex']] = node;\n        }\n      }\n      return true;\n    });\n  return objects;\n};\n\nObject3DUtil.traverseModelInstances = function (modelInstance, callback) {\n  Object3DUtil.traverse(\n    modelInstance.object3D,\n    function (node) {\n      if (node instanceof THREE.Object3D) {\n        if (modelInstance.object3D === node) return true;\n        if (node.metadata && node.metadata.modelInstance) {\n          callback(node.metadata.modelInstance);\n        }\n      }\n      return true;\n    });\n};\n\nObject3DUtil.hasDirectLineage = function(candidate, object3D) {\n  if (object3D instanceof Array) {\n    return object3D.indexOf(candidate) >= 0 || Object3DUtil.isAncestorOf(candidate, object3D) || Object3DUtil.isDescendantOf(candidate, object3D);\n  } else {\n    return object3D === candidate || Object3DUtil.isAncestorOf(candidate, object3D) || Object3DUtil.isDescendantOf(candidate, object3D);\n  }\n};\n\nObject3DUtil.isAncestorOf = function (candidate, object3D, includeSelf) {\n  // Is candidate ancestor of object3D?\n  var isAnc = false;\n  if (object3D instanceof Array) {\n    for (var i = 0; i < object3D.length; i++) {\n      isAnc = Object3DUtil.isAncestorOf(candidate, object3D[i], includeSelf);\n      if (isAnc) {\n        break;\n      }\n    }\n  } else {\n    var anc = Object3DUtil.findFirstAncestor(object3D, function(node) {\n      return node === candidate;\n    }, includeSelf);\n    isAnc = (anc != null);\n  }\n  return isAnc;\n};\n\nObject3DUtil.isDescendantOf = function (candidate, object3D, includeSelf) {\n  // Is candidate descendant of object3D?\n  var isDesc = false;\n  if (object3D instanceof Array) {\n    for (var i = 0; i < object3D.length; i++) {\n      isDesc = Object3DUtil.isDescendantOf(candidate, object3D[i], includeSelf);\n      if (isDesc) {\n        break;\n      }\n    }\n  } else {\n    var anc = Object3DUtil.findFirstAncestor(candidate, function(node) {\n      return node === object3D;\n    }, includeSelf);\n    isDesc = (anc != null);\n  }\n  return isDesc;\n};\n\nObject3DUtil.deepClone = function(object3D) {\n  // Deep clone that makes a copy of the geometry as well\n  var clone = object3D.clone();\n  clone.traverse(function (node) {\n    if (node instanceof THREE.Mesh || node instanceof THREE.Line || node instanceof THREE.Points) {\n      var newGeom = GeometryUtil.clone(node.geometry);\n      node.geometry = newGeom;\n    }\n  });\n  return clone;\n};\n\nObject3DUtil.deepConvert = function(object3D, convertFn) {\n  Object3DUtil.traverse(object3D, function(node) {\n    return true;\n  }, function(node) {\n    var converted = _.map(node.children, convertFn);\n    Object3DUtil.removeAllChildren(node);\n    for (var i = 0; i < converted.length; i++) {\n      node.add(converted[i]);\n    }\n  });\n  return convertFn(object3D);\n};\n\nObject3DUtil.copyObjectWithModelInstances = function (origObject, modelInstances, keepOldIndices, indexField) {\n  indexField = indexField || 'objectIndex';\n  // Clone object\n  Object3DUtil.revertMaterials(origObject);\n  origObject.updateMatrixWorld();\n  var clonedObject = origObject.clone();\n\n  // we want the cloned object to be detached, so set its matrix transform to its matrixWorld\n  // and update position, quaternion and scale so the matrix is retained.\n  clonedObject.matrix = clonedObject.matrixWorld.clone();\n  clonedObject.matrix.decompose(clonedObject.position, clonedObject.quaternion, clonedObject.scale);\n  clonedObject.updateMatrixWorld();\n\n  // Make sure attached model instance information is properly copied as well\n  var clonedModelInstances = [];\n  Object3DUtil.traverse(clonedObject, function (node) {\n    if (node.userData.type === 'ModelInstance') {\n      var objectIndex = node.userData[indexField];\n      var modelInstance = modelInstances[objectIndex].clone(node);\n      node.metadata = {modelInstance: modelInstance};\n\n      var nextIndex = (keepOldIndices)? objectIndex : clonedModelInstances.length;\n      modelInstance.index = nextIndex;\n      node.index = nextIndex;\n      node.userData[indexField] = nextIndex;\n      clonedModelInstances[nextIndex] = modelInstance;\n    }\n    return true;\n  });\n\n  return {\n    object: clonedObject,\n    modelInstances: clonedModelInstances\n  };\n};\n\nObject3DUtil.findModelInstances = function (object3D, modelInstances, indexField) {\n  modelInstances = modelInstances || [];\n\n  Object3DUtil.traverse(object3D, function (node) {\n    if (node.userData.type === 'ModelInstance') {\n      if (indexField) {\n        node.userData[indexField] = modelInstances.length;\n      }\n      modelInstances.push(node.metadata.modelInstance);\n    }\n    return true;\n  });\n\n  return modelInstances;\n};\n\nObject3DUtil.detachModelInstances = function (modelInstance, detachAll, scene) {\n  var modelInstances = Object3DUtil.findModelInstances(modelInstance.object3D);\n  var detached = [];\n  for (var i = 0; i < modelInstances.length; i++) {\n    var mi = modelInstances[i];\n    if (mi.index !== modelInstance.index) {\n      var parent = mi.object3D.parent;\n      var parentInstance = Object3DUtil.getModelInstance(parent);\n      var detach = detachAll || parentInstance.index === mi.index;\n      if (detach) {\n        Object3DUtil.detachFromParent(mi.object3D, scene);\n        detached.push(mi);\n      }\n    }\n  }\n  return detached;\n};\n\n\nObject3DUtil.clearCache = function (object3D) {\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      delete node.cached;\n      return true;\n    });\n};\n\nObject3DUtil.dispose = function(parentObject) {\n  parentObject.traverse(function (node) {\n    // TODO: properly dispose of materials, textures and lights\n    if (node instanceof THREE.Mesh || node instanceof THREE.Line || node instanceof THREE.Points) {\n      if (node.geometry) {\n        node.geometry.dispose();\n      }\n\n      if (node.material) {\n\n        if (Array.isArray(node.material)) {\n          node.material.forEach(function (mtrl, idx) {\n            if (mtrl.map) mtrl.map.dispose();\n            if (mtrl.lightMap) mtrl.lightMap.dispose();\n            if (mtrl.bumpMap) mtrl.bumpMap.dispose();\n            if (mtrl.normalMap) mtrl.normalMap.dispose();\n            if (mtrl.specularMap) mtrl.specularMap.dispose();\n            if (mtrl.envMap) mtrl.envMap.dispose();\n\n            mtrl.dispose();    // disposes any programs associated with the material\n          });\n        }\n        else {\n          if (node.material.map) node.material.map.dispose();\n          if (node.material.lightMap) node.material.lightMap.dispose();\n          if (node.material.bumpMap) node.material.bumpMap.dispose();\n          if (node.material.normalMap) node.material.normalMap.dispose();\n          if (node.material.specularMap) node.material.specularMap.dispose();\n          if (node.material.envMap) node.material.envMap.dispose();\n\n          node.material.dispose();   // disposes any programs associated with the material\n        }\n      }\n    }\n  });\n};\n\nObject3DUtil.getModelInstance = function (object3D, searchAncestors) {\n  if (!object3D) return;\n  if (object3D.metadata && object3D.metadata.modelInstance) {\n    return object3D.metadata.modelInstance;\n  }\n  if (searchAncestors) {\n    var modelInstance = undefined;\n    Object3DUtil.traverseAncestors(object3D, function(obj) {\n      if (obj.metadata && obj.metadata.modelInstance) {\n        modelInstance = obj.metadata.modelInstance;\n        return false;\n      } else {\n        return true;\n      }\n    });\n    return modelInstance;\n  }\n};\n\nObject3DUtil.traverseAncestors = function(object3D, callback) {\n  var parent = object3D.parent;\n  if ( parent != null ) {\n    var continueTraversal = callback( parent );\n    if (continueTraversal) {\n      Object3DUtil.traverseAncestors(parent, callback);\n    }\n  }\n};\n\nObject3DUtil.findFirstAncestor = function(object3D, filter, includeSelf) {\n  var node = includeSelf? object3D : object3D.parent;\n  var n = includeSelf? 0 : 1;\n  while (node != null) {\n    var matched = filter(node);\n    if (matched) {\n      return { ancestor: node, pathLength: n };\n    } else {\n      node = node.parent;\n      n = n+1;\n    }\n  }\n};\n\nObject3DUtil.getMinimalSpanningNodes = function(nodes) {\n  var roots = [];\n  var spanning = [];\n  var toProcess = [];\n  // use temporary variable to mark nodes\n  for (var i = 0; i < nodes.length; i++) {\n    toProcess.push(nodes[i]);\n    nodes[i].userData.__isMarked = true;\n  }\n  // http://localhost:8010/model-viewer?modelId=3dw.b82b59df5afc875e414442b3db8c133\n  // Collect nodes that span these nodes\n  while (toProcess.length > 0) {\n    var node = toProcess.pop();\n    //console.log('processing', node.userData.__isMarked, node);\n    // skip if we already got ancestor of this node\n    if (Object3DUtil.isDescendantOf(node, spanning, true)) {\n      continue;\n    }\n    if (node.userData.__isMarked && node.parent != null) {\n      var parent = node.parent;\n      Object3DUtil.traverse(parent, function (n) {\n        if (n.userData.__isMarked === true || n.userData.__isMarked === false) {\n          return false; // No need to traverse down\n        } else {\n          return true;  // Make sure that __isMarked is set\n        }\n      }, function (n) {\n        if (n.userData.__isMarked == undefined) {\n          var hasMarked = _.any(n.children, function (c) {\n            return c.userData.__isMarked;\n          });\n          if (hasMarked) {\n            n.userData.__isMarked = _.all(n.children, function (c) {\n              return c.userData.__isMarked || !Object3DUtil.getBoundingBox(c).valid();\n            });\n          } else {\n            n.userData.__isMarked = false;\n          }\n        }\n      });\n      toProcess = _.filter(toProcess, function(n) { return !Object3DUtil.isAncestorOf(parent, n, true); });\n      toProcess.push(parent);\n    } else {\n      roots.push(node);\n      Object3DUtil.traverse(node, function(n) {\n        if (n.userData.__isRoot) {\n          return false;\n        } else if (n.userData.__isMarked) {\n          spanning.push(n);\n          return false; // No need to traverse down\n        } else {\n          return true;  // Check children\n        }\n      });\n      node.userData.__isRoot = true;\n    }\n  }\n\n  // Clear temporary variable\n  _.each(roots, function(root) {\n    root.traverse(function(node) {\n      delete node.userData.__isMarked;\n      delete node.userData.__isRoot;\n    });\n  });\n\n  return spanning;\n};\n\n// Find nodes that returns true for the given filter\nObject3DUtil.findNodes = function(object3D, filter, visibleOnly) {\n  var nodes = [];\n  if (visibleOnly && !object3D.visible) {\n    return nodes;\n  }\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (filter(node)) {\n        nodes.push(node);\n      }\n\n      if (visibleOnly) {\n        return node.visible;\n      } else {\n        return true;\n      }\n  });\n  return nodes;\n};\n\nObject3DUtil.findNode = function(object3D, filter, visibleOnly) {\n  // Finds and returns first node satisfying filter\n  var nodes = Object3DUtil.findNodes(object3D, filter, visibleOnly);\n  if (nodes.length) {\n    return nodes[0];\n  }\n};\n\nObject3DUtil.findTopMostNodes = function(object3D, filter) {\n  var nodes = [];\n  Object3DUtil.traverse(\n    object3D,\n    function (node) {\n      if (filter(node)) {\n        nodes.push(node);\n        return false;\n      } else {\n        return true;\n      }\n   });\n  return nodes;\n};\n\nObject3DUtil.removeNodes = function(node, filterOrNodes) {\n  var matches = _.isArray(filterOrNodes)? filterOrNodes : Object3DUtil.findTopMostNodes(node, filterOrNodes);\n  for (var i = 0; i < matches.length; i++) {\n    var match = matches[i];\n    match.parent.remove(match);\n  }\n  if (matches.length) {\n    //console.log(\"Removed \" + matches.length + ' nodes');\n    Object3DUtil.clearCache(node);\n  }\n  return matches;\n};\n\n\n// Return object with minimum distance\nObject3DUtil.getMinDistanceToObjectBBoxes = function(object3Ds, points, opt) {\n  var minDist = Infinity;\n  var index = null;\n  //console.log('length', object3Ds.length);\n  for (var i = 0; i < object3Ds.length; i++) {\n    var o = object3Ds[i];\n    var bbox = Object3DUtil.getBoundingBox(o);\n    var dists = _.map(points, function(point) { return bbox.distanceToPoint(point, opt); });\n    //console.log('dists', dists);\n    var dist = _.min(dists);\n    if (dist < minDist) {\n      //console.log('dist ', dist, o.userData);\n      minDist = dist;\n      index = i;\n    }\n  }\n  return { dist: minDist, index: i };\n};\n\nObject3DUtil.removeAllChildren = function (object3D) {\n  while (object3D.children.length > 0) {\n    object3D.remove(object3D.children[0]);\n  }\n};\n\nObject3DUtil.setVisibleForType = function(object, type, visible) {\n  if (object) {\n    object.traverse(function(x) {\n      if ((x instanceof THREE.Line && type === 'line') ||\n          (x instanceof THREE.Points && type === 'point') ||\n          (x instanceof THREE.Mesh && type === 'mesh')) {\n        x.visible = visible;\n      }\n    });\n  }\n};\n\nObject3DUtil.setVisible = function (object, visible, recursive) {\n  if (object) {\n    object.visible = visible;\n    if (recursive) {\n      object.traverse(function(x) {\n        x.visible = visible;\n      });\n    }\n  }\n};\n\nObject3DUtil.setChildrenVisible = function (object, isVisible) {\n  if (object) {\n    for (var i = 0; i < object.children.length; i++) {\n      var c = object.children[i];\n      c.visible = isVisible(c);\n    }\n  }\n};\n\nObject3DUtil.setPartsVisible = function(root, parts, flag, recursive) {\n  parts = Array.isArray(parts)? parts : [parts];\n  if (flag) {\n    // Make sure root to part is visible\n    _.each(parts, function (part) {\n      Object3DUtil.traverseAncestors(part, function (p) {\n        Object3DUtil.setVisible(p, flag, false);\n        return (p !== root);\n      });\n      Object3DUtil.setVisible(part, flag, recursive);\n    });\n  } else {\n    _.each(parts, function (part) {\n      Object3DUtil.setVisible(part, flag, recursive);\n    });\n  }\n};\n\nObject3DUtil.setState = function (object, field, value, filter) {\n  if (object) {\n    Object3DUtil.traverse(object, function (node) {\n      if (!filter || filter(node)) {\n        node.userData[field] = value;\n        return true;\n      }\n    });\n  }\n};\n\n/**\n * Traverses the scene graph with given root and orders nodes, geometries, materials for serialization\n * Each node, geometry, material will have their `userData.nodeIndex`, `userData.geometryIndex`, or `userData.materialIndex` field set appropriately.\n * @param object3D {THREE.Object3D} Root object to with nodes to index\n * @param [options] Additional options\n * @param [options.splitByMaterial=false] Whether to split nodes with Material into separate multiple meshes.\n *   The old mesh in the scene graph is replaced with the split up meshes.\n * @param [options.splitByConnectivity=false] Whether to split disconnected triangles into separate meshes.\n *   The old mesh in the scene graph is replaced with the split up meshes.\n * @param [options.keepDoubleFacesTogether=false] Whether to keep double faces together.\n * @returns {{nodes: THREE.Object3D[], geometries: THREE.Geometry[], materials: THREE.Material[], leafNodes: THREE.Mesh[]}}\n */\nObject3DUtil.getIndexedNodes = function (object3D, options) {\n  options = options || {};\n  var result = options.result || {\n    nodes: [],\n    geometries: [],\n    materials: []\n  };\n  object3D.traverse(function (node) {\n    node.userData.nodeIndex = result.nodes.length;\n    result.nodes.push(node);\n    if (node instanceof THREE.Mesh) {\n      var geometry = node.geometry;\n      if (!geometry.userData) {\n        geometry.userData = {};\n      }\n      if (geometry.userData.geometryIndex == undefined || result.geometries[geometry.userData.geometryIndex] !== geometry) {\n        geometry.userData.geometryIndex = result.geometries.length;\n        result.geometries.push(geometry);\n      }\n      var materials;\n      if (node.material instanceof THREE.MultiMaterial) {\n        materials = node.material.materials;\n      } else if (_.isArray(node.material)) {\n        materials = node.material;\n      } else {\n        materials = [node.material];\n      }\n      for (var i = 0; i < materials.length; i++) {\n        var m = materials[i];\n        if (!m.userData) {\n          m.userData = {};\n        }\n        if (m.userData.materialIndex == undefined || result.materials[m.userData.materialIndex] !== m) {\n          m.userData.materialIndex = result.materials.length;\n          result.materials.push(m);\n        }\n      }\n    }\n  });\n  // Split multi material\n  var meshNodes = _.filter(result.nodes, function(x) { return x instanceof THREE.Mesh; });\n  if (options.splitByMaterial || options.splitByConnectivity) {\n    var splitGeometries = _.clone(result.geometries);\n    var leafNodes = [];\n    for (var i = 0; i < meshNodes.length; i++) {\n      var mesh = meshNodes[i];\n      var nodeIndex = mesh.userData.nodeIndex;\n      var splitMeshes = (options.splitByMaterial)? GeometryUtil.splitByMaterial(mesh, {\n        validOnly: true, keepDoubleFacesTogether: options.keepDoubleFacesTogether }) : [mesh];\n      if (options.splitByConnectivity) {\n        splitMeshes = _.flatten(\n          _.map(splitMeshes, function(m) {\n            return GeometryUtil.splitByConnectivity(m, { validOnly: true });\n          }));\n      }\n      if (splitMeshes.length > 1) {\n        console.log('splitting mesh ' + nodeIndex + ' for ' + object3D.name);\n        // Update geometry index\n        for (var j = 0; j < splitMeshes.length; j++) {\n          var geometry = splitMeshes[j].geometry;\n          if (!geometry.userData) {\n            geometry.userData = {};\n          }\n        }\n\n        var origGeomIndex = mesh.geometry.userData.geometryIndex;\n        splitMeshes[0].geometry.userData.geometryIndex = origGeomIndex;\n        splitGeometries[origGeomIndex] = splitMeshes[0].geometry;\n        for (var j = 1; j < splitMeshes.length; j++) {\n          splitMeshes[j].geometry.userData.geometryIndex = splitGeometries.length;\n          splitGeometries.push(splitMeshes[j].geometry);\n        }\n\n        // Merge node into results\n        var newNode = new THREE.Object3D();\n        newNode.name = mesh.name;\n        _.assign(newNode.userData, mesh.userData);\n\n        Object3DUtil.setMatrix(newNode, mesh.matrix);\n        Object3DUtil.replaceChild(mesh, newNode);\n        result.nodes[nodeIndex] = newNode;\n        for (var j = 0; j < splitMeshes.length; j++) {\n          var childNode = splitMeshes[j];\n          childNode.userData.nodeIndex = result.nodes.length;\n          result.nodes.push(childNode);\n          leafNodes.push(childNode);\n          // Add child to parent\n          newNode.add(childNode);\n        }\n        newNode.updateMatrixWorld();\n      } else {\n        splitGeometries.push(mesh.geometry);\n        leafNodes.push(mesh);\n      }\n    }\n    result.geometries = splitGeometries;\n    result.leafNodes = leafNodes;\n    //console.log('got result', result.nodes.length, result.geometries.length);\n  } else {\n    result.leafNodes = meshNodes;\n  }\n  result.root = result.nodes[0];\n  return result;\n};\n\nObject3DUtil.getMeshList = function (object, recursive, meshes) {\n  meshes = meshes || [];\n  Object3DUtil.traverseMeshes(\n    object,\n    !recursive,\n    function (mesh) {\n      meshes.push(mesh);\n    }\n  );\n  return meshes;\n};\n\nObject3DUtil.getFilteredMeshList = function (object, filter, meshes) {\n  meshes = meshes || [];\n  Object3DUtil.traverseMeshes(\n      object,\n      filter,\n      function (mesh) {\n        meshes.push(mesh);\n      }\n  );\n  return meshes;\n};\n\nObject3DUtil.getVisibleMeshList = function (object, recursive, meshes) {\n  meshes = meshes || [];\n  Object3DUtil.traverseVisibleMeshes(\n    object,\n    !recursive,\n    function (mesh) {\n      meshes.push(mesh);\n    }\n  );\n  return meshes;\n};\n\nObject3DUtil.findClosestBBFaceByOutNormal = function (outNorm, threshold) {\n  if (threshold === undefined) {\n    threshold = 0.99;\n  }\n  for (var i = 0; i < Object3DUtil.OutNormals.length; i++) {\n    var norm = Object3DUtil.OutNormals[i];\n    if (outNorm.dot(norm) >= threshold) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nObject3DUtil.findClosestBBFaceByInNormal = function (inNorm, threshold) {\n  if (threshold === undefined) {\n    threshold = 0.99;\n  }\n  for (var i = 0; i < Object3DUtil.InNormals.length; i++) {\n    var norm = Object3DUtil.InNormals[i];\n    if (inNorm.dot(norm) >= threshold) {\n      return i;\n    }\n  }\n  return -1;\n};\n\nObject3DUtil.findNodesToExtract = function(root, nodeIds) {\n  var nonSGIds = [];\n  var matchedNodes = [];\n  for (var i = 0; i < nodeIds.length; i++) {\n    var nodeId = nodeIds[i];\n\n    if (nodeId.toUpperCase().startsWith('SGPATH-')) {\n      var node = Object3DUtil.getNodeFromSceneGraphPath(root, nodeId.substr(7));\n      if (node) {\n        matchedNodes.push(node);\n      }\n    } else {\n      nonSGIds.push(nodeId);\n    }\n  }\n  if (nonSGIds.length > 0) {\n    var additionalNodes = Object3DUtil.findNodes(root, function(node) {\n      return nonSGIds.indexOf(node.userData.id) >= 0;\n    });\n    matchedNodes.push.apply(matchedNodes, additionalNodes);\n  }\n  return matchedNodes;\n}\n\nObject3DUtil.extractNodes = function(root, operation, nodeIds) {\n  var matchedNodes = Object3DUtil.findNodesToExtract(root, nodeIds);\n  if (matchedNodes.length === 0) {\n    throw \"No nodes matched!\";\n  }\n  if (operation === 'keep') {\n    Object3DUtil.removeNodes(root, function(node) {\n      var keep = Object3DUtil.hasDirectLineage(node, matchedNodes);\n      return !keep;\n    });\n    return root;\n  } else if (operation === 'remove') {\n    Object3DUtil.removeNodes(root, matchedNodes);\n    return root;\n  } else {\n    throw \"Unknown operation: \" + operation;\n  }\n};\n\n// segments is a array of segments\n//  Each segment can have one of the following formats:\n//   a. array of meshTri: [...]\n//   b. object with field meshTri: { meshTri: array of meshTri }\n//   c. object with meshTri fields: {meshIndex: x, triIndex: [...] }\n//  Each meshTri has following fields: {meshIndex: x, triIndex: [...] }\nObject3DUtil.remeshObject = function (object, segments, material) {\n  // Get remesh of the object\n  // TODO: Have the meshIndex be consistent?  Sorted by userData.meshIndex?\n  //       Some models have several different pieces that are loaded, meshIndex only makes sense within each one\n  var origMeshes = Object3DUtil.getMeshList(object);\n\n  var meshes = [];\n  var idToMeshIndices = {};\n  var needConsolidation = false;\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var meshTris = [segment];  // Default to case c)\n    if (segment.hasOwnProperty('meshTri')) {\n      // Case b\n      meshTris = segment['meshTri'];\n    } else if (segment.length) {\n      // Case a\n      meshTris = segment;\n    }\n    var componentMeshes = [];\n\n    for (var j = 0; j < meshTris.length; j++) {\n      var meshTri = meshTris[j];\n      var meshIndex = meshTri.meshIndex;\n      var origMesh = (meshTri.mesh) ? meshTri.mesh : origMeshes[meshIndex];\n\n      var componentMesh;\n      if (meshTri.triIndex) {\n        // Remesh with specific triangles\n        componentMesh = GeometryUtil.extractMesh(origMesh, meshTri.triIndex, material? false : true);\n      } else {\n        // Just my mesh\n        componentMesh = origMesh.clone();\n      }\n\n      // Get world transform from our parent\n      // TODO: if there is a scene transform, it needs to be undone by the viewer...\n      var parent = origMesh.parent;\n      if (parent) {\n        componentMesh.applyMatrix(parent.matrixWorld);\n        componentMesh.matrixWorldNeedsUpdate = true;\n      }\n      //Object3DUtil.setMatrix(componentMesh, origMesh.matrixWorld);\n      //console.log('component', componentMesh.matrix.determinant(), origMesh.matrixWorld.determinant());\n      if (material) {\n        componentMesh.material = material;\n      }\n      componentMeshes.push(componentMesh);\n    }\n\n    var myMesh = GeometryUtil.mergeMeshes(componentMeshes);\n    myMesh.name = (segment.id != undefined)? segment.id.toString() : object.name + '-remeshed-' + i;\n    myMesh.userData = {\n      id: (segment.id != undefined)? segment.id : 'mesh' + i,\n      index: i\n    };\n    meshes.push(myMesh);\n    idToMeshIndices[myMesh.userData.id] = idToMeshIndices[myMesh.userData.id] || [];\n    idToMeshIndices[myMesh.userData.id].push(i);\n    if (idToMeshIndices[myMesh.userData.id].length > 1) {\n      needConsolidation = true;\n    }\n  }\n  if (needConsolidation) {\n    // Need to consolidation some meshes\n    //console.log('consolidating', idToMeshIndices);\n    var newMeshes = [];\n    var consolidated = new Set();\n    for (var i = 0; i < meshes.length; i++) {\n      var myMesh = meshes[i];\n      var id = myMesh.userData.id;\n      if (!consolidated.has(id)) {\n        var indices = idToMeshIndices[id];\n        if (indices.length > 1) {\n          var componentMeshes = indices.map(idx => meshes[idx]);\n          var merged = GeometryUtil.mergeMeshes(componentMeshes);\n          merged.name = myMesh.name;\n          merged.userData.id = myMesh.userData.id;\n          myMesh = merged;\n        }\n        myMesh.userData.index = i;\n        newMeshes.push(myMesh);\n        consolidated.add(id);\n      }\n    }\n    //console.log(newMeshes);\n    meshes = newMeshes;\n  }\n\n\n  // Clone the relevant mesh\n  var remeshedObj = new THREE.Object3D();\n  remeshedObj.name = object.name + '-remeshed';\n  for (var i = 0; i < meshes.length; i++) {\n    var myMesh = meshes[i];\n    remeshedObj.add(myMesh);\n  }\n  // Clear out any __bufferGeometry\n  for (var i = 0; i < origMeshes.length; i++) {\n    delete origMeshes[i].__bufferGeometry;\n  }\n  return remeshedObj;\n};\n\nObject3DUtil.assignMultiMaterialToSegments = function (object, segments, createMaterialFn) {\n  if (!createMaterialFn) {\n    createMaterialFn = function(index, segment) {\n      var material = Object3DUtil.getSimpleFalseColorMaterial(index);\n      return material;\n    };\n  }\n  // Get remesh of the object\n  // TODO: Have the meshIndex be consistent?  Sorted by userData.meshIndex?\n  //       Some models have several different pieces that are loaded, meshIndex only makes sense within each one\n  var origMeshes = Object3DUtil.getMeshList(object);\n\n  // Clone the original meshes\n  var materials = [];\n  var multiMaterial = new THREE.MultiMaterial(materials);\n  var remeshedObj = new THREE.Object3D();\n  remeshedObj.name = object.name + '-remeshed';\n  var clonedMeshes = _.map(origMeshes, function(x) {\n    x.updateMatrixWorld();\n    var cloned = x.clone();\n    cloned.geometry = GeometryUtil.toGeometry(cloned.geometry);\n    cloned.material = multiMaterial;\n    cloned.matrix.copy(x.matrixWorld);\n    cloned.matrix.decompose(cloned.position, cloned.quaternion, cloned.scale);\n    cloned.matrixWorldNeedsUpdate = true;\n    remeshedObj.add(cloned);\n    return cloned;\n  });\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    materials[i] = createMaterialFn(i, segment);\n    var meshTris = [segment];  // Default to case c)\n    if (segment.hasOwnProperty('meshTri')) {\n      // Case b\n      meshTris = segment['meshTri'];\n    } else if (segment.length) {\n      // Case a\n      meshTris = segment;\n    }\n\n    for (var j = 0; j < meshTris.length; j++) {\n      var meshTri = meshTris[j];\n      var meshIndex = meshTri.meshIndex;\n      var clonedMesh = (meshTri.mesh) ? meshTri.mesh : clonedMeshes[meshIndex];\n\n      // TODO: Try to handle Buffer Geometry too\n      var faces = clonedMesh.geometry.faces;\n      if (meshTri.triIndex) {\n        var triIndices = meshTri.triIndex;\n        for (var ti in triIndices) {\n          if (triIndices.hasOwnProperty(ti)) {\n            faces[ti].materialIndex = i;\n          }\n        }\n      } else {\n        for (var k = 0; k < faces.length; k++) {\n          faces[k].materialIndex = i;\n        }\n      }\n    }\n\n  }\n  return remeshedObj;\n};\n\n// segmentGroups is a array of segment groups\n//  Each segmentGroup is a object with id, label, objectId, obb, and segments (optional)\n//  vertToSegIndices is a mapping of vertex to segment index\nObject3DUtil.remeshObjectUsingSegmentGroups = function (object, segmentGroups, vertToSegIndices, quiet) {\n  // Go over segment groups\n  var origMeshes = Object3DUtil.getMeshList(object);\n  // Assumes just one mesh\n  var origMesh = origMeshes[0];\n  var segToTriIndices = GeometryUtil.segVertIndicesToSegTriIndices(origMesh, vertToSegIndices);\n  // Convert to buffered geometry since extractMeshVertIndices works faster with buffered geometry\n  var origMeshBuffered = origMesh.clone();\n  origMeshBuffered.geometry = GeometryUtil.toBufferGeometry(origMesh.geometry);\n  var remeshedObj = new THREE.Object3D();\n  remeshedObj.name = object.name + '-remeshed';\n  var noIndices = [];\n  for (var i = 0; i < segmentGroups.length; i++) {\n    var segGroup = segmentGroups[i];\n    if (segGroup.segments && segGroup.segments.length > 0) {\n      //console.time('triIndices');\n      var segs = segGroup.segments;\n      var triIndices = [];\n      for (var si = 0; si < segs.length; si++) {\n        var vis = segToTriIndices[segs[si]];\n        if (vis) {\n          for (var j = 0; j < vis.length; j++) {\n            triIndices.push(vis[j]);\n          }\n          //Array.prototype.push.apply(triIndices, vis);\n        } else {\n          noIndices.push(segs[si]);\n        }\n      }\n      //console.time('triIndicesUniq');\n      triIndices = _.uniq(triIndices);\n      //console.timeEnd('triIndicesUniq');\n      //console.timeEnd('triIndices');\n      var myMesh = GeometryUtil.extractMesh(origMeshBuffered, triIndices, true);\n      var parent = origMesh.parent;\n      if (parent) {\n        myMesh.applyMatrix(parent.matrixWorld);\n        myMesh.matrixWorldNeedsUpdate = true;\n      }\n      myMesh.name = object.name + '-remeshed-' + i;\n      myMesh.userData = segGroup;\n      segGroup['index'] = i;\n      remeshedObj.add(myMesh);\n    }\n  }\n  if (!quiet && noIndices.length > 0) {\n    console.error('No indices for ' + noIndices.length + ' segments', noIndices);\n  }\n  return remeshedObj;\n};\n\n//  vertToSegIndices is a mapping of vertex index to a mapped segment index, negative segment indices are not used\nObject3DUtil.copyAndRecolorVertices = function (object, vertToSegIndices, color) {\n  // Go over segment groups\n  var meshes = Object3DUtil.getMeshList(object);\n  // Assumes just one mesh\n  var mesh = meshes[0];\n  var geometry = mesh.geometry.clone();\n  var gray = new THREE.Color(0.5, 0.5, 0.5);\n  var colors = [];\n  function getColor(vi) {\n    var si = vertToSegIndices[vi];\n    if (si == undefined) {\n      return gray;\n    } else {\n      if (!colors[si]) {\n        if (color) {\n          colors[si] = color.clone();\n        } else {\n          colors[si] = (si >= 0) ? Object3DUtil.createColor(Math.abs(si)) : gray.clone();\n        }\n      }\n      return colors[si];\n    }\n  }\n  if (geometry.faces) {\n    // Maintain array of colors for vertex (for easy update)\n    // TODO: Do we need this in memory?\n    // geometry.colors = [];\n    // var nVertices = GeometryUtil.getGeometryVertexCount(geometry);\n    // for (var i = 0; i < nVertices; i++) {\n    //   geometry.colors.push(getColor(i));\n    // }\n    // Update face vertex\n    for (var i = 0; i < geometry.faces.length; i++) {\n      geometry.faces[i].vertexColors = [\n        getColor(geometry.faces[i].a),\n        getColor(geometry.faces[i].b),\n        getColor(geometry.faces[i].c)\n      ];\n    }\n    geometry.colorsNeedUpdate = true;\n    geometry.elementsNeedUpdate = true;\n  } else {\n    var attributes = geometry.attributes;\n    if ( attributes.position ) {\n      var positions = attributes.position.array;\n      if (attributes.color === undefined) {\n        geometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(positions.length), 3));\n      }\n      // Update vertex colors\n      var vcolors = attributes.color.array;\n      for (var i = 0; i < vcolors.length; i+=3) {\n        var vi = i / 3;\n        var c = getColor(vi);\n        vcolors[i] = c.r;\n        vcolors[i+1] = c.g;\n        vcolors[i+2] = c.b;\n      }\n    }\n  }\n  geometry.computeFaceNormals();\n  geometry.computeVertexNormals();\n  var material = new THREE.MeshPhongMaterial({ vertexColors: THREE.VertexColors });\n  var recolored = new THREE.Mesh(geometry, material);\n  recolored.name = object.name + '-recolored';\n  recolored.userData.segColors = colors;\n  Object3DUtil.setMatrix(recolored, mesh.matrixWorld);\n  return recolored;\n};\n\nObject3DUtil.getAllMeshMaterials = function(object3D) {\n  // Returns a list of materials with mesh and material index;\n  var materials = [];\n  Object3DUtil.traverseMeshes(object3D, true, function (node) {\n    if (node instanceof THREE.Mesh && node.material) {\n      if (Array.isArray(node.material)) {\n        // Actual material definition is embedded in geometry...\n        var mats = node.material;\n        for (var j = 0; j < mats.length; j++) {\n          var m = mats[j];\n          materials.push({mesh: node, material: m, index: j});\n        }\n      } else if (node.material instanceof THREE.MultiMaterial) {\n        // Actual material definition is embedded in geometry...\n        var mats = node.material.materials;\n        for (var j = 0; j < mats.length; j++) {\n          var m = mats[j];\n          materials.push({ mesh: node, material: m, index: j });\n        }\n      } else {\n        materials.push({ mesh: node, material: node.material, index: node.material.index });\n      }\n    }\n  });\n  return materials;\n};\n\n/**\n * Represents a subset of a mesh\n * @typedef PartialMesh\n * @type {object}\n * @property {THREE.Mesh} mesh\n * @property {int[]} List of face indices to include\n * @property {int} materialIndex Index of material\n * @memberOf geo\n */\n\n\n/**\n * Information about a material\n * @typedef MaterialSetMeshInfo\n * @type {object}\n * @property {string} id\n * @property {string} name\n * @property {string} type material\n * @property {THREE.Material} material - Material\n * @property {Array<THREE.Mesh|PartialMesh>} meshes - Meshes associated with this material\n * @memberOf geo\n */\n\n/**\n * Information about a set of material\n * @typedef MaterialMeshInfo\n * @type {object}\n * @property {string} id\n * @property {string} name\n * @property {string} type material_set\n * @property {Array<THREE.Material>} materials - Set of materials\n * @property {Array<THREE.Mesh|PartialMesh>} meshes - Meshes associated with a material in this set of materials\n * @memberOf geo\n */\n\n/**\n * Returns map of material id to material-mesh info\n * @param object3D {THREE.Object3D}\n * @return Map<string, MaterialMeshInfo|MaterialSetMeshInfp>\n * @memberOf geo\n */\nObject3DUtil.getMaterialsMap = function (object3D) {\n  // each entry of materials holds\n  //   name: name of material\n  //   material: actual material\n  //   meshes: meshes with which the material is associated\n  var materials = {};\n  var count = 0;\n  var allMeshes = [];\n  var allMeshesWithTexture = [];\n  var allMaterials = [];\n  var allMaterialsWithTexture = [];\n\n  function addMaterial(mesh, material) {\n    var id = material.id;\n    var name = material.name;\n    if (id === undefined) {\n      //noinspection JSUnresolvedVariable\n      if (THREE.MaterialCount === undefined) {\n        THREE.MaterialCount = 0;\n      }\n      id = THREE.MaterialCount++;\n      material.id = id;\n      console.log('Material without id (assigned id ' + id + ')');\n    }\n    if (name === undefined) {\n      name = 'mat' + count;\n      material.name = name;\n      console.log('Material ' + id + ' without name (assigned name ' + name + ')');\n    }\n    var old = materials[id];\n    if (old) {\n      old.meshes.push(mesh);\n    } else {\n      materials[id] = {\n        id: id,\n        name: name,\n        material: material,\n        meshes: [mesh],\n        type: 'material'\n      };\n    }\n    allMaterials.push(id);\n    allMeshes.push(mesh);\n    if (material.map) {\n      allMeshesWithTexture.push(mesh);\n      allMaterialsWithTexture.push(id);\n    }\n    count++;\n  }\n\n  object3D.traverse(function (node) {\n    if (node instanceof THREE.Mesh && node.material) {\n      if (Array.isArray(node.material) || node.material instanceof THREE.MultiMaterial) {\n        // Actual material definition is embedded in geometry...\n        var meshFaces = [];\n        // Break down materials into individual faces...\n        // TODO: Same as geometryGroups/geometryGroupsList in geometry?\n        // If so, just use materialIndex instead of tracking the faceIndices...\n        if (node.geometry.faces) {\n          for (var j = 0; j < node.geometry.faces.length; j++) {\n            var face = node.geometry.faces[j];\n            var materialIndex = face.materialIndex;\n            if (!meshFaces[materialIndex]) {\n              meshFaces[materialIndex] = [j];\n            } else {\n              meshFaces[materialIndex].push(j);\n            }\n          }\n        } else {\n          var nFaces = GeometryUtil.getGeometryFaceCount(node.geometry);\n          for (var j = 0; j < nFaces; j++) {\n            var iv = j*3;\n            var group = _.find(node.geometry.groups, function (g) {\n              return (iv >= g.start) && (iv < g.start + g.count);\n            });\n            var materialIndex = group? group.materialIndex : 0;\n            if (!meshFaces[materialIndex]) {\n              meshFaces[materialIndex] = [j];\n            } else {\n              meshFaces[materialIndex].push(j);\n            }\n          }\n        }\n        var mats = node.material.materials || node.material;\n        for (var i = 0; i < mats.length; i++) {\n          if (meshFaces.length > 0) {\n            addMaterial({mesh: node, faceIndices: meshFaces[i], materialIndex: i}, mats[i]);\n          }\n        }\n      } else {\n        addMaterial(node, node.material);\n      }\n    }\n  });\n  materials['all'] = {\n    id: 'all', name: 'All', type: 'material_set',\n    meshes: allMeshes, materials: allMaterials\n  };\n  materials['textured'] = {\n    id: 'textured', name: 'Textured', type: 'material_set',\n    meshes: allMeshesWithTexture, materials: allMaterialsWithTexture\n  };\n  return materials;\n};\n\n\nObject3DUtil.populateSceneGraphPath = function (node, parentRoot) {\n  node.traverse(function(n) {\n    n.userData.sceneGraphPath = Object3DUtil.getSceneGraphPath(n, parentRoot);\n  });\n};\n\nObject3DUtil.getSceneGraphPath = function (node, parentRoot) {\n  // Follow up to parents\n  var path = [];\n  var parent = node;\n  var child;\n  while (parent && parent !== parentRoot) {\n    var name = parent.id;\n    var parentUserDataId = _.get(parent, ['userData', 'id']);\n    if (parentUserDataId == null) {\n      parentUserDataId = _.get(parent, ['userData', 'partId']);\n    }\n    if (parentUserDataId != null) {\n      name = parentUserDataId;\n    }\n    if (child) {\n      name = name + '[' + parent.children.indexOf(child) + ']';\n    }\n    path.push(name);\n    // Go up\n    child = parent;\n    parent = parent.parent;\n  }\n  path.reverse();\n  if (path.length > 0) {\n    return '/' + path.join('/');\n  } else {\n    return '';\n  }\n};\n\nObject3DUtil.getNodeFromSceneGraphPath = function (parentRoot, path) {\n  if (typeof (path) === 'string') {\n    path = path.split('/');\n  }\n  if (path[0] === '') {\n    path.shift();\n  }\n  var parent = parentRoot;\n  var regex = /^(.*)\\[(\\d+)\\]$/;\n  for (var i = 0; i < path.length; i++) {\n    var matched = regex.exec(path[i]);\n    var expectedName = (matched != null)? matched[1] : path[i];\n    if (i === 0) {\n      for (var ci = 0; ci < parent.children.length; ci++) {\n        if (parent.children[ci].userData.id === expectedName) {\n          parent = parent.children[ci];\n          break;\n        }\n      }\n    }\n\n    var userdata = parent.userData;\n    var name = '';\n    if (userdata.hasOwnProperty('id')) {\n      name = userdata['id'];\n    } else if (userdata.hasOwnProperty('partId')) {\n      name = userdata['partId'];\n    }\n    if (expectedName !== name) {\n      console.warn('Name does not match: expected ' + expectedName + ', actual ' + name);\n    }\n    if (matched) {\n      var ci = matched[2];\n      var child = parent.children[ci];\n      if (!child) {\n        console.warn('Cannot find child ' + path[i]);\n        break;\n      }\n      parent = child;\n    } else {\n      if (i < path.length - 1) {\n        console.warn('Exiting search for ' + path);\n      }\n      break;\n    }\n  }\n  if (i >= path.length - 1) {\n    return parent;\n  } else {\n    return null;\n  }\n};\n\nObject3DUtil.findMaterials = function(object3D, nonrecursive, materialFilter) {\n  var materials = [];\n  Object3DUtil.traverseMeshes(object3D, nonrecursive, function(mesh) {\n    //console.log('traverse', mesh);\n    var material = mesh.material;\n    if (Array.isArray(material) || material instanceof THREE.MultiMaterial) {\n      var mats = material.materials || material;\n      for (var i = 0; i < mats.length; i++) {\n        var mat = mats[i];\n        if (materialFilter(mat)) {\n          materials.push({\n            mesh: mesh,\n            material: mat,\n            setMaterial: function(index, newMat) {\n              mats[index] = newMat;\n            }.bind(mesh, i)\n          });\n        }\n      }\n    } else {\n      if (materialFilter(material)) {\n        materials.push({\n          mesh: mesh,\n          material: material,\n          setMaterial: function(newMat) {\n            mesh.material = newMat;\n          }.bind(mesh)\n        });\n      }\n    }\n  });\n  return materials;\n};\n\nObject3DUtil.addMirrors = function(object3D, opts) {\n  var mirrors = [];\n  Object3DUtil.traverseMeshes(object3D, false, function(mesh) {\n    //console.log('Check for mirror material', object3D);\n    // Find materials with mirror\n    var mirrorMatName = opts.mirrorMaterialName || 'mirror';\n    var mirrorMats = Object3DUtil.findMaterials(mesh, true, opts.filterMaterial || function (m) {\n        //console.log('check ' + m.name, m);\n        return m.name === mirrorMatName && !m.map;\n      });\n\n    // Check if it has material with name video\n    var hasMirror = mirrorMats.length > 0;\n    if (hasMirror) {\n      var Mirror = __webpack_require__(/*! capabilities/Mirror */ \"./js/lib/capabilities/Mirror.js\");\n      _.each(mirrorMats, function(mat) {\n        mesh.mirror = new Mirror(_.defaults({object3D: mesh, mirrorMaterials: [mat], color: mat.material.color}, opts));\n        mirrors.push(mesh.mirror);\n      });\n    }\n  });\n  return mirrors;\n};\n\nObject3DUtil.addVideoPlayer = function(object3D, opts) {\n  //console.log('Check for video capability', object3D);\n  // Find materials with video\n  var videoMatName = opts.videoMaterialName || 'video';\n  var videoMats = Object3DUtil.findMaterials(object3D, true, opts.filterMaterial || function(m) {\n    //console.log('check ' + m.name, m);\n    return m.name === videoMatName;\n  });\n\n  // Check if it has material with name video\n  var hasVideo = videoMats.length > 0;\n  if (hasVideo) {\n    var VideoPlayer = __webpack_require__(/*! capabilities/VideoPlayer */ \"./js/lib/capabilities/VideoPlayer.js\");\n    object3D.videoPlayer = new VideoPlayer({\n      object3D: object3D,\n      videoMaterials: videoMats,\n      assetManager: opts.assetManager\n    });\n  }\n  return object3D.videoPlayer;\n};\n\nObject3DUtil.addArticulationPlayer = function(object3D, opts) {\n  var articulatable = Object3DUtil.findNodes(object3D, n => n.isArticulated);\n  if (articulatable.length > 0) {\n    var ArticulationPlayer = __webpack_require__(/*! articulations/ArticulationPlayer */ \"./js/lib/articulations/ArticulationPlayer.js\");\n    object3D.articulationPlayer = new ArticulationPlayer({\n      articulatedObject: articulatable[0],\n      assetManager: opts.assetManager\n    });\n  }\n  return object3D.articulationPlayer;\n};\n\n// TODO(MS): Experimental function to push transform to leaf-like nodes\nObject3DUtil.pushWorldTransformToMeshes = function (object3D) {\n  Object3DUtil.traverse(object3D, function (node) {\n    if (node instanceof THREE.Mesh || node instanceof THREE.Light) {\n      Object3DUtil.setMatrix(node, node.matrixWorld);\n      return false;\n    }\n    return true;\n  }, function (node) {\n    var isStop = node instanceof THREE.Mesh || node instanceof THREE.Light;\n    if (!isStop) {\n      Object3DUtil.setMatrix(node, new THREE.Matrix4());\n    }\n  });\n};\n\nObject3DUtil.findLights = function(object3D) {\n  return Object3DUtil.findNodes(object3D, function (node) {\n    return node instanceof THREE.Light;\n  });\n};\n\nObject3DUtil.setLights = function (object3D, flag) {\n  var lights = Object3DUtil.findLights(object3D);\n  for (var i = 0; i < lights.length; ++i) {\n    var l = lights[i];\n    l.userData.isOn = flag;\n    if (l.userData.isOn) {\n      l.intensity = l.userData.intensity;\n    } else {\n      l.intensity = 0;\n    }\n  }\n  return lights.length;\n};\n\nObject3DUtil.setMaterialState = function (object3D, matOverrides, flag) {\n  if (!matOverrides) { return; }\n  // overrides for emissive surfaces and shade transparency\n  function setMatState(meshMaterial, matIndex) {\n    //console.log(matIndex);\n    if (matOverrides.emissive && matOverrides.emissive.indexOf(matIndex) >= 0) {\n      //console.log('emissive', matIndex);\n      if (flag) {\n        meshMaterial.emissive.set(0xFFFF00);\n        meshMaterial.emissiveIntensity = 5;\n      } else {\n        meshMaterial.emissive.set(0x000000);\n        meshMaterial.emissiveIntensity = 0;\n      }\n    }\n    if (matOverrides.shade && matOverrides.shade.indexOf(matIndex) >= 0) {\n      if (!meshMaterial.defaults) {\n        meshMaterial.defaults = {\n          opacity: meshMaterial.opacity, transparent: meshMaterial.transparent\n        };\n      }\n      if (flag) {\n        meshMaterial.transparent = true;\n        meshMaterial.opacity = 0.9;\n      } else {\n        meshMaterial.transparent = meshMaterial.defaults.transparent;\n        meshMaterial.opacity = meshMaterial.defaults.opacity;\n      }\n    }\n  }\n\n  Object3DUtil.traverseMeshes(object3D, true, function (mesh) {\n    if (Array.isArray(mesh.material) || mesh.material instanceof THREE.MultiMaterial) {\n      var mats = mesh.material.materials || mesh.material;\n      for (var i = 0, l = mats.length; i < l; i++) {\n        var meshMaterial = mats[i];\n        setMatState(meshMaterial, i);\n      }\n    } else if (mesh.material.index != undefined) {\n      setMatState(mesh.material, mesh.material.index);\n    }\n  });\n};\n\nObject3DUtil.setCapability = function(object3D, name, flag) {\n  if (!object3D.userData.capabilities) {\n    object3D.userData.capabilities = {};\n  }\n  object3D.userData.capabilities[name] = flag;\n};\n\nObject3DUtil.getCapability = function(object3D, name, defaultValue) {\n  var v;\n  if (object3D.userData.capabilities) {\n    v = object3D.userData.capabilities[name];\n    if (v != undefined) {\n      return v;\n    }\n  }\n  if (defaultValue != undefined) {\n    if (typeof defaultValue === \"function\") {\n      v = defaultValue();\n    } else {\n      v = defaultValue;\n    }\n    Object3DUtil.setCapability(object3D, name, v || false);\n    return v;\n  }\n};\n\nObject3DUtil.getCapabilities = function(object3D) {\n  return object3D.userData.capabilities;\n};\n\nObject3DUtil.addSphere = function (scene, centerTo, size, materialOrColor) {\n  size = size || 10;\n  var sphereGeo = new THREE.SphereGeometry(size);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(sphereGeo, material);\n  mesh.position.copy(centerTo);\n  scene.add(mesh);\n  return mesh;\n};\n\nObject3DUtil.setCylinderDirection = function (obj, dir) {\n  // Assumes dir is normalized\n  if (dir.y > 0.99999) {\n    obj.quaternion.set(0, 0, 0, 1);\n  } else if (dir.y < -0.99999) {\n    obj.quaternion.set(1, 0, 0, 0);\n  } else {\n    var axis = new THREE.Vector3();\n    axis.set(dir.z, 0, -dir.x).normalize();\n    var radians = Math.acos(dir.y);\n    obj.quaternion.setFromAxisAngle(axis, radians);\n  }\n};\n\nObject3DUtil.makeColumn = function (basePoint, columnDir, height, width, materialOrColor) {\n  width = width || 10;\n  var cylinderGeo = new THREE.CylinderGeometry(width, width, height);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(cylinderGeo, material);\n  mesh.name = 'Column';\n  var centerTo = basePoint.clone().add(columnDir.clone().multiplyScalar(height / 2));\n  Object3DUtil.setCylinderDirection(mesh, columnDir);\n  mesh.position.copy(centerTo);\n  return mesh;\n};\n\nObject3DUtil.addColumn = function (scene, basePoint, columnDir, height, width, materialOrColor) {\n  var column = Object3DUtil.makeColumn(basePoint, columnDir, height, width, materialOrColor);\n  scene.add(column);\n};\n\nObject3DUtil.makeCylinder = function (start, end, width, materialOrColor) {\n  var columnDir = end.clone().sub(start).normalize();\n  var height = start.distanceTo(end);\n  var cylinderGeo = new THREE.CylinderBufferGeometry(width, width, height);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(cylinderGeo, material);\n  mesh.name = 'Cylinder';\n  var centerTo = start.clone().add(end).multiplyScalar(0.5);\n  Object3DUtil.setCylinderDirection(mesh, columnDir);\n  mesh.position.copy(centerTo);\n  return mesh;\n};\n\nObject3DUtil.updateCylinderEndpoints = function (mesh, start, end) {\n  var columnDir = end.clone().sub(start).normalize();\n  var height = start.distanceTo(end);\n  var centerTo = start.clone().add(end).multiplyScalar(0.5);\n  Object3DUtil.setCylinderDirection(mesh, columnDir);\n  mesh.position.copy(centerTo);\n  var cylinderHeight = mesh.geometry.parameters.height;\n  var s = height/cylinderHeight;\n  mesh.scale.set(1, s, 1);\n  mesh.matrixWorldNeedsUpdate = true;\n  return mesh;\n};\n\nObject3DUtil.makeBall = function (origin, radius, materialOrColor) {\n  var ballGeo = new THREE.SphereBufferGeometry(radius);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(ballGeo, material);\n  mesh.name = 'Ball';\n  mesh.position.copy(origin);\n  return mesh;\n};\n\nObject3DUtil.makeBalls = function (points, radius, materialOrColor, name, group) {\n  name = name || 'Ball';\n  group = group || new THREE.Group();\n  for (var i = 0; i < points.length; i++) {\n    var ball = Object3DUtil.makeBall(points[i], radius, materialOrColor);\n    ball.name = name + i;\n    group.add(ball);\n  }\n  return group;\n};\n\nObject3DUtil.makeBoxFromToOrientation = function (from, to, orientation, size, materialOrColor) {\n  var dist = to.distanceTo(from); // * 0.5;\n  var center = from.clone().add(to).multiplyScalar(0.5);\n\n  var boxGeo = new THREE.BoxGeometry(dist, size, size);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(boxGeo, material);\n  mesh.setRotationFromQuaternion(orientation);\n  mesh.position.copy(center);\n  return mesh;\n};\n\nObject3DUtil.makeWall = function (baseStart, baseEnd, wallUpDir, height, depth, materialOrColor) {\n  depth = depth || 10;\n  var width = baseEnd.distanceTo(baseStart);\n  // x = width, y = height, z = depth\n  // Build box geo\n  var boxGeo = new THREE.BoxGeometry(width, height, depth);\n  var material = Object3DUtil.getMaterial(materialOrColor);\n  var mesh = new THREE.Mesh(boxGeo, material);\n  mesh.name = 'Wall';\n\n  // Take start --> end to be right, front to be normal\n  var startToEnd = baseEnd.clone().sub(baseStart).normalize();\n  var wallFrontDir = new THREE.Vector3();\n  wallFrontDir.crossVectors(startToEnd, wallUpDir).normalize();\n  var alignMatrix = Object3DUtil.getAlignmentMatrix(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1),\n    wallUpDir, wallFrontDir);\n\n  var centerTo = baseStart.clone().add(baseEnd).multiplyScalar(0.5);\n  centerTo.add(wallUpDir.clone().multiplyScalar(height / 2));\n  alignMatrix.setPosition(centerTo);\n\n  Object3DUtil.setMatrix(mesh, alignMatrix);\n  return mesh;\n};\n\n// Make geometry for one pieces of a wall\nObject3DUtil.__makeWallWithHolesGeometry = function(opts) {\n  var holes = opts.holes;\n  var height = opts.height;\n  var depth = opts.depth;\n  var width = opts.width;\n\n  var initialHeight = opts.initialHeight;\n  var initialWidth = opts.initialWidth;\n\n  var wdelta = (width - initialWidth) / 2;\n\n  // Assume holes are disjoint\n  // Split holes into outside (on border) and inside holes (inside wall)\n  var outsideHoles = [];\n  var leftHoles = [], rightHoles = [], topHoles = [], bottomHoles = [];\n  var insideHoles = [];\n  if (holes) {\n    for (var iHole = 0; iHole < holes.length; iHole++) {\n      var hole = holes[iHole];\n      if (hole.min.x <= 0 && hole.max.x < initialWidth) {\n        leftHoles.push(hole);\n        outsideHoles.push(hole);\n      } else if (hole.min.x > 0 && hole.max.x >= initialWidth) {\n        rightHoles.push(hole);\n        outsideHoles.push(hole);\n      } else if (hole.min.y <= 0 && hole.max.y < initialHeight) {\n        bottomHoles.push(hole);\n        outsideHoles.push(hole);\n      } else if (hole.min.y > 0 && hole.max.y >= initialHeight) {\n        topHoles.push(hole);\n        outsideHoles.push(hole);\n      } else {\n        insideHoles.push(hole);\n      }\n    }\n  }\n\n  var wallShape = new THREE.Shape();\n  if (outsideHoles.length > 0) {\n    //console.log('processing outside holes', bottomHoles, rightHoles, topHoles, leftHoles);\n    bottomHoles = _.sortBy(bottomHoles, function(hole) { return hole.min.x; });\n    rightHoles = _.sortBy(rightHoles, function(hole) { return hole.max.y; });\n    topHoles = _.sortBy(topHoles, function(hole) { return -hole.max.x; });\n    leftHoles = _.sortBy(leftHoles, function(hole) { return -hole.max.y; });\n\n    // Start at lower left\n    wallShape.moveTo(0, 0);\n\n    // Process bottom holes\n    for (var i = 0; i < bottomHoles.length; i++) {\n      var hole = bottomHoles[i];\n      wallShape.lineTo(wdelta + hole.min.x, 0);\n      wallShape.lineTo(wdelta + hole.min.x, hole.max.y);\n      wallShape.lineTo(wdelta + hole.max.x, hole.max.y);\n      wallShape.lineTo(wdelta + hole.max.x, 0);\n    }\n    wallShape.lineTo(width, 0);\n\n    // Process right holes\n    for (var i = 0; i < rightHoles.length; i++) {\n      var hole = rightHoles[i];\n      wallShape.lineTo(width, hole.min.y);\n      wallShape.lineTo(wdelta + hole.min.x, hole.min.y);\n      wallShape.lineTo(wdelta + hole.min.x, hole.max.y);\n      wallShape.lineTo(width, hole.max.y);\n    }\n    // Go to top\n    if (!hole || hole.max.y < height) {\n      wallShape.lineTo(width, height);\n    }\n\n    // Process top holes\n    for (var i = 0; i < topHoles.length; i++) {\n      var hole = topHoles[i];\n      wallShape.lineTo(wdelta + hole.max.x, height);\n      wallShape.lineTo(wdelta + hole.max.x, hole.min.y);\n      wallShape.lineTo(wdelta + hole.min.x, hole.min.y);\n      wallShape.lineTo(wdelta + hole.min.x, height);\n    }\n    wallShape.lineTo(0, height);\n\n    // Process left holes\n    for (var i = 0; i < leftHoles.length; i++) {\n      var hole = leftHoles[i];\n      wallShape.lineTo(0, hole.max.y);\n      wallShape.lineTo(wdelta + hole.max.x, hole.max.y);\n      wallShape.lineTo(wdelta + hole.max.x, hole.min.y);\n      wallShape.lineTo(0, hole.min.y);\n    }\n\n    if (!hole || hole.min.y > 0) {\n      wallShape.lineTo(0, 0);\n    }\n  } else {\n    wallShape.moveTo(0, 0);\n    wallShape.lineTo(width, 0);\n    wallShape.lineTo(width, height);\n    wallShape.lineTo(0, height);\n    wallShape.lineTo(0, 0);\n  }\n\n  if (insideHoles.length) {\n    for (var iHole = 0; iHole < insideHoles.length; iHole++) {\n      var hole = insideHoles[iHole];\n      var holePath = new THREE.Path();\n      // Make sure holes are inside wall...\n      var minx = Math.max(wdelta + hole.min.x, 0.000);\n      var maxx = Math.min(wdelta + hole.max.x, width - 0.000);\n      var miny = Math.max(hole.min.y, 0.000);\n      var maxy = Math.min(hole.max.y, height - 0.000);\n\n      holePath.moveTo(minx, miny);\n      holePath.lineTo(maxx, miny);\n      holePath.lineTo(maxx, maxy);\n      holePath.lineTo(minx, maxy);\n      holePath.lineTo(minx, miny);\n      wallShape.holes.push(holePath);\n    }\n  }\n\n  var extrudeSettings = { depth: depth / 2, bevelEnabled: false };\n  var geo = new THREE.ExtrudeGeometry(wallShape, extrudeSettings);\n  return geo;\n};\n\nObject3DUtil.makeWallWithHoles = function (baseStart, baseEnd, wallUpDir, wallHeight, extraHeight,\n                                           depth, holes, materials) {\n  depth = depth || 10;\n  var height = wallHeight + extraHeight;\n  var wallDir = baseEnd.clone().sub(baseStart).normalize();\n  var wallFrontDir = new THREE.Vector3();\n  wallFrontDir.crossVectors(wallDir, wallUpDir).normalize();\n  var wallEndOffset = wallDir.clone().multiplyScalar(depth / 2 - depth / 10);\n\n  var p0 = baseStart.clone().sub(wallEndOffset);\n  var p1 = baseEnd.clone().add(wallEndOffset);\n  var width = p1.distanceTo(p0);\n\n  // Account for slight difference in original width and extended width\n  var initialWidth = baseStart.distanceTo(baseEnd);\n\n  var geo = Object3DUtil.__makeWallWithHolesGeometry({\n    holes: holes,\n    height: height,\n    depth: depth,\n    width: width,\n    initialWidth: initialWidth,\n    initialHeight: wallHeight\n  });\n\n  var materialBetween = Object3DUtil.getBasicMaterial('gray');\n  var materialIn  = [materials[0], materialBetween];\n  var materialOut = [materials[1], materialBetween];\n  var meshIn = new THREE.Mesh(geo, materialIn);\n  var meshOut = new THREE.Mesh(geo, materialOut);\n  meshIn.name = 'WallInside';\n  meshOut.name = 'WallOutside';\n\n  var alignMatrix = Object3DUtil.getAlignmentMatrix(\n    new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1),\n    wallUpDir, wallFrontDir);\n  alignMatrix.setPosition(p0);\n  Object3DUtil.setMatrix(meshIn, alignMatrix);\n\n  var offset = wallFrontDir.clone().multiplyScalar(-depth / 2 + depth / 19);  // NOTE: d/19 offset to avoid z-fighting\n  alignMatrix.setPosition(p0.clone().add(offset));\n  Object3DUtil.setMatrix(meshOut, alignMatrix);\n\n  var merged = new THREE.Object3D('DoubleSidedWall');\n  merged.add(meshIn);\n  merged.add(meshOut);\n  merged.name = 'DoubleSidedWall';\n\n  return merged;\n};\n\nObject3DUtil.addWall = function (scene, baseStart, baseEnd, wallUpDir, height, depth, color) {\n  var wall = Object3DUtil.makeWall(baseStart, baseEnd, wallUpDir, height, depth, color);\n  scene.add(wall);\n};\n\nfunction mergeHoles(holeBBoxes) {\n  var mergedHoleIndices = [];\n  var finalHoleBoxes = [];\n  for (var i = 0; i < holeBBoxes.length; i++) {\n    if (mergedHoleIndices.indexOf(i) >= 0) {\n      continue;\n    }\n    var iHoleBBox = holeBBoxes[i];\n    for (var j = i + 1; j < holeBBoxes.length; j++) {\n      var jHoleBBox = holeBBoxes[j];\n      if (iHoleBBox.intersects(jHoleBBox)) {\n        mergedHoleIndices.push(j);\n        //console.log('Merging ' + jHoleBBox.toString() + ' to ' + iHoleBBox.toString());\n        iHoleBBox.includeBBox(jHoleBBox);\n        //console.log('Got ' + iHoleBBox.toString());\n      }\n    }\n    finalHoleBoxes.push(iHoleBBox);\n  }\n  return { holeBBoxes: finalHoleBoxes, mergedHoleIndices: mergedHoleIndices };\n}\n\nfunction repeatedMergeHoles(holeBBoxes) {\n  var m = mergeHoles(holeBBoxes);\n  while (m.mergedHoleIndices.length > 0) {\n    m = mergeHoles(m.holeBBoxes);\n  }\n  return m.holeBBoxes;\n}\n\nObject3DUtil.mergeHoles = repeatedMergeHoles;\n\nObject3DUtil.getVisibleWidthHeight = function (camera, dist) {\n  var vFOV = camera.fov * Math.PI / 180;   // convert vertical fov to radians\n  var height = 2 * Math.tan(vFOV / 2) * dist;   // visible height\n  var width = height * camera.aspect;\n  return new THREE.Vector2(width, height);\n};\n\nObject3DUtil.makeCameraFrustum = function (origCamera) {\n  var camera = origCamera.clone();\n  camera.near = 50;\n  camera.far = 100;\n  camera.updateProjectionMatrix();\n  camera.updateMatrixWorld();\n  return new THREE.CameraHelper(camera);\n};\n\nObject3DUtil.decomposeMatrix4 = function(matrix) {\n  var scale = new THREE.Vector3();\n  var position = new THREE.Vector3();\n  var orientation = new THREE.Quaternion();\n  matrix.decompose(position, orientation, scale);\n  return {\n    position: position,\n    orientation: orientation,\n    scale: scale\n  };\n};\n\nObject3DUtil.transferFaceAttributeToVertexColor = function(object3D, attribute, convertAttrFn) {\n  var color = new THREE.Color();\n  Object3DUtil.colorVerticesUsingFaceAttribute(object3D, attribute, function(x) {\n    var v = convertAttrFn? convertAttrFn(x) : x;\n    color.setHex(v);\n    return color;\n  });\n};\n\nObject3DUtil.colorVerticesUsingFaceAttribute = function(object3D, attribute, colorIndexOrFn) {\n  var colorFn = null;\n  if (colorIndexOrFn) {\n    if (_.isFunction(colorIndexOrFn)) {\n      colorFn = colorIndexOrFn;\n    } else {\n      colorFn = function(x) { return colorIndexOrFn[x]; };\n    }\n  }\n  Object3DUtil.traverseMeshes(object3D, false, function(mesh) {\n    var geometry = mesh.geometry;\n    if (geometry.customFaceAttributes) {\n      var faceAttributes = geometry.customFaceAttributes[attribute];\n      var vertexColorBuffer = geometry.attributes['color'].array;\n      console.log('got faceAttributes ' + attribute + ': ' + faceAttributes.length /*, _.min(faceAttributes), _.max(faceAttributes)*/);\n      GeometryUtil.forFaceVertexIndices(geometry, function(iFace, vertIndices) {\n        var v = faceAttributes[iFace];\n        //console.log('got face attribute ' + v + ', vertices ' + JSON.stringify(vertIndices));\n        var c = colorFn? colorFn(v) : v;\n        if (c == undefined) {\n          c = v || 0;\n        }\n        c = _.isInteger(c)? Object3DUtil.createColor(c) : Object3DUtil.getColor(c);\n        for (var i = 0; i < vertIndices.length; i++) {\n          var ci = vertIndices[i]*3;\n          vertexColorBuffer[ci] = c.r;\n          vertexColorBuffer[ci+1] = c.g;\n          vertexColorBuffer[ci+2] = c.b;\n        }\n      });\n    }\n  });\n};\n\nObject3DUtil.transferVertexAttributeToVertexColor = function(object3D, attribute, convertAttrFn) {\n  var color = new THREE.Color();\n  Object3DUtil.colorVerticesUsingVertexAttribute(object3D, attribute, function(x) {\n    var v = convertAttrFn? convertAttrFn(x) : x;\n    color.setHex(v);\n    return color;\n  });\n};\n\nObject3DUtil.colorVerticesUsingVertexAttribute = function(object3D, attribute, colorIndexOrFn) {\n  var colorFn = null;\n  if (colorIndexOrFn) {\n    if (_.isFunction(colorIndexOrFn)) {\n      colorFn = colorIndexOrFn;\n    } else {\n      colorFn = function(x) { return colorIndexOrFn[x]; };\n    }\n  }\n  Object3DUtil.traverseMeshes(object3D, false, function(mesh) {\n    var geometry = mesh.geometry;\n    if (geometry.customVertexAttributes) {\n      var vertexAttributes = geometry.customVertexAttributes[attribute];\n      var vertexColorBuffer = geometry.attributes['color'].array;\n      console.log('got vertexAttributes ' + attribute + ': ' + vertexAttributes.length /*, _.min(vertexAttributes), _.max(vertexAttributes)*/);\n      var nvertices = vertexColorBuffer.length/3;\n      for (var iVert = 0; iVert < nvertices; iVert++) {\n        var v = vertexAttributes[iVert];\n        //console.log('got vertex attribute ' + v + ', vertex ' + iVert);\n        var c = colorFn? colorFn(v) : v;\n        if (c == undefined) {\n          c = v || 0;\n        }\n        c = _.isInteger(c)? Object3DUtil.createColor(c) : Object3DUtil.getColor(c);\n        var ci = iVert*3;\n        vertexColorBuffer[ci] = c.r;\n        vertexColorBuffer[ci+1] = c.g;\n        vertexColorBuffer[ci+2] = c.b;\n      }\n    }\n  });\n};\n\nObject3DUtil.grayOutVertices = function(object3D, center, maxRadius, grayColor) {\n  Object3DUtil.traverseMeshes(object3D, false, function (mesh) {\n    GeometryUtil.grayOutVertices(mesh, center, maxRadius, grayColor);\n  });\n};\n\nObject3DUtil.filterByCategory = function(node, categories, includeNonModelInstances) {\n  var modelInstance = Object3DUtil.getModelInstance(node);\n  if (modelInstance) {\n    return modelInstance.model.hasCategoryIn(categories, true);\n  } else {\n    if (includeNonModelInstances && node.userData.type) {\n      var t = node.userData.type.toLowerCase();\n      return _.any(categories, function(cat) { return t === cat.toLowerCase(); });\n    } else {\n      return false;\n    }\n  }\n};\n\nObject3DUtil.isHidden = function(node) {\n  return !Object3DUtil.isVisible(node);\n};\n\nObject3DUtil.isVisible = function(node) {\n  var visible = node.visible;\n  while (node != null) {\n    if (!node.visible) {\n      visible = false;\n      break;\n    }\n    node = node.parent;\n  }\n  return visible;\n};\n\nObject3DUtil.BlackMatParams = {\n  type: 'phong',\n  opacity: 1,\n  color: 0,\n  emissive: 0x000000,\n  specular: 0x000000,\n  side: THREE.DoubleSide,\n  name: 'black'\n};\n\nObject3DUtil.BlackMat = Object3DUtil.createMaterial(Object3DUtil.BlackMatParams);\n\nObject3DUtil.ClearMatParams = {\n  type: 'basic',\n  opacity: 0.1,\n  color: 0,\n  side: THREE.DoubleSide,\n  name: 'clear'\n};\n\nObject3DUtil.ClearMat = Object3DUtil.createMaterial(Object3DUtil.ClearMatParams);\nObject3DUtil.ClearColor = new THREE.Color('gray');\n\nObject3DUtil.TransparentMatParams = {\n  type: 'basic',\n  opacity: 0.4,\n  color: 0x111111,\n  side: THREE.DoubleSide,\n  name: 'transparent'\n};\n\nObject3DUtil.TransparentMat = Object3DUtil.createMaterial(Object3DUtil.TransparentMatParams);\n\nObject3DUtil.InvisibleMat = Object3DUtil.createMaterial({\n  type: 'basic',\n  visible: false,\n  name: 'invisible'\n});\n\n// Exports\nmodule.exports = Object3DUtil;\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/Object3DUtil.js?");

/***/ }),

/***/ "./js/lib/geo/RaycasterUtil.js":
/*!*************************************!*\
  !*** ./js/lib/geo/RaycasterUtil.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\nvar self = {};\n\n// TODO: Move more functions from Picker here\n// Temp variables\nvar __raycaster = new THREE.Raycaster();\nvar __backfaceRaycaster = new THREE.Raycaster();\n__backfaceRaycaster.intersectBackFaces = true;\n\n/**\n * Intersection information\n * @typedef Intersect\n * @type {object}\n * @property {number} distance\n * @property {THREE.Vector3} point\n * @property {int} index\n * @property {THREE.Face3} face Face being intersected\n * @property {int} faceIndex Index of face\n * @property {THREE.Object3D} object\n * @property {THREE.Mesh} descendant\n */\n\n/**\n * Returns list of intersected for ray\n * @param raycaster {THREE.Raycaster} Raycaster\n * @param objects {THREE.Object3D[]} List objects to intersect\n * @param ignore {THREE.Object3D} Object to ignore\n * @param n {int} Number of intersects to return\n * @param renderer {THREE.Renderer}\n * @returns {Intersect[]}\n */\nself.getIntersectedForRay = function (raycaster, objects, ignore, n, renderer) {\n  var intersected = raycaster.intersectObjects(objects, true);\n  intersected = self.filterClipped(intersected, renderer);\n  self.sortIntersectionsByNormal(raycaster.ray, intersected);\n  return self.selectIntersectedObjects(intersected, objects, ignore, n);\n};\n\n/**\n * Filters intersected by renderer clippingPlanes\n * @param intersected {Intersect[]}\n * @param renderer {gfx.Renderer}\n * @returns {*}\n */\nself.filterClipped = function(intersected, renderer) {\n  if (renderer && renderer.clippingPlanes.length > 0) {\n    intersected = intersected.filter(function(elem) {\n      return renderer.clippingPlanes.every(function(elem2) {\n        return elem2.distanceToPoint(elem.point) > 0;\n      });\n    });\n  }\n  return intersected;\n};\n\nself.getIntersected = function(objects, opts) {\n  var rc = opts.intersectBackFaces? __backfaceRaycaster : __raycaster;\n  rc.ray.origin.copy(opts.position);\n  rc.ray.direction.copy(opts.direction);\n  rc.near = opts.near || 0;\n  rc.far = opts.far || Infinity;\n  return self.getIntersectedForRay(rc, objects, opts.ignore, opts.n, opts.renderer);\n};\n\nself.sortIntersectionsByNormal = function(ray, intersections) {\n  var d = ray.direction;\n  intersections.sort(function (a, b) {\n    if (a.distance < b.distance) { return -1; }\n    if (a.distance > b.distance) { return 1; }\n    var na = self.getIntersectedNormal(a);\n    var nb = self.getIntersectedNormal(b);\n    var nadot = na? d.dot(na) : NaN;\n    var nbdot = nb? d.dot(nb) : NaN;\n    //console.log(nadot);\n    //console.log(nbdot);\n    if (nadot < nbdot) { return -1; }\n    if (nadot > nbdot) { return 1; }\n    return 0;\n  });\n};\n\n/**\n * From list of intersected, pick out the ones that are actually in the list of objects\n * If the object is intersected multiple times, it will be picked multiple times\n * Original intersected mesh/points is moved to `descendant` field and matched object is now called `object`\n * @param intersected {Intersect[]} Array of intersected objects\n * @param objects {THREE.Object3D[]} Array of ancestor objects that we are actually interested in\n * @param [ignore] {THREE.Object3D[]} Array of objects to ignore\n * @param [n] {int} Max number of entries to return\n * @param [allowAllModelInstances] {boolean} Whether any model instance is allowed as intersected object\n * @returns {Intersect[]}\n */\nself.selectIntersectedObjects = function (intersected, objects, ignore, n, allowAllModelInstances) {\n  var intersectedObjects = [];\n  for (var i = 0; i < intersected.length; i++) {\n    var c = intersected[i].object;\n    // follow parents until we reach an object we know about\n    var o = c;\n    var index = -1;\n    var modelInstance = null;\n    while (o) {\n      index = objects.indexOf(o);\n      if (index >= 0) {\n        break;\n      }\n      // Drop out if model instance (not object we care about)\n      modelInstance = Object3DUtil.getModelInstance(o);\n      if (modelInstance) {\n        break;\n      }\n      o = o.parent;\n    }\n    if (index >= 0 || allowAllModelInstances) {\n      intersected[i].object = o;\n      intersected[i].descendant = c;\n      var ignoreObject = (ignore && Object3DUtil.isDescendantOf(o, ignore, true));\n      if (!ignoreObject) {\n        intersectedObjects.push(intersected[i]);\n      }\n      // Reached limit of how many we wanted\n      if (n && intersectedObjects.length > n) break;\n    } else {\n      //console.log('Cannot find parent for intersected child');\n    }\n  }\n  return intersectedObjects;\n};\n\nself.getClosestPerObject = function(intersected, deltaThreshold) {\n  if (intersected.length < 2) { return intersected; }\n  var objects = {};\n  var filtered = [];\n  var maxDist = (deltaThreshold != undefined)? (intersected[0].distance + deltaThreshold) : undefined;\n  for (var i = 0; i < intersected.length; i++) {\n    var a = intersected[i];\n    if (maxDist !== undefined) {\n      if (a.distance > maxDist) {\n        break;\n      }\n    }\n    if (objects[a.object.id]) {\n      // Already seen this one\n    } else {\n      objects[a.object.id] = true;\n      filtered.push(a);\n    }\n  }\n  return filtered;\n};\n\n\nself.getIntersectedNormal = function() {\n  var edge1 = new THREE.Vector3();\n  var edge2 = new THREE.Vector3();\n  var va = new THREE.Vector3();\n  var vb = new THREE.Vector3();\n  var vc = new THREE.Vector3();\n  return function (intersected) {\n    if (intersected.normal) return intersected.normal;\n    // TODO: Can use face.normal too (multiply by mesh.matrixWorld.extractRotation?\n    if (intersected.face) {\n      var mesh = intersected.descendant;\n      if (mesh === undefined) {\n        mesh = intersected.object;\n      }\n      if (mesh instanceof THREE.Mesh) {\n        var geom = mesh.geometry;\n        var a = GeometryUtil.getGeometryVertex(geom, intersected.face.a, mesh.matrixWorld, va);\n        var b = GeometryUtil.getGeometryVertex(geom, intersected.face.b, mesh.matrixWorld, vb);\n        var c = GeometryUtil.getGeometryVertex(geom, intersected.face.c, mesh.matrixWorld, vc);\n        var normal = new THREE.Vector3();\n        edge1.subVectors(b, a).normalize();\n        edge2.subVectors(c, a).normalize();\n        normal.crossVectors(edge1, edge2).normalize();\n        var numFlips = Object3DUtil.countMirroringTransforms(mesh);\n        var geomFlips = geom.isFlipped? 1 : 0;\n        // Mismatch between number of flips we have done with the geometry vs our transform\n        // flip our normal for placement purposes\n        if (numFlips % 2 !== geomFlips) { normal.multiplyScalar(-1); }\n        intersected.normal = normal;\n      } else if (mesh instanceof THREE.Points) {\n\n      } else if (mesh instanceof THREE.Line) {\n\n      }\n     }\n    return intersected.normal;\n  };\n}();\n\n// Modified version of Mesh.raycast to allow for intersection with subsets of triangles (need to be updated for three.js 8x and not really helping yet)\nself.raycastMeshTriangles = ( function () {\n\n  var inverseMatrix = new THREE.Matrix4();\n  var ray = new THREE.Ray();\n  var sphere = new THREE.Sphere();\n\n  var vA = new THREE.Vector3();\n  var vB = new THREE.Vector3();\n  var vC = new THREE.Vector3();\n\n  var tempA = new THREE.Vector3();\n  var tempB = new THREE.Vector3();\n  var tempC = new THREE.Vector3();\n\n  var uvA = new THREE.Vector2();\n  var uvB = new THREE.Vector2();\n  var uvC = new THREE.Vector2();\n\n  var barycoord = new THREE.Vector3();\n\n  var intersectionPoint = new THREE.Vector3();\n  var intersectionPointWorld = new THREE.Vector3();\n\n  function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\n\n    THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\n\n    uv1.multiplyScalar( barycoord.x );\n    uv2.multiplyScalar( barycoord.y );\n    uv3.multiplyScalar( barycoord.z );\n\n    uv1.add( uv2 ).add( uv3 );\n\n    return uv1.clone();\n\n  }\n\n  function checkIntersection( object, raycaster, ray, pA, pB, pC, point ){\n\n    var intersect;\n    var material = object.material;\n\n    // AXC: Add control for raycaster to not do back face culling (by setting raycaster.intersectBackFaces)\n    if ( material.side === THREE.BackSide ) {\n\n      intersect = ray.intersectTriangle( pC, pB, pA, !raycaster.intersectBackFaces && true, point );\n\n    } else {\n\n      intersect = ray.intersectTriangle( pA, pB, pC, !raycaster.intersectBackFaces && material.side !== THREE.DoubleSide, point );\n\n    }\n\n    if ( intersect === null ) return null;\n\n    intersectionPointWorld.copy( point );\n    intersectionPointWorld.applyMatrix4( object.matrixWorld );\n\n    var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\n\n    if ( distance < raycaster.near || distance > raycaster.far ) return null;\n\n    return {\n      distance: distance,\n      point: intersectionPointWorld.clone(),\n      object: object\n    };\n\n  }\n\n  function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\n\n    vA.fromArray( positions, a * 3 );\n    vB.fromArray( positions, b * 3 );\n    vC.fromArray( positions, c * 3 );\n\n    var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\n\n    if ( intersection ) {\n\n      if ( uvs ) {\n\n        uvA.fromArray( uvs, a * 2 );\n        uvB.fromArray( uvs, b * 2 );\n        uvC.fromArray( uvs, c * 2 );\n\n        intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\n\n      }\n\n      intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\n      intersection.faceIndex = a;\n\n    }\n\n    return intersection;\n\n  }\n\n  return function raycast( mesh, triIndices, raycaster, raylocal, intersects ) {\n\n    var geometry = mesh.geometry;\n    var material = mesh.material;\n\n    if ( material === undefined ) return;\n\n    ray.copy(raylocal);\n    // if (raycasterIsWorld) {\n    //   var matrixWorld = mesh.matrixWorld;\n    //   inverseMatrix.getInverse(matrixWorld);\n    //   ray.applyMatrix4(inverseMatrix);\n    // }\n    //\n    // if (checkBounds) {\n    //   // Checking boundingSphere distance to ray\n    //\n    //   if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n    //\n    //   if (ray.isIntersectionSphere(geometry.boundingSphere) === false) return;\n    //\n    //   // Check boundingBox before continuing\n    //\n    //   if (geometry.boundingBox !== null) {\n    //\n    //     if (ray.isIntersectionBox(geometry.boundingBox) === false) return;\n    //\n    //   }\n    // }\n\n    var uvs, intersection;\n\n    if ( geometry instanceof THREE.BufferGeometry ) {\n\n      var a, b, c;\n      var index = geometry.index;\n      var attributes = geometry.attributes;\n      var positions = attributes.position.array;\n\n      if ( attributes.uv !== undefined ){\n\n        uvs = attributes.uv.array;\n\n      }\n\n      if ( index !== null ) {\n\n        var indices = index.array;\n\n        for ( var ti = 0, l = triIndices.length; ti < l; ti ++ ) {\n          var f = triIndices[ti];\n          var i = triIndices[ti]*3;\n          a = indices[ i ];\n          b = indices[ i + 1 ];\n          c = indices[ i + 2 ];\n\n          intersection = checkBufferGeometryIntersection( mesh, raycaster, ray, positions, uvs, a, b, c );\n\n          if ( intersection ) {\n\n            intersection.faceIndex = f; // triangle number in indices buffer semantics\n            intersects.push( intersection );\n\n          }\n\n        }\n\n      } else {\n\n\n        for ( var ti = 0, l = triIndices.length; ti < l; ti ++ ) {\n          var f = triIndices[ti];\n          a = f * 3;\n          b = a + 1;\n          c = a + 2;\n\n          intersection = checkBufferGeometryIntersection( mesh, raycaster, ray, positions, uvs, a, b, c );\n\n          if ( intersection ) {\n\n            // AXC: Fix faceIndex\n            intersection.faceIndex = f; // triangle number in positions buffer semantics\n            intersects.push( intersection );\n\n          }\n\n        }\n\n      }\n\n    } else if ( geometry instanceof THREE.Geometry ) {\n\n      var fvA, fvB, fvC;\n      var isFaceMaterial = material instanceof THREE.MeshFaceMaterial;\n      var materials = isFaceMaterial === true ? material.materials : null;\n\n      var vertices = geometry.vertices;\n      var faces = geometry.faces;\n      var faceVertexUvs = geometry.faceVertexUvs[ 0 ];\n      if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\n\n      for ( var ti = 0, l = triIndices.length; ti < l; ti ++ ) {\n        var f = triIndices[ti];\n\n        var face = faces[ f ];\n        var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\n\n        if ( faceMaterial === undefined ) continue;\n\n        fvA = vertices[ face.a ];\n        fvB = vertices[ face.b ];\n        fvC = vertices[ face.c ];\n\n        if ( faceMaterial.morphTargets === true ) {\n\n          var morphTargets = geometry.morphTargets;\n          var morphInfluences = mesh.morphTargetInfluences;\n\n          vA.set( 0, 0, 0 );\n          vB.set( 0, 0, 0 );\n          vC.set( 0, 0, 0 );\n\n          for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\n\n            var influence = morphInfluences[ t ];\n\n            if ( influence === 0 ) continue;\n\n            var targets = morphTargets[ t ].vertices;\n\n            vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\n            vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\n            vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\n\n          }\n\n          vA.add( fvA );\n          vB.add( fvB );\n          vC.add( fvC );\n\n          fvA = vA;\n          fvB = vB;\n          fvC = vC;\n\n        }\n\n        intersection = checkIntersection( mesh, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\n\n        if ( intersection ) {\n          if ( uvs && uvs[ f ]) {  // NOTE(MS): This check avoids error due to sparse uvs\n\n            var uvs_f = uvs[ f ];\n            uvA.copy( uvs_f[ 0 ] );\n            uvB.copy( uvs_f[ 1 ] );\n            uvC.copy( uvs_f[ 2 ] );\n\n            intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\n\n          }\n\n          intersection.face = face;\n          intersection.faceIndex = f;\n          intersects.push( intersection );\n\n        }\n\n      }\n\n    }\n\n  };\n\n}() );\n\n\n\nmodule.exports = self;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/geo/RaycasterUtil.js?");

/***/ }),

/***/ "./js/lib/geo/TriangleAccessor.js":
/*!****************************************!*\
  !*** ./js/lib/geo/TriangleAccessor.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Helper for accessing faces of a mesh\n * @param mesh {THREE.Mesh}\n * @constructor\n * @private\n * @memberOf geo\n */\nfunction TriangleAccessor(mesh) {\n  this.mesh = mesh;\n  this.geo = mesh.geometry;\n  this.isBufferGeometry = mesh.geometry instanceof THREE.BufferGeometry;\n  this.V = this.isBufferGeometry ? this.geo.attributes.position.array : this.geo.vertices;\n  this.F = this.isBufferGeometry ? null : this.geo.faces;\n}\nTriangleAccessor.prototype.constructor = TriangleAccessor;\n\nTriangleAccessor.prototype.numTriangles = function () {\n  return GeometryUtil.getGeometryFaceCount(this.geo);\n};\n\nfunction getVertexAttr(attr, vidx, stride) {\n  if (!attr) { return; }\n  var i = vidx * stride;\n  return attr.array.slice(i, i + stride);\n}\n\n/**\n * Returns the ith triangle of this mesh\n * @param i {int}\n * @returns {MeshSampling.Face}\n */\nTriangleAccessor.prototype.get = function (i) {\n  var face = { index: i };  // fields : va, vb, vc, na, nb, nc, ca, cb, cc, uva, uvb, uvc, materialIndex\n  if (this.isBufferGeometry) {\n    var vidxs = GeometryUtil.getFaceVertexIndices(this.geo, i);\n\n    face.va = GeometryUtil.getGeometryVertex(this.geo, vidxs[0]);\n    face.vb = GeometryUtil.getGeometryVertex(this.geo, vidxs[1]);\n    face.vc = GeometryUtil.getGeometryVertex(this.geo, vidxs[2]);\n\n    if (this.geo.groups) {  // material indices\n      var vi = i*3;\n      var group = _.find(this.geo.groups, function (g) {\n        return (vi >= g.start) && (vi < g.start + g.count);\n      });\n      if (group) {\n        face.materialIndex = group.materialIndex;\n      }\n    }\n\n    var normals = this.geo.attributes['normal'];\n    if (normals && (normals.count || normals.length)) {\n      face.hasNormals = true;\n      face.na = Object3DUtil.toVector3(getVertexAttr(normals, vidxs[0], 3));\n      face.nb = Object3DUtil.toVector3(getVertexAttr(normals, vidxs[1], 3));\n      face.nc = Object3DUtil.toVector3(getVertexAttr(normals, vidxs[2], 3));\n    }\n\n    var colors = this.geo.attributes['color'];\n    if (colors && (colors.count || colors.length)) {\n      face.hasVertexColors = true;\n      face.ca = Object3DUtil.getColor(getVertexAttr(colors, vidxs[0], 3));\n      face.cb = Object3DUtil.getColor(getVertexAttr(colors, vidxs[1], 3));\n      face.cc = Object3DUtil.getColor(getVertexAttr(colors, vidxs[2], 3));\n    }\n\n    var uvs = this.geo.attributes['uv'];\n    if (uvs && (uvs.count || uvs.length)) {\n      face.hasUVs = true;\n      face.uva = Object3DUtil.toVector2(getVertexAttr(uvs, vidxs[0], 2));\n      face.uvb = Object3DUtil.toVector2(getVertexAttr(uvs, vidxs[1], 2));\n      face.uvc = Object3DUtil.toVector2(getVertexAttr(uvs, vidxs[2], 2));\n    }\n\n  } else {\n    var f = this.geo.faces[i];\n    face.materialIndex = f.materialIndex;\n\n    face.va = this.V[f.a];\n    face.vb = this.V[f.b];\n    face.vc = this.V[f.c];\n\n    if (f.vertexNormals && f.vertexNormals.length === 3) {\n      face.hasNormals = true;\n      face.na = f.vertexNormals[0];\n      face.nb = f.vertexNormals[1];\n      face.nc = f.vertexNormals[2];\n    }\n\n    if (f.vertexColors && f.vertexColors.length === 3) {\n      face.hasVertexColors = true;\n      face.ca = f.vertexColors[0];\n      face.cb = f.vertexColors[1];\n      face.cc = f.vertexColors[2];\n    }\n\n    if (this.geo.faceVertexUvs && this.geo.faceVertexUvs[0]) {\n      var vertexUVs = this.geo.faceVertexUvs[0][i];\n      if (vertexUVs) {\n        face.hasUVs = true;\n        face.uva = vertexUVs[0];\n        face.uvb = vertexUVs[1];\n        face.uvc = vertexUVs[2];\n      }\n    }\n\n  }\n\n  return face;\n};\n\nTriangleAccessor.prototype.getTriangle = function(i, triangle, transform) {\n  return GeometryUtil.getTriangle(this.geo, i, triangle, transform);\n};\n\nTriangleAccessor.prototype.getTriangleVertexIndices = function(i) {\n  return GeometryUtil.getFaceVertexIndices(this.geo, i);\n};\n\nTriangleAccessor.prototype.getTriangleArea = (function() {\n  var tri = new THREE.Triangle();\n  var scope = this;\n  return function(i, transform) {\n    scope.getTriangle(i, tri, transform);\n    return tri.getArea();\n  };\n}());\n\n// Extended triangle accessor will also handle partial meshes\nfunction ExtendedTriangleAccessor(mesh) {\n  if (mesh.mesh && mesh.faceIndices) {\n    TriangleAccessor.call(this, mesh.mesh);\n    this.faceIndices = mesh.faceIndices;\n  } else {\n    TriangleAccessor.call(this, mesh);\n  }\n}\n\nExtendedTriangleAccessor.prototype = Object.create(TriangleAccessor.prototype);\nExtendedTriangleAccessor.prototype.constructor = ExtendedTriangleAccessor;\n\nExtendedTriangleAccessor.prototype.numTriangles = function () {\n  if (this.faceIndices) {\n    return this.faceIndices.length;\n  } else {\n    return TriangleAccessor.prototype.numTriangles.call(this);\n  }\n};\n\n\nExtendedTriangleAccessor.prototype.get = function (i) {\n  if (this.faceIndices) {\n    var f = TriangleAccessor.prototype.get.call(this, this.faceIndices[i]);\n    return f;\n  } else {\n    return TriangleAccessor.prototype.get.call(this, i);\n  }\n};\n\nExtendedTriangleAccessor.prototype.getTriangleVertexIndices = function(i) {\n  if (this.faceIndices) {\n    return TriangleAccessor.prototype.getTriangleVertexIndices.call(this, this.faceIndices[i]);\n  } else {\n    return TriangleAccessor.prototype.getTriangleVertexIndices.call(this, i);\n  }\n};\n\nExtendedTriangleAccessor.prototype.getTriangle = function(i, triangle, transform) {\n  if (this.faceIndices) {\n    var f = TriangleAccessor.prototype.getTriangle.call(this, this.faceIndices[i], triangle, transform);\n    return f;\n  } else {\n    return TriangleAccessor.prototype.getTriangle.call(this, i, triangle, transform);\n  }\n};\n\nmodule.exports = ExtendedTriangleAccessor;\n\n//# sourceURL=webpack://STK/./js/lib/geo/TriangleAccessor.js?");

/***/ }),

/***/ "./js/lib/geo/VideoTexture.js":
/*!************************************!*\
  !*** ./js/lib/geo/VideoTexture.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Represents a video texture\n * @param options\n * @constructor\n * @memberOf geo\n */\nvar VideoTexture = function(options){\n  if (typeof options === 'string') {\n    // Assume just url\n    options = { url: options, autoplay: true, loop: true };\n  }\n  // From https://github.com/jeromeetienne/threex.videotexture\n\n  // create the video element\n  var video = document.createElement('video');\n  // video.id = 'video';\n  // video.type = ' video/ogg; codecs=\"theora, vorbis\" ';\n  video.autoplay  = options.autoplay;\n  video.loop  = options.loop;\n  video.src = options.url; //\"videos/sintel.ogv\";\n  if (options.width && options.height) {\n    video.width = options.width;\n    video.height = options.height;\n  }\n  console.log('Load video from ' + video.src);\n  //video.load(); // must call after setting/changing source\n  //video.play();\n\n  // alternative method --\n  // create DIV in HTML:\n  // <video id=\"myVideo\" autoplay style=\"display:none\">\n  //  <source src=\"videos/sintel.ogv\" type='video/ogg; codecs=\"theora, vorbis\"'>\n  // </video>\n  // and set JS variable:\n  // video = document.getElementById( 'myVideo' );\n\n  var videoTexture = new THREE.Texture(video);\n  videoTexture.minFilter = THREE.LinearFilter;\n  videoTexture.magFilter = THREE.LinearFilter;\n  videoTexture.needsUpdate = true;\n\n  // expose video as this.video\n  this.video = video;\n  // expose texture as this.texture\n  this.texture  = videoTexture;\n\n  /**\n   * update the object\n   * @memberOf geo.VideoTexture\n   * @instance\n   */\n  this.update = function(){\n    if (video.readyState !== video.HAVE_ENOUGH_DATA) {\n      return;\n    }\n    //tell texture object it needs to be updated\n    videoTexture.needsUpdate = true;\n  };\n\n  /**\n   * destroy the object\n   * @memberOf geo.VideoTexture\n   * @instance\n   */\n  this.destroy = function(){\n    video.pause();\n  };\n};\n\nmodule.exports = VideoTexture;\n\n//# sourceURL=webpack://STK/./js/lib/geo/VideoTexture.js?");

/***/ }),

/***/ "./js/lib/gfx/Camera.js":
/*!******************************!*\
  !*** ./js/lib/gfx/Camera.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Camera wrapper class\n */\n\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction Camera(fov, aspect, near, far) {\n  THREE.PerspectiveCamera.call(this, fov, aspect, near, far);\n}\n\nCamera.prototype = Object.create(THREE.PerspectiveCamera.prototype);\nCamera.prototype.constructor = Camera;\n\n// Initializes Camera from pair of strings giving extrinsics and intrinsics.\n// extrinsics is 4x4 transformation matrix taking camera coordinates to world.\n// Camera axes are +x=right, +y=up, -z=view\n// intrinsics are given as: { width, height, fx, fy, cx, cy }\nCamera.prototype.initFromExtrinsicsIntrinsics = function (extrMatrix, intr) {\n  this.matrix.copy(extrMatrix);\n  this.matrix.decompose(this.position, this.quaternion, this.scale);\n  if (intr) {\n    this.fov = 2 * Math.atan(intr.height / (2 * intr.fy)) * (180 / Math.PI);\n    this.aspect = intr.width / intr.height;\n  }\n  this.matrixWorldNeedsUpdate = true;\n  this.updateMatrixWorld();\n  this.updateProjectionMatrix();\n};\n\n// Parse Camera representation from gaps string\nCamera.prototype.initFromGapsString = function (str, aspect) {\n  var l = str.split(/\\s+/).map(function (s) { return parseFloat(s); });\n  var vx = l[0], vy = l[1], vz = l[2],\n      tx = l[3], ty = l[4], tz = l[5],\n      ux = l[6], uy = l[7], uz = l[8],\n      xf = l[9], yf = l[10], v = l[11];\n\n  // Old coordinates used to be different\n  // this.position.set(vx, vz, -vy).multiplyScalar(Constants.metersToVirtualUnit);\n  // this.up.set(ux, uz, -uy);\n  // var towards = new THREE.Vector3(tx, tz, -ty);\n\n  //this.position.set(-vx, vy, -vz).multiplyScalar(Constants.metersToVirtualUnit);\n  //this.up.set(-ux, uy, -uz);\n  //var towards = new THREE.Vector3(-tx, ty, -tz);\n\n  this.position.set(vx, vy, vz);\n  this.up.set(ux, uy, uz);\n  var towards = new THREE.Vector3(tx, ty, tz);\n  //var right = new THREE.Vector3();\n  //right.crossVectors(this.up, towards);\n  //towards.normalize();\n  //this.up.crossVectors(right, towards);\n  //this.up.normalize();\n  var target = this.position.clone();\n  target.add(towards);\n  this.lookAt(target);\n  this.fov = THREE.Math.radToDeg(yf) * 2;  // set vertical fov and ignore horizontal fov\n  this.value = v;\n  this.aspect = aspect;\n\n  this.updateProjectionMatrix();\n};\n\nCamera.prototype.applyTransform = (function () {\n  var normalMatrix = new THREE.Matrix3();\n  var rot = new THREE.Matrix4();\n  var q = new THREE.Quaternion();\n  return function(transform) {\n    normalMatrix.getNormalMatrix(transform);\n    this.up.applyMatrix3(normalMatrix);\n    this.up.normalize();\n\n    // Apply transform to camera\n    q.setFromRotationMatrix(rot.extractRotation(transform));\n    this.quaternion.multiplyQuaternions(q, this.quaternion);\n    this.position.applyMatrix4(transform);\n    this.updateMatrix();\n    this.updateMatrixWorld();\n    this.updateProjectionMatrix();\n    return this;\n  };\n}());\n\n// Create camera from json\nCamera.fromJson = function(json, width, height) {\n  var camera;\n  width = width || json.width;\n  height = height || json.height;\n  var aspect = (width && height)? width / height : json.aspect;\n  switch (json.type) {\n    case 'combined':\n    case 'CombinedCamera':\n      camera = new THREE.CombinedCamera(json.width, height, json.fov, json.near, json.far, json.near, json.far);\n      break;\n    case 'orthographic':\n    case 'OrthographicCamera':\n      var left =  json.left || -width/2;\n      var right = json.right || width/2;\n      var top = json.top || height/2;\n      var bottom = json.bottom || -height/2;\n      camera = new THREE.OrthographicCamera(left, right, top, bottom, json.near, json.far);\n      camera.fov = json.fov;\n      camera.aspect = aspect;\n      break;\n    // case 'direct':\n    //   camera = new THREE.Camera();\n    //   camera.projectionMatrix.copy(json.projectionMatrix);\n    //   break;\n    case 'perspective':\n    case 'PerspectiveCamera':\n    default:\n      camera = new THREE.PerspectiveCamera(json.fov, aspect, json.near, json.far);\n      break;\n  }\n  if (json.type === 'equirectangular' || json.type === \"equirectangularCamera\" || json.isEquirectangular) {\n    camera.isEquirectangular = true;\n  }\n  var updateProjectMatrixNeeded = false;\n  if (json.position) {\n    camera.position.copy(Object3DUtil.toVector3(json.position));\n    updateProjectMatrixNeeded = true;\n  }\n  if (json.target) {\n    camera.lookAt(Object3DUtil.toVector3(json.target));\n    updateProjectMatrixNeeded = true;\n  }\n  camera.updateMatrix();\n  if (updateProjectMatrixNeeded/*&& json.type !== 'direct'*/) {\n    camera.updateProjectionMatrix();\n  }\n  return camera;\n};\n\nCamera.setView = function(camera, options) {\n  var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n  var target = Object3DUtil.toVector3(options.target);        // Target to look at\n  var position = Object3DUtil.toVector3(options.position);    // Camera position\n  var up = Object3DUtil.toVector3(options.up);  // Up direction\n  var lookatUp = Object3DUtil.toVector3(options.lookatUp) || up;  // Up to use for looking at target\n\n  // Set up to use for lookAt\n  var cameraUp = up || camera.up.clone();\n  if (lookatUp) {\n    camera.up.copy(lookatUp);\n  }\n  camera.position.copy(position);\n  camera.lookAt(target);\n\n  // Set back up to use for camera\n  camera.up.copy(cameraUp);\n\n  if (options.fov) {\n    camera.fov = options.fov;\n  }\n  if (options.near) {\n    camera.near = options.near;\n  }\n  if (options.far) {\n    camera.far = options.far;\n  }\n\n  if (camera instanceof THREE.OrthographicCamera) {\n    // The size that we set is the mid plane of the viewing frustum\n    var hyperfocus = target.clone().sub(camera.position).length();\n    var halfHeight = Math.tan(camera.fov * Math.PI / 180 / 2) * hyperfocus;\n    var planeHeight = 2 * halfHeight;\n    var planeWidth = planeHeight * camera.aspect;\n    var halfWidth = planeWidth / 2;\n\n    camera.left = -halfWidth;\n    camera.right = halfWidth;\n    camera.top = halfHeight;\n    camera.bottom = -halfHeight;\n  }\n  camera.updateMatrix();\n  camera.updateProjectionMatrix(target);\n};\n\nTHREE.ArrayCamera.prototype.resizeCameras = function(totalWidth, totalHeight) {\n  var nCamsY = this.userData.shape[0];\n  var nCamsX = this.userData.shape[1];\n  var cameraWidth = Math.ceil(totalWidth/nCamsX);\n  var cameraHeight = Math.ceil(totalHeight/nCamsY);\n  var aspectRatio = cameraWidth / cameraHeight;\n  for (var i = 0; i < this.cameras.length; i++) {\n    var subcamera = this.cameras[i];\n    subcamera.aspect = aspectRatio;\n    subcamera.updateProjectionMatrix();\n  }\n};\n\n/**\n * Create a camera array\n * @param config\n * @param config.width [int]\n * @param config.height [int]\n * @param config.fov [number]\n * @param config.near [number]\n * @param config.far [number]\n * @param config.position {THREE.Vector3[]}\n * @param config.orientation {THREE.Vector3[]}\n * @param [config.isEquirectangular] {boolean}\n * @param [config.cameraArrayShape] {int[]} How many camera to have in each row (0) /column (1)\n * @param [config.stacking] {string} Stack camera `vertical` or `horizontal` (default)\n * @returns {ArrayCamera}\n */\nCamera.createArrayCamera = function(config) {\n  var nCameras = config.position.length;\n  var cameraArrayShape = config.cameraArrayShape;\n  if (!cameraArrayShape) {\n    if (config.stacking === 'vertical') {\n      cameraArrayShape = [nCameras, 1];\n    } else {\n      cameraArrayShape = [1, nCameras];\n    }\n  }\n  var nCamsY = cameraArrayShape[0];\n  var nCamsX = cameraArrayShape[1];\n  var sizeX = 1/nCamsX;\n  var sizeY = 1/nCamsY;\n  var aspectRatio = config.width / config.height;\n  //console.log(\"got aspectRatio\", aspectRatio);\n  var cameras = [];\n  for (var y = 0; y < nCamsY; y++ ) {\n    for ( var x = 0; x < nCamsX; x++ ) {\n      var i = nCamsY*y + x;\n      var subcamera = new Camera(config.fov, aspectRatio, config.near, config.far );\n      subcamera.bounds = new THREE.Vector4( x / nCamsX, y / nCamsY, sizeX, sizeY );\n      subcamera.position.copy(config.position[i]);\n      subcamera.isEquirectangular = config.isEquirectangular;\n\n      // TODO: figure out orientation\n      if (config.orientation) {\n        var target = subcamera.position.clone();\n        target.add(config.orientation[i]);\n        subcamera.lookAt(target);\n      }\n      subcamera.updateMatrix();\n      subcamera.updateProjectionMatrix();\n      subcamera.updateMatrixWorld();\n      cameras.push( subcamera );\n    }\n  }\n  var arrayCamera = new THREE.ArrayCamera( cameras );\n  for (var i = 0; i < cameras.length; i++) {\n    arrayCamera.add(cameras[i]);\n  }\n  arrayCamera.userData.shape = cameraArrayShape;\n  arrayCamera.userData.imageShape = [cameraArrayShape[1]*config.width, cameraArrayShape[0]*config.height];\n  //console.log('got arrayCamera', arrayCamera, cameras);\n  return arrayCamera;\n};\n\nmodule.exports = Camera;\n\n\n//# sourceURL=webpack://STK/./js/lib/gfx/Camera.js?");

/***/ }),

/***/ "./js/lib/gfx/CubemapToEquirectangular.js":
/*!************************************************!*\
  !*** ./js/lib/gfx/CubemapToEquirectangular.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Takes cubemap and creates equirectangular panorama\n// Adapted from https://github.com/spite/THREE.CubemapToEquirectangular\n// MIT License\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\n\nvar vertexShader = [\n  \"attribute vec3 position;\",\n  \"attribute vec2 uv;\",\n\n  \"uniform mat4 projectionMatrix;\",\n  \"uniform mat4 modelViewMatrix;\",\n\n  \"varying vec2 vUv;\",\n\n  \"void main()  {\",\n\n  \"  vUv = vec2( 1.- uv.x, 1. - uv.y );\",\n  \"  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n  \"}\"\n].join(\"\\n\");\n\nvar fragmentShader = [\n  \"precision mediump float;\",\n\n  \"uniform samplerCube map;\",\n\n  \"varying vec2 vUv;\",\n\n  \"#define M_PI 3.1415926535897932384626433832795\",\n\n  \"void main()  {\",\n\n  \"  vec2 uv = vUv;\",\n\n  \"  float longitude = uv.x * 2. * M_PI - M_PI + M_PI / 2.;\",\n  \"  float latitude = uv.y * M_PI;\",\n\n  \"  vec3 dir = vec3(\",\n  \"    - sin( longitude ) * sin( latitude ),\",\n  \"    cos( latitude ),\",\n  \"    - cos( longitude ) * sin( latitude )\",\n  \"  );\",\n  \"  normalize( dir );\",\n\n  \"  gl_FragColor = textureCube( map, dir );\",\n\n  \"}\"\n].join(\"\\n\");\n\nfunction CubemapToEquirectangular( renderer, width, height ) {\n  width = width || 4096;\n  height = height || 2048;\n\n  this.width = 1;\n  this.height = 1;\n\n  this.renderer = renderer;\n\n  this.material = new THREE.RawShaderMaterial( {\n    uniforms: {\n      map: { type: 't', value: null }\n    },\n    vertexShader: vertexShader,\n    fragmentShader: fragmentShader,\n    side: THREE.DoubleSide,\n    transparent: true\n  } );\n\n  this.scene = new THREE.Scene();\n  this.quad = new THREE.Mesh(\n    new THREE.PlaneBufferGeometry( 1, 1 ),\n    this.material\n  );\n  this.scene.add( this.quad );\n  this.camera = new THREE.OrthographicCamera( 1 / - 2, 1 / 2, 1 / 2, 1 / - 2, -10000, 10000 );\n\n  this.cubeCamera = null;\n\n  this.setSize( width, height );\n\n  var gl = this.renderer.getContext();\n  this.maxCubeMapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\n\n  this.setupCubeCamera( 2048 )\n}\n\nCubemapToEquirectangular.prototype.setSize = function( width, height ) {\n\n  this.width = width;\n  this.height = height;\n\n  this.quad.scale.set( this.width, this.height, 1 );\n\n  this.camera.left = this.width / - 2;\n  this.camera.right = this.width / 2;\n  this.camera.top = this.height / 2;\n  this.camera.bottom = this.height / - 2;\n\n  this.camera.updateProjectionMatrix();\n\n  if (this.output == null) {\n    this.output = new THREE.WebGLRenderTarget( this.width, this.height, {\n      minFilter: THREE.LinearFilter,\n      magFilter: THREE.LinearFilter,\n      wrapS: THREE.ClampToEdgeWrapping,\n      wrapT: THREE.ClampToEdgeWrapping,\n      format: THREE.RGBAFormat,\n      type: THREE.UnsignedByteType\n    });\n  } else {\n    this.output.setSize(this.width, this.height);\n  }\n};\n\nCubemapToEquirectangular.prototype.setupCubeCamera = function( size ) {\n\n  var cubeMapSize = Math.min( this.maxCubeMapSize, size );\n  this.cubeCamera = new THREE.CubeCamera( .1*Constants.metersToVirtualUnit, 1000*Constants.metersToVirtualUnit, cubeMapSize );\n\n  var options = { format: THREE.RGBAFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\n  this.cubeCamera.renderTarget = new THREE.WebGLRenderTargetCube( cubeMapSize, cubeMapSize, options );\n\n  return this.cubeCamera;\n\n};\n\nCubemapToEquirectangular.prototype.getPixels = function(pixels) {\n  pixels = pixels || new Uint8Array( 4 * this.width * this.height );\n  this.renderer.readRenderTargetPixels( this.output, 0, 0, this.width, this.height, pixels );\n  return pixels;\n};\n\nCubemapToEquirectangular.prototype.getCubemapPixels = function(pixels, cubeFace) {\n  var cubeMapSize = this.cubeCamera.renderTarget.width;\n  pixels = pixels || new Uint8Array( 4 * cubeMapSize * cubeMapSize );\n  this.cubeCamera.renderTarget.activeCubeFace = cubeFace;\n  this.renderer.readRenderTargetPixels( this.cubeCamera.renderTarget, 0, 0, cubeMapSize, cubeMapSize, pixels );\n  return pixels;\n};\n\nCubemapToEquirectangular.prototype.render = function( scene, camera, renderTarget ) {\n  var oldAutoClear = this.renderer.autoClear;\n  this.renderer.autoClear = true;\n  this.cubeCamera.setFromCamera(camera);\n  this.cubeCamera.update( this.renderer, scene );\n  this.renderer.autoClear = oldAutoClear;\n\n  this.quad.material.uniforms.map.value = this.cubeCamera.renderTarget.texture;\n  this.renderer.setRenderTarget(renderTarget? renderTarget : null);\n  this.renderer.clear();\n  this.renderer.render( this.scene, this.camera );\n};\n\nCubemapToEquirectangular.prototype.update = function( scene, camera ) {\n  this.render(scene, camera, this.output);\n};\n\nmodule.exports = CubemapToEquirectangular;\n\n//# sourceURL=webpack://STK/./js/lib/gfx/CubemapToEquirectangular.js?");

/***/ }),

/***/ "./js/lib/gfx/EDLPass.js":
/*!*******************************!*\
  !*** ./js/lib/gfx/EDLPass.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n__webpack_require__(/*! three-shaders */ \"./js/vendor/three/shaders.js\");\n\nTHREE.EDLShader = {\n  uniforms: {\n    \"tDiffuse\":     { value: null },\n    \"tDepth\":       { value: null },\n    \"size\":         { value: new THREE.Vector2( 512, 512 ) },\n    \"cameraNear\":   { value: 1.0 },\n    \"cameraFar\":    { value: 100.0 },\n    \"radius\":       { value: 1.0 },\n    \"strength\":     { value: 1.0 },\n    \"onlyAO\":       { value: 0 }\n  },\n\n  vertexShader: [\n    \"void main() {\",\n    \"  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n    \"}\"\n  ].join( \"\\n\" ),\n\n  fragmentShader: [\n    \"precision highp float;\",\n    \"uniform float cameraNear;\",\n    \"uniform float cameraFar;\",\n    \"#ifdef USE_LOGDEPTHBUF\",\n    \"uniform float logDepthBufFC;\",\n    \"#endif\",\n    \"uniform vec2 size;\",        // texture width, height\n    \"uniform float radius;\",\n    \"uniform float strength;\",\n    \"uniform bool onlyAO;\",      // use only ambient occlusion pass?\n    \"uniform sampler2D tDiffuse;\",\n    \"uniform sampler2D tDepth;\",\n\n    // RGBA depth\n    \"#include <packing>\",\n    \"float readDepth( const in vec2 coord ) {\",\n    \"  float cameraFarPlusNear = cameraFar + cameraNear;\",\n    \"  float cameraFarMinusNear = cameraFar - cameraNear;\",\n    \"  float cameraCoef = 2.0 * cameraNear;\",\n    \"#ifdef USE_LOGDEPTHBUF\",\n    \"  float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\n    \"  float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\",\n    \"  float z = (logz / w) + 1.0;\",\n    \"#else\",\n    \"  float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\n    \"#endif\",\n    \"  return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );\",\n    \"}\",\n\n    \"void main() {\",\n    \"  vec2 vUv = gl_FragCoord.xy / size;\",\n    \"  vec4 color = texture2D( tDiffuse, vUv );\",\n    \"  float x_step = radius / size.x;\",\n    \"  float y_step = radius / size.y;\",\n    \"  float d_c = log2(readDepth(vUv));\",\n    \"  float d_n = log2(readDepth(vUv+vec2(     0.0,  y_step)));\",\n    \"  float d_s = log2(readDepth(vUv+vec2(     0.0, -y_step)));\",\n    \"  float d_w = log2(readDepth(vUv+vec2( -x_step,     0.0)));\",\n    \"  float d_e = log2(readDepth(vUv+vec2(  x_step,     0.0)));\",\n    \"\",\n    \"  float response = 0.0;\",\n    \"  response += max(0.0, d_c - d_n);\",\n    \"  response += max(0.0, d_c - d_s);\",\n    \"  response += max(0.0, d_c - d_e);\",\n    \"  response += max(0.0, d_c - d_w);\",\n    \"  response /= 4.0;\",\n    \"\",\n    \"  float edl_shade = exp(-response * 300.0 * strength);\",\n    \"  float edl_alpha = float(response > 0.0);\",\n    \"\",\n    \"  if ( onlyAO ) {\",\n    \"    gl_FragColor = vec4( vec3(edl_shade), clamp(edl_alpha, 0.0, 1.0) );\",\n    \"  } else {\",\n    \"    gl_FragColor = vec4( color.rgb * edl_shade, clamp(color.a + edl_alpha, 0.0, 1.0) );\",\n    \"  }\",\n    \"}\"\n  ].join( \"\\n\" )\n};\n\n\n/**\n * Eye-dome lighting shader pass\n *\n * Has the following parameters\n *  - radius\n *  - strength\n * To output to screen set renderToScreens true\n * @class THREE.EDLPass\n */\nTHREE.EDLPass = function ( scene, camera, width, height ) {\n  THREE.ShaderPass.call( this, THREE.EDLShader );\n\n  this.width = ( width !== undefined ) ? width : 512;\n  this.height = ( height !== undefined ) ? height : 256;\n\n  this.renderToScreen = false;\n\n  this.camera2 = camera;\n  this.scene2 = scene;\n\n  //Depth material\n  this.depthMaterial = new THREE.MeshDepthMaterial();\n  this.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n  this.depthMaterial.blending = THREE.NoBlending;\n\n  //Depth render target\n  this.depthRenderTarget = new THREE.WebGLRenderTarget( this.width, this.height,\n    { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter } );\n\n  //Shader uniforms\n  this.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;\n  this.uniforms[ 'size' ].value.set( this.width, this.height );\n  this.uniforms[ 'cameraNear' ].value = this.camera2.near;\n  this.uniforms[ 'cameraFar' ].value = this.camera2.far;\n\n  this.uniforms[ 'radius' ].value = 1;\n  this.uniforms[ 'strength' ].value = 1;\n\n  //Setters and getters for uniforms\n  var self = this;\n  Object.defineProperties(this, {\n    radius: {\n      get: function() { return self.uniforms[ 'radius' ].value; },\n      set: function( value ) { self.uniforms[ 'radius' ].value = value; }\n    },\n    strength: {\n      get: function() { return self.uniforms[ 'strength' ].value; },\n      set: function( value ) { self.uniforms[ 'strength' ].value = value; }\n    },\n    onlyAO: {\n      get: function() { return self.uniforms[ 'onlyAO' ].value; },\n      set: function( value ) { self.uniforms[ 'onlyAO' ].value = value; }\n    }\n  });\n};\n\nTHREE.EDLPass.prototype = Object.create( THREE.ShaderPass.prototype );\n\n/**\n * Render using this pass.\n *\n * @method THREE.EDLPass.render\n * @param {WebGLRenderer} renderer\n * @param {WebGLRenderTarget} writeBuffer Buffer to write output.\n * @param {WebGLRenderTarget} readBuffer Input buffer.\n * @param {Number} delta Delta time in milliseconds.\n * @param {Boolean} maskActive Not used in this pass.\n */\nTHREE.EDLPass.prototype.render = function( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n  // AXC: Save oldOverrideMaterial so it can be restored\n  var oldOverrideMaterial = this.scene2.overrideMaterial;\n  this.scene2.overrideMaterial = this.depthMaterial;\n  renderer.setRenderTarget( this.depthRenderTarget );\n  renderer.clear();\n  renderer.render( this.scene2, this.camera2 );\n  this.scene2.overrideMaterial = oldOverrideMaterial;\n  THREE.ShaderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta, maskActive );\n};\n\n/**\n * Change scene to be renderer by this render pass.\n *\n * @method THREE.EDLPass.setScene\n * @param {Scene} scene\n */\nTHREE.EDLPass.prototype.setScene = function(scene) {\n  this.scene2 = scene;\n};\n\n/**\n * Set camera used by this render pass.\n *\n * @method THREE.EDLPass.setCamera\n * @param {Camera} camera\n */\nTHREE.EDLPass.prototype.setCamera = function( camera ) {\n  this.camera2 = camera;\n  this.uniforms[ 'cameraNear' ].value = this.camera2.near;\n  this.uniforms[ 'cameraFar' ].value = this.camera2.far;\n};\n\n/**\n * Set resolution of this render pass.\n *\n * @method THREE.EDLPass.setSize\n * @param {Number} width\n * @param {Number} height\n */\nTHREE.EDLPass.prototype.setSize = function( width, height ) {\n  this.width = width;\n  this.height = height;\n  this.uniforms[ 'size' ].value.set( this.width, this.height );\n  this.depthRenderTarget.setSize( this.width, this.height );\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/gfx/EDLPass.js?");

/***/ }),

/***/ "./js/lib/gfx/Lights.js":
/*!******************************!*\
  !*** ./js/lib/gfx/Lights.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var Lights = {};\n\nLights.getDefaultHemisphereLight = function(usePhysicalLights, lightsOn) {\n  // There is actually three modes:\n  //   usePhysicallyCorrectLights off\n  //   usePhysicallyCorrectLights without lights enabled\n  //   usePhysicallyCorrectLights with    lights enabled\n  var ambientIntensity = usePhysicalLights ? (lightsOn? 0.5 : 2.0) : 1.0;\n  if (THREE.REVISION < 80) {\n    ambientIntensity = 1.0;\n  }\n  return new THREE.HemisphereLight(0xffffff, 0x202020, ambientIntensity);\n};\n\n\nLights.addSimple2LightSetup = function (scene, position, doShadowMap) {\n  position = position || new THREE.Vector3(-100, 100, 100);\n  var ambient = new THREE.AmbientLight(0x050505);\n\n  var light0 = new THREE.PointLight(0xdadacd, 0.85);\n  var p0 = new THREE.Vector3();\n  p0.copy(position);\n  light0.position.copy(p0);\n  var light1 = new THREE.PointLight(0x030309, 0.03);\n  var p1 = new THREE.Vector3();\n  p1.copy(position);\n  p1.negate();\n  light1.position.copy(p1);\n\n  if (doShadowMap) {\n    var light = Lights.createSpotLightShadowMapped(1000);\n    light.position.copy(light0.position);\n    // light.onlyShadow = true;  // Removed https://github.com/mrdoob/three.js/issues/7825\n    scene.add(light);\n    //var helper = new THREE.CameraHelper( light.shadow.camera );\n    //scene.add( helper );\n  }\n\n  scene.add(ambient);\n  scene.add(light0);\n  scene.add(light1);\n  return { ambient: ambient, directional: [light0, light1] };\n};\n\nLights.createSpotLightShadowMapped = function (lightBoxSize) {\n  var light = new THREE.SpotLight(0xffffff, 1, 0, Math.PI, 1);\n  light.target.position.set(0, 0, 0);\n\n  light.castShadow = true;\n\n  light.shadow.camera.near = 1;\n  light.shadow.camera.far = lightBoxSize;\n  light.shadow.camera.right = lightBoxSize;\n  light.shadow.camera.left = -lightBoxSize;\n  light.shadow.camera.top = lightBoxSize;\n  light.shadow.camera.bottom = -lightBoxSize;\n  light.shadow.camera.fov = 50;\n\n  light.shadow.bias = 0.0001;\n  //light.shadowDarkness = 0.5; // Removed https://github.com/mrdoob/three.js/issues/8238\n\n  light.shadow.mapSize.width = 2048;\n  light.shadow.mapSize.height = 2048;\n\n  //light.shadowCameraVisible = true; // Removed\n\n  return light;\n};\n\n\nmodule.exports = Lights;\n\n\n//# sourceURL=webpack://STK/./js/lib/gfx/Lights.js?");

/***/ }),

/***/ "./js/lib/gfx/MaterialHelper.js":
/*!**************************************!*\
  !*** ./js/lib/gfx/MaterialHelper.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar MaterialHelper = {};\n\nMaterialHelper.getImageData = function (image) {\n  if (!image) {\n    return null;\n  }\n  if (image.data) {\n    return { data: image.data, width: image.width, height: image.height };\n  }\n  var canvas = document.createElement('canvas');\n  canvas.width = image.width;\n  canvas.height = image.height;\n  var context = canvas.getContext('2d');\n  context.drawImage(image, 0, 0);\n  return context.getImageData(0, 0, image.width, image.height);\n};\n\nMaterialHelper.getPixel = function (imagedata, x, y) {\n  var i = (x + imagedata.width * y) * 4;\n  var data = imagedata.data;\n  return { r: data[i], g: data[i + 1], b: data[i + 2], a: data[i + 3] };\n};\n\nMaterialHelper.getPixelAtUV = function (imagedata, u, v) {\n  var x = THREE.Math.clamp(Math.round(u * imagedata.width), 0, imagedata.width-1);\n  var y = THREE.Math.clamp(Math.round(v * imagedata.height), 0, imagedata.height-1);\n  return MaterialHelper.getPixel(imagedata, x, y);\n};\n\nmodule.exports = MaterialHelper;\n\n//# sourceURL=webpack://STK/./js/lib/gfx/MaterialHelper.js?");

/***/ }),

/***/ "./js/lib/gfx/Renderer.js":
/*!********************************!*\
  !*** ./js/lib/gfx/Renderer.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Constants */ \"./js/lib/Constants.js\"),__webpack_require__(/*! util/ImageUtil */ \"./js/lib/util/ImageUtil.js\"),__webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\"),__webpack_require__(/*! gfx/CubemapToEquirectangular */ \"./js/lib/gfx/CubemapToEquirectangular.js\"), __webpack_require__(/*! three-shaders */ \"./js/vendor/three/shaders.js\"), __webpack_require__(/*! gfx/EDLPass */ \"./js/lib/gfx/EDLPass.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Constants, ImageUtil, Object3DUtil, CubemapToEquirectangular) {\n\n  /**\n   * Main rendering class (wrapper around THREE.Renderer)\n   * @param opt\n   * @constructor\n   * @memberOf gfx\n   */\n  function Renderer(opt) {\n    this.container = opt.container;\n    this.isOffscreen = opt.isOffscreen;\n    this.renderer = opt.renderer;\n    this.width = opt.width || opt.container.clientWidth;\n    this.height = opt.height || opt.container.clientHeight;\n    this.useAmbientOcclusion = (opt.useAmbientOcclusion !== undefined) ? opt.useAmbientOcclusion : false;\n    this.useOutlineShader = (opt.useOutlineShader !== undefined) ? opt.useOutlineShader : false;\n    this.useEDLShader = (opt.useEDLShader !== undefined) ? opt.useEDLShader : false;\n    this.outlineColor = (opt.outlineColor !== undefined) ? opt.outlineColor : 0xffffff;\n    this.ambientOcclusionOptions = _.merge({\n      type: opt.ambientOcclusionType || 'ssao'\n    }, opt.ambientOcclusionOptions);\n    this.useShadows = (opt.useShadows !== undefined) ? opt.useShadows : false;\n    this.useLights = (opt.useLights !== undefined) ? opt.useLights : false; // Default to false\n    this.__reuseBuffers = opt.reuseBuffers;  // Reuse buffers?\n    this.renderPass = null;\n    this.ssaoPass = null;\n    this.domElement = null;\n    this.composer = null;\n\n    this.__needFlipY = false;  // Do we need to flip about Y for rendering?\n    this.__maxViewportDims = null;  // Maximum viewport dimensions before we need to have tiles?\n    this.__tiles = null;\n\n    this.init(opt);\n  }\n\n  Renderer.prototype.init = function (opt) {\n    this.renderer = this.renderer || new THREE.WebGLRenderer({\n      width: this.width,\n      height: this.height,\n      context: opt.context || null,\n      antialias: true,\n      alpha: true,\n      logarithmicDepthBuffer: opt.logarithmicDepthBuffer\n    });\n    if (this.useLights) {\n      this.renderer.physicallyCorrectLights = true;\n      //this.renderer.toneMapping = THREE.ReinhardToneMapping;\n      this.renderer.toneMapping = THREE.Uncharted2ToneMapping;\n      this.renderer.gammaInput = true;\n      this.renderer.gammaOutput = true;\n    }\n\n    if (this.isOffscreen) {\n      this.__rtTexture = new THREE.WebGLRenderTarget(this.width, this.height, {\n        minFilter: THREE.LinearFilter,\n        magFilter: THREE.NearestFilter,\n        format: THREE.RGBAFormat\n      });\n    }\n\n    //this.renderer.setPixelRatio(window.devicePixelRatio || 1);\n    this.renderer.setSize(this.width, this.height);\n\n    if (this.useShadows) {\n      this.renderer.shadowMap.enabled = true;\n      this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n    }\n\n    if (this.useAmbientOcclusion || this.useOutlineShader || this.useEDLShader) {\n      //var pixelRatio = this.renderer.getPixelRatio();\n      //var width  = Math.floor(this.width  / pixelRatio) || 1;\n      //var height = Math.floor(this.height / pixelRatio) || 1;\n      var rt = new THREE.WebGLRenderTarget(this.width, this.height,\n        { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat, stencilBuffer: true });\n      this.composer = new THREE.EffectComposer(this.renderer, rt);\n      this.composer.renderTarget1.stencilBuffer = true;\n      this.composer.renderTarget2.stencilBuffer = true;\n      this.renderPass = new THREE.RenderPass();\n      this.composer.addPass(this.renderPass);\n\n      var scene = {};\n      var camera = new THREE.PerspectiveCamera( 65, this.width / this.height, 1, 4000 );\n\n      if (this.useAmbientOcclusion) {\n        var ssao = null;\n        if (this.ambientOcclusionOptions.type === 'ssao') {\n          ssao = new THREE.SSAOPass(scene, camera /*, this.width, this.height*/);\n          ssao.radius = this.ambientOcclusionOptions.radius || (0.1*Constants.virtualUnitToMeters);\n          ssao.lumInfluence = (this.ambientOcclusionOptions.lumInfluence != undefined)? this.ambientOcclusionOptions.lumInfluence : 0.5;\n          console.log('set ssao.radius to', ssao.radius, 'ssao.lumInfluence to', ssao.lumInfluence);\n        } else if (this.ambientOcclusionOptions.type === 'sao') {\n          ssao = new THREE.SAOPass(scene, camera, false, true);\n          ssao.params.saoScale = this.ambientOcclusionOptions.scale || 20000;  // TODO(MS): set this parameter more intelligently\n          // ssao.params.saoScaleFixed = 0.03;\n          // ssao.params.saoScale = ssao.params.saoScaleFixed*camera.far;  // TODO(MS): set this parameter more intelligently\n          console.log('set sao.params.soaScale to', ssao.params.saoScale, 'with camera far', camera.far );\n        } else {\n          console.warn('Unsupported ambientOcclusion configuration', this.ambientOcclusionOptions);\n        }\n        if (ssao) {\n          if (!this.useOutlineShader) {\n            ssao.renderToScreen = true;\n          }\n          this.composer.addPass(ssao);\n        }\n        this.ssaoPass = ssao;\n      }\n\n      if (this.useOutlineShader) {\n        var outline = new THREE.OutlinePass(new THREE.Vector2(this.width, this.height), scene, camera);\n        outline.edgeStrength = 100.0;\n        outline.edgeThickness = 1.0;\n        outline.visibleEdgeColor.set(this.outlineColor);\n        outline.hiddenEdgeColor.set(this.outlineColor);\n        // outline.clear = false;\n        // if (!this.useAmbientOcclusion) { outline.renderToScreen = true; }\n        if (!this.useEDLShader) { outline.renderToScreen = true; }\n        this.outlinePass = outline;\n        // this.outlineMaskPass = new THREE.MaskPass(scene, camera);\n        // this.outlineMaskPass.inverse = true;\n        // var colorCorrection = new THREE.ShaderPass(THREE.ColorCorrectionShader);\n        // colorCorrection.uniforms.mulRGB.value = new THREE.Vector3(0, 0, 0);\n        // var clearMaskPass = new THREE.ClearMaskPass();\n        // var copyPass = new THREE.ShaderPass(THREE.CopyShader);\n        // copyPass.renderToScreen = true;\n\n        // this.composer.addPass(this.outlineMaskPass);\n        this.composer.addPass(outline);\n        // this.composer.addPass(colorCorrection);\n        // this.composer.addPass(clearMaskPass);\n        // this.composer.addPass(copyPass);\n\n        // var effectGrayScale = new THREE.ShaderPass( THREE.LuminosityShader );\n        // this.composer.addPass(effectGrayScale);\n        // effectSobel = new THREE.ShaderPass( THREE.SobelOperatorShader );\n        // effectSobel.renderToScreen = true;\n        // effectSobel.uniforms.resolution.value.x = this.width;\n        // effectSobel.uniforms.resolution.value.y = this.height;\n        // this.composer.addPass(effectSobel);\n      }\n\n      if (this.useEDLShader) {\n        var edlPass = new THREE.EDLPass(scene, camera, this.width, this.height);\n        edlPass.renderToScreen = true;\n        this.edlPass = edlPass;\n        this.composer.addPass(edlPass);\n      }\n\n    }\n\n    if (this.renderer.domElement) {\n      this.domElement = this.renderer.domElement;\n      this.domElement.setAttribute('tabindex','1');\n      if (this.container) { this.container.appendChild(this.domElement); }\n      // Grabs focus when mouse is over this element\n      this.domElement.addEventListener('mouseover', function () { this.domElement.focus(); }.bind(this),false);\n      this.domElement.addEventListener('mouseout', function () { this.domElement.blur(); }.bind(this),false);\n    }\n  };\n\n  Renderer.setMaxViewportDims = function(w,h) {\n    this.__maxViewportDims = [w,h];\n    this.setSize(this.width, this.height);\n  };\n\n  Renderer.prototype.createPixelBuffer = function() {\n    return new Uint8Array(4 * this.width * this.height);\n  };\n\n  Renderer.prototype.__getPixelBuffer = function() {\n    var createNewBuffer = !this.__reuseBuffers || !this.__pixelBuffer || (this.width * this.height * 4 !== this.__pixelBuffer.length);\n    if (createNewBuffer) {\n      this.__pixelBuffer = this.createPixelBuffer();\n    }\n    return this.__pixelBuffer;\n  };\n\n  // handle y flip due to WebGL render target\n  Renderer.prototype.__flipY = function (p) {\n    var t;\n    var numElementsPerRow = 4 * this.width;\n    for (var row = 0; row < this.height / 2; row++) {\n      var yOut = this.height - row - 1;\n      var base = numElementsPerRow * row;\n      var baseOut = numElementsPerRow * yOut;\n      for (var col = 0; col < this.width; col++) {\n        var step = col << 2;  // 4*x\n        var idx = base + step;\n        var idxOut = baseOut + step;\n        t = p[idxOut    ]; p[idxOut    ] = p[idx    ]; p[idx    ] = t;  // R\n        t = p[idxOut + 1]; p[idxOut + 1] = p[idx + 1]; p[idx + 1] = t;  // G\n        t = p[idxOut + 2]; p[idxOut + 2] = p[idx + 2]; p[idx + 2] = t;  // B\n        t = p[idxOut + 3]; p[idxOut + 3] = p[idx + 3]; p[idx + 3] = t;  // A\n      }\n    }\n  };\n\n  function copyPixels(source, target, flipY, bytesPerPixel) {\n    bytesPerPixel = bytesPerPixel || 4;\n    // TODO: make more efficent\n    //console.log('copyPixels', _.omit(source, ['buffer']), _.omit(target, ['buffer']), flipY);\n    var sourceNumElementPerRow = bytesPerPixel * source.fullWidth;\n    var targetNumElementPerRow = bytesPerPixel * target.fullWidth;\n    var sourceColOffset = bytesPerPixel * source.x;\n    var targetColOffset = bytesPerPixel * target.x;\n    var bytesToCopyPerRow = bytesPerPixel * source.width;\n    //console.log('bytesToCopyPerRow is ', bytesToCopyPerRow);\n    for (var row = 0; row < source.height; row++) {\n      var sourceRow = flipY? (source.fullHeight - source.height + source.y + row) : (source.y + row);\n      var base = sourceNumElementPerRow * sourceRow + sourceColOffset;\n      var targetRow = target.y + row;\n      if (flipY) {\n        targetRow = target.y + (source.height - row - 1);\n        //targetRow = target.fullHeight - targetRow;\n      }\n      var baseOut = targetNumElementPerRow * targetRow + targetColOffset;\n      //console.log('source start/end is ', base, base + bytesToCopyPerRow, source.buffer.length);\n      //console.log('target start/end is ', baseOut, baseOut + bytesToCopyPerRow, target.buffer.length);\n      var s = source.buffer.subarray(base, base + bytesToCopyPerRow);\n      target.buffer.set(s, baseOut);\n      //for (var j = 0; j < bytesToCopyPerRow; j++) {\n      //  target.buffer[baseOut+j] = source.buffer[base+j];\n      //}\n    }\n  }\n\n  function updateSAO(sao, scene, camera) {\n    sao.scene = scene;\n    sao.camera = camera;\n    //sao.params.saoScale = sao.params.saoScaleFixed*camera.far;  // TODO(MS): set this parameter more intelligently\n    //console.log('set sao.params.soaScale to ', sao.params.saoScale, camera.far );\n    sao.saoMaterial.uniforms[ 'cameraNear' ].value = camera.near;\n    sao.saoMaterial.uniforms[ 'cameraFar' ].value = camera.far;\n    sao.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse(camera.projectionMatrix);\n    sao.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = camera.projectionMatrix;\n    sao.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = (camera.isPerspectiveCamera || camera.inPerspectiveMode) ? 1 : 0;\n  }\n\n  function updateAmbientOcclusion(ssaoPass, scene, camera) {\n    if (ssaoPass instanceof THREE.SSAOPass) {\n      ssaoPass.setScene(scene);\n      ssaoPass.setCamera(camera);\n    } else if (ssaoPass instanceof THREE.SAOPass) {\n      updateSAO(ssaoPass, scene, camera);\n    }\n  }\n\n  Renderer.prototype.__getCubemapToEquirectangularConverter = function() {\n    if (!this.__cubemapToEquirectangular) {\n      this.__cubemapToEquirectangular = new CubemapToEquirectangular(this.renderer, this.width, this.height);\n    } else {\n      if (this.width !== this.__cubemapToEquirectangular.width || this.height !== this.__cubemapToEquirectangular.height) {\n        this.__cubemapToEquirectangular.setSize(this.width, this.height);\n      }\n    }\n    return this.__cubemapToEquirectangular;\n  };\n\n  Renderer.prototype.__renderToTarget = function(scene, camera, renderTarget, forceClear) {\n    if (renderTarget) {\n      this.renderer.setRenderTarget(renderTarget);\n    } else {\n      this.renderer.setRenderTarget( null );\n    }\n    if (forceClear) {\n      this.renderer.clear();\n    }\n    this.renderer.render(scene, camera);\n  };\n\n  Renderer.prototype.__render = function(scene, camera, fullWidth, fullHeight, renderTarget, forceClear) {\n    if (camera.isArrayCamera) {\n      // TODO: CHECK setViewport takes lower left corner of rectangular region\n      var oldAutoClear = this.renderer.autoClear;\n      for (var i = 0; i < camera.cameras.length; i++) {\n        var cam = camera.cameras[i];\n        var bounds = cam.bounds;\n\n        var x = bounds.x * fullWidth;\n        var y = bounds.y * fullHeight;\n        var width = bounds.z * fullWidth;\n        var height = bounds.w * fullHeight;\n\n        this.renderer.autoClear = (i === 0) ? oldAutoClear : false;\n        this.renderer.setViewport(x, y, width, height);\n        this.__renderToTarget(scene, cam, renderTarget, forceClear);\n      }\n      this.renderer.autoClear = oldAutoClear;\n      this.renderer.setViewport(0, 0, fullWidth, fullHeight);\n    } else if (camera.isEquirectangular) {\n      var converter = this.__getCubemapToEquirectangularConverter();\n      // TODO: Figure out why we need to do this twice (otherwise, goal frame in simulator same as initial frame)\n      converter.render(scene, camera, renderTarget);\n      converter.render(scene, camera, renderTarget);\n    } else {\n      this.__renderToTarget(scene, camera, renderTarget, forceClear);\n    }\n  };\n\n\n  Renderer.prototype.__renderScene = function (scene, camera, opts) {\n    opts = opts || {};\n    var height = opts.height;\n    var width = opts.width;\n    var offsetX = opts.offsetX || 0;\n    var offsetY = opts.offsetY || 0;\n    if ((this.useAmbientOcclusion && this.ssaoPass.enabled) ||\n        (this.useOutlineShader && this.outlinePass.enabled) ||\n        (this.useEDLShader && this.edlPass.enabled)) {\n      // Render to composer\n      // Bad RenderPass API design requires setting scene and camera\n      this.renderPass.scene = scene; this.renderPass.camera = camera;\n      if (this.useAmbientOcclusion) {\n        updateAmbientOcclusion(this.ssaoPass, scene, camera);\n      }\n      if (this.useOutlineShader) {\n        this.outlinePass.renderScene = scene;\n        this.outlinePass.renderCamera = camera;\n        // this.outlineMaskPass.scene = scene;\n        // this.outlineMaskPass.camera = camera;\n        var meshes = Object3DUtil.getVisibleMeshList(scene, true);\n        meshes = meshes.filter(function (m) { return !m.name.startsWith('Wall') && !m.name.startsWith('Floor'); });\n        this.outlinePass.selectedObjects = meshes;\n        // console.log(this.outlinePass.selectedObjects);\n      }\n      if (this.useEDLShader) {\n        this.edlPass.setScene(scene);\n        this.edlPass.setCamera(camera);\n      }\n      this.composer.render();\n    } else {\n      if (this.domElement) {\n        // Render to canvas\n        this.__render(scene, camera, width, height);\n      } else {\n        // Render to offscreen texture\n        this.__render(scene, camera, width, height, this.__rtTexture, true);\n      }\n    }\n    if (this.isOffscreen) {\n      if (this.domElement) {\n        // We also want to return the pixels\n        // Let's try to read it from the domElement\n        var pixels = opts.pixelBuffer;\n        var context = this.renderer.getContext();\n        context.readPixels(offsetX, offsetY, width, height, context.RGBA, context.UNSIGNED_BYTE, pixels);\n        return pixels;\n      } else {\n        var renderTarget = this.useAmbientOcclusion ? this.composer.writeBuffer : this.__rtTexture;\n        var pixels = opts.pixelBuffer;\n        this.renderer.readRenderTargetPixels(renderTarget, offsetX, offsetY, width, height, pixels);\n        return pixels;\n      }\n    }\n  };\n\n  Renderer.prototype.__renderTiles = function (scene, camera, opts) {\n    // TODO: Handle array cameras and tiles!\n    var fullWidth = this.width;\n    var fullHeight = this.height;\n    if (this.__tiles) {\n      //console.log('render with tiles');\n      var tileBuffer = this.__getTileBuffer();\n      //var oldAutoClear = this.renderer.autoClear;\n      //this.renderer.autoClear = false;\n      var pixels = opts.pixelBuffer || this.__getPixelBuffer();\n      for (var i = 0; i < this.__tiles.length; i++) {\n        var tile = this.__tiles[i];\n        //console.log('render with tile', tile.x, tile.y, tile.width, tile.height);\n        camera.setViewOffset(fullWidth, fullHeight, tile.x, tile.y, this.__tileWidth, this.__tileHeight);\n        var tilePixels = this.__renderScene(scene, camera, _.defaults({pixelBuffer: tileBuffer, width: this.__tileWidth, height: this.__tileHeight}, opts));\n        if (this.isOffscreen) {\n          // copy from tilePixels into our pixels\n          copyPixels(\n            { buffer: tilePixels, x: 0, y: 0, width: tile.width, height: tile.height, fullWidth: this.__tileWidth, fullHeight: this.__tileHeight },\n            { buffer: pixels, x: tile.x, y: tile.y, width: tile.width, height: tile.height, fullWidth: fullWidth, fullHeight: fullHeight },\n            this.__needFlipY\n          );\n        }\n      }\n      camera.clearViewOffset(); // TODO: restore old view offset\n      //this.renderer.autoClear = oldAutoClear;\n      return this.isOffscreen? pixels : null;\n    } else {\n      //console.log('render no tiles');\n      var pixelBuffer = opts.pixelBuffer || this.__getPixelBuffer();\n      var pixels = this.__renderScene(scene, camera, _.defaults({pixelBuffer: pixelBuffer, width: fullWidth, height: fullHeight}, opts));\n      if (this.__needFlipY) {\n        this.__flipY(pixels);\n      }\n      return pixels;\n    }\n  };\n\n  Renderer.prototype.render = function (scene, camera, opts) {\n    opts = opts || {};\n    var pixels = this.__renderTiles(scene, camera, opts);\n    if (opts.postprocess) {\n      pixels = this.postprocessPixels(pixels, opts.postprocess, camera);\n    }\n    return pixels;\n  };\n\n  Renderer.prototype.setSize = function (width, height) {\n    this.__setSize(width, height);\n    var maxTileWidth = this.__maxViewportDims? this.__maxViewportDims[0] : Infinity;\n    var maxTileHeight = this.__maxViewportDims? this.__maxViewportDims[1] : Infinity;\n    if (this.width < maxTileWidth && this.height < maxTileHeight) {\n      this.__setTileSize(width, height);\n      this.__tiles = null;\n    } else {\n      var tilew = maxTileWidth;\n      var tileh = maxTileHeight;\n      this.__setTileSize(tilew, tileh);\n      this.__tiles = [];\n      var nw = Math.ceil(width / tilew);\n      var nh = Math.ceil(height / tileh);\n      for (var i = 0; i < nw; i++) {\n        var sx = i*tilew;\n        var w = Math.min(width-sx, tilew);\n        for (var j = 0; j < nh; j++) {\n          var sy = j*tileh;\n          var h = Math.min(height-sy, tileh);\n          this.__tiles.push({ x: sx, y: sy, width: w, height: h });\n        }\n      }\n    }\n  };\n\n  Renderer.prototype.__getTileBuffer = function() {\n    var createNewBuffer = !this.__tileBuffer || (this.__tileWidth * this.__tileHeight * 4 !== this.__tileBuffer.length);\n    if (createNewBuffer) {\n      this.__tileBuffer = new Uint8Array(4 * this.__tileWidth * this.__tileHeight);\n    }\n    return this.__tileBuffer;\n  };\n\n  Renderer.prototype.__setSize = function (width, height) {\n    this.width = width;\n    this.height = height;\n  };\n\n  Renderer.prototype.__setTileSize = function(width, height) {\n    this.__tileWidth = width;\n    this.__tileHeight = height;\n    if (this.renderer) {\n      this.renderer.setSize(width, height);\n    }\n    if (this.__rtTexture) {\n      this.__rtTexture.setSize(width, height);\n    }\n    // Update ambient occlusion sizes\n    if (this.composer) {\n      this.composer.setSize(width, height);\n    }\n  };\n\n  Renderer.prototype.getMaxAnisotropy = function() {\n    return this.renderer.capabilities.getMaxAnisotropy();\n  };\n\n  Renderer.prototype.postprocessPixels = function(pixels, options, camera) {\n    if (_.isString(options)) {\n      options = { operation: options };\n    }\n    if (options.operation === 'unpackRGBAdepth') {\n      pixels = ImageUtil.unpackRGBAdepth(pixels, camera, options.dataType, options.metersToUnit);\n    }\n    return pixels;\n  };\n\n  // Exports\n  return Renderer;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/lib/gfx/Renderer.js?");

/***/ }),

/***/ "./js/lib/gfx/RendererFactory.js":
/*!***************************************!*\
  !*** ./js/lib/gfx/RendererFactory.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Renderer = __webpack_require__(/*! gfx/Renderer */ \"./js/lib/gfx/Renderer.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Factor for creating more renderers\n * @param opts.rendererType Renderer class\n * @param opts.renderers {Object<string,gfx.Renderer>} Prespecified renderers\n * @param opts.configSets {Object<string,*>} Prespecified renderer configurations\n * @constructor\n * @memberOf gfx\n */\nfunction RendererFactory(opts) {\n  this.__rendererType = opts.rendererType;\n  this.__cachedRenderers = {}; // Map of name to renderer\n  this.__rendererConfigs = {}; // Map of config setting to renderer\n  if (opts.renderers) {\n    _.defaults(this.__cachedRenderers, opts.renderers); // Copy prespecified renderers\n  }\n  if (opts.configSets) {\n    _.defaults(this.__rendererConfigs, opts.configSets); // Copy prespecified configurations\n  }\n}\n\nRendererFactory.prototype.getRenderer = function(name, opts) {\n  if (!this.__cachedRenderers[name]) {\n    var rendererOpts = opts;\n    if (opts.configSet && this.__rendererConfigs[opts.configSet]) {\n      rendererOpts = _.defaults(Object.create(null), opts || {}, this.__rendererConfigs[opts.configSet]);\n      if (rendererOpts.cameraArrayShape && !opts.width && !opts.height) {\n        rendererOpts.width = rendererOpts.cameraArrayShape[1]*rendererOpts.width;\n        rendererOpts.height = rendererOpts.cameraArrayShape[0]*rendererOpts.height;\n      }\n    }\n    console.log('Creating new renderer ' + name, rendererOpts);\n    this.__cachedRenderers[name] = new this.__rendererType(rendererOpts);\n  }\n  return this.__cachedRenderers[name];\n};\n\nRendererFactory.createRenderer = function(opts) {\n  return new Renderer(opts);\n};\n\nRendererFactory.createOffscreenRenderer = function(opts) {\n  opts = _.defaults({ isOffscreen: true }, opts, {\n    useAmbientOcclusion: false,\n    useLights: false,\n    useShadows: false,\n    reuseBuffers: true\n  });\n  return RendererFactory.createRenderer(opts);\n};\n\nmodule.exports = RendererFactory;\n\n//# sourceURL=webpack://STK/./js/lib/gfx/RendererFactory.js?");

/***/ }),

/***/ "./js/lib/gfx/SceneSetupHelper.js":
/*!****************************************!*\
  !*** ./js/lib/gfx/SceneSetupHelper.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst Camera = __webpack_require__(/*! gfx/Camera */ \"./js/lib/gfx/Camera.js\");\nconst CameraControls = __webpack_require__(/*! controls/CameraControls */ \"./js/lib/controls/CameraControls.js\");\nconst Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nconst Lights = __webpack_require__(/*! gfx/Lights */ \"./js/lib/gfx/Lights.js\");\n\nclass SceneSetupHelper {\n  static createCameraControls(renderer, options) {\n    const cameraConfig = _.defaults(Object.create(null), options.camera || {}, {\n      type: 'perspective',\n      fov: 50,\n      near: 0.1 * Constants.metersToVirtualUnit,\n      far: 400 * Constants.metersToVirtualUnit\n    });\n    const camera = Camera.fromJson(cameraConfig, options.width, options.height);\n    const cameraControls = new CameraControls({\n      camera: camera,\n      container: renderer.canvas,\n      controlType: 'none',\n      cameraPositionStrategy: 'positionByCentroid' //'positionByCentroid'\n    });\n    return cameraControls;\n  }\n\n  static createScene(camera, options) {\n    const scene = new THREE.Scene();\n    scene.add(camera);\n    if (options.useDirectionalLights) {\n      Lights.addSimple2LightSetup(camera, new THREE.Vector3(0, 0, 0), true);\n    } else {\n      const light = Lights.getDefaultHemisphereLight(options.useLights, options.useLights);\n      scene.add(light);\n    }\n    if (options.backgroundColor != null) {\n      scene.background = Colors.toColor(options.backgroundColor);\n    }\n    return scene;\n  }\n}\n\nmodule.exports = SceneSetupHelper;\n\n//# sourceURL=webpack://STK/./js/lib/gfx/SceneSetupHelper.js?");

/***/ }),

/***/ "./js/lib/gfx/ViewGenerator.js":
/*!*************************************!*\
  !*** ./js/lib/gfx/ViewGenerator.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n\n/**\n * Generate appropriate camera parameters for different types of views\n * @constructor\n * @param params Configuration parameters\n * @param [params.cameraPositionStrategy=`positionToFit`] {string} General camera position strategy to use\n *    (values are `positionToFit`, `positionByDistance`, `positionByCentroid`, `positionToFixedResolution`, `positionByBBoxOffset`)\n *    Used for computing view points for bounding boxes.\n * @param params.camera {THREE.Camera} Reference camera from which fov and aspect ratio is currently taken (used for computing views for 'positionToFit')\n * @memberOf gfx\n */\nfunction ViewGenerator(params) {\n  params = params || {};\n  this.defaultDistanceScale = 1.0;\n  this.cameraPositionStrategy = params.cameraPositionStrategy || 'positionToFit';\n  this.camera = params.camera;\n}\n\nViewGenerator.prototype.getDefaultView = function (bbox) {\n  // default view position from +y, -z (looks at front from slightly top-down view)\n  return this.getBBoxViewFromOffsetPosition('default', bbox, [ 0, 1, -1 ], [ 0, 1, -0.25 ]);\n};\n\n/**\n * Generate a view targeting the centroid of a bbox and positioned from a particular offset (given by multiples of bbox dimensions)\n * @param name {string} view name\n * @param bbox {geo.BBox} target bounding box\n * @param offsetByDim {Array} offset factor (add to centroid dimension of bounding box scaled by this factor)\n * @param padByMaxDim {Array} pad factor (add to centroid max dimension of bounding box scaled by this factor)\n * @returns {{name, position, target, up}}\n */\nViewGenerator.prototype.getBBoxViewFromOffsetPosition = function (name, bbox, offsetByDim, padByMaxDim) {\n  var centroid = bbox.centroid().toArray();\n  var dims = bbox.dimensions().toArray();\n  var maxDim = Math.max(dims[0], dims[1], dims[2]);\n  var eye = [\n    centroid[0] + (offsetByDim[0] * dims[0] / 2) + (padByMaxDim[0] * maxDim),\n    centroid[1] + (offsetByDim[1] * dims[1] / 2) + (padByMaxDim[1] * maxDim),\n    centroid[2] + (offsetByDim[2] * dims[2] / 2) + (padByMaxDim[2] * maxDim)\n  ];\n  return {\n    name: name || ('bboxOffsetPosition-' + JSON.stringify(offsetByDim) + '-' + JSON.stringify(padByMaxDim)),\n    position: eye,\n    target: centroid,\n    up: [ 0, 1, 0 ]\n  };\n};\n\n/**\n * @typedef {Object} ViewGenerator.ViewOptions\n * @memberOf gfx\n * @property opts.name {string} view name\n * @property opts.target {THREE.Object3D|geo.BBox|THREE.Vector3} target object/bounding box/point to look at\n * @property [opts.viewIndex] {int} Prespecified views (1=left,2=right,3=bottom,4=top,5=front,6=back)\n * @property [opts.theta] {number} angle from horizontal in radians (latitude), must be specified if viewIndex is not specified\n * @property [opts.phi] {number} rotation from front in radians (longitude), must be specified if viewIndex is not specified\n * @property [opts.dists] {THREE.Vector3|number} distance from bounding box\n */\n\n/**\n * Returns camera parameters for looking at a target\n * @param opts {gfx.ViewGenerator.ViewOptions} View parameters\n * @returns {{name, position, target, up, fov, near, far}}\n */\nViewGenerator.prototype.getView = function (opts) {\n  var obj = opts.target;\n  if (opts.viewIndex != undefined && opts.phi == undefined && opts.theta == undefined) {\n    var thetaPhi = Constants.BBoxFacesThetaPhi[opts.viewIndex-1];\n    if (thetaPhi) {\n      opts = _.merge(Object.create(null), opts, {theta: thetaPhi[0], phi: thetaPhi[1] });\n    }\n  }\n  if (obj instanceof THREE.Object3D) {\n    var bbox = Object3DUtil.getBoundingBox(obj);\n    return this.getViewForBBox(_.merge(Object.create(null), opts, { target: bbox }));\n  } else if (obj instanceof BBox) {\n    return this.getViewForBBox(opts);\n  } else if (obj instanceof THREE.Vector3) {\n    return this.getViewForPoint(opts.name, obj, opts.theta, opts.phi, opts.dists);\n  } else {\n    console.warn('Cannot get view for object ' + typeof obj);\n  }\n};\n\nViewGenerator.prototype.__getDistsFromBBoxCenter = function(bbox, dists, cameraPositionStrategy) {\n  cameraPositionStrategy = cameraPositionStrategy || this.cameraPositionStrategy;\n  if (!dists || typeof dists === 'number') {\n    var dims = bbox.dimensions();\n    var maxDim = Math.max(dims.x, dims.y, dims.z);\n    var distanceScale = dists || this.defaultDistanceScale;\n    if (cameraPositionStrategy === 'positionToFit') {\n      var d = this.__getDistsToFitBBox(bbox);\n      dists = new THREE.Vector3(dims.x / 2 + d[0],dims.y / 2 + d[1],dims.z / 2 + d[2]);\n    } else if (cameraPositionStrategy === 'positionByDistance') {\n      var d = maxDim * distanceScale;\n      dists = new THREE.Vector3(dims.x / 2 + d,dims.y / 2 + d,dims.z / 2 + d);\n    } else if (cameraPositionStrategy === 'positionByCentroid') {\n      var d = maxDim * distanceScale;\n      dists = new THREE.Vector3(d, d, d);\n    }\n  }\n  return dists;\n};\n\nViewGenerator.prototype.__getDistsFromBBoxFaces = function(bbox, dists, cameraPositionStrategy) {\n  cameraPositionStrategy = cameraPositionStrategy || this.cameraPositionStrategy;\n  if (!dists || typeof dists === 'number') {\n    var dims = bbox.dimensions();\n    var maxDim = Math.max(dims.x, dims.y, dims.z);\n    var distanceScale = dists || this.defaultDistanceScale;\n    if (cameraPositionStrategy === 'positionToFit') {\n      var d = this.__getDistsToFitBBox(bbox);\n      dists = new THREE.Vector3(d[0], d[1], d[2]);\n    } else if (cameraPositionStrategy === 'positionByDistance') {\n      var d = maxDim * distanceScale;\n      dists = new THREE.Vector3(d, d, d);\n    } else if (cameraPositionStrategy === 'positionByCentroid') {\n      var d = maxDim * distanceScale;\n      dists = new THREE.Vector3(d - dims.x / 2, d - dims.y / 2, d - dims.z / 2);\n    }\n  }\n  return dists;\n};\n\n/**\n * Returns a good view for an axis aligned bounding box\n * @param opts View parameters\n * @param opts.name {string} view name\n * @param opts.bbox {geo.BBox} axis aligned bounding box\n * @param opts.theta {number} angleFromHorizontal (latitude)\n * @param opts.phi {number} rotation from front (longitude)\n * @param [opts.dists] {THREE.Vector3|number} distance from bounding box\n * @param [opts.cameraPositionStrategy] {string} Optional camera position strategy (overrides `this.cameraPositionStrategy`)\n * @param [opts.objectDepth] {number} depth of target in view frustum in meters (far - near, for 'positionToFixedResolution'))\n * @param [opts.imageHeight] {number} maximum image height in meters (for 'positionToFixedResolution'))\n * @param [opts.pixelWidth] {number}  width of single pixel in image plane in meters (for 'positionToFixedResolution'))\n * @param [opts.useSquareImage] {boolean} Whether image should be square (for 'positionToFixedResolution')\n * @param [opts.offsetByDim] {Array} offset camera by this multiple of bounding box dimensions (for 'positionByBBoxOffset')\n * @param [opts.padByMaxDim] {Array} offset camera by this multiple of maximum bounding box dimensions (for 'positionByBBoxOffset')\n * @returns {{name, position, target, up, fov, near, far}}\n */\nViewGenerator.prototype.getViewForBBox = function (opts) {\n  // Find a good view point based on the scene bounds\n  var bbox = opts.target;\n  var cameraPositionStrategy = opts.cameraPositionStrategy || this.cameraPositionStrategy;\n  if (cameraPositionStrategy === 'positionToFixedResolution') {\n    return this.getFixedResolutionViewForBBox(opts.name, bbox, opts.objectDepth, opts.imageHeight, opts.pixelWidth, opts.theta, opts.phi, opts.useSquareImage);\n  } else if (cameraPositionStrategy === 'positionByBBoxOffset') {\n    return this.getBBoxViewFromOffsetPosition(opts.name, bbox, opts.offsetByDim, opts.padByMaxDim);\n  } else {\n    var dists = this.__getDistsFromBBoxCenter(bbox, opts.dists, cameraPositionStrategy);\n    return this.getViewForPoint(opts.name, bbox.centroid(), opts.theta, opts.phi, dists);\n  }\n};\n\n/**\n * Get camera frustum params (fov, near, far) for target object of depth objectDepth m in frustum view direction\n * maximum image plane width objectWidth in meters, and maximum perspective width of pixelWidth for objectDepth tall plane\n * @param objectDepth {number} target object depth in frustum view direction in meters\n * @param objectWidth {number} maximum image plane width in meters\n * @param pixelWidth {number} maximum perspective width in pixels for objectDepth\n * @param [eps=0.01m] {number}\n * @returns {{fov: *, near: number, far: *}}\n */\nViewGenerator.prototype.getFrustumParams = function(objectDepth, objectWidth, pixelWidth, eps) {\n  eps = eps || (Constants.metersToVirtualUnit * 0.01);\n  var fov = 2 * Math.atan(pixelWidth / objectDepth);\n  var objectWidthFar = 2 * (pixelWidth + (objectWidth / 2));\n  var far = objectWidthFar * objectDepth / (2 * pixelWidth) + eps;\n  var near = far - objectDepth - eps;\n  return { fov: THREE.Math.radToDeg(fov), near: near, far: far };\n};\n\nViewGenerator.prototype.__getViewBBoxDims = function(dims, theta, phi) {\n  var st = Math.abs(Math.sin(theta));\n  var ct = Math.abs(Math.cos(theta));\n  var sp = Math.abs(Math.sin(phi));\n  var cp = Math.abs(Math.cos(phi));\n\n  // 0,0 --> x,y,z (for w,h,d)\n  // 0, PI/2 --> z,y,x\n  // PI/2,0 --> x,z,y\n  var w = cp*dims.x + sp*dims.z;\n  var h = ct*dims.y + st*(sp*dims.x + cp*dims.z);\n  var d = st*dims.y + ct*(sp*dims.x + cp*dims.z);\n  return [w,h,d];\n};\n\n/**\n * Returns camera parameters for a fixed resolution view of a bbox\n * @example\n *  var viewGen = new ViewGenerator({ camera: scope.camera });\n *  var view = viewGen.getFixedResolutionViewForBBox('view', scope.getSceneBoundingBox(), 1, 10, 0.01);  // 1m tall, 10m wide, 1cm pixels\n *  scope.cameraControls.viewTarget(view);\n * @param name {string} id for generated view\n * @param bbox {geo.BBox} target bounding box\n * @param [objectDepth] {number} depth of target in view frustum in m (far - near)\n * @param [imageHeight] {number} maximum image height in m\n * @param pixelWidth {number} width of single pixel in image plane in m\n * @param theta {number} angleFromHorizontal (latitude in rad)\n * @param phi {number} rotation from front (longitude in rad)\n * @param [useSquareImage=false] {boolean} Whether to have a square image or not\n * @returns {{name, position, target, up, fov, near, far}}\n */\nViewGenerator.prototype.getFixedResolutionViewForBBox = function (name, bbox, objectDepth, imageHeight, pixelWidth, theta, phi, useSquareImage) {\n  pixelWidth = pixelWidth || 0.01;  // 1cm\n  theta = (theta != undefined)? theta : (Math.PI / 2);\n  phi = (phi != undefined)? phi : 0;\n\n  var dims = bbox.dimensions();\n  var viewDims = this.__getViewBBoxDims(dims, theta, phi);\n  //console.log('got viewDims', viewDims, theta, phi);\n  var imageHeightVU;\n  if (!imageHeight) {  // Find a good view point based on the scene bounds\n    var width = useSquareImage? Math.max(viewDims[0], viewDims[1]) : viewDims[1];\n    imageHeightVU = width * this.defaultDistanceScale;  // maximum image dimension in virtual units\n  } else {\n    imageHeightVU = imageHeight * Constants.metersToVirtualUnit;  // rescale from meters to virtual units\n  }\n\n  var objectDepthVU = objectDepth? (objectDepth * Constants.metersToVirtualUnit) : (viewDims[2] * this.defaultDistanceScale);\n  var params = this.getFrustumParams(objectDepthVU, imageHeightVU, pixelWidth * Constants.metersToVirtualUnit);\n  var dists = new THREE.Vector3(params.far - objectDepthVU/2, params.far - objectDepthVU/2, params.far - objectDepthVU/2);\n  var viewOpts = this.getViewForPoint(name, bbox.centroid(), theta, phi, dists, params.fov, params.near, params.far);\n  viewOpts.imageHeightMeters = imageHeightVU / Constants.metersToVirtualUnit;\n  viewOpts.objectDepthMeters = objectDepthVU / Constants.metersToVirtualUnit;\n  viewOpts.pixelWidthMeters = pixelWidth;\n  viewOpts.imageSize = useSquareImage?\n    [\n      Math.ceil(viewOpts.imageHeightMeters / viewOpts.pixelWidthMeters),\n      Math.ceil(viewOpts.imageHeightMeters / viewOpts.pixelWidthMeters)\n    ] :\n    [\n      Math.ceil((viewDims[0] / Constants.metersToVirtualUnit) / viewOpts.pixelWidthMeters),\n      Math.ceil((viewDims[1] / Constants.metersToVirtualUnit) / viewOpts.pixelWidthMeters)\n    ];\n  return viewOpts;\n};\n\n/**\n * Returns camera parameters for looking at a point\n * @param name {string} view name\n * @param target {THREE.Vector3} target point to look at\n * @param theta {number} angleFromHorizontal (latitude in rad)\n * @param phi {number} rotation from front (longitude in rad)\n * @param [dists] {THREE.Vector3|number} distance from bounding box\n * @param [fov] {number} field of view\n * @param [near] {number}\n * @param [far] {number}\n * @returns {{name, position, target, up, fov, near, far}}\n */\nViewGenerator.prototype.getViewForPoint = function (name, target, theta, phi, dists, fov, near, far) {\n  var ry = dists.y;\n  var rz = dists.z * Math.cos(phi) * (-1);\n  var rx = dists.x * Math.sin(phi);\n  var camX = target.x + (rx * Math.cos(theta));\n  var camY = target.y + (ry * Math.sin(theta));\n  var camZ = target.z + (rz * Math.cos(theta));\n\n  var eye = [camX, camY, camZ];\n  var up = Constants.worldUp.clone();\n  var camVec = new THREE.Vector3(target.x - camX, target.y - camY, target.z - camZ);\n  var lookatUp;\n  var dot = Math.abs(camVec.normalize().dot(up));\n  if (dot > 0.95) {\n    lookatUp = Constants.worldFront.clone().negate();\n  }\n  return {\n    name: name,\n    position: eye,\n    target: target,\n    lookatUp: lookatUp,\n    up: up,\n    fov: fov,\n    near: near,\n    far: far\n  };\n};\n\n/**\n * Generate views with varying theta and phi\n * @param target {THREE.Object3D|geo.BBox|THREE.Point}\n * @param thetaRange {Range|number}\n * @param phiRange {Range|number}\n * @returns {Array}\n */\nViewGenerator.prototype.generateRotatingViews = function (target, thetaRange, phiRange) {\n  var views = [];\n  if (_.isNumber(thetaRange)) { thetaRange = { start: thetaRange, end: thetaRange + 1, step: 1 }; }\n  if (_.isNumber(phiRange)) { phiRange = { start: phiRange, end: phiRange + 1, step: 1 }; }\n  for (var theta = thetaRange.start; theta < thetaRange.end; theta += thetaRange.step) {\n    for (var phi = phiRange.start; phi < phiRange.end; phi += phiRange.step) {\n      var view = this.getView({ name: 'view-' + theta + '-' + phi, target: target, theta: theta, phi: phi});\n      views.push(view);\n    }\n  }\n  return views;\n};\n\n\n// TODO: Cleanup following functions\n\n/**\n * Generate canonical views for looking at a bounding box\n * @param bbox {geo.BBox}\n * @param width {number}\n * @param height {number}\n * @returns {Array}\n */\nViewGenerator.prototype.generateViewsForBBox = function (bbox, width, height) {\n  // TODO: Make this function respect cameraPositioningStrategy\n  var basicViews = this.__generateBasicViewsForBBoxToFit(bbox, width, height);\n  var defaultView = this.getDefaultView(bbox);\n  var views = [];\n  views.push(defaultView);\n  views = views.concat(basicViews);\n  return views;\n};\n\n// TODO: Make this function more general\nViewGenerator.prototype.generateViews = ViewGenerator.prototype.generateViewsForBBox;\n\nViewGenerator.prototype.__generateBasicViewsForBBoxWithDistScale = function (bbox, distScale) {\n  if (!distScale) {\n    // Some default distance scale\n    distScale = this.defaultDistanceScale;\n  }\n  // Find a good view point based on the scene bounds\n  var dims = bbox.dimensions().toArray();\n  var maxDim = Math.max(dims[0], dims[1], dims[2]);\n  var dists = [maxDim * distScale, maxDim * distScale, maxDim * distScale];\n  return this.__generateBasicViewsForBBoxWithDists(bbox, dists);\n};\n\nViewGenerator.prototype.__generateBasicViewsForBBoxToFit = function (bbox, width, height) {\n  // Find a good view point based on the scene bounds\n  var dists = this.__getDistsToFitBBox(bbox, width, height);\n  return this.__generateBasicViewsForBBoxWithDists(bbox, dists);\n};\n\n/**\n * Returns distance to fit giving bounding box in view\n * @private\n */\nViewGenerator.prototype.__getDistsToFitBBox = function (bbox, width, height) {\n  var dims = bbox.dimensions().toArray();\n  var aspectRatio = (width > 0 && height > 0) ? width / height : this.camera.aspect;\n  var maxDims = [\n      Math.max(dims[2] / aspectRatio, dims[1]),\n      Math.max(dims[0] / aspectRatio, dims[2]),\n      Math.max(dims[0] / aspectRatio, dims[1])\n  ];\n  var tanFov = Math.tan((Math.PI / 180) * this.camera.fov / 2);\n  var dists = maxDims.map(function (m) {\n      return 0.5 * m / tanFov;\n  });\n  return dists;\n};\n\n/**\n * Generate 6 canonical views for a bounding box with given distances\n * @param bbox\n * @param dists\n * @returns {Array}\n * @private\n */\nViewGenerator.prototype.__generateBasicViewsForBBoxWithDists = function (bbox, dists) {\n  // Find a good view point based on the scene bounds\n  var centroid = bbox.centroid().toArray();\n  var bbMin = bbox.min.toArray();\n  var bbMax = bbox.max.toArray();\n\n  var lookAt = centroid;\n  var up = [0, 1, 0];\n  var camPositions = [\n    [bbMin[0] - dists[0], centroid[1], centroid[2]],\n    [bbMax[0] + dists[0], centroid[1], centroid[2]],\n    [centroid[0], bbMin[1] - dists[1], centroid[2]],\n    [centroid[0], bbMax[1] + dists[1], centroid[2]],\n    [centroid[0], centroid[1], bbMin[2] - dists[2]],\n    [centroid[0], centroid[1], bbMax[2] + dists[2]]\n  ];\n  var camNames = [\n    'left',\n    'right',\n    'bottom',\n    'top',\n    'front',\n    'back'\n  ];\n  var camUps = [\n    up,\n    up,\n    [0, 0, 1],\n    [0, 0, 1],\n    up,\n    up\n  ];\n  var views = camPositions.map(function (x, index) {\n    return {\n      name: camNames[index],\n      position: x,\n      target: lookAt,\n      lookatUp: camUps[index]\n    };\n  });\n  return views;\n};\n\n\nmodule.exports = ViewGenerator;\n\n//# sourceURL=webpack://STK/./js/lib/gfx/ViewGenerator.js?");

/***/ }),

/***/ "./js/lib/gfx/ViewUtils.js":
/*!*********************************!*\
  !*** ./js/lib/gfx/ViewUtils.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * View based utility functions for analyzing geometry\n * @module ViewUtils\n */\nvar ViewUtils = {};\n\n/**\n * Identifies visible triangles by rendering from different views and counting which triangles were seen\n * @param opts Options for identifying visible triangles\n * @param opts.width {int} Width of image to render\n * @param opts.height {int} Height of image to render\n * @param opts.scene {THREE.Object3D} Scene to render\n * @returns {Object<int, Object<int, int>>} Map of mesh id to map of pickable face indices to counts\n */\nfunction identifyVisibleTriangles(opts) {\n  var scene = opts.scene;\n  var sceneBBox = Object3DUtil.getBoundingBox(scene);\n  var dims = sceneBBox.dimensions();\n  var minDim = Math.min(dims.x, dims.y, dims.z);\n  var maxDim = Math.max(dims.x, dims.y, dims.z);\n  var OffscreenPicker = __webpack_require__(/*! controls/OffscreenPicker */ \"./js/lib/controls/OffscreenPicker.js\");\n  var Camera = __webpack_require__(/*! gfx/Camera */ \"./js/lib/gfx/Camera.js\");\n  var camera = new THREE.PerspectiveCamera(45, opts.width/opts.height,\n    opts.near || Math.min(minDim/20, 0.01*Constants.metersToVirtualUnit),\n    opts.far || Math.max(10*maxDim, 10*Constants.metersToVirtualUnit));\n  //console.log('near, far', camera.near, camera.far);\n  var offscreenPicker = new OffscreenPicker({\n    debug: false,\n    useFullBuffer: true,\n    width: opts.width,\n    height: opts.height,\n    camera: camera\n  });\n  var ViewGenerator = __webpack_require__(/*! gfx/ViewGenerator */ \"./js/lib/gfx/ViewGenerator.js\");\n  var viewGenerator = new ViewGenerator({\n    camera: camera,\n    cameraPositionStrategy: 'positionToFit'\n  });\n  var views = viewGenerator.generateViews(sceneBBox, opts.width, opts.height);\n  views = views.concat(viewGenerator.generateRotatingViews(sceneBBox, Math.PI/6, { start: Math.PI/6, end: 2*Math.PI, step: Math.PI/8 }));\n  views = views.concat(viewGenerator.generateRotatingViews(sceneBBox, -Math.PI/6, { start: -Math.PI/6, end: 2*Math.PI, step: Math.PI/8 }));\n  var visible = {};\n  _.each(views, function(view) {\n    //console.log('view', view);\n    Camera.setView(camera, view);\n    offscreenPicker.updatePickables(camera, scene, visible);\n  });\n  //console.log('visible', visible);\n  return visible;\n}\nViewUtils.identifyVisibleTriangles = identifyVisibleTriangles;\n\nmodule.exports = ViewUtils;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/gfx/ViewUtils.js?");

/***/ }),

/***/ "./js/lib/io/Ajax.js":
/*!***************************!*\
  !*** ./js/lib/io/Ajax.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Helper methods for making ajax calls\n\nvar Ajax = {};\n\n/**\n * Create a serialized representation of an array, a plain object, or a jQuery object suitable for use in a URL query string or Ajax request\n * Currently pass through to jquery {@link http://api.jquery.com/jQuery.param/|$.params}\n * @param opts {Object} Javascript object with options to encode as parameters\n */\nAjax.param = function(opts) {\n  return $.param(opts);\n};\n\n/**\n * Perform an asynchronous HTTP (Ajax) request.\n * Currently pass through to jquery {@link http://api.jquery.com/jQuery.ajax/|$.ajax}\n * @param opts\n * @param opts.url {string}\n * @param opts.callback {callback} Optional error first callback\n * @param opts.data {string|Object|Array} Data to be set to the server for processing\n * @param opts.dataType {string} What to interpret the response as (`json|jsonp|text|xml|html`)\n * @param opts.jsonp {string|boolean} Override the callback function name in a JSONP request\n * @param opts.traditional {string} Set to true to use traditional parameter serialization.  Example, if field is array, it will become field=a1&field=a2 instead of field[0]=a1&field[1]=a2\n * @param opts.timeout {number} Timeout in milliseconds. With JSONP, this is the only way to get the error handler to fire.\n */\nAjax.ajax = function(opts) {\n  opts = Ajax.__prepareAjaxOpts(opts);\n  return $.ajax(opts);\n};\n\n/**\n * Perform an asynchronous HTTP (Ajax) request using post.\n * Currently pass through to jquery {@link http://api.jquery.com/jQuery.post/|$.post}\n * @param opts Option\n * @param opts.url {string}\n * @param callback {callback} Optional error first callback\n */\nAjax.post = function(opts) {\n  opts = Ajax.__prepareAjaxOpts(opts);\n  return $.post(opts);\n};\n\n// Creates suitable function that ensures that callback / params.success / params.error are called\nfunction __getCallback(params, cb) {\n  return function(err, res) {\n    if (err) {\n      // Error\n      if (params && params.error) { params.error(err); }\n    } else {\n      // Success\n      if (params && params.success) { params.success(res); }\n    }\n    if (cb) { cb(err, res); }\n  };\n}\n\nfunction toAjaxSucceededCallback(cb) {\n  return function(data, textStatus, jqXHR) {\n    if (data.error) {\n      cb(data, null);\n    } else {\n      cb(null, data);\n    }\n  };\n}\n\nfunction toAjaxFailedCallback(cb) {\n  return function(jqXHR, textStatus, errorThrown) {\n    cb(textStatus + ' ' + errorThrown, null);\n  };\n}\n\nAjax.getCallback = __getCallback;\n\nAjax.__prepareAjaxOpts = function(opts) {\n  if (opts.callback) {\n    var cb = __getCallback(opts, opts.callback);\n    opts = Object.assign({}, opts);\n    opts.success = toAjaxSucceededCallback(cb);\n    opts.error = toAjaxFailedCallback(cb);\n  }\n  //console.log('opts', opts);\n  return opts;\n};\n\nmodule.exports = Ajax;\n\n//# sourceURL=webpack://STK/./js/lib/io/Ajax.js?");

/***/ }),

/***/ "./js/lib/io/FileLoader.js":
/*!*********************************!*\
  !*** ./js/lib/io/FileLoader.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar LocalFileLoader = __webpack_require__(/*! io/LocalFileLoader */ \"./js/lib/io/LocalFileLoader.js\");\n\nfunction FileLoader(params) {\n  params = params || {};\n  this.manager = params.manager;\n  this.crossOrigin = params.crossOrigin;\n  this.defaultOnLoad = params.defaultOnLoad;\n  this.defaultOnProgress = params.defaultOnProgress;\n  this.defaultOnError = params.defaultOnError || function (event) {\n    console.error('Error fetching');\n    console.log(event);\n  };\n}\n\nFileLoader.prototype.loadErrorFirst = function (fileOrUrl, encoding, callback) {\n  // Load with node.js error first style callback(err, result)\n  this.load(fileOrUrl, encoding,\n    function(data) { callback(null, data); },\n    null,\n    function(err) { callback(err, null); }\n  );\n};\n\nFileLoader.prototype.load = function (fileOrUrl, encoding, onLoad, onProgress, onError) {\n  // Load compatible in style to THREE.js loaders\n  if (fileOrUrl instanceof File) {\n    return this.loadFromLocal(fileOrUrl, encoding, onLoad, onProgress, onError);\n  } else if (typeof fileOrUrl === 'string') {\n    return this.loadFromUrl(fileOrUrl, encoding, onLoad, onProgress, onError);\n  } else {\n    console.error('Invalid argument to load: ', fileOrUrl);\n    if (onError) {\n      onError('Invalid argument to load: ', fileOrUrl);\n    }\n  }\n};\n\nFileLoader.prototype.loadFromLocal = function (file, encoding, onLoad, onProgress, onError) {\n  onLoad = onLoad || this.defaultOnLoad;\n  onProgress = onProgress || this.defaultOnProgress;\n  onError = onError || this.defaultOnError;\n  var localLoader = new LocalFileLoader();\n  return localLoader.load(file, encoding, onLoad, onProgress, onError);\n};\n\nFileLoader.prototype.loadFromUrl = function (url, encoding, onLoad, onProgress, onError) {\n  onLoad = onLoad || this.defaultOnLoad;\n  onProgress = onProgress || this.defaultOnProgress;\n  onError = onError || this.defaultOnError;\n  var loader = new THREE.FileLoader(this.manager);\n  //loader.setCrossOrigin(this.crossOrigin);\n  if (encoding) {\n    if (encoding === 'json') {\n      if (onLoad) {\n        var oldOnLoad = onLoad;\n        onLoad = function (text) {\n          var parsed;\n          try {\n            parsed = JSON.parse(text);\n          } catch (err) {\n            onError('Invalid json from ' + url);\n            return;\n          }\n          oldOnLoad(parsed);\n        };\n      }\n    } else {\n      if (Constants.isBrowser && encoding.toLowerCase().replace('-', '') === 'utf8') {\n        encoding = 'text';\n      }\n      loader.setResponseType(encoding);\n    }\n  }\n  return loader.load(url, onLoad, onProgress, onError);\n};\n\nmodule.exports = FileLoader;\n\n//# sourceURL=webpack://STK/./js/lib/io/FileLoader.js?");

/***/ }),

/***/ "./js/lib/io/FileUtil.js":
/*!*******************************!*\
  !*** ./js/lib/io/FileUtil.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Utility functions for working with the file system\n\nvar FileSaver = __webpack_require__(/*! file-saver */ \"../node_modules/file-saver/FileSaver.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar self = {};\n\nfunction saveText(string, filename) {\n  var blob = new Blob([string], {type: \"text/plain;charset=utf-8\"});\n  FileSaver.saveAs(blob, filename);\n}\n\nself.saveText = saveText;\n\nfunction saveJson(object, filename, replacer) {\n  var blob = new Blob([JSON.stringify(object, replacer)], {type: \"text/plain;charset=utf-8\"});\n  FileSaver.saveAs(blob, filename);\n}\n\nself.saveJson = saveJson;\n\nfunction saveBlob(blob, filename) {\n  FileSaver.saveAs(blob, filename);\n}\n\nself.saveBlob = saveBlob;\n\nfunction saveCanvasImage(canvas, filename) {\n  canvas.toBlob(function(blob) {\n    FileSaver.saveAs(blob, filename);\n  }, \"image/png\");\n}\n\nself.saveCanvasImage = saveCanvasImage;\n\n/* Convenience function for loading files from anywhere! */\nfunction readAsync(uri, opts, cb) {\n  var encoding = (opts == undefined || typeof opts === 'string') ? opts : opts.encoding;\n  var FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\n  var fileLoader = new FileLoader();\n  fileLoader.load(uri, encoding, function(data) {\n    cb(null, data);\n  }, null, function(err) {\n    cb(err, null);\n  });\n}\n\nself.readAsync = readAsync;\n\nfunction loadDelimited(file, opts, callback) {\n  var IOUtil = __webpack_require__(/*! io/IOUtil */ \"./js/lib/io/IOUtil.js\");\n  // By default, we assume there is a header, don't want empty lines, and will do dynamicTyping\n  opts = _.defaults(Object.create(null), opts || { filename: file.name || file });\n  readAsync(file, 'utf8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      var parsed = IOUtil.parseDelimited(data, opts);\n      callback(null, parsed);\n    }\n  });\n}\n\nself.loadDelimited = loadDelimited;\n\n\n/* File system utils */\nfunction __fsReadFileCallback(filename, successCallback, errorCallback, fs) {\n  var errorHandler = function (e) {\n    console.error('Error reading file ' + filename);\n    console.log(e);\n    if (errorCallback) errorCallback();\n  };\n\n  fs.root.getFile(filename, {}, function(fileEntry) {\n    // Get a File object representing the file,\n    // then use FileReader to read its contents.\n    fileEntry.file(function(file) {\n      successCallback(file);\n    }, errorHandler);\n  }, errorHandler);\n}\n\nfunction fsReadFile(filename, successCallback, errorCallback) {\n  var callback = __fsReadFileCallback.bind(null, filename, successCallback, errorCallback);\n  initFs(callback);\n}\n\nself.fsReadFile = fsReadFile;\n\nfunction fsExportFile(fsFilename, finalFilename) {\n  fsReadFile(fsFilename, function(blob) {\n    FileSaver.saveAs(blob, finalFilename);\n  });\n}\n\nself.fsExportFile = fsExportFile;\n\nfunction __fsWriteToFileCallback(opts) {\n  var filename = opts.filename;\n  var content = opts.content;\n  var initialContent = opts.initialContent;\n  var append = opts.append;\n  var successCallback = opts.success;\n  var errorCallback = opts.error;\n  var fs = opts.fs;\n\n  var errorHandler = function (e) {\n    console.error('Error writing file ' + filename);\n    console.log(e);\n    if (errorCallback) errorCallback();\n  };\n\n  fs.root.getFile(filename, { create: true }, function (fileEntry) {\n    console.log('Writing to file at ' + fileEntry.fullPath + ', append=' + append + '.');\n    // Create a FileWriter object for our FileEntry (log.txt).\n    fileEntry.createWriter(function (fileWriter) {\n      var truncating = false;\n      // Create a new Blob and write it to filename.\n      var contents = [content];\n      if (initialContent && (!append || fileWriter.length === 0)) {\n        // There is some initial content that should go into the file\n        contents = [initialContent, content];\n      }\n      var blob = (typeof content === 'string')?\n        new Blob(contents, { type: 'text/plain;charset=utf-8' }) :\n        new Blob(contents, { type: 'application/binary' });\n\n      fileWriter.onwriteend = function (e) {\n        if (truncating)  {\n          truncating = false;\n          fileWriter.write(blob);\n        } else {\n          console.log('Write completed.');\n          if (successCallback) successCallback();\n        }\n      };\n\n      fileWriter.onerror = function(e) {\n        console.log('Write failed: ' + e.toString());\n        if (errorCallback) errorCallback();\n      };\n\n      if (append) {\n        // Appending, go to correct place\n        console.log('Write to position ' + fileWriter.length + ' of ' + fileEntry.fullPath);\n        fileWriter.seek(fileWriter.length);\n        fileWriter.write(blob);\n      } else {\n        if (fileWriter.length > 0) {\n          // Not appending, lets truncates file to 0\n          console.log('Truncate file ' + fileEntry.fullPath );\n          truncating = true;\n          fileWriter.truncate(0);\n          // After truncate is successful - should get onwriteend callback...\n        } else {\n          fileWriter.write(blob);\n        }\n      }\n    }, errorHandler);\n\n  }, errorHandler);\n\n}\n\nfunction fsWriteToFile(filename, content, successCallback, errorCallback) {\n  initFs(function(fs) {\n    __fsWriteToFileCallback({\n      fs: fs,\n      filename: filename,\n      content: content,\n      append: false,\n      success: successCallback,\n      error: errorCallback\n    });\n  });\n}\n\nself.fsWriteToFile = fsWriteToFile;\n\nfunction fsAppendToFile(filename, content, successCallback, errorCallback) {\n  initFs(function(fs) {\n    __fsWriteToFileCallback({\n      fs: fs,\n      filename: filename,\n      content: content,\n      append: true,\n      success: successCallback,\n      error: errorCallback\n    });\n  });\n}\n\nself.fsAppendToFile = fsAppendToFile;\n\nfunction writeToFile(filename, content, opts, callback) {\n  opts = opts || {};\n  if (typeof(opts) === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (!callback) {\n    callback = opts.callback;\n  }\n  initFs(function(fs) {\n    __fsWriteToFileCallback({\n      fs: fs,\n      filename: filename,\n      content: content,\n      initialContent: opts.initialContent,\n      append: opts.append,\n      success: callback? function(data) { callback(null, data); } : null,\n      error: callback? function(err) { callback(err, null); } : null\n    });\n  });\n}\n\nself.writeToFile = writeToFile;\n\nfunction initFs(callback) {\n  // Uses HTML5 file system (see http://www.html5rocks.com/en/tutorials/file/filesystem/)\n  // Use the HTML5 Filesystem explorer for chrome to look at your file\n  var errorHandler = function (e) {\n    console.log('Error initializing FS!!!!');\n    console.log(e);\n  };\n  console.log('Attempt to use FS!!!');\n  window.requestFileSystem  = window.requestFileSystem || window.webkitRequestFileSystem;\n  window.webkitStorageInfo.requestQuota(window.PERSISTENT, 500*1024*1024, function(grantedBytes) {\n    window.requestFileSystem(window.PERSISTENT, grantedBytes, callback, errorHandler);\n  }, function (e) {\n    console.log('Error requesting quota!!!', e);\n  });\n}\n\nself.initFs = initFs;\n\nmodule.exports = self;\n\n\n//# sourceURL=webpack://STK/./js/lib/io/FileUtil.js?");

/***/ }),

/***/ "./js/lib/io/IOUtil.js":
/*!*****************************!*\
  !*** ./js/lib/io/IOUtil.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var csv = __webpack_require__(/*! papaparse */ \"../node_modules/papaparse/papaparse.min.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar IOUtil = {};\n\n// Thin wrapper about papaparse (see http://papaparse.com/docs)\nfunction parseDelimited(data, opts) {\n  // By default, we assume there is a header, don't want empty lines, and will do dynamicTyping\n  opts = _.defaults(Object.create(null), opts || {}, { header: true, skipEmptyLines: true, dynamicTyping: true });\n  // Delimiter is not specified\n  if (opts.delimiter == null && opts.filename) {\n    if (opts.filename.endsWith('.tsv')) {\n      opts.delimiter = '\\t';\n      opts.quoteChar = '\\0'; // no quote char\n    }\n  }\n  var parsed = csv.parse(data, opts);\n  if (opts.remapFields) {\n    parsed.data = _.each(parsed.data, function(d) {\n      _.each(opts.remapFields, function(nf,of) {\n        d[nf] = d[of];\n      });\n    });\n  }\n  if (opts.keyBy) {\n    parsed.data = _.keyBy(parsed.data, opts.keyBy);\n  }\n  return parsed;\n}\n\nIOUtil.parseDelimited = parseDelimited;\n\nfunction parseJsonl(data, opts) {\n  opts = opts || {};\n  // Parses jsonl into array of json objects\n  var objects = [];\n  var startIndex = 0;\n  var endIndex = -1;\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] === '\\n' || data[i] === '\\r') {\n      endIndex = i;\n      if (endIndex > startIndex) {\n        var str = data.substring(startIndex, endIndex);\n        str = str.trim();\n        if (str.length > 0) {\n          objects.push(JSON.parse(str));\n        }\n      }\n      startIndex = endIndex + 1;\n    }\n  }\n  if (opts.flatten) {\n    objects = _.flatten(objects);\n  }\n  return objects;\n}\n\nIOUtil.parseJsonl = parseJsonl;\n\nfunction indexLines(data, opts) {\n  opts = opts || {};\n  var lines = data.split('\\n');\n  var labelToIndex = {};\n  for (var i = 0; i < lines.length; i++) {\n    lines[i] = lines[i].trim();\n    if (lines[i]) {\n      var fields = opts.delimiter? lines[i].split(opts.delimiter) : [lines[i]];\n      if (fields.length > 1) {\n        labelToIndex[fields[0]] = parseInt(fields[1]);\n      } else {\n        labelToIndex[fields[0]] = i;\n      }\n    }\n  }\n  return labelToIndex;\n}\n\nIOUtil.indexLines = indexLines;\n\nmodule.exports = IOUtil;\n\n\n//# sourceURL=webpack://STK/./js/lib/io/IOUtil.js?");

/***/ }),

/***/ "./js/lib/io/JSONUtil.js":
/*!*******************************!*\
  !*** ./js/lib/io/JSONUtil.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var self = {};\n\nvar getJSON = function (url, callback) {\n  var FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\n  var loader = new FileLoader();\n  loader.loadErrorFirst(url, 'json', callback);\n\n  //var xobj = new XMLHttpRequest();\n  ////xobj.overrideMimeType('application/json');\n  //xobj.open('GET', url, !isSync);\n  //xobj.onreadystatechange = function () {\n  //  if (xobj.readyState == 4) {\n  //    if (xobj.status == '200' || xobj.status == '304') {\n  //      // Required use of an anonymous callback as .open will NOT return a value but simply returns undefined in asynchronous mode\n  //      callback(null, xobj.responseText);\n  //    } else {  // assume error\n  //      callback(xobj.status, null);\n  //    }\n  //  }\n  //};\n  //xobj.send(null);\n};\n\n/**\n * Utility function for fetching a json file\n * @param url {string}\n * @param callback {callback} Optional error first callback\n */\nself.getJSON = function (url, callback) {\n  var __done = function (data) {\n    if (callback) {\n      callback(null, data);\n    } else {\n      console.log('getJSON received from ' + url);\n      console.log(data);\n    }\n  };\n  var __fail = function (err) {\n    if (callback) {\n      callback(err, null);\n    } else {\n      console.error('getJSON error from ' + url);\n      console.error(err);\n    }\n  };\n  var f = function () {\n\n  };\n\n  f.done = function (cb) {\n    __done = cb;\n    return f;\n  };\n\n  f.fail = function (cb) {\n    __fail = cb;\n    return f;\n  };\n\n  getJSON(url, function (err, res) {\n    if (err) {\n      __fail({ err: err, url: url, res: res });\n    } else {\n      __done(res);\n    }\n  });\n\n  return f;\n};\n\nmodule.exports = self;\n\n//# sourceURL=webpack://STK/./js/lib/io/JSONUtil.js?");

/***/ }),

/***/ "./js/lib/io/LocalFileLoader.js":
/*!**************************************!*\
  !*** ./js/lib/io/LocalFileLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar LocalFileLoader = function (manager) {\n  this.manager = (manager !== undefined) ? manager : THREE.DefaultLoadingManager;\n};\n\nLocalFileLoader.prototype = {\n\n  constructor: LocalFileLoader,\n\n  load: function (file, encodingType, onLoad, onProgress, onError) {\n    var scope = this;\n    var filename = file.name;\n    var fileReader = new FileReader();\n    fileReader.onload = function (fileLoadedEvent) {\n      var loaded = fileLoadedEvent.target.result;\n      if (encodingType === 'json') {\n        try {\n          loaded = JSON.parse(loaded);\n        } catch (err) {\n          if (onError) {\n            onError(err);\n          } else {\n            console.error('Error parsing file ' + filename + ' as json', err);\n          }\n          scope.manager.itemError(filename);\n          return;\n        }\n      }\n      if (onLoad) onLoad(loaded);\n      scope.manager.itemEnd(filename);\n    }.bind(this);\n\n    if (onProgress) {\n      fileReader.onprogress = function (event) {\n        onProgress(event);\n      };\n    }\n\n    fileReader.onerror = function (event) {\n      if (onError) onError(event);\n      scope.manager.itemError(filename);\n    };\n\n    if (encodingType === 'binary') {\n      fileReader.readAsBinaryString(file);\n    } else if (encodingType === 'arraybuffer') {\n      fileReader.readAsArrayBuffer(file);\n    } else if (encodingType === 'dataURL') {\n      fileReader.readAsDataURL(file);\n    } else if (encodingType === 'json') {\n      fileReader.readAsText(file, 'UTF-8');\n    } else {\n      fileReader.readAsText(file, encodingType);\n    }\n\n    scope.manager.itemStart(filename);\n    return fileReader;\n  }\n\n};\n\nmodule.exports = LocalFileLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/io/LocalFileLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/ALNLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/ALNLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var BasicLoader = __webpack_require__(/*! loaders/BasicLoader */ \"./js/lib/loaders/BasicLoader.js\");\n\n/**\n * Loader for aln (meshlab alignment matrices) files\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction ALNLoader(params) {\n  this.fs = params.fs;\n}\n\nALNLoader.prototype = Object.create(BasicLoader.prototype);\nALNLoader.prototype.constructor = ALNLoader;\n\nALNLoader.prototype.parse = function(filename, data) {\n  return this.__parseMatrices(filename, data);\n};\n\nALNLoader.prototype.__parseMatrices = function(filename, data) {\n  // 1\n  // scene0700_00_vh_clean_2.ply\n  // #\n  // -0.809017   0.587785          0   0.352544\n  // -0.587785  -0.809017          0    3.71646\n  // 0          0          1 -0.0462523\n  // 0          0          0          1\n  // 0\n\n  // Format of file:\n  // number of aligment matrices\n  // repeating\n  //   Name of scene\n  //   #\n  //   matrix\n  // 0\n  var lines = data.split('\\n');\n  var ws = /\\s+/;\n  if (lines.length > 0) {\n    var lineno = 0;\n    var nmatrices = parseInt(lines[lineno++].trim());\n    var matrices = [];\n    for (var i = 0; i < nmatrices; i++) {\n      var filename = lines[lineno++].trim();\n      var sep = lines[lineno++].trim();\n      if (sep !== '#') {\n        throw 'Unexpected line at ' + filename + ':' + lineno;\n      }\n      var r0 = lines[lineno++].trim().split(ws);\n      var r1 = lines[lineno++].trim().split(ws);\n      var r2 = lines[lineno++].trim().split(ws);\n      var r3 = lines[lineno++].trim().split(ws);\n      var m = new THREE.Matrix4();\n      m.set(\n        r0[0], r0[1], r0[2], r0[3],\n        r1[0], r1[1], r1[2], r1[3],\n        r2[0], r2[1], r2[2], r2[3],\n        r3[0], r3[1], r3[2], r3[3]\n      );\n      matrices.push({ filename: filename, matrix: m });\n    }\n    return matrices;\n  }\n};\n\nmodule.exports = ALNLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/ALNLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/ArchLoader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/ArchLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ArchCreator = __webpack_require__(/*! geo/ArchCreator */ \"./js/lib/geo/ArchCreator.js\");\n\n/**\n * Loader for wall files\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction ArchLoader(params) {\n  this.fs = params.fs;\n\n  var archCreatorOptions = ArchCreator.DEFAULTS;\n  if (params.archOptions) {\n    archCreatorOptions = _.defaultsDeep(Object.create(null), params.archOptions, archCreatorOptions);\n  }\n  // console.log('archCreatorOptions', params.archOptions);\n  this.archFilter = ArchCreator.getFilter({\n    includeCeiling: archCreatorOptions.filter.includeCeiling,\n    includeFloor: archCreatorOptions.filter.includeFloor,\n    includeWalls: archCreatorOptions.filter.includeWalls,\n    room: archCreatorOptions.filter.room,\n    level: archCreatorOptions.filter.level,\n    archIds: archCreatorOptions.filter.archIds\n  });\n  this.archCreator = new ArchCreator(archCreatorOptions);\n}\n\n\nArchLoader.prototype.load = function(file, callback) {\n  if (file.file) { file = file.file; }\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      callback(null, scope.parse(filename, data));\n    }\n  });\n};\n\nArchLoader.prototype.parse = function(filename, data) {\n  var archData = JSON.parse(data);\n  var arch = this.archCreator.createArch(archData, {\n    filterElements: this.archFilter, groupRoomsToLevels: true });\n  return { json: archData, arch: arch };\n};\n\nArchLoader.prototype.loadAsScene = function(file, callback) {\n  var scope = this;\n  this.load(file, function(err, res) {\n    if (err) {\n      callback(err);\n    } else {\n      var sceneState = scope.archCreator.toSceneState(res.json, res.arch, true);\n      callback(null, sceneState);\n    }\n  });\n};\n\nmodule.exports = ArchLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/ArchLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/BasicLoader.js":
/*!***************************************!*\
  !*** ./js/lib/loaders/BasicLoader.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Basic loader\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction Loader(params) {\n  this.fs = params.fs;\n  this.debug = params.debug;\n  this.fileEncoding = params.fileEncoding || params.encoding || 'utf-8';\n  this.format = params.format;\n}\n\n/**\n * Load and parses house file\n * @param file\n * @param callback {function(err, Object)}\n */\nLoader.prototype.load = function(file, callback) {\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, this.fileEncoding, function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        var parsed = scope.parse(filename, data);\n        callback(null, parsed);\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\n/**\n * Parses data\n * @param filename\n * @param data\n * @returns Object\n */\nLoader.prototype.parse = function(filename, data) {\n  if (this.format === 'json') {\n    return JSON.parse(data);\n  } else {\n    return data;\n  }\n};\n\nmodule.exports = Loader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/BasicLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/BinvoxLoader.js":
/*!****************************************!*\
  !*** ./js/lib/loaders/BinvoxLoader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bitview = __webpack_require__(/*! bitview */ \"./js/vendor/jbinary/bitview.js\");\nvar BinaryView = __webpack_require__(/*! util/BinaryView */ \"./js/lib/util/BinaryView.js\");\n\n/**\n * BinvoxLoader\n * @constructor\n * @memberof loaders\n */\nvar BinvoxLoader = function () {\n};\n\n// binary is a jbinary object\nBinvoxLoader.prototype.parse = function (filename, binary) {\n  // here you can use `binary` instance to parse data\n  //console.log(binary);\n\n  var binvoxData = binary.view;\n  //\n  // read header\n  //\n  var grid = {\n    type: 'binvox',\n    worldToGrid: new THREE.Matrix4(),\n    gridToWorld: new THREE.Matrix4(),\n    labels: ['occupied'],\n    voxelSize: 1,\n    numVoxels: 0,\n    // Binvox specific fields\n    binvoxTranslate: new THREE.Vector3(),\n    binvoxScale: 1.0\n  };\n\n  var offset = 0;\n  var lineData = BinaryView.getLine(binvoxData, offset);\n  if (!lineData) {\n    console.error('Parsing binvox ' + filename + ': Empty binvox data');\n    return false;\n  }\n  var line = lineData.string;\n  if (!line.startsWith('#binvox')) {\n    console.error('Parsing binvox ' + filename + ': first line reads [' + line + '] instead of [#binvox]');\n    return false;\n  }\n\n  var versionString = line.substring(8);\n  var version = parseInt(versionString);\n  console.log('Parsing binvox ' + filename + ': Reading binvox version ' + version);\n\n  grid.depth = grid.height = grid.width = 0;\n  var done = false;\n  while (!done) {\n    lineData = BinaryView.getLine(binvoxData, lineData.next);\n    line = lineData.string;\n    if (line.startsWith('data')) {\n      done = true;\n    } else if (line.startsWith('dim')) {\n      var dimensions = line.split(' ');\n      grid.depth = parseInt(dimensions[1]);\n      grid.height = parseInt(dimensions[2]);\n      grid.width = parseInt(dimensions[3]);\n    } else if (line.startsWith('translate')) {\n      var translate = line.split(' ');\n      grid.binvoxTranslate.x = parseFloat(translate[1]);\n      grid.binvoxTranslate.y = parseFloat(translate[2]);\n      grid.binvoxTranslate.z = parseFloat(translate[3]);\n    } else if (line.startsWith('scale')) {\n      var scale = line.split(' ');\n      grid.binvoxScale = parseFloat(scale[1]);\n    } else {\n      console.warn('Parsing binvox ' + filename + ': unrecognized keyword [' + line + '], skipping');\n    }\n  }  // while\n\n  if (!done) {\n    console.error('Parsing binvox ' + filename + ':  error reading header');\n    return false;\n  }\n  if (grid.depth === 0) {\n    console.error('Parsing binvox ' + filename + ':  missing dimensions in header');\n    return false;\n  }\n\n  grid.size = grid.width * grid.height * grid.depth;\n  grid.dims = [grid.depth, grid.width, grid.height];\n  this.updateGridTransforms(grid);\n\n  // Store voxels as bit array backed by UInt8Array\n  // Number of bytes to allocate for voxels\n  // Can use ndarray\n  var nbytes = Math.ceil(grid.size / 8);\n  var voxelsBuffer = new Uint8Array(nbytes);\n  /* globals BitView */\n  grid.voxels = new BitView(voxelsBuffer.buffer);\n  grid.isVoxelSet = function (x, y, z) {\n    var vi = x * grid.width * grid.height + z * grid.width + y;\n    return (vi >= 0 && vi < grid.size) ? grid.voxels.getBit(vi) : 0;\n  };\n  grid.getVoxel = function (x, y, z) {\n    return grid.isVoxelSet(x,y,z);\n  };\n  grid.setVoxel = function (x, y, z, flag) {\n    var vi = x * grid.width * grid.height + z * grid.width + y;\n    if (vi >= 0 && vi < grid.size) {\n      grid.voxels.setBit(vi, flag);\n    }\n  };\n\n  //\n  // read voxel data\n  //\n  var value;\n  var count;\n  var index = 0;\n  var endIndex = 0;\n  var nVoxelsRead = 0;\n  var i;\n\n  binvoxData.seek(lineData.next);\n  while (endIndex < grid.size) {\n\n    value = binvoxData.getUint8();\n    count = binvoxData.getUint8();\n\n    endIndex = index + count;\n    if (endIndex > grid.size) {\n      console.error('More data than grid specified (endIndex:'+endIndex+' grid.size:'+grid.size);\n      return false;\n    }\n    for (i = index; i < endIndex; i++) {\n      grid.voxels.setBit(i, value);\n    }\n\n    if (value > 0) nVoxelsRead += count;\n    index = endIndex;\n\n  }  // while\n  grid.numVoxels = nVoxelsRead;\n\n  console.log('Parsing binvox ' + filename + ':  read ' + nVoxelsRead + ' voxels');\n  //console.log(grid);\n  return grid;\n};\n\nBinvoxLoader.prototype.updateGridTransforms = function (grid) {\n  // Take voxels to model space\n  // Rescale voxels to model space and translate\n  var maxVoxelDim = Math.max.apply(null, grid.dims); // Get max of array\n  var voxelScale = grid.binvoxScale / maxVoxelDim;\n\n  var quaternion = new THREE.Quaternion();\n  grid.gridToWorld.compose(grid.binvoxTranslate, quaternion,\n    new THREE.Vector3(voxelScale, voxelScale, voxelScale));\n  grid.worldToGrid.getInverse(grid.gridToWorld);\n  grid.voxelSize = voxelScale;\n};\n\nmodule.exports = BinvoxLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/BinvoxLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/ColladaLoader.js":
/*!*****************************************!*\
  !*** ./js/lib/loaders/ColladaLoader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Modified version of THREE.ColladaLoader from three.js r73\n * @author Tim Knip / http://www.floorplanner.com/ / tim at floorplanner.com\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n * @constructor\n * @memberOf loaders\n */\n\nTHREE.ColladaLoader = function (manager) {\n\n\tvar COLLADA = null;\n\tvar scene = null;\n\tvar visualScene;\n\tvar kinematicsModel;\n\n\tvar readyCallbackFunc = null;\n\n\tvar sources = {};\n\tvar images = {};\n\tvar animations = {};\n\tvar controllers = {};\n\tvar geometries = {};\n\tvar materials = {};\n\tvar effects = {};\n\tvar cameras = {};\n\tvar lights = {};\n\n\tvar animData;\n\tvar kinematics;\n\tvar visualScenes;\n\tvar kinematicsModels;\n\tvar baseUrl;\n\tvar morphs;\n\tvar skins;\n\tvar __reportedMessages = {};\n\n\tvar flip_uv = true;\n\tvar preferredShading = THREE.SmoothShading;\n\n\tvar options = {\n\t\t// Force Geometry to always be centered at the local origin of the\n\t\t// containing Mesh.\n\t\tcenterGeometry: false,\n\n\t\t// Axis conversion is done for geometries, animations, and controllers.\n\t\t// If we ever pull cameras or lights out of the COLLADA file, they'll\n\t\t// need extra work.\n\t\tconvertUpAxis: false,\n\n\t\tsubdivideFaces: true,\n\n\t\tupAxis: 'Y',\n\n\t\t// For reflective or refractive materials we'll use this cubemap\n\t\tdefaultEnvMap: null,\n\n\t\t// Manager (AXC)\n\t\tmanager: ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager,\n\n\t\t// If we want to skip lines (AXC)\n\t\tskipLines: false\n\n  };\n\n\tvar colladaUnit = 1.0;\n\tvar colladaUp = 'Y';\n\tvar upConversion = null;\n\n\tfunction load ( url, readyCallback, progressCallback, failCallback ) {\n\n\t\tvar length = 0;\n\n\t\tif ( document.implementation && document.implementation.createDocument ) {\n\n\t\t\tvar request = new XMLHttpRequest();\n\n\t\t\trequest.onreadystatechange = function() {\n\n\t\t\t\tif ( request.readyState === 4 ) {\n\n\t\t\t\t\tif ( request.status === 0 || request.status === 200 ) {\n\n\n\t\t\t\t\t\tif ( request.responseXML ) {\n\n\t\t\t\t\t\t\treadyCallbackFunc = readyCallback;\n\t\t\t\t\t\t\tparse( request.responseXML, undefined, url );\n\n\t\t\t\t\t\t} else if ( request.responseText ) {\n\n\t\t\t\t\t\t\treadyCallbackFunc = readyCallback;\n\t\t\t\t\t\t\tvar xmlParser = new DOMParser();\n\t\t\t\t\t\t\tvar responseXML = xmlParser.parseFromString( request.responseText, \"application/xml\" );\n\t\t\t\t\t\t\tparse( responseXML, undefined, url );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tif ( failCallback ) {\n\n\t\t\t\t\t\t\t\tfailCallback();\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tconsole.error( \"ColladaLoader: Empty or non-existing file (\" + url + \")\" );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( request.readyState === 3 ) {\n\n\t\t\t\t\tif ( progressCallback ) {\n\n\t\t\t\t\t\tif ( length === 0 ) {\n\n\t\t\t\t\t\t\tlength = request.getResponseHeader( \"Content-Length\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprogressCallback( { total: length, loaded: request.responseText.length } );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\trequest.open( \"GET\", url, true );\n\t\t\trequest.send( null );\n\n\t\t} else {\n\n\t\t\talert( \"Don't know how to parse XML!\" );\n\n\t\t}\n\n\t}\n\n\tfunction parse( doc, callBack, url ) {\n\n\t\tCOLLADA = doc;\n\t\tcallBack = callBack || readyCallbackFunc;\n\n\t\tif ( url !== undefined ) {\n\n\t\t\tvar parts = url.split( '/' );\n\t\t\tparts.pop();\n\t\t\tbaseUrl = ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';\n\n\t\t}\n\n\t\tparseAsset();\n\t\tsetUpConversion();\n\t\timages = parseLib( \"library_images image\", _Image, \"image\" );\n\t\tmaterials = parseLib( \"library_materials material\", Material, \"material\" );\n\t\teffects = parseLib( \"library_effects effect\", Effect, \"effect\" );\n\t\tgeometries = parseLib( \"library_geometries geometry\", Geometry, \"geometry\" );\n\t\tcameras = parseLib( \"library_cameras camera\", Camera, \"camera\" );\n\t\tlights = parseLib( \"library_lights light\", Light, \"light\" );\n\t\tcontrollers = parseLib( \"library_controllers controller\", Controller, \"controller\" );\n\t\tanimations = parseLib( \"library_animations animation\", Animation, \"animation\" );\n\t\tvisualScenes = parseLib( \"library_visual_scenes visual_scene\", VisualScene, \"visual_scene\" );\n\t\tkinematicsModels = parseLib( \"library_kinematics_models kinematics_model\", KinematicsModel, \"kinematics_model\" );\n\n\t\tmorphs = [];\n\t\tskins = [];\n\n\t\tvisualScene = parseScene();\n\t\tscene = new THREE.Group();\n\t\tscene.url = url;  // AXC: Keep track of scene url\n\n\t\tfor ( var i = 0; i < visualScene.nodes.length; i ++ ) {\n\n\t\t\tscene.add( createSceneGraph( visualScene.nodes[ i ] ) );\n\n\t\t}\n\n\t\t// unit conversion\n\t\tscene.scale.multiplyScalar( colladaUnit );\n\n\t\tcreateAnimations();\n\n\t\tkinematicsModel = parseKinematicsModel();\n\t\tcreateKinematics();\n\n\t\tvar result = {\n\n\t\t\tscene: scene,\n\t\t\tmorphs: morphs,\n\t\t\tskins: skins,\n\t\t\tanimations: animData,\n\t\t\tkinematics: kinematics,\n\t\t\tdae: {\n\t\t\t\tup: colladaUp,     // AXC: Add up\n\t\t\t\tunit: colladaUnit, // AXC: Add unit\n\t\t\t\timages: images,\n\t\t\t\tmaterials: materials,\n\t\t\t\tcameras: cameras,\n\t\t\t\tlights: lights,\n\t\t\t\teffects: effects,\n\t\t\t\tgeometries: geometries,\n\t\t\t\tcontrollers: controllers,\n\t\t\t\tanimations: animations,\n\t\t\t\tvisualScenes: visualScenes,\n\t\t\t\tvisualScene: visualScene,\n\t\t\t\tscene: visualScene,\n\t\t\t\tkinematicsModels: kinematicsModels,\n\t\t\t\tkinematicsModel: kinematicsModel\n\t\t\t}\n\n\t\t};\n\n\t\tif ( callBack ) {\n\n\t\t\tcallBack( result );\n\n\t\t}\n\n\t\treturn result;\n\n\t}\n\n\tfunction setPreferredShading ( shading ) {\n\n\t\tpreferredShading = shading;\n\n\t}\n\n\tfunction parseAsset () {\n\n\t\tvar elements = COLLADA.querySelectorAll('asset');\n\n\t\tvar element = elements[0];\n\n\t\tif ( element && element.childNodes ) {\n\n\t\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'unit':\n\n\t\t\t\t\t\tvar meter = child.getAttribute( 'meter' );\n\n\t\t\t\t\t\tif ( meter ) {\n\n\t\t\t\t\t\t\tcolladaUnit = parseFloat( meter );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'up_axis':\n\n\t\t\t\t\t\tcolladaUp = child.textContent.charAt(0);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction parseLib ( q, classSpec, prefix ) {\n\n\t\tvar elements = COLLADA.querySelectorAll(q);\n\n\t\tvar lib = {};\n\n\t\tvar i = 0;\n\n\t\tvar elementsLength = elements.length;\n\n\t\tfor ( var j = 0; j < elementsLength; j ++ ) {\n\n\t\t\tvar element = elements[j];\n\t\t\tvar daeElement = ( new classSpec() ).parse( element );\n\n\t\t\tif ( !daeElement.id || daeElement.id.length === 0 ) daeElement.id = prefix + ( i ++ );\n\t\t\tlib[ daeElement.id ] = daeElement;\n\n\t\t}\n\n\t\treturn lib;\n\n\t}\n\n\tfunction parseScene() {\n\n\t\tvar sceneElement = COLLADA.querySelectorAll('scene instance_visual_scene')[0];\n\n\t\tif ( sceneElement ) {\n\n\t\t\tvar url = sceneElement.getAttribute( 'url' ).replace( /^#/, '' );\n\t\t\treturn visualScenes[ url.length > 0 ? url : 'visual_scene0' ];\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tfunction parseKinematicsModel() {\n\n\t\tvar kinematicsModelElement = COLLADA.querySelectorAll('instance_kinematics_model')[0];\n\n\t\tif ( kinematicsModelElement ) {\n\n\t\t\tvar url = kinematicsModelElement.getAttribute( 'url' ).replace(/^#/, '');\n\t\t\treturn kinematicsModels[ url.length > 0 ? url : 'kinematics_model0' ];\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t}\n\n\tfunction createAnimations() {\n\n\t\tanimData = [];\n\n\t\t// fill in the keys\n\t\trecurseHierarchy( scene );\n\n\t}\n\n\tfunction recurseHierarchy( node ) {\n\n\t\tvar n = visualScene.getChildById( node.colladaId, true ),\n\t\t\tnewData = null;\n\n\t\tif ( n && n.keys ) {\n\n\t\t\tnewData = {\n\t\t\t\tfps: 60,\n\t\t\t\thierarchy: [ {\n\t\t\t\t\tnode: n,\n\t\t\t\t\tkeys: n.keys,\n\t\t\t\t\tsids: n.sids\n\t\t\t\t} ],\n\t\t\t\tnode: node,\n\t\t\t\tname: 'animation_' + node.name,\n\t\t\t\tlength: 0\n\t\t\t};\n\n\t\t\tanimData.push(newData);\n\n\t\t\tfor ( var i = 0, il = n.keys.length; i < il; i ++ ) {\n\n\t\t\t\tnewData.length = Math.max( newData.length, n.keys[i].time );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tnewData = {\n\t\t\t\thierarchy: [ {\n\t\t\t\t\tkeys: [],\n\t\t\t\t\tsids: []\n\t\t\t\t} ]\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0, il = node.children.length; i < il; i ++ ) {\n\n\t\t\tvar d = recurseHierarchy( node.children[i] );\n\n\t\t\tfor ( var j = 0, jl = d.hierarchy.length; j < jl; j ++ ) {\n\n\t\t\t\tnewData.hierarchy.push( {\n\t\t\t\t\tkeys: [],\n\t\t\t\t\tsids: []\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn newData;\n\n\t}\n\n\tfunction calcAnimationBounds () {\n\n\t\tvar start = 1000000;\n\t\tvar end = -start;\n\t\tvar frames = 0;\n\t\tvar ID;\n\t\tfor ( var id in animations ) {\n\n\t\t\tvar animation = animations[ id ];\n\t\t\tID = ID || animation.id;\n\t\t\tfor ( var i = 0; i < animation.sampler.length; i ++ ) {\n\n\t\t\t\tvar sampler = animation.sampler[ i ];\n\n\t\t\t\tsampler.create();\n\n\t\t\t\tstart = Math.min( start, sampler.startTime );\n\t\t\t\tend = Math.max( end, sampler.endTime );\n\t\t\t\tframes = Math.max( frames, sampler.input.length );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn { start:start, end:end, frames:frames,ID:ID };\n\n\t}\n\n\tfunction createMorph ( geometry, ctrl ) {\n\n\t\tvar morphCtrl = ctrl instanceof InstanceController ? controllers[ ctrl.url ] : ctrl;\n\n\t\tif ( !morphCtrl || !morphCtrl.morph ) {\n\n\t\t\tconsole.log(\"could not find morph controller!\");\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar morph = morphCtrl.morph;\n\n\t\tfor ( var i = 0; i < morph.targets.length; i ++ ) {\n\n\t\t\tvar target_id = morph.targets[ i ];\n\t\t\tvar daeGeometry = geometries[ target_id ];\n\n\t\t\tif ( !daeGeometry.mesh ||\n\t\t\t\t !daeGeometry.mesh.primitives ||\n\t\t\t\t !daeGeometry.mesh.primitives.length ) {\n\t\t\t\t continue;\n\t\t\t}\n\n\t\t\tvar target = daeGeometry.mesh.primitives[ 0 ].geometry;\n\n\t\t\tif ( target.vertices.length === geometry.vertices.length ) {\n\n\t\t\t\tgeometry.morphTargets.push( { name: \"target_1\", vertices: target.vertices } );\n\n\t\t\t}\n\n\t\t}\n\n\t\tgeometry.morphTargets.push( { name: \"target_Z\", vertices: geometry.vertices } );\n\n\t};\n\n\tfunction createSkin ( geometry, ctrl, applyBindShape ) {\n\n\t\tvar skinCtrl = controllers[ ctrl.url ];\n\n\t\tif ( !skinCtrl || !skinCtrl.skin ) {\n\n\t\t\tconsole.log( \"could not find skin controller!\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( !ctrl.skeleton || !ctrl.skeleton.length ) {\n\n\t\t\tconsole.log( \"could not find the skeleton for the skin!\" );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar skin = skinCtrl.skin;\n\t\tvar skeleton = visualScene.getChildById( ctrl.skeleton[ 0 ] );\n\t\tvar hierarchy = [];\n\n\t\tapplyBindShape = applyBindShape !== undefined ? applyBindShape : true;\n\n\t\tvar bones = [];\n\t\tgeometry.skinWeights = [];\n\t\tgeometry.skinIndices = [];\n\n\t\t//createBones( geometry.bones, skin, hierarchy, skeleton, null, -1 );\n\t\t//createWeights( skin, geometry.bones, geometry.skinIndices, geometry.skinWeights );\n\n\t\t/*\n\t\tgeometry.animation = {\n\t\t\tname: 'take_001',\n\t\t\tfps: 30,\n\t\t\tlength: 2,\n\t\t\tJIT: true,\n\t\t\thierarchy: hierarchy\n\t\t};\n\t\t*/\n\n\t\tif ( applyBindShape ) {\n\n\t\t\tfor ( var i = 0; i < geometry.vertices.length; i ++ ) {\n\n\t\t\t\tgeometry.vertices[ i ].applyMatrix4( skin.bindShapeMatrix );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction setupSkeleton ( node, bones, frame, parent ) {\n\n\t\tnode.world = node.world || new THREE.Matrix4();\n\t\tnode.localworld = node.localworld || new THREE.Matrix4();\n\t\tnode.world.copy( node.matrix );\n\t\tnode.localworld.copy( node.matrix );\n\n\t\tif ( node.channels && node.channels.length ) {\n\n\t\t\tvar channel = node.channels[ 0 ];\n\t\t\tvar m = channel.sampler.output[ frame ];\n\n\t\t\tif ( m instanceof THREE.Matrix4 ) {\n\n\t\t\t\tnode.world.copy( m );\n\t\t\t\tnode.localworld.copy(m);\n\t\t\t\tif (frame === 0)\n\t\t\t\t\tnode.matrix.copy(m);\n\t\t\t}\n\n\t\t}\n\n\t\tif ( parent ) {\n\n\t\t\tnode.world.multiplyMatrices( parent, node.world );\n\n\t\t}\n\n\t\tbones.push( node );\n\n\t\tfor ( var i = 0; i < node.nodes.length; i ++ ) {\n\n\t\t\tsetupSkeleton( node.nodes[ i ], bones, frame, node.world );\n\n\t\t}\n\n\t}\n\n\tfunction setupSkinningMatrices ( bones, skin ) {\n\n\t\t// FIXME: this is dumb...\n\n\t\tfor ( var i = 0; i < bones.length; i ++ ) {\n\n\t\t\tvar bone = bones[ i ];\n\t\t\tvar found = -1;\n\n\t\t\tif ( bone.type != 'JOINT' ) continue;\n\n\t\t\tfor ( var j = 0; j < skin.joints.length; j ++ ) {\n\n\t\t\t\tif ( bone.sid === skin.joints[ j ] ) {\n\n\t\t\t\t\tfound = j;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( found >= 0 ) {\n\n\t\t\t\tvar inv = skin.invBindMatrices[ found ];\n\n\t\t\t\tbone.invBindMatrix = inv;\n\t\t\t\tbone.skinningMatrix = new THREE.Matrix4();\n\t\t\t\tbone.skinningMatrix.multiplyMatrices(bone.world, inv); // (IBMi * JMi)\n\t\t\t\tbone.animatrix = new THREE.Matrix4();\n\n\t\t\t\tbone.animatrix.copy(bone.localworld);\n\t\t\t\tbone.weights = [];\n\n\t\t\t\tfor ( var j = 0; j < skin.weights.length; j ++ ) {\n\n\t\t\t\t\tfor (var k = 0; k < skin.weights[ j ].length; k ++ ) {\n\n\t\t\t\t\t\tvar w = skin.weights[ j ][ k ];\n\n\t\t\t\t\t\tif ( w.joint === found ) {\n\n\t\t\t\t\t\t\tbone.weights.push( w );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( \"ColladaLoader: Could not find joint '\" + bone.sid + \"'.\" );\n\n\t\t\t\tbone.skinningMatrix = new THREE.Matrix4();\n\t\t\t\tbone.weights = [];\n\n\t\t\t}\n\t\t}\n\n\t}\n\n\t//Walk the Collada tree and flatten the bones into a list, extract the position, quat and scale from the matrix\n\tfunction flattenSkeleton(skeleton) {\n\n\t\tvar list = [];\n\t\tvar walk = function(parentid, node, list) {\n\n\t\t\tvar bone = {};\n\t\t\tbone.name = node.sid;\n\t\t\tbone.parent = parentid;\n\t\t\tbone.matrix = node.matrix;\n\t\t\tvar data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];\n\t\t\tif (bone.matrix) {\n\t\t\t\tbone.matrix.decompose(data[0], data[1], data[2]);\n\t\t\t}\n\n\t\t\tbone.pos = [ data[0].x,data[0].y,data[0].z ];\n\n\t\t\tbone.scl = [ data[2].x,data[2].y,data[2].z ];\n\t\t\tbone.rotq = [ data[1].x,data[1].y,data[1].z,data[1].w ];\n\t\t\tlist.push(bone);\n\n\t\t\tfor (var i in node.nodes) {\n\n\t\t\t\twalk(node.sid, node.nodes[i], list);\n\n\t\t\t}\n\n\t\t};\n\n\t\twalk(-1, skeleton, list);\n\t\treturn list;\n\n\t}\n\n\t//Move the vertices into the pose that is proper for the start of the animation\n\tfunction skinToBindPose(geometry,skeleton,skinController) {\n\n\t\tvar bones = [];\n\t\tsetupSkeleton( skeleton, bones, -1 );\n\t\tsetupSkinningMatrices( bones, skinController.skin );\n\t\tvar v = new THREE.Vector3();\n\t\tvar skinned = [];\n\n\t\tfor (var i = 0; i < geometry.vertices.length; i ++) {\n\n\t\t\tskinned.push(new THREE.Vector3());\n\n\t\t}\n\n\t\tfor ( i = 0; i < bones.length; i ++ ) {\n\n\t\t\tif ( bones[ i ].type != 'JOINT' ) continue;\n\n\t\t\tfor ( var j = 0; j < bones[ i ].weights.length; j ++ ) {\n\n\t\t\t\tvar w = bones[ i ].weights[ j ];\n\t\t\t\tvar vidx = w.index;\n\t\t\t\tvar weight = w.weight;\n\n\t\t\t\tvar o = geometry.vertices[vidx];\n\t\t\t\tvar s = skinned[vidx];\n\n\t\t\t\tv.x = o.x;\n\t\t\t\tv.y = o.y;\n\t\t\t\tv.z = o.z;\n\n\t\t\t\tv.applyMatrix4( bones[i].skinningMatrix );\n\n\t\t\t\ts.x += (v.x * weight);\n\t\t\t\ts.y += (v.y * weight);\n\t\t\t\ts.z += (v.z * weight);\n\t\t\t}\n\n\t\t}\n\n\t\tfor (var i = 0; i < geometry.vertices.length; i ++) {\n\n\t\t\tgeometry.vertices[i] = skinned[i];\n\n\t\t}\n\n\t}\n\n\tfunction applySkin ( geometry, instanceCtrl, frame ) {\n\n\t\tvar skinController = controllers[ instanceCtrl.url ];\n\n\t\tframe = frame !== undefined ? frame : 40;\n\n\t\tif ( !skinController || !skinController.skin ) {\n\n\t\t\tconsole.log( 'ColladaLoader: Could not find skin controller.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( !instanceCtrl.skeleton || !instanceCtrl.skeleton.length ) {\n\n\t\t\tconsole.log( 'ColladaLoader: Could not find the skeleton for the skin. ' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar animationBounds = calcAnimationBounds();\n\t\tvar skeleton = visualScene.getChildById( instanceCtrl.skeleton[0], true ) || visualScene.getChildBySid( instanceCtrl.skeleton[0], true );\n\n\t\t//flatten the skeleton into a list of bones\n\t\tvar bonelist = flattenSkeleton(skeleton);\n\t\tvar joints = skinController.skin.joints;\n\n\t\t//sort that list so that the order reflects the order in the joint list\n\t\tvar sortedbones = [];\n\t\tfor (var i = 0; i < joints.length; i ++) {\n\n\t\t\tfor (var j = 0; j < bonelist.length; j ++) {\n\n\t\t\t\tif (bonelist[j].name === joints[i]) {\n\n\t\t\t\t\tsortedbones[i] = bonelist[j];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t//hook up the parents by index instead of name\n\t\tfor (var i = 0; i < sortedbones.length; i ++) {\n\n\t\t\tfor (var j = 0; j < sortedbones.length; j ++) {\n\n\t\t\t\tif (sortedbones[i].parent === sortedbones[j].name) {\n\n\t\t\t\t\tsortedbones[i].parent = j;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar i, j, w, vidx, weight;\n\t\tvar v = new THREE.Vector3(), o, s;\n\n\t\t// move vertices to bind shape\n\t\tfor ( i = 0; i < geometry.vertices.length; i ++ ) {\n\t\t\tgeometry.vertices[i].applyMatrix4( skinController.skin.bindShapeMatrix );\n\t\t}\n\n\t\tvar skinIndices = [];\n\t\tvar skinWeights = [];\n\t\tvar weights = skinController.skin.weights;\n\n\t\t// hook up the skin weights\n\t\t// TODO - this might be a good place to choose greatest 4 weights\n\t\tfor ( var i =0; i < weights.length; i ++ ) {\n\n\t\t\tvar indicies = new THREE.Vector4(weights[i][0] ? weights[i][0].joint : 0,weights[i][1] ? weights[i][1].joint : 0,weights[i][2] ? weights[i][2].joint : 0,weights[i][3] ? weights[i][3].joint : 0);\n\t\t\tvar weight = new THREE.Vector4(weights[i][0] ? weights[i][0].weight : 0,weights[i][1] ? weights[i][1].weight : 0,weights[i][2] ? weights[i][2].weight : 0,weights[i][3] ? weights[i][3].weight : 0);\n\n\t\t\tskinIndices.push(indicies);\n\t\t\tskinWeights.push(weight);\n\n\t\t}\n\n\t\tgeometry.skinIndices = skinIndices;\n\t\tgeometry.skinWeights = skinWeights;\n\t\tgeometry.bones = sortedbones;\n\t\t// process animation, or simply pose the rig if no animation\n\n\t\t//create an animation for the animated bones\n\t\t//NOTE: this has no effect when using morphtargets\n\t\tvar animationdata = { \"name\":animationBounds.ID,\"fps\":30,\"length\":animationBounds.frames / 30,\"hierarchy\":[] };\n\n\t\tfor (var j = 0; j < sortedbones.length; j ++) {\n\n\t\t\tanimationdata.hierarchy.push({ parent:sortedbones[j].parent, name:sortedbones[j].name, keys:[] });\n\n\t\t}\n\n\t\tconsole.log( 'ColladaLoader:', animationBounds.ID + ' has ' + sortedbones.length + ' bones.' );\n\n\n\n\t\tskinToBindPose(geometry, skeleton, skinController);\n\n\n\t\tfor ( frame = 0; frame < animationBounds.frames; frame ++ ) {\n\n\t\t\tvar bones = [];\n\t\t\tvar skinned = [];\n\t\t\t// process the frame and setup the rig with a fresh\n\t\t\t// transform, possibly from the bone's animation channel(s)\n\n\t\t\tsetupSkeleton( skeleton, bones, frame );\n\t\t\tsetupSkinningMatrices( bones, skinController.skin );\n\n\t\t\tfor (var i = 0; i < bones.length; i ++) {\n\n\t\t\t\tfor (var j = 0; j < animationdata.hierarchy.length; j ++) {\n\n\t\t\t\t\tif (animationdata.hierarchy[j].name === bones[i].sid) {\n\n\t\t\t\t\t\tvar key = {};\n\t\t\t\t\t\tkey.time = (frame / 30);\n\t\t\t\t\t\tkey.matrix = bones[i].animatrix;\n\n\t\t\t\t\t\tif (frame === 0)\n\t\t\t\t\t\t\tbones[i].matrix = key.matrix;\n\n\t\t\t\t\t\tvar data = [ new THREE.Vector3(),new THREE.Quaternion(),new THREE.Vector3() ];\n\t\t\t\t\t\tkey.matrix.decompose(data[0], data[1], data[2]);\n\n\t\t\t\t\t\tkey.pos = [ data[0].x,data[0].y,data[0].z ];\n\n\t\t\t\t\t\tkey.scl = [ data[2].x,data[2].y,data[2].z ];\n\t\t\t\t\t\tkey.rot = data[1];\n\n\t\t\t\t\t\tanimationdata.hierarchy[j].keys.push(key);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgeometry.animation = animationdata;\n\n\t\t}\n\n\t};\n\n\tfunction createKinematics() {\n\n\t\tif ( kinematicsModel && kinematicsModel.joints.length === 0 ) {\n\t\t\tkinematics = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tvar jointMap = {};\n\n\t\tvar _addToMap = function( jointIndex, parentVisualElement ) {\n\n\t\t\tvar parentVisualElementId = parentVisualElement.getAttribute( 'id' );\n\t\t\tvar colladaNode = visualScene.getChildById( parentVisualElementId, true );\n\t\t\tvar joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\tscene.traverse(function( node ) {\n\n\t\t\t\tif ( node.colladaId == parentVisualElementId ) {\n\n\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\tnode: node,\n\t\t\t\t\t\ttransforms: colladaNode.transforms,\n\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t};\n\n\t\t\t\t}\n\n\t\t\t});\n\n\t\t};\n\n\t\tkinematics = {\n\n\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\tgetJointValue: function( jointIndex ) {\n\n\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.log( 'getJointValue: joint ' + jointIndex + ' doesn\\'t exist' );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tsetJointValue: function( jointIndex, value ) {\n\n\t\t\t\tvar jointData = jointMap[ jointIndex ];\n\n\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\tvar joint = jointData.joint;\n\n\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\tconsole.log( 'setJointValue: joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ')' );\n\n\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\tconsole.log( 'setJointValue: joint ' + jointIndex + ' is static' );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar threejsNode = jointData.node;\n\t\t\t\t\t\tvar axis = joint.axis;\n\t\t\t\t\t\tvar transforms = jointData.transforms;\n\n\t\t\t\t\t\tvar matrix = new THREE.Matrix4();\n\n\t\t\t\t\t\tfor (i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\tvar transform = transforms[ i ];\n\n\t\t\t\t\t\t\t// kinda ghetto joint detection\n\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( 'joint' + jointIndex ) !== -1 ) {\n\n\t\t\t\t\t\t\t\t// apply actual joint value here\n\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\tcase 'revolute':\n\n\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m1.makeRotationAxis( axis, THREE.Math.degToRad(value) ) );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\n\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m1.makeTranslation(axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'setJointValue: unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tvar m1 = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m1.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m1.makeRotationAxis( transform.obj, transform.angle ) );\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// apply the matrix to the threejs node\n\t\t\t\t\t\tvar elementsFloat32Arr = matrix.elements;\n\t\t\t\t\t\tvar elements = Array.prototype.slice.call( elementsFloat32Arr );\n\n\t\t\t\t\t\tvar elementsRowMajor = [\n\t\t\t\t\t\t\telements[ 0 ],\n\t\t\t\t\t\t\telements[ 4 ],\n\t\t\t\t\t\t\telements[ 8 ],\n\t\t\t\t\t\t\telements[ 12 ],\n\t\t\t\t\t\t\telements[ 1 ],\n\t\t\t\t\t\t\telements[ 5 ],\n\t\t\t\t\t\t\telements[ 9 ],\n\t\t\t\t\t\t\telements[ 13 ],\n\t\t\t\t\t\t\telements[ 2 ],\n\t\t\t\t\t\t\telements[ 6 ],\n\t\t\t\t\t\t\telements[ 10 ],\n\t\t\t\t\t\t\telements[ 14 ],\n\t\t\t\t\t\t\telements[ 3 ],\n\t\t\t\t\t\t\telements[ 7 ],\n\t\t\t\t\t\t\telements[ 11 ],\n\t\t\t\t\t\t\telements[ 15 ]\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tthreejsNode.matrix.set.apply( threejsNode.matrix, elementsRowMajor );\n\t\t\t\t\t\tthreejsNode.matrix.decompose( threejsNode.position, threejsNode.quaternion, threejsNode.scale );\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.log( 'setJointValue: joint ' + jointIndex + ' doesn\\'t exist' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tvar element = COLLADA.querySelector('scene instance_kinematics_scene');\n\n\t\tif ( element ) {\n\n\t\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\n\t\t\t\t\t\tvar visualTarget = child.getAttribute( 'target' ).split( '/' ).pop();\n\t\t\t\t\t\tvar axis = child.querySelector('axis param').textContent;\n\t\t\t\t\t\tvar jointIndex = parseInt( axis.split( 'joint' ).pop().split( '.' )[0] );\n\t\t\t\t\t\tvar visualTargetElement = COLLADA.querySelector( '[sid=\"' + visualTarget + '\"]' );\n\n\t\t\t\t\t\tif ( visualTargetElement ) {\n\t\t\t\t\t\t\tvar parentVisualElement = visualTargetElement.parentElement;\n\t\t\t\t\t\t\t_addToMap(jointIndex, parentVisualElement);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t};\n\n\tfunction createSceneGraph ( node, parent ) {\n\n\t\tvar obj = new THREE.Group();  // AXC: Use Group\n\t\tvar skinned = false;\n\t\tvar skinController;\n\t\tvar morphController;\n\t\tvar i, j;\n\n\t\t// FIXME: controllers\n\n\t\tfor ( i = 0; i < node.controllers.length; i ++ ) {\n\n\t\t\tvar controller = controllers[ node.controllers[ i ].url ];\n\n\t\t\tswitch ( controller.type ) {\n\n\t\t\t\tcase 'skin':\n\n\t\t\t\t\tif ( geometries[ controller.skin.source ] ) {\n\n\t\t\t\t\t\tvar inst_geom = new InstanceGeometry();\n\n\t\t\t\t\t\tinst_geom.url = controller.skin.source;\n\t\t\t\t\t\tinst_geom.instance_material = node.controllers[ i ].instance_material;\n\n\t\t\t\t\t\tnode.geometries.push( inst_geom );\n\t\t\t\t\t\tskinned = true;\n\t\t\t\t\t\tskinController = node.controllers[ i ];\n\n\t\t\t\t\t} else if ( controllers[ controller.skin.source ] ) {\n\n\t\t\t\t\t\t// urgh: controller can be chained\n\t\t\t\t\t\t// handle the most basic case...\n\n\t\t\t\t\t\tvar second = controllers[ controller.skin.source ];\n\t\t\t\t\t\tmorphController = second;\n\t\t\t\t\t//\tskinController = node.controllers[i];\n\n\t\t\t\t\t\tif ( second.morph && geometries[ second.morph.source ] ) {\n\n\t\t\t\t\t\t\tvar inst_geom = new InstanceGeometry();\n\n\t\t\t\t\t\t\tinst_geom.url = second.morph.source;\n\t\t\t\t\t\t\tinst_geom.instance_material = node.controllers[ i ].instance_material;\n\n\t\t\t\t\t\t\tnode.geometries.push( inst_geom );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'morph':\n\n\t\t\t\t\tif ( geometries[ controller.morph.source ] ) {\n\n\t\t\t\t\t\tvar inst_geom = new InstanceGeometry();\n\n\t\t\t\t\t\tinst_geom.url = controller.morph.source;\n\t\t\t\t\t\tinst_geom.instance_material = node.controllers[ i ].instance_material;\n\n\t\t\t\t\t\tnode.geometries.push( inst_geom );\n\t\t\t\t\t\tmorphController = node.controllers[ i ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconsole.log( 'ColladaLoader: Morph-controller partially supported.' );\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// geometries\n\n\t\tvar double_sided_materials = {};\n\n\t\tfor ( i = 0; i < node.geometries.length; i ++ ) {\n\n\t\t\tvar instance_geometry = node.geometries[i];\n\t\t\tvar instance_materials = instance_geometry.instance_material;\n\t\t\tvar geometry = geometries[ instance_geometry.url ];\n\t\t\tvar used_materials = {};\n\t\t\tvar used_materials_array = [];\n\t\t\tvar num_materials = 0;\n\t\t\tvar first_material;\n\n\t\t\tif ( geometry ) {\n\n\t\t\t\tif ( !geometry.mesh || !geometry.mesh.primitives )\n\t\t\t\t\tcontinue;\n\n\t\t\t\tif ( obj.name.length === 0 ) {\n\n\t\t\t\t\tobj.name = geometry.id;\n\n\t\t\t\t}\n\n\t\t\t\t// collect used fx for this geometry-instance\n\n\t\t\t\tif ( instance_materials ) {\n\n\t\t\t\t\tfor ( j = 0; j < instance_materials.length; j ++ ) {\n\n\t\t\t\t\t\tvar instance_material = instance_materials[ j ];\n\t\t\t\t\t\tvar mat = materials[ instance_material.target ];\n\t\t\t\t\t\tvar effect_id = mat.instance_effect.url;\n\t\t\t\t\t\tvar shader = effects[ effect_id ].shader;\n\t\t\t\t\t\tvar material3js = shader.material;\n\n\t\t\t\t\t\tif ( geometry.doubleSided ) {\n\n\t\t\t\t\t\t\tif ( !( instance_material.symbol in double_sided_materials ) ) {\n\n\t\t\t\t\t\t\t\tvar _copied_material = material3js.clone();\n\t\t\t\t\t\t\t\t_copied_material.side = THREE.DoubleSide;\n\t\t\t\t\t\t\t\tdouble_sided_materials[ instance_material.symbol ] = _copied_material;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial3js = double_sided_materials[ instance_material.symbol ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterial3js.opacity = !material3js.opacity ? 1 : material3js.opacity;\n\t\t\t\t\t\tused_materials[ instance_material.symbol ] = num_materials;\n\t\t\t\t\t\tused_materials_array.push( material3js );\n\t\t\t\t\t\tfirst_material = material3js;\n\t\t\t\t\t\tfirst_material.name = mat.name === null || mat.name === '' ? mat.id : mat.name;\n\t\t\t\t\t\tnum_materials ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar mesh;\n\t\t\t\tvar material = first_material || new THREE.MeshPhongMaterial( { color: 0xdddddd, side: geometry.doubleSided ? THREE.DoubleSide : THREE.FrontSide } );\n\t\t\t\tvar geom = geometry.mesh.geometry3js;\n\n\t\t\t\tif ( num_materials > 1 ) {\n\n\t\t\t\t\tmaterial = new THREE.MultiMaterial( used_materials_array );\n\n\t\t\t\t\tvar defaultMaterialIndex;\n\t\t\t\t\tvar warned_materials = {};\n\t\t\t\t\tfor ( j = 0; j < geom.faces.length; j ++ ) {\n\n\t\t\t\t\t\tvar face = geom.faces[ j ];\n\t\t\t\t\t\tface.materialIndex = used_materials[ face.daeMaterial ];\n\t\t\t\t\t\t// AXC: Log error and use default material\n\t\t\t\t\t\tif (face.materialIndex === undefined && !warned_materials[face.daeMaterial]) {\n\t\t\t\t\t\t\tconsole.warn('Unknown material when loading collada model', face.daeMaterial);\n\t\t\t\t\t\t\twarned_materials[face.daeMaterial] = 1;\n\t\t\t\t\t\t\tif (defaultMaterialIndex == undefined) {\n\t\t\t\t\t\t\t\tdefaultMaterialIndex = used_materials_array.length;\n\t\t\t\t\t\t\t\tused_materials_array.push(options.defaultMaterial);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tused_materials[ face.daeMaterial ] = defaultMaterialIndex;\n\t\t\t\t\t\t\tface.materialIndex = defaultMaterialIndex;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( skinController !== undefined ) {\n\n\n\t\t\t\t\tapplySkin( geom, skinController );\n\n\t\t\t\t\tif ( geom.morphTargets.length > 0 ) {\n\n\t\t\t\t\t\tmaterial.morphTargets = true;\n\t\t\t\t\t\tmaterial.skinning = false;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial.morphTargets = false;\n\t\t\t\t\t\tmaterial.skinning = true;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tmesh = new THREE.SkinnedMesh( geom, material, false );\n\n\n\t\t\t\t\t//mesh.skeleton = skinController.skeleton;\n\t\t\t\t\t//mesh.skinController = controllers[ skinController.url ];\n\t\t\t\t\t//mesh.skinInstanceController = skinController;\n\t\t\t\t\tmesh.name = 'skin_' + skins.length;\n\n\n\n\t\t\t\t\t//mesh.animationHandle.setKey(0);\n\t\t\t\t\tskins.push( mesh );\n\n\t\t\t\t} else if ( morphController !== undefined ) {\n\n\t\t\t\t\tcreateMorph( geom, morphController );\n\n\t\t\t\t\tmaterial.morphTargets = true;\n\n\t\t\t\t\tmesh = new THREE.Mesh( geom, material );\n\t\t\t\t\tmesh.name = 'morph_' + morphs.length;\n\n\t\t\t\t\tmorphs.push( mesh );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmesh = new THREE.Mesh( geom, material );\n\n\t\t\t\t}\n\n\t\t\t\tif (geom.faces.length) {\n                    obj.add(mesh);\n                }\n\n                // AXC: Handle lines separately\n                if (!options.skipLines) {\n                    for (var gi = 0; gi < geometry.mesh.lineGeometries.length; gi++) {\n                        var geom = geometry.mesh.lineGeometries[gi];\n                        if (geom.isLineStrip === true) {\n\n                            mesh = new THREE.Line(geom); // drawn using gl.LINE_STRIP (vertices keep going to next)\n                            mesh.material.color.set(material.color);\n                            mesh.material.transparent = material.transparent;\n                            mesh.material.opacity = material.opacity;\n\n                        } else if (geom.isLine === true) {\n                            // AXC: Handle line strip vs line  // drawn using gl.LINE (pairs of vertices)\n                            mesh = new THREE.LineSegments(geom);\n                            // AXC: Set line color and opacity\n                            mesh.material.color.set(material.color);\n                            mesh.material.transparent = material.transparent;\n                            mesh.material.opacity = material.opacity;\n                        }\n                        obj.add(mesh);\n                    }\n                }\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = 0; i < node.cameras.length; i ++ ) {\n\n\t\t\tvar instance_camera = node.cameras[i];\n\t\t\tvar cparams = cameras[instance_camera.url];\n\n\t\t\tvar cam = new THREE.PerspectiveCamera(cparams.yfov, parseFloat(cparams.aspect_ratio),\n\t\t\t\t\tparseFloat(cparams.znear), parseFloat(cparams.zfar));\n\n\t\t\tobj.add(cam);\n\t\t}\n\n\t\tfor ( i = 0; i < node.lights.length; i ++ ) {\n\n\t\t\tvar light = null;\n\t\t\tvar instance_light = node.lights[i];\n\t\t\tvar lparams = lights[instance_light.url];\n\n\t\t\tif ( lparams && lparams.technique ) {\n\n\t\t\t\tvar color = lparams.color.getHex();\n\t\t\t\tvar intensity = lparams.intensity;\n\t\t\t\tvar distance = lparams.distance;\n\t\t\t\tvar angle = lparams.falloff_angle;\n\t\t\t\tvar exponent; // Intentionally undefined, don't know what this is yet\n\n\t\t\t\tswitch ( lparams.technique ) {\n\n\t\t\t\t\tcase 'directional':\n\n\t\t\t\t\t\tlight = new THREE.DirectionalLight( color, intensity, distance );\n\t\t\t\t\t\tlight.position.set(0, 0, 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'point':\n\n\t\t\t\t\t\tlight = new THREE.PointLight( color, intensity, distance );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'spot':\n\n\t\t\t\t\t\tlight = new THREE.SpotLight( color, intensity, distance, angle, exponent );\n\t\t\t\t\t\tlight.position.set(0, 0, 1);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tlight = new THREE.AmbientLight( color );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (light) {\n\t\t\t\tobj.add(light);\n\t\t\t}\n\t\t}\n\n\t\tobj.name = node.name || node.id || \"\";\n\t\tobj.colladaId = node.id || \"\";\n\t\tobj.layer = node.layer || \"\";\n\t\tobj.matrix = node.matrix;\n\t\tobj.matrix.decompose( obj.position, obj.quaternion, obj.scale );\n\n\t\tif ( options.centerGeometry && obj.geometry ) {\n\n\t\t\tvar delta = obj.geometry.center();\n\t\t\tdelta.multiply( obj.scale );\n\t\t\tdelta.applyQuaternion( obj.quaternion );\n\n\t\t\tobj.position.sub( delta );\n\n\t\t}\n\n\t\tfor ( i = 0; i < node.nodes.length; i ++ ) {\n\n\t\t\tobj.add( createSceneGraph( node.nodes[i], node ) );\n\n\t\t}\n\n\t\treturn obj;\n\n\t};\n\n\tfunction getJointId( skin, id ) {\n\n\t\tfor ( var i = 0; i < skin.joints.length; i ++ ) {\n\n\t\t\tif ( skin.joints[ i ] === id ) {\n\n\t\t\t\treturn i;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction getLibraryNode( id ) {\n\n\t\tvar nodes = COLLADA.querySelectorAll('library_nodes node');\n\n\t\tfor ( var i = 0; i < nodes.length; i++ ) {\n\n\t\t\tvar attObj = nodes[i].attributes.getNamedItem('id');\n\n\t\t\tif ( attObj && attObj.value === id ) {\n\n\t\t\t\treturn nodes[i];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn undefined;\n\n\t};\n\n\tfunction getChannelsForNode ( node ) {\n\n\t\tvar channels = [];\n\t\tvar startTime = 1000000;\n\t\tvar endTime = -1000000;\n\n\t\tfor ( var id in animations ) {\n\n\t\t\tvar animation = animations[id];\n\n\t\t\tfor ( var i = 0; i < animation.channel.length; i ++ ) {\n\n\t\t\t\tvar channel = animation.channel[i];\n\t\t\t\tvar sampler = animation.sampler[i];\n\t\t\t\tvar id = channel.target.split('/')[0];\n\n\t\t\t\tif ( id == node.id ) {\n\n\t\t\t\t\tsampler.create();\n\t\t\t\t\tchannel.sampler = sampler;\n\t\t\t\t\tstartTime = Math.min(startTime, sampler.startTime);\n\t\t\t\t\tendTime = Math.max(endTime, sampler.endTime);\n\t\t\t\t\tchannels.push(channel);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( channels.length ) {\n\n\t\t\tnode.startTime = startTime;\n\t\t\tnode.endTime = endTime;\n\n\t\t}\n\n\t\treturn channels;\n\n\t};\n\n\tfunction calcFrameDuration( node ) {\n\n\t\tvar minT = 10000000;\n\n\t\tfor ( var i = 0; i < node.channels.length; i ++ ) {\n\n\t\t\tvar sampler = node.channels[i].sampler;\n\n\t\t\tfor ( var j = 0; j < sampler.input.length - 1; j ++ ) {\n\n\t\t\t\tvar t0 = sampler.input[ j ];\n\t\t\t\tvar t1 = sampler.input[ j + 1 ];\n\t\t\t\tminT = Math.min( minT, t1 - t0 );\n\n\t\t\t}\n\t\t}\n\n\t\treturn minT;\n\n\t};\n\n\tfunction calcMatrixAt( node, t ) {\n\n\t\tvar animated = {};\n\n\t\tvar i, j;\n\n\t\tfor ( i = 0; i < node.channels.length; i ++ ) {\n\n\t\t\tvar channel = node.channels[ i ];\n\t\t\tanimated[ channel.sid ] = channel;\n\n\t\t}\n\n\t\tvar matrix = new THREE.Matrix4();\n\n\t\tfor ( i = 0; i < node.transforms.length; i ++ ) {\n\n\t\t\tvar transform = node.transforms[ i ];\n\t\t\tvar channel = animated[ transform.sid ];\n\n\t\t\tif ( channel !== undefined ) {\n\n\t\t\t\tvar sampler = channel.sampler;\n\t\t\t\tvar value;\n\n\t\t\t\tfor ( j = 0; j < sampler.input.length - 1; j ++ ) {\n\n\t\t\t\t\tif ( sampler.input[ j + 1 ] > t ) {\n\n\t\t\t\t\t\tvalue = sampler.output[ j ];\n\t\t\t\t\t\t//console.log(value.flatten)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( value !== undefined ) {\n\n\t\t\t\t\tif ( value instanceof THREE.Matrix4 ) {\n\n\t\t\t\t\t\tmatrix.multiplyMatrices( matrix, value );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// FIXME: handle other types\n\n\t\t\t\t\t\tmatrix.multiplyMatrices( matrix, transform.matrix );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmatrix.multiplyMatrices( matrix, transform.matrix );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tmatrix.multiplyMatrices( matrix, transform.matrix );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn matrix;\n\n\t};\n\n\tfunction bakeAnimations ( node ) {\n\n\t\tif ( node.channels && node.channels.length ) {\n\n\t\t\tvar keys = [],\n\t\t\t\tsids = [];\n\n\t\t\tfor ( var i = 0, il = node.channels.length; i < il; i ++ ) {\n\n\t\t\t\tvar channel = node.channels[i],\n\t\t\t\t\tfullSid = channel.fullSid,\n\t\t\t\t\tsampler = channel.sampler,\n\t\t\t\t\tinput = sampler.input,\n\t\t\t\t\ttransform = node.getTransformBySid( channel.sid ),\n\t\t\t\t\tmember;\n\n\t\t\t\tif ( channel.arrIndices ) {\n\n\t\t\t\t\tmember = [];\n\n\t\t\t\t\tfor ( var j = 0, jl = channel.arrIndices.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tmember[ j ] = getConvertedIndex( channel.arrIndices[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmember = getConvertedMember( channel.member );\n\n\t\t\t\t}\n\n\t\t\t\tif ( transform ) {\n\n\t\t\t\t\tif ( sids.indexOf( fullSid ) === -1 ) {\n\n\t\t\t\t\t\tsids.push( fullSid );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0, jl = input.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar time = input[j],\n\t\t\t\t\t\t\tdata = sampler.getData( transform.type, j, member ),\n\t\t\t\t\t\t\tkey = findKey( keys, time );\n\n\t\t\t\t\t\tif ( !key ) {\n\n\t\t\t\t\t\t\tkey = new Key( time );\n\t\t\t\t\t\t\tvar timeNdx = findTimeNdx( keys, time );\n\t\t\t\t\t\t\tkeys.splice( timeNdx === -1 ? keys.length : timeNdx, 0, key );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tkey.addTarget( fullSid, transform, member, data );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.log( 'Could not find transform \"' + channel.sid + '\" in node ' + node.id );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// post process\n\t\t\tfor ( var i = 0; i < sids.length; i ++ ) {\n\n\t\t\t\tvar sid = sids[ i ];\n\n\t\t\t\tfor ( var j = 0; j < keys.length; j ++ ) {\n\n\t\t\t\t\tvar key = keys[ j ];\n\n\t\t\t\t\tif ( !key.hasTarget( sid ) ) {\n\n\t\t\t\t\t\tinterpolateKeys( keys, key, j, sid );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnode.keys = keys;\n\t\t\tnode.sids = sids;\n\n\t\t}\n\n\t};\n\n\tfunction findKey ( keys, time) {\n\n\t\tvar retVal = null;\n\n\t\tfor ( var i = 0, il = keys.length; i < il && retVal === null; i ++ ) {\n\n\t\t\tvar key = keys[i];\n\n\t\t\tif ( key.time === time ) {\n\n\t\t\t\tretVal = key;\n\n\t\t\t} else if ( key.time > time ) {\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn retVal;\n\n\t};\n\n\tfunction findTimeNdx ( keys, time) {\n\n\t\tvar ndx = -1;\n\n\t\tfor ( var i = 0, il = keys.length; i < il && ndx === -1; i ++ ) {\n\n\t\t\tvar key = keys[i];\n\n\t\t\tif ( key.time >= time ) {\n\n\t\t\t\tndx = i;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ndx;\n\n\t};\n\n\tfunction interpolateKeys ( keys, key, ndx, fullSid ) {\n\n\t\tvar prevKey = getPrevKeyWith( keys, fullSid, ndx ? ndx - 1 : 0 ),\n\t\t\tnextKey = getNextKeyWith( keys, fullSid, ndx + 1 );\n\n\t\tif ( prevKey && nextKey ) {\n\n\t\t\tvar scale = (key.time - prevKey.time) / (nextKey.time - prevKey.time),\n\t\t\t\tprevTarget = prevKey.getTarget( fullSid ),\n\t\t\t\tnextData = nextKey.getTarget( fullSid ).data,\n\t\t\t\tprevData = prevTarget.data,\n\t\t\t\tdata;\n\n\t\t\tif ( prevTarget.type === 'matrix' ) {\n\n\t\t\t\tdata = prevData;\n\n\t\t\t} else if ( prevData.length ) {\n\n\t\t\t\tdata = [];\n\n\t\t\t\tfor ( var i = 0; i < prevData.length; ++ i ) {\n\n\t\t\t\t\tdata[ i ] = prevData[ i ] + ( nextData[ i ] - prevData[ i ] ) * scale;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata = prevData + ( nextData - prevData ) * scale;\n\n\t\t\t}\n\n\t\t\tkey.addTarget( fullSid, prevTarget.transform, prevTarget.member, data );\n\n\t\t}\n\n\t};\n\n\t// Get next key with given sid\n\n\tfunction getNextKeyWith( keys, fullSid, ndx ) {\n\n\t\tfor ( ; ndx < keys.length; ndx ++ ) {\n\n\t\t\tvar key = keys[ ndx ];\n\n\t\t\tif ( key.hasTarget( fullSid ) ) {\n\n\t\t\t\treturn key;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\t// Get previous key with given sid\n\n\tfunction getPrevKeyWith( keys, fullSid, ndx ) {\n\n\t\tndx = ndx >= 0 ? ndx : ndx + keys.length;\n\n\t\tfor ( ; ndx >= 0; ndx -- ) {\n\n\t\t\tvar key = keys[ ndx ];\n\n\t\t\tif ( key.hasTarget( fullSid ) ) {\n\n\t\t\t\treturn key;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tfunction _Image() {\n\n\t\tthis.id = \"\";\n\t\tthis.init_from = \"\";\n\n\t};\n\n\t_Image.prototype.parse = function(element) {\n\n\t\tthis.id = element.getAttribute('id');\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tif ( child.nodeName === 'init_from' ) {\n\n\t\t\t\tthis.init_from = child.textContent;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Controller() {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.type = \"\";\n\t\tthis.skin = null;\n\t\tthis.morph = null;\n\n\t};\n\n\tController.prototype.parse = function( element ) {\n\n\t\tthis.id = element.getAttribute('id');\n\t\tthis.name = element.getAttribute('name');\n\t\tthis.type = \"none\";\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'skin':\n\n\t\t\t\t\tthis.skin = (new Skin()).parse(child);\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'morph':\n\n\t\t\t\t\tthis.morph = (new Morph()).parse(child);\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Morph() {\n\n\t\tthis.method = null;\n\t\tthis.source = null;\n\t\tthis.targets = null;\n\t\tthis.weights = null;\n\n\t};\n\n\tMorph.prototype.parse = function( element ) {\n\n\t\tvar sources = {};\n\t\tvar inputs = [];\n\t\tvar i;\n\n\t\tthis.method = element.getAttribute( 'method' );\n\t\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n\n\t\tfor ( i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'source':\n\n\t\t\t\t\tvar source = ( new Source() ).parse( child );\n\t\t\t\t\tsources[ source.id ] = source;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'targets':\n\n\t\t\t\t\tinputs = this.parseInputs( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( i = 0; i < inputs.length; i ++ ) {\n\n\t\t\tvar input = inputs[ i ];\n\t\t\tvar source = sources[ input.source ];\n\n\t\t\tswitch ( input.semantic ) {\n\n\t\t\t\tcase 'MORPH_TARGET':\n\n\t\t\t\t\tthis.targets = source.read();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'MORPH_WEIGHT':\n\n\t\t\t\t\tthis.weights = source.read();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tMorph.prototype.parseInputs = function(element) {\n\n\t\tvar inputs = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'input':\n\n\t\t\t\t\tinputs.push( (new Input()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn inputs;\n\n\t};\n\n\tfunction Skin() {\n\n\t\tthis.source = \"\";\n\t\tthis.bindShapeMatrix = null;\n\t\tthis.invBindMatrices = [];\n\t\tthis.joints = [];\n\t\tthis.weights = [];\n\n\t};\n\n\tSkin.prototype.parse = function( element ) {\n\n\t\tvar sources = {};\n\t\tvar joints, weights;\n\n\t\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n\t\tthis.invBindMatrices = [];\n\t\tthis.joints = [];\n\t\tthis.weights = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'bind_shape_matrix':\n\n\t\t\t\t\tvar f = _floats(child.textContent);\n\t\t\t\t\tthis.bindShapeMatrix = getConvertedMat4( f );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'source':\n\n\t\t\t\t\tvar src = new Source().parse(child);\n\t\t\t\t\tsources[ src.id ] = src;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'joints':\n\n\t\t\t\t\tjoints = child;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vertex_weights':\n\n\t\t\t\t\tweights = child;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\tthis.parseJoints( joints, sources );\n\t\tthis.parseWeights( weights, sources );\n\n\t\treturn this;\n\n\t};\n\n\tSkin.prototype.parseJoints = function ( element, sources ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'input':\n\n\t\t\t\t\tvar input = ( new Input() ).parse( child );\n\t\t\t\t\tvar source = sources[ input.source ];\n\n\t\t\t\t\tif ( input.semantic === 'JOINT' ) {\n\n\t\t\t\t\t\tthis.joints = source.read();\n\n\t\t\t\t\t} else if ( input.semantic === 'INV_BIND_MATRIX' ) {\n\n\t\t\t\t\t\tthis.invBindMatrices = source.read();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tSkin.prototype.parseWeights = function ( element, sources ) {\n\n\t\tvar v, vcount, inputs = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'input':\n\n\t\t\t\t\tinputs.push( ( new Input() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'v':\n\n\t\t\t\t\tv = _ints( child.textContent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vcount':\n\n\t\t\t\t\tvcount = _ints( child.textContent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar index = 0;\n\n\t\tfor ( var i = 0; i < vcount.length; i ++ ) {\n\n\t\t\tvar numBones = vcount[i];\n\t\t\tvar vertex_weights = [];\n\n\t\t\tfor ( var j = 0; j < numBones; j ++ ) {\n\n\t\t\t\tvar influence = {};\n\n\t\t\t\tfor ( var k = 0; k < inputs.length; k ++ ) {\n\n\t\t\t\t\tvar input = inputs[ k ];\n\t\t\t\t\tvar value = v[ index + input.offset ];\n\n\t\t\t\t\tswitch ( input.semantic ) {\n\n\t\t\t\t\t\tcase 'JOINT':\n\n\t\t\t\t\t\t\tinfluence.joint = value;//this.joints[value];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'WEIGHT':\n\n\t\t\t\t\t\t\tinfluence.weight = sources[ input.source ].data[ value ];\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvertex_weights.push( influence );\n\t\t\t\tindex += inputs.length;\n\t\t\t}\n\n\t\t\tfor ( var j = 0; j < vertex_weights.length; j ++ ) {\n\n\t\t\t\tvertex_weights[ j ].index = i;\n\n\t\t\t}\n\n\t\t\tthis.weights.push( vertex_weights );\n\n\t\t}\n\n\t};\n\n\tfunction VisualScene () {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.nodes = [];\n\t\tthis.scene = new THREE.Group();\n\n\t};\n\n\tVisualScene.prototype.getChildById = function( id, recursive ) {\n\n\t\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\n\n\t\t\tvar node = this.nodes[ i ].getChildById( id, recursive );\n\n\t\t\tif ( node ) {\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tVisualScene.prototype.getChildBySid = function( sid, recursive ) {\n\n\t\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\n\n\t\t\tvar node = this.nodes[ i ].getChildBySid( sid, recursive );\n\n\t\t\tif ( node ) {\n\n\t\t\t\treturn node;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tVisualScene.prototype.parse = function( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\t\tthis.nodes = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'node':\n\n\t\t\t\t\tthis.nodes.push( ( new Node() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Node() {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.sid = \"\";\n\t\tthis.nodes = [];\n\t\tthis.controllers = [];\n\t\tthis.transforms = [];\n\t\tthis.geometries = [];\n\t\tthis.channels = [];\n\t\tthis.matrix = new THREE.Matrix4();\n\n\t};\n\n\tNode.prototype.getChannelForTransform = function( transformSid ) {\n\n\t\tfor ( var i = 0; i < this.channels.length; i ++ ) {\n\n\t\t\tvar channel = this.channels[i];\n\t\t\tvar parts = channel.target.split('/');\n\t\t\tvar id = parts.shift();\n\t\t\tvar sid = parts.shift();\n\t\t\tvar dotSyntax = (sid.indexOf(\".\") >= 0);\n\t\t\tvar arrSyntax = (sid.indexOf(\"(\") >= 0);\n\t\t\tvar arrIndices;\n\t\t\tvar member;\n\n\t\t\tif ( dotSyntax ) {\n\n\t\t\t\tparts = sid.split(\".\");\n\t\t\t\tsid = parts.shift();\n\t\t\t\tmember = parts.shift();\n\n\t\t\t} else if ( arrSyntax ) {\n\n\t\t\t\tarrIndices = sid.split(\"(\");\n\t\t\t\tsid = arrIndices.shift();\n\n\t\t\t\tfor ( var j = 0; j < arrIndices.length; j ++ ) {\n\n\t\t\t\t\tarrIndices[ j ] = parseInt( arrIndices[ j ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( sid === transformSid ) {\n\n\t\t\t\tchannel.info = { sid: sid, dotSyntax: dotSyntax, arrSyntax: arrSyntax, arrIndices: arrIndices };\n\t\t\t\treturn channel;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tNode.prototype.getChildById = function ( id, recursive ) {\n\n\t\tif ( this.id === id ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( recursive ) {\n\n\t\t\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\n\n\t\t\t\tvar n = this.nodes[ i ].getChildById( id, recursive );\n\n\t\t\t\tif ( n ) {\n\n\t\t\t\t\treturn n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tNode.prototype.getChildBySid = function ( sid, recursive ) {\n\n\t\tif ( this.sid === sid ) {\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( recursive ) {\n\n\t\t\tfor ( var i = 0; i < this.nodes.length; i ++ ) {\n\n\t\t\t\tvar n = this.nodes[ i ].getChildBySid( sid, recursive );\n\n\t\t\t\tif ( n ) {\n\n\t\t\t\t\treturn n;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tNode.prototype.getTransformBySid = function ( sid ) {\n\n\t\tfor ( var i = 0; i < this.transforms.length; i ++ ) {\n\n\t\t\tif ( this.transforms[ i ].sid === sid ) return this.transforms[ i ];\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tNode.prototype.parse = function( element ) {\n\n\t\tvar url;\n\n\t\tthis.id = element.getAttribute('id');\n\t\tthis.sid = element.getAttribute('sid');\n\t\tthis.name = element.getAttribute('name');\n\t\tthis.type = element.getAttribute('type');\n\t\tthis.layer = element.getAttribute('layer');\n\n\t\tthis.type = this.type === 'JOINT' ? this.type : 'NODE';\n\n\t\tthis.nodes = [];\n\t\tthis.transforms = [];\n\t\tthis.geometries = [];\n\t\tthis.cameras = [];\n\t\tthis.lights = [];\n\t\tthis.controllers = [];\n\t\tthis.matrix = new THREE.Matrix4();\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'node':\n\n\t\t\t\t\tthis.nodes.push( ( new Node() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'instance_camera':\n\n\t\t\t\t\tthis.cameras.push( ( new InstanceCamera() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'instance_controller':\n\n\t\t\t\t\tthis.controllers.push( ( new InstanceController() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'instance_geometry':\n\n\t\t\t\t\tthis.geometries.push( ( new InstanceGeometry() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'instance_light':\n\n\t\t\t\t\tthis.lights.push( ( new InstanceLight() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'instance_node':\n\n\t\t\t\t\turl = child.getAttribute( 'url' ).replace( /^#/, '' );\n\t\t\t\t\tvar iNode = getLibraryNode( url );\n\n\t\t\t\t\tif ( iNode ) {\n\n\t\t\t\t\t\tthis.nodes.push( ( new Node() ).parse( iNode )) ;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\tcase 'translate':\n\t\t\t\tcase 'scale':\n\t\t\t\tcase 'matrix':\n\t\t\t\tcase 'lookat':\n\t\t\t\tcase 'skew':\n\n\t\t\t\t\tthis.transforms.push( ( new Transform() ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'extra':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.channels = getChannelsForNode( this );\n\t\tbakeAnimations( this );\n\n\t\tthis.updateMatrix();\n\n\t\treturn this;\n\n\t};\n\n\tNode.prototype.updateMatrix = function () {\n\n\t\tthis.matrix.identity();\n\n\t\tfor ( var i = 0; i < this.transforms.length; i ++ ) {\n\n\t\t\tthis.transforms[ i ].apply( this.matrix );\n\n\t\t}\n\n\t};\n\n\tfunction Transform () {\n\n\t\tthis.sid = \"\";\n\t\tthis.type = \"\";\n\t\tthis.data = [];\n\t\tthis.obj = null;\n\n\t};\n\n\tTransform.prototype.parse = function ( element ) {\n\n\t\tthis.sid = element.getAttribute( 'sid' );\n\t\tthis.type = element.nodeName;\n\t\tthis.data = _floats( element.textContent );\n\t\tthis.convert();\n\n\t\treturn this;\n\n\t};\n\n\tTransform.prototype.convert = function () {\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase 'matrix':\n\n\t\t\t\tthis.obj = getConvertedMat4( this.data );\n\t\t\t\tbreak;\n\n\t\t\tcase 'rotate':\n\n\t\t\t\tthis.angle = THREE.Math.degToRad( this.data[3] );\n\n\t\t\tcase 'translate':\n\n\t\t\t\tfixCoords( this.data, -1 );\n\t\t\t\tthis.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\n\t\t\t\tbreak;\n\n\t\t\tcase 'scale':\n\n\t\t\t\tfixCoords( this.data, 1 );\n\t\t\t\tthis.obj = new THREE.Vector3( this.data[ 0 ], this.data[ 1 ], this.data[ 2 ] );\n\t\t\t\tbreak;\n\n\t\t\t// AXC: Interpret lookat\n\t\t\tcase 'lookat':\n\t\t\t  this.obj = {\n\t\t\t\t  eye: new THREE.Vector3( this.data[0], this.data[1], this.data[2] ),\n\t\t\t\t  target: new THREE.Vector3( this.data[3], this.data[4], this.data[5] ),\n  \t\t\t\tup: new THREE.Vector3( this.data[6], this.data[7], this.data[8] )\n\t  \t\t};\n\t\t    break;\n\n\t\t\tdefault:\n\t\t\t\tconsole.log( 'Can not convert Transform of type ' + this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tTransform.prototype.apply = function () {\n\n\t\tvar m1 = new THREE.Matrix4();\n\n\t\treturn function ( matrix ) {\n\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tmatrix.multiply( this.obj );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\n\t\t\t\t\tmatrix.multiply( m1.makeTranslation( this.obj.x, this.obj.y, this.obj.z ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\n\t\t\t\t\tmatrix.multiply( m1.makeRotationAxis( this.obj, this.angle ) );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\n\t\t\t\t\tmatrix.scale( this.obj );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t// AXC: Interpret lookat\n\t\t\t  case 'lookat':\n\t\t\t\t  matrix.lookAt( this.obj.eye, this.obj.target, this.obj.up );\n\t\t\t\t  break;\n\t\t\t}\n\n\t\t};\n\n\t}();\n\n\tTransform.prototype.update = function ( data, member ) {\n\n\t\tvar members = [ 'X', 'Y', 'Z', 'ANGLE' ];\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase 'matrix':\n\n\t\t\t\tif ( ! member ) {\n\n\t\t\t\t\tthis.obj.copy( data );\n\n\t\t\t\t} else if ( member.length === 1 ) {\n\n\t\t\t\t\tswitch ( member[ 0 ] ) {\n\n\t\t\t\t\t\tcase 0:\n\n\t\t\t\t\t\t\tthis.obj.n11 = data[ 0 ];\n\t\t\t\t\t\t\tthis.obj.n21 = data[ 1 ];\n\t\t\t\t\t\t\tthis.obj.n31 = data[ 2 ];\n\t\t\t\t\t\t\tthis.obj.n41 = data[ 3 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 1:\n\n\t\t\t\t\t\t\tthis.obj.n12 = data[ 0 ];\n\t\t\t\t\t\t\tthis.obj.n22 = data[ 1 ];\n\t\t\t\t\t\t\tthis.obj.n32 = data[ 2 ];\n\t\t\t\t\t\t\tthis.obj.n42 = data[ 3 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 2:\n\n\t\t\t\t\t\t\tthis.obj.n13 = data[ 0 ];\n\t\t\t\t\t\t\tthis.obj.n23 = data[ 1 ];\n\t\t\t\t\t\t\tthis.obj.n33 = data[ 2 ];\n\t\t\t\t\t\t\tthis.obj.n43 = data[ 3 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 3:\n\n\t\t\t\t\t\t\tthis.obj.n14 = data[ 0 ];\n\t\t\t\t\t\t\tthis.obj.n24 = data[ 1 ];\n\t\t\t\t\t\t\tthis.obj.n34 = data[ 2 ];\n\t\t\t\t\t\t\tthis.obj.n44 = data[ 3 ];\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else if ( member.length === 2 ) {\n\n\t\t\t\t\tvar propName = 'n' + ( member[ 0 ] + 1 ) + ( member[ 1 ] + 1 );\n\t\t\t\t\tthis.obj[ propName ] = data;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.log('Incorrect addressing of matrix in transform.');\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'translate':\n\t\t\tcase 'scale':\n\n\t\t\t\tif ( Object.prototype.toString.call( member ) === '[object Array]' ) {\n\n\t\t\t\t\tmember = members[ member[ 0 ] ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( member ) {\n\n\t\t\t\t\tcase 'X':\n\n\t\t\t\t\t\tthis.obj.x = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Y':\n\n\t\t\t\t\t\tthis.obj.y = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\n\t\t\t\t\t\tthis.obj.z = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tthis.obj.x = data[ 0 ];\n\t\t\t\t\t\tthis.obj.y = data[ 1 ];\n\t\t\t\t\t\tthis.obj.z = data[ 2 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'rotate':\n\n\t\t\t\tif ( Object.prototype.toString.call( member ) === '[object Array]' ) {\n\n\t\t\t\t\tmember = members[ member[ 0 ] ];\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( member ) {\n\n\t\t\t\t\tcase 'X':\n\n\t\t\t\t\t\tthis.obj.x = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Y':\n\n\t\t\t\t\t\tthis.obj.y = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\n\t\t\t\t\t\tthis.obj.z = data;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'ANGLE':\n\n\t\t\t\t\t\tthis.angle = THREE.Math.degToRad( data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tthis.obj.x = data[ 0 ];\n\t\t\t\t\t\tthis.obj.y = data[ 1 ];\n\t\t\t\t\t\tthis.obj.z = data[ 2 ];\n\t\t\t\t\t\tthis.angle = THREE.Math.degToRad( data[ 3 ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction InstanceController() {\n\n\t\tthis.url = \"\";\n\t\tthis.skeleton = [];\n\t\tthis.instance_material = [];\n\n\t};\n\n\tInstanceController.prototype.parse = function ( element ) {\n\n\t\tthis.url = element.getAttribute('url').replace(/^#/, '');\n\t\tthis.skeleton = [];\n\t\tthis.instance_material = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'skeleton':\n\n\t\t\t\t\tthis.skeleton.push( child.textContent.replace(/^#/, '') );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bind_material':\n\n\t\t\t\t\tvar instances = child.querySelectorAll('instance_material');\n\n\t\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\tvar instance = instances[j];\n\t\t\t\t\t\tthis.instance_material.push( (new InstanceMaterial()).parse(instance) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'extra':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction InstanceMaterial () {\n\n\t\tthis.symbol = \"\";\n\t\tthis.target = \"\";\n\n\t};\n\n\tInstanceMaterial.prototype.parse = function ( element ) {\n\n\t\tthis.symbol = element.getAttribute('symbol');\n\t\tthis.target = element.getAttribute('target').replace(/^#/, '');\n\t\treturn this;\n\n\t};\n\n\tfunction InstanceGeometry() {\n\n\t\tthis.url = \"\";\n\t\tthis.instance_material = [];\n\n\t};\n\n\tInstanceGeometry.prototype.parse = function ( element ) {\n\n\t\tthis.url = element.getAttribute('url').replace(/^#/, '');\n\t\tthis.instance_material = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tif ( child.nodeName === 'bind_material' ) {\n\n\t\t\t\tvar instances = child.querySelectorAll('instance_material');\n\n\t\t\t\tfor ( var j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\tvar instance = instances[j];\n\t\t\t\t\tthis.instance_material.push( (new InstanceMaterial()).parse(instance) );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Geometry() {\n\n\t\tthis.id = \"\";\n\t\tthis.mesh = null;\n\n\t};\n\n\tGeometry.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute('id');\n\n\t\textractDoubleSided( this, element );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'mesh':\n\n\t\t\t\t\tthis.mesh = (new Mesh(this)).parse(child);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'extra':\n\n\t\t\t\t\t// console.log( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Mesh( geometry ) {\n\n\t\tthis.geometry = geometry.id;\n\t\tthis.primitives = [];\n\t\tthis.vertices = null;\n\t\tthis.geometry3js = null;\n\n\t};\n\n\tMesh.prototype.parse = function ( element ) {\n\n\t\tthis.primitives = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'source':\n\n\t\t\t\t\t_source( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vertices':\n\n\t\t\t\t\tthis.vertices = ( new Vertices() ).parse( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lines': // AXC: Add lines\n\n\t\t\t\t\tthis.primitives.push( ( new Lines().parse( child ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'linestrips':\n\n\t\t\t\t\tthis.primitives.push( ( new LineStrips().parse( child ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'triangles':\n\n\t\t\t\t\tthis.primitives.push( ( new Triangles().parse( child ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygons':\n\n\t\t\t\t\tthis.primitives.push( ( new Polygons().parse( child ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polylist':\n\n\t\t\t\t\tthis.primitives.push( ( new Polylist().parse( child ) ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.lineGeometries = [];\n\t\tthis.geometry3js = new THREE.Geometry();\n\t\tthis.geometry3js.colladaId = this.geometry;  // AXC: Add colladaId here (in the variable this.geometry)\n\n\t\tif ( this.vertices === null ) {\n\n\t\t\t// TODO (mrdoob): Study case when this is null (carrier.dae)\n\n\t\t\treturn this;\n\n\t\t}\n\n\t\tif ( !this.vertices.input['POSITION'] ) {\n\n\t\t// TODO (AXC): no positions for vertices!\n\n\t\treturn this;\n\n\t\t}\n\n        // TODO (AXC): Switch to revamped ColladaLoader that handles multiple primitives per mesh\n\t\t// mesh can have primitives in any order and any number!\n\t\t// Code here assumes one primitive (or at least one primitive type) for Collada mesh\n\t\tvar vertexData = sources[ this.vertices.input['POSITION'].source ].data;\n\n\t\tfor ( var i = 0; i < vertexData.length; i += 3 ) {\n\n\t\t\tthis.geometry3js.vertices.push( getConvertedVec3( vertexData, i ).clone() );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.primitives.length; i ++ ) {\n\n\t\t\tvar primitive = this.primitives[ i ];\n\t\t\tprimitive.setVertices( this.vertices );\n\t\t\tthis.handlePrimitive( primitive, this.geometry3js );\n\t\t\tvar isLine = (primitive.geometry.isLine || primitive.geometry.isLineStrip);\n\t\t\tif (isLine) {\n\t\t\t\tthis.lineGeometries.push(primitive.geometry);\n\t\t\t}\n\t\t}\n\n\t\tif ( this.geometry3js.calcNormals ) {\n\n\t\t\tthis.geometry3js.computeVertexNormals();\n\t\t\tdelete this.geometry3js.calcNormals;\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tMesh.prototype.handlePrimitive = function ( primitive, geom ) {\n\n\t\tif ( primitive instanceof LineStrips || primitive instanceof Lines ) {\n\n\t\t\t// TODO: Handle indices. Maybe easier with BufferGeometry?\n\t\t\t// AXC: handle indices\n\t\t\tvar pLists = primitive.p;\n\t\t\tif (pLists) {\n\t\t\t\tvar vertices = geom.vertices;\n\t\t\t\tprimitive.geometry.vertices = [];\n                primitive.geometry.colladaId = geom.colladaId;\n\t\t\t\tfor (var i = 0; i < pLists.length; i++) {\n\t\t\t\t\tvar pList = pLists[i];\n\t\t\t\t\tfor (var j = 0; j < pList.length; j++) {\n                        primitive.geometry.vertices.push(vertices[pList[j]]);\n\t\t\t\t\t\tif (vertices[pList[j]] == null) {\n                            if (!__reportedMessages['lineMissingVertex']) {   // AXC: Make reporting of these messages quieter\n                                console.warn('THREE.ColladaLoader.Mesh.handlePrimitive: Missing vertex!');\n                                __reportedMessages['lineMissingVertex'] = true;\n                            }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tvar j, k, pList = primitive.p, inputs = primitive.inputs;\n\t\tvar input, index, idx32;\n\t\tvar source, numParams;\n\t\tvar vcIndex = 0, vcount = 3, maxOffset = 0;\n\t\tvar texture_sets = [];\n\n\t\tfor ( j = 0; j < inputs.length; j ++ ) {\n\n\t\t\tinput = inputs[ j ];\n\n\t\t\tvar offset = input.offset + 1;\n\t\t\tmaxOffset = (maxOffset < offset) ? offset : maxOffset;\n\n\t\t\tswitch ( input.semantic ) {\n\n\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\ttexture_sets.push( input.set );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var pCount = 0; pCount < pList.length; ++ pCount ) {\n\n\t\t\tvar p = pList[ pCount ], i = 0;\n\n\t\t\twhile ( i < p.length ) {\n\n\t\t\t\tvar vs = [];\n\t\t\t\tvar ns = [];\n\t\t\t\tvar ts = null;\n\t\t\t\tvar cs = [];\n\n\t\t\t\tif ( primitive.vcount ) {\n\n\t\t\t\t\tvcount = primitive.vcount.length ? primitive.vcount[ vcIndex ++ ] : primitive.vcount;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvcount = p.length / maxOffset;\n\n\t\t\t\t}\n\n\n\t\t\t\tfor ( j = 0; j < vcount; j ++ ) {\n\n\t\t\t\t\tfor ( k = 0; k < inputs.length; k ++ ) {\n\n\t\t\t\t\t\tinput = inputs[ k ];\n\t\t\t\t\t\tsource = sources[ input.source ];\n\n\t\t\t\t\t\tindex = p[ i + ( j * maxOffset ) + input.offset ];\n\t\t\t\t\t\tnumParams = source.accessor.params.length;\n\t\t\t\t\t\tidx32 = index * numParams;\n\n\t\t\t\t\t\tswitch ( input.semantic ) {\n\n\t\t\t\t\t\t\tcase 'VERTEX':\n\n\t\t\t\t\t\t\t\tvs.push( index );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'NORMAL':\n\n\t\t\t\t\t\t\t\tns.push( getConvertedVec3( source.data, idx32 ) );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'TEXCOORD':\n\n\t\t\t\t\t\t\t\tts = ts || { };\n\t\t\t\t\t\t\t\tif ( ts[ input.set ] === undefined ) ts[ input.set ] = [];\n\t\t\t\t\t\t\t\t// invert the V\n\t\t\t\t\t\t\t\tts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], source.data[ idx32 + 1 ] ) );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'COLOR':\n\n\t\t\t\t\t\t\t\tcs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ns.length === 0 ) {\n\n\t\t\t\t\t// check the vertices inputs\n\t\t\t\t\tinput = this.vertices.input.NORMAL;\n\n\t\t\t\t\tif ( input ) {\n\n\t\t\t\t\t\tsource = sources[ input.source ];\n\t\t\t\t\t\tnumParams = source.accessor.params.length;\n\n\t\t\t\t\t\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n\t\t\t\t\t\t\tns.push( getConvertedVec3( source.data, vs[ ndx ] * numParams ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tgeom.calcNormals = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( !ts ) {\n\n\t\t\t\t\tts = { };\n\t\t\t\t\t// check the vertices inputs\n\t\t\t\t\tinput = this.vertices.input.TEXCOORD;\n\n\t\t\t\t\tif ( input ) {\n\n\t\t\t\t\t\ttexture_sets.push( input.set );\n\t\t\t\t\t\tsource = sources[ input.source ];\n\t\t\t\t\t\tnumParams = source.accessor.params.length;\n\n\t\t\t\t\t\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n\t\t\t\t\t\t\tidx32 = vs[ ndx ] * numParams;\n\t\t\t\t\t\t\tif ( ts[ input.set ] === undefined ) ts[ input.set ] = [ ];\n\t\t\t\t\t\t\t// invert the V\n\t\t\t\t\t\t\tts[ input.set ].push( new THREE.Vector2( source.data[ idx32 ], 1.0 - source.data[ idx32 + 1 ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( cs.length === 0 ) {\n\n\t\t\t\t\t// check the vertices inputs\n\t\t\t\t\tinput = this.vertices.input.COLOR;\n\n\t\t\t\t\tif ( input ) {\n\n\t\t\t\t\t\tsource = sources[ input.source ];\n\t\t\t\t\t\tnumParams = source.accessor.params.length;\n\n\t\t\t\t\t\tfor ( var ndx = 0, len = vs.length; ndx < len; ndx ++ ) {\n\n\t\t\t\t\t\t\tidx32 = vs[ ndx ] * numParams;\n\t\t\t\t\t\t\tcs.push( new THREE.Color().setRGB( source.data[ idx32 ], source.data[ idx32 + 1 ], source.data[ idx32 + 2 ] ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar face = null, faces = [], uv, uvArr;\n\n\t\t\t\tif ( vcount === 3 ) {\n\n\t\t\t\t\tfaces.push( new THREE.Face3( vs[0], vs[1], vs[2], ns, cs.length ? cs : new THREE.Color() ) );\n\n\t\t\t\t} else if ( vcount === 4 ) {\n\n\t\t\t\t\tfaces.push( new THREE.Face3( vs[0], vs[1], vs[3], [ ns[0].clone(), ns[1].clone(), ns[3].clone() ], cs.length ? [ cs[0], cs[1], cs[3] ] : new THREE.Color() ) );\n\n\t\t\t\t\tfaces.push( new THREE.Face3( vs[1], vs[2], vs[3], [ ns[1].clone(), ns[2].clone(), ns[3].clone() ], cs.length ? [ cs[1], cs[2], cs[3] ] : new THREE.Color() ) );\n\n\t\t\t\t} else if ( vcount > 4 && options.subdivideFaces ) {\n\n\t\t\t\t\tvar clr = cs.length ? cs : new THREE.Color(),\n\t\t\t\t\t\tvec1, vec2, vec3, v1, v2, norm;\n\n\t\t\t\t\t// subdivide into multiple Face3s\n\n\t\t\t\t\tfor ( k = 1; k < vcount - 1; ) {\n\n\t\t\t\t\t\tfaces.push( new THREE.Face3( vs[0], vs[k], vs[k + 1], [ ns[0].clone(), ns[k ++].clone(), ns[k].clone() ], clr ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( faces.length ) {\n\n\t\t\t\t\tfor ( var ndx = 0, len = faces.length; ndx < len; ndx ++ ) {\n\n\t\t\t\t\t\tface = faces[ndx];\n\t\t\t\t\t\tface.daeMaterial = primitive.material;\n\t\t\t\t\t\tgeom.faces.push( face );\n\t\t\t\t\t\t// AXC: Track face index\n\t\t\t\t\t\tvar fi = geom.faces.length - 1;\n\n\t\t\t\t\t\tfor ( k = 0; k < texture_sets.length; k ++ ) {\n\n\t\t\t\t\t\t\tuv = ts[ texture_sets[k] ];\n\n\t\t\t\t\t\t\tif ( vcount > 4 ) {\n\n\t\t\t\t\t\t\t\t// Grab the right UVs for the vertices in this face\n\t\t\t\t\t\t\t\tuvArr = [ uv[0], uv[ndx + 1], uv[ndx + 2] ];\n\n\t\t\t\t\t\t\t} else if ( vcount === 4 ) {\n\n\t\t\t\t\t\t\t\tif ( ndx === 0 ) {\n\n\t\t\t\t\t\t\t\t\tuvArr = [ uv[0], uv[1], uv[3] ];\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tuvArr = [ uv[1].clone(), uv[2], uv[3].clone() ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tuvArr = [ uv[0], uv[1], uv[2] ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( geom.faceVertexUvs[k] === undefined ) {\n\n\t\t\t\t\t\t\t\tgeom.faceVertexUvs[k] = [];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// AXC: Put uvArr for correct face index\n\t\t\t\t\t\t\tgeom.faceVertexUvs[k][fi] = uvArr;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.log( 'dropped face with vcount ' + vcount + ' for geometry with id: ' + geom.id );\n\n\t\t\t\t}\n\n\t\t\t\ti += maxOffset * vcount;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction Polygons () {\n\n\t\tthis.material = \"\";\n\t\tthis.count = 0;\n\t\tthis.inputs = [];\n\t\tthis.vcount = null;\n\t\tthis.p = [];\n\t\tthis.geometry = new THREE.Geometry();\n\n\t};\n\n\tPolygons.prototype.setVertices = function ( vertices ) {\n\n\t\tfor ( var i = 0; i < this.inputs.length; i ++ ) {\n\n\t\t\tif ( this.inputs[ i ].source === vertices.id ) {\n\n\t\t\t\tthis.inputs[ i ].source = vertices.input[ 'POSITION' ].source;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tPolygons.prototype.parse = function ( element ) {\n\n\t\tthis.material = element.getAttribute( 'material' );\n\t\tthis.count = _attr_as_int( element, 'count', 0 );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'input':\n\n\t\t\t\t\tthis.inputs.push( ( new Input() ).parse( element.childNodes[ i ] ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'vcount':\n\n\t\t\t\t\tthis.vcount = _ints( child.textContent );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'p':\n\n\t\t\t\t\tthis.p.push( _ints( child.textContent ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ph':\n\n\t\t\t\t\tconsole.warn( 'polygon holes not yet supported!' );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Polylist () {\n\n\t\tPolygons.call( this );\n\n\t\tthis.vcount = [];\n\n\t};\n\n\tPolylist.prototype = Object.create( Polygons.prototype );\n\tPolylist.prototype.constructor = Polylist;\n\n\tfunction LineStrips() {\n\n\t\tPolygons.call( this );\n\n\t\tthis.vcount = 1;\n\t\tthis.geometry.isLineStrip = true;\n\n\t};\n\n\tLineStrips.prototype = Object.create( Polygons.prototype );\n\tLineStrips.prototype.constructor = LineStrips;\n\n    function Lines() {\n\n        Polygons.call( this );\n\n        this.vcount = 1;\n        this.geometry.isLine = true;\n\n    };\n\n    Lines.prototype = Object.create( Polygons.prototype );\n    Lines.prototype.constructor = Lines;\n\n\tfunction Triangles () {\n\n\t\tPolygons.call( this );\n\n\t\tthis.vcount = 3;\n\n\t};\n\n\tTriangles.prototype = Object.create( Polygons.prototype );\n\tTriangles.prototype.constructor = Triangles;\n\n\tfunction Accessor() {\n\n\t\tthis.source = \"\";\n\t\tthis.count = 0;\n\t\tthis.stride = 0;\n\t\tthis.params = [];\n\n\t};\n\n\tAccessor.prototype.parse = function ( element ) {\n\n\t\tthis.params = [];\n\t\tthis.source = element.getAttribute( 'source' );\n\t\tthis.count = _attr_as_int( element, 'count', 0 );\n\t\tthis.stride = _attr_as_int( element, 'stride', 0 );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tif ( child.nodeName === 'param' ) {\n\n\t\t\t\tvar param = {};\n\t\t\t\tparam[ 'name' ] = child.getAttribute( 'name' );\n\t\t\t\tparam[ 'type' ] = child.getAttribute( 'type' );\n\t\t\t\tthis.params.push( param );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Vertices() {\n\n\t\tthis.input = {};\n\n\t};\n\n\tVertices.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute('id');\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tif ( element.childNodes[i].nodeName === 'input' ) {\n\n\t\t\t\tvar input = ( new Input() ).parse( element.childNodes[ i ] );\n\t\t\t\tthis.input[ input.semantic ] = input;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Input () {\n\n\t\tthis.semantic = \"\";\n\t\tthis.offset = 0;\n\t\tthis.source = \"\";\n\t\tthis.set = 0;\n\n\t};\n\n\tInput.prototype.parse = function ( element ) {\n\n\t\tthis.semantic = element.getAttribute('semantic');\n\t\tthis.source = element.getAttribute('source').replace(/^#/, '');\n\t\tthis.set = _attr_as_int(element, 'set', -1);\n\t\tthis.offset = _attr_as_int(element, 'offset', 0);\n\n\t\tif ( this.semantic === 'TEXCOORD' && this.set < 0 ) {\n\n\t\t\tthis.set = 0;\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Source ( id ) {\n\n\t\tthis.id = id;\n\t\tthis.type = null;\n\n\t};\n\n\tSource.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'bool_array':\n\n\t\t\t\t\tthis.data = _bools( child.textContent );\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'float_array':\n\n\t\t\t\t\tthis.data = _floats( child.textContent );\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'int_array':\n\n\t\t\t\t\tthis.data = _ints( child.textContent );\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IDREF_array':\n\t\t\t\tcase 'Name_array':\n\n\t\t\t\t\tthis.data = _strings( child.textContent );\n\t\t\t\t\tthis.type = child.nodeName;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'technique_common':\n\n\t\t\t\t\tfor ( var j = 0; j < child.childNodes.length; j ++ ) {\n\n\t\t\t\t\t\tif ( child.childNodes[ j ].nodeName === 'accessor' ) {\n\n\t\t\t\t\t\t\tthis.accessor = ( new Accessor() ).parse( child.childNodes[ j ] );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log(child.nodeName);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tSource.prototype.read = function () {\n\n\t\tvar result = [];\n\n\t\t//for (var i = 0; i < this.accessor.params.length; i++) {\n\n\t\tvar param = this.accessor.params[ 0 ];\n\n\t\t\t//console.log(param.name + \" \" + param.type);\n\n\t\tswitch ( param.type ) {\n\n\t\t\tcase 'IDREF':\n\t\t\tcase 'Name': case 'name':\n\t\t\tcase 'float':\n\n\t\t\t\treturn this.data;\n\n\t\t\tcase 'float4x4':\n\n\t\t\t\tfor ( var j = 0; j < this.data.length; j += 16 ) {\n\n\t\t\t\t\tvar s = this.data.slice( j, j + 16 );\n\t\t\t\t\tvar m = getConvertedMat4( s );\n\t\t\t\t\tresult.push( m );\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.log( 'ColladaLoader: Source: Read dont know how to read ' + param.type + '.' );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t//}\n\n\t\treturn result;\n\n\t};\n\n\tfunction Material () {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.instance_effect = null;\n\n\t};\n\n\tMaterial.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tif ( element.childNodes[ i ].nodeName === 'instance_effect' ) {\n\n\t\t\t\tthis.instance_effect = ( new InstanceEffect() ).parse( element.childNodes[ i ] );\n\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction ColorOrTexture () {\n\n\t\tthis.color = new THREE.Color();\n\t\tthis.color.setRGB( Math.random(), Math.random(), Math.random() );\n\t\tthis.color.a = 1.0;\n\n\t\tthis.texture = null;\n\t\tthis.texcoord = null;\n\t\tthis.texOpts = null;\n\n\t};\n\n\tColorOrTexture.prototype.isColor = function () {\n\n\t\treturn ( this.texture === null );\n\n\t};\n\n\tColorOrTexture.prototype.isTexture = function () {\n\n\t\treturn ( this.texture != null );\n\n\t};\n\n\tColorOrTexture.prototype.parse = function ( element ) {\n\n\t\tif (element.nodeName === 'transparent') {\n\n\t\t\tthis.opaque = element.getAttribute('opaque');\n\n\t\t}\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'color':\n\n\t\t\t\t\tvar rgba = _floats( child.textContent );\n\t\t\t\t\tthis.color = new THREE.Color();\n\t\t\t\t\tthis.color.setRGB( rgba[0], rgba[1], rgba[2] );\n\t\t\t\t\tthis.color.a = rgba[3];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\n\t\t\t\t\tthis.texture = child.getAttribute('texture');\n\t\t\t\t\tthis.texcoord = child.getAttribute('texcoord');\n\t\t\t\t\t// Defaults from:\n\t\t\t\t\t// https://collada.org/mediawiki/index.php/Maya_texture_placement_MAYA_extension\n\t\t\t\t\tthis.texOpts = {\n\t\t\t\t\t\toffsetU: 0,\n\t\t\t\t\t\toffsetV: 0,\n\t\t\t\t\t\trepeatU: 1,\n\t\t\t\t\t\trepeatV: 1,\n\t\t\t\t\t\twrapU: 1,\n\t\t\t\t\t\twrapV: 1\n\t\t\t\t\t};\n\t\t\t\t\tthis.parseTexture( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tColorOrTexture.prototype.parseTexture = function ( element ) {\n\n\t\tif ( ! element.childNodes ) return this;\n\n\t\t// This should be supported by Maya, 3dsMax, and MotionBuilder\n\n\t\tif ( element.childNodes[1] && element.childNodes[1].nodeName === 'extra' ) {\n\n\t\t\telement = element.childNodes[1];\n\n\t\t\tif ( element.childNodes[1] && element.childNodes[1].nodeName === 'technique' ) {\n\n\t\t\t\telement = element.childNodes[1];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'offsetU':\n\t\t\t\tcase 'offsetV':\n\t\t\t\tcase 'repeatU':\n\t\t\t\tcase 'repeatV':\n\n\t\t\t\t\tthis.texOpts[ child.nodeName ] = parseFloat( child.textContent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'wrapU':\n\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t// some dae have a value of true which becomes NaN via parseInt\n\n\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\tthis.texOpts[ child.nodeName ] = 1;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.texOpts[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tthis.texOpts[ child.nodeName ] = child.textContent;\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Shader ( type, effect ) {\n\n\t\tthis.type = type;\n\t\tthis.effect = effect;\n\t\tthis.material = null;\n\n\t};\n\n\tShader.prototype.parse = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'emission':\n\t\t\t\tcase 'diffuse':\n\t\t\t\tcase 'specular':\n\t\t\t\tcase 'transparent':\n\n\t\t\t\t\tthis[ child.nodeName ] = ( new ColorOrTexture() ).parse( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// If 'bumptype' is 'heightfield', create a 'bump' property\n\t\t\t\t\t// Else if 'bumptype' is 'normalmap', create a 'normal' property\n\t\t\t\t\t// (Default to 'bump')\n\t\t\t\t\tvar bumpType = child.getAttribute( 'bumptype' );\n\t\t\t\t\tif ( bumpType ) {\n\t\t\t\t\t\tif ( bumpType.toLowerCase() === \"heightfield\" ) {\n\t\t\t\t\t\t\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n\t\t\t\t\t\t} else if ( bumpType.toLowerCase() === \"normalmap\" ) {\n\t\t\t\t\t\t\tthis[ 'normal' ] = ( new ColorOrTexture() ).parse( child );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error( \"Shader.prototype.parse: Invalid value for attribute 'bumptype' (\" + bumpType + \") - valid bumptypes are 'HEIGHTFIELD' and 'NORMALMAP' - defaulting to 'HEIGHTFIELD'\" );\n\t\t\t\t\t\t\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.warn( \"Shader.prototype.parse: Attribute 'bumptype' missing from bump node - defaulting to 'HEIGHTFIELD'\" );\n\t\t\t\t\t\tthis[ 'bump' ] = ( new ColorOrTexture() ).parse( child );\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'shininess':\n\t\t\t\tcase 'reflectivity':\n\t\t\t\tcase 'index_of_refraction':\n\t\t\t\tcase 'transparency':\n\n\t\t\t\t\tvar f = child.querySelectorAll('float');\n\n\t\t\t\t\tif ( f.length > 0 )\n\t\t\t\t\t\tthis[ child.nodeName ] = parseFloat( f[ 0 ].textContent );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.create();\n\t\treturn this;\n\n\t};\n\n\tShader.prototype.create = function() {\n\n\t\tvar props = {};\n\n\t\tvar transparent = false;\n\n\t\tif (this['transparency'] !== undefined && this['transparent'] !== undefined) {\n\t\t\t// convert transparent color RBG to average value\n\t\t\tvar transparentColor = this['transparent'];\n\t\t\tvar transparencyLevel = (this.transparent.color.r + this.transparent.color.g + this.transparent.color.b) / 3 * this.transparency;\n\n\t\t\tif (transparencyLevel > 0) {\n\t\t\t\ttransparent = true;\n\t\t\t\tprops[ 'transparent' ] = true;\n\t\t\t\tprops[ 'opacity' ] = 1 - transparencyLevel;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar keys = {\n\t\t\t'diffuse':'map',\n\t\t\t'ambient':'lightMap',\n\t\t\t'specular':'specularMap',\n\t\t\t'emission':'emissionMap',\n\t\t\t'bump':'bumpMap',\n\t\t\t'normal':'normalMap'\n\t\t\t};\n\n\t\tfor ( var prop in this ) {\n\n\t\t\tswitch ( prop ) {\n\n\t\t\t\tcase 'ambient':\n\t\t\t\tcase 'emission':\n\t\t\t\tcase 'diffuse':\n\t\t\t\tcase 'specular':\n\t\t\t\tcase 'bump':\n\t\t\t\tcase 'normal':\n\n\t\t\t\t\tvar cot = this[ prop ];\n\n\t\t\t\t\tif ( cot instanceof ColorOrTexture ) {\n\n\t\t\t\t\t\tif ( cot.isTexture() ) {\n\n\t\t\t\t\t\t\tvar samplerId = cot.texture;\n\t\t\t\t\t\t\tvar surfaceId = this.effect.sampler[samplerId];\n\n\t\t\t\t\t\t\tif ( surfaceId !== undefined && surfaceId.source !== undefined ) {\n\n\t\t\t\t\t\t\t\tvar surface = this.effect.surface[surfaceId.source];\n\n\t\t\t\t\t\t\t\tif ( surface !== undefined ) {\n\n\t\t\t\t\t\t\t\t\tvar image = images[ surface.init_from ];\n\n\t\t\t\t\t\t\t\t\tif ( image ) {\n\n\t\t\t\t\t\t\t\t\t\tvar url = baseUrl + image.init_from;\n\n\t\t\t\t\t\t\t\t\t\tvar texture;\n\n\t\t\t\t\t\t\t\t\t\t// AXC - custom texture loading for KMZLoader\n\t\t\t\t\t\t\t\t\t\tif (options.loadTextureCallback) {\n\t\t\t\t\t\t\t\t\t\t\ttexture = options.loadTextureCallback(baseUrl, image.init_from);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tvar loader = options.manager.getHandler(url);\n\t\t\t\t\t\t\t\t\t\t\tif (loader !== null) {\n\t\t\t\t\t\t\t\t\t\t\t\ttexture = loader.load(url);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\ttexture = new THREE.Texture();\n\t\t\t\t\t\t\t\t\t\t\t\tloadTextureImage(texture, url);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttexture.wrapS = cot.texOpts.wrapU ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\t\t\ttexture.wrapT = cot.texOpts.wrapV ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\t\t\ttexture.offset.x = cot.texOpts.offsetU;\n\t\t\t\t\t\t\t\t\t\ttexture.offset.y = cot.texOpts.offsetV;\n\t\t\t\t\t\t\t\t\t\ttexture.repeat.x = cot.texOpts.repeatU;\n\t\t\t\t\t\t\t\t\t\ttexture.repeat.y = cot.texOpts.repeatV;\n\t\t\t\t\t\t\t\t\t\tprops[keys[prop]] = texture;\n\n\t\t\t\t\t\t\t\t\t\t// Texture with baked lighting?\n\t\t\t\t\t\t\t\t\t\tif (prop === 'emission') props['emissive'] = 0xffffff;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if ( prop === 'diffuse' || !transparent ) {\n\n\t\t\t\t\t\t\tif ( prop === 'emission' ) {\n\n\t\t\t\t\t\t\t\tprops[ 'emissive' ] = cot.color.getHex();\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tprops[ prop ] = cot.color.getHex();\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'shininess':\n\n\t\t\t\t\tprops[ prop ] = this[ prop ];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'reflectivity':\n\n\t\t\t\t\tprops[ prop ] = this[ prop ];\n\t\t\t\t\tif ( props[ prop ] > 0.0 ) props['envMap'] = options.defaultEnvMap;\n\t\t\t\t\tprops['combine'] = THREE.MixOperation;\t//mix regular shading with reflective component\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'index_of_refraction':\n\n\t\t\t\t\tprops[ 'refractionRatio' ] = this[ prop ]; //TODO: \"index_of_refraction\" becomes \"refractionRatio\" in shader, but I'm not sure if the two are actually comparable\n\t\t\t\t\tif ( this[ prop ] !== 1.0 ) props['envMap'] = options.defaultEnvMap;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'transparency':\n\t\t\t\t\t// gets figured out up top\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tprops[ 'flatShading' ] = preferredShading;\n\t\tprops[ 'side' ] = this.effect.doubleSided ? THREE.DoubleSide : THREE.FrontSide;\n\n\t\tswitch ( this.type ) {\n\n\t\t\tcase 'constant':\n\n\t\t\t\tif (props.emissive != undefined) props.color = props.emissive;\n\t\t\t\tthis.material = new THREE.MeshBasicMaterial( props );\n\t\t\t\tbreak;\n\n\t\t\tcase 'phong':\n\t\t\tcase 'blinn':\n\n\t\t\t\tif (props.diffuse != undefined) props.color = props.diffuse;\n\t\t\t\tdelete props.ambient;  // AXC: THREE.js now warns about extra params, ambient is no longer supported\n\t\t\t\tdelete props.diffuse;  // AXC: THREE.js now warns about extra params, diffuse is mapped to color\n\t\t\t\tthis.material = new THREE.MeshPhongMaterial( props );\n\t\t\t\tbreak;\n\n\t\t\tcase 'lambert':\n\t\t\tdefault:\n\n\t\t\t\tif (props.diffuse != undefined) props.color = props.diffuse;\n\t\t\t\tdelete props.ambient;  // AXC: THREE.js now warns about extra params, ambient is no longer supported\n\t\t\t\tdelete props.diffuse;  // AXC: THREE.js now warns about extra params, diffuse is mapped to color\n\t\t\t\tthis.material = new THREE.MeshPhongMaterial( props );  // MS: MeshLambertMaterial is broken with shadow maps\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\treturn this.material;\n\n\t};\n\n\tfunction Surface ( effect ) {\n\n\t\tthis.effect = effect;\n\t\tthis.init_from = null;\n\t\tthis.format = null;\n\n\t};\n\n\tSurface.prototype.parse = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'init_from':\n\n\t\t\t\t\tthis.init_from = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'format':\n\n\t\t\t\t\tthis.format = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( \"unhandled Surface prop: \" + child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Sampler2D ( effect ) {\n\n\t\tthis.effect = effect;\n\t\tthis.source = null;\n\t\tthis.wrap_s = null;\n\t\tthis.wrap_t = null;\n\t\tthis.minfilter = null;\n\t\tthis.magfilter = null;\n\t\tthis.mipfilter = null;\n\n\t};\n\n\tSampler2D.prototype.parse = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'source':\n\n\t\t\t\t\tthis.source = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'minfilter':\n\n\t\t\t\t\tthis.minfilter = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'magfilter':\n\n\t\t\t\t\tthis.magfilter = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mipfilter':\n\n\t\t\t\t\tthis.mipfilter = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'wrap_s':\n\n\t\t\t\t\tthis.wrap_s = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'wrap_t':\n\n\t\t\t\t\tthis.wrap_t = child.textContent;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( \"unhandled Sampler2D prop: \" + child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Effect () {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.shader = null;\n\t\tthis.surface = {};\n\t\tthis.sampler = {};\n\n\t};\n\n\tEffect.prototype.create = function () {\n\n\t\tif ( this.shader === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t};\n\n\tEffect.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\n\t\textractDoubleSided( this, element );\n\n\t\tthis.shader = null;\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'profile_COMMON':\n\n\t\t\t\t\tthis.parseTechnique( this.parseProfileCOMMON( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tEffect.prototype.parseNewparam = function ( element ) {\n\n\t\tvar sid = element.getAttribute( 'sid' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'surface':\n\n\t\t\t\t\tthis.surface[sid] = ( new Surface( this ) ).parse( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sampler2D':\n\n\t\t\t\t\tthis.sampler[sid] = ( new Sampler2D( this ) ).parse( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'extra':\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tEffect.prototype.parseProfileCOMMON = function ( element ) {\n\n\t\tvar technique;\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'profile_COMMON':\n\n\t\t\t\t\tthis.parseProfileCOMMON( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'technique':\n\n\t\t\t\t\ttechnique = child;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'newparam':\n\n\t\t\t\t\tthis.parseNewparam( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'image':\n\n\t\t\t\t\tvar _image = ( new _Image() ).parse( child );\n\t\t\t\t\timages[ _image.id ] = _image;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'extra':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log( child.nodeName );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn technique;\n\n\t};\n\n\tEffect.prototype.parseTechnique = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'constant':\n\t\t\t\tcase 'lambert':\n\t\t\t\tcase 'blinn':\n\t\t\t\tcase 'phong':\n\n\t\t\t\t\tthis.shader = ( new Shader( child.nodeName, this ) ).parse( child );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'extra':\n\t\t\t\t\tthis.parseExtra(child);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tEffect.prototype.parseExtra = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'technique':\n\t\t\t\t\tthis.parseExtraTechnique( child );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tEffect.prototype.parseExtraTechnique = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[i];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'bump':\n\t\t\t\t\tthis.shader.parse( element );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction InstanceEffect () {\n\n\t\tthis.url = \"\";\n\n\t};\n\n\tInstanceEffect.prototype.parse = function ( element ) {\n\n\t\tthis.url = element.getAttribute( 'url' ).replace( /^#/, '' );\n\t\treturn this;\n\n\t};\n\n\tfunction Animation() {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.source = {};\n\t\tthis.sampler = [];\n\t\tthis.channel = [];\n\n\t};\n\n\tAnimation.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\t\tthis.source = {};\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'animation':\n\n\t\t\t\t\tvar anim = ( new Animation() ).parse( child );\n\n\t\t\t\t\tfor ( var src in anim.source ) {\n\n\t\t\t\t\t\tthis.source[ src ] = anim.source[ src ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var j = 0; j < anim.channel.length; j ++ ) {\n\n\t\t\t\t\t\tthis.channel.push( anim.channel[ j ] );\n\t\t\t\t\t\tthis.sampler.push( anim.sampler[ j ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'source':\n\n\t\t\t\t\tvar src = ( new Source() ).parse( child );\n\t\t\t\t\tthis.source[ src.id ] = src;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'sampler':\n\n\t\t\t\t\tthis.sampler.push( ( new Sampler( this ) ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'channel':\n\n\t\t\t\t\tthis.channel.push( ( new Channel( this ) ).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Channel( animation ) {\n\n\t\tthis.animation = animation;\n\t\tthis.source = \"\";\n\t\tthis.target = \"\";\n\t\tthis.fullSid = null;\n\t\tthis.sid = null;\n\t\tthis.dotSyntax = null;\n\t\tthis.arrSyntax = null;\n\t\tthis.arrIndices = null;\n\t\tthis.member = null;\n\n\t};\n\n\tChannel.prototype.parse = function ( element ) {\n\n\t\tthis.source = element.getAttribute( 'source' ).replace( /^#/, '' );\n\t\tthis.target = element.getAttribute( 'target' );\n\n\t\tvar parts = this.target.split( '/' );\n\n\t\tvar id = parts.shift();\n\t\tvar sid = parts.shift();\n\n\t\tvar dotSyntax = ( sid.indexOf(\".\") >= 0 );\n\t\tvar arrSyntax = ( sid.indexOf(\"(\") >= 0 );\n\n\t\tif ( dotSyntax ) {\n\n\t\t\tparts = sid.split(\".\");\n\t\t\tthis.sid = parts.shift();\n\t\t\tthis.member = parts.shift();\n\n\t\t} else if ( arrSyntax ) {\n\n\t\t\tvar arrIndices = sid.split(\"(\");\n\t\t\tthis.sid = arrIndices.shift();\n\n\t\t\tfor (var j = 0; j < arrIndices.length; j ++ ) {\n\n\t\t\t\tarrIndices[j] = parseInt( arrIndices[j].replace(/\\)/, '') );\n\n\t\t\t}\n\n\t\t\tthis.arrIndices = arrIndices;\n\n\t\t} else {\n\n\t\t\tthis.sid = sid;\n\n\t\t}\n\n\t\tthis.fullSid = sid;\n\t\tthis.dotSyntax = dotSyntax;\n\t\tthis.arrSyntax = arrSyntax;\n\n\t\treturn this;\n\n\t};\n\n\tfunction Sampler ( animation ) {\n\n\t\tthis.id = \"\";\n\t\tthis.animation = animation;\n\t\tthis.inputs = [];\n\t\tthis.input = null;\n\t\tthis.output = null;\n\t\tthis.strideOut = null;\n\t\tthis.interpolation = null;\n\t\tthis.startTime = null;\n\t\tthis.endTime = null;\n\t\tthis.duration = 0;\n\n\t};\n\n\tSampler.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.inputs = [];\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'input':\n\n\t\t\t\t\tthis.inputs.push( (new Input()).parse( child ) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tSampler.prototype.create = function () {\n\n\t\tfor ( var i = 0; i < this.inputs.length; i ++ ) {\n\n\t\t\tvar input = this.inputs[ i ];\n\t\t\tvar source = this.animation.source[ input.source ];\n\n\t\t\tswitch ( input.semantic ) {\n\n\t\t\t\tcase 'INPUT':\n\n\t\t\t\t\tthis.input = source.read();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OUTPUT':\n\n\t\t\t\t\tthis.output = source.read();\n\t\t\t\t\tthis.strideOut = source.accessor.stride;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'INTERPOLATION':\n\n\t\t\t\t\tthis.interpolation = source.read();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'IN_TANGENT':\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'OUT_TANGENT':\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tconsole.log(input.semantic);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.startTime = 0;\n\t\tthis.endTime = 0;\n\t\tthis.duration = 0;\n\n\t\tif ( this.input.length ) {\n\n\t\t\tthis.startTime = 100000000;\n\t\t\tthis.endTime = -100000000;\n\n\t\t\tfor ( var i = 0; i < this.input.length; i ++ ) {\n\n\t\t\t\tthis.startTime = Math.min( this.startTime, this.input[ i ] );\n\t\t\t\tthis.endTime = Math.max( this.endTime, this.input[ i ] );\n\n\t\t\t}\n\n\t\t\tthis.duration = this.endTime - this.startTime;\n\n\t\t}\n\n\t};\n\n\tSampler.prototype.getData = function ( type, ndx, member ) {\n\n\t\tvar data;\n\n\t\tif ( type === 'matrix' && this.strideOut === 16 ) {\n\n\t\t\tdata = this.output[ ndx ];\n\n\t\t} else if ( this.strideOut > 1 ) {\n\n\t\t\tdata = [];\n\t\t\tndx *= this.strideOut;\n\n\t\t\tfor ( var i = 0; i < this.strideOut; ++ i ) {\n\n\t\t\t\tdata[ i ] = this.output[ ndx + i ];\n\n\t\t\t}\n\n\t\t\tif ( this.strideOut === 3 ) {\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\tfixCoords( data, -1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\tfixCoords( data, 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.strideOut === 4 && type === 'matrix' ) {\n\n\t\t\t\tfixCoords( data, -1 );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tdata = this.output[ ndx ];\n\n\t\t\tif ( member && type === 'translate' ) {\n\t\t\t\tdata = getConvertedTranslation( member, data );\n\t\t\t}\n\n\t\t}\n\n\t\treturn data;\n\n\t};\n\n\tfunction Key ( time ) {\n\n\t\tthis.targets = [];\n\t\tthis.time = time;\n\n\t};\n\n\tKey.prototype.addTarget = function ( fullSid, transform, member, data ) {\n\n\t\tthis.targets.push( {\n\t\t\tsid: fullSid,\n\t\t\tmember: member,\n\t\t\ttransform: transform,\n\t\t\tdata: data\n\t\t} );\n\n\t};\n\n\tKey.prototype.apply = function ( opt_sid ) {\n\n\t\tfor ( var i = 0; i < this.targets.length; ++ i ) {\n\n\t\t\tvar target = this.targets[ i ];\n\n\t\t\tif ( !opt_sid || target.sid === opt_sid ) {\n\n\t\t\t\ttarget.transform.update( target.data, target.member );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tKey.prototype.getTarget = function ( fullSid ) {\n\n\t\tfor ( var i = 0; i < this.targets.length; ++ i ) {\n\n\t\t\tif ( this.targets[ i ].sid === fullSid ) {\n\n\t\t\t\treturn this.targets[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tKey.prototype.hasTarget = function ( fullSid ) {\n\n\t\tfor ( var i = 0; i < this.targets.length; ++ i ) {\n\n\t\t\tif ( this.targets[ i ].sid === fullSid ) {\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn false;\n\n\t};\n\n\t// TODO: Currently only doing linear interpolation. Should support full COLLADA spec.\n\tKey.prototype.interpolate = function ( nextKey, time ) {\n\n\t\tfor ( var i = 0, l = this.targets.length; i < l; i ++ ) {\n\n\t\t\tvar target = this.targets[ i ],\n\t\t\t\tnextTarget = nextKey.getTarget( target.sid ),\n\t\t\t\tdata;\n\n\t\t\tif ( target.transform.type !== 'matrix' && nextTarget ) {\n\n\t\t\t\tvar scale = ( time - this.time ) / ( nextKey.time - this.time ),\n\t\t\t\t\tnextData = nextTarget.data,\n\t\t\t\t\tprevData = target.data;\n\n\t\t\t\tif ( scale < 0 ) scale = 0;\n\t\t\t\tif ( scale > 1 ) scale = 1;\n\n\t\t\t\tif ( prevData.length ) {\n\n\t\t\t\t\tdata = [];\n\n\t\t\t\t\tfor ( var j = 0; j < prevData.length; ++ j ) {\n\n\t\t\t\t\t\tdata[ j ] = prevData[ j ] + ( nextData[ j ] - prevData[ j ] ) * scale;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tdata = prevData + ( nextData - prevData ) * scale;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tdata = target.data;\n\n\t\t\t}\n\n\t\t\ttarget.transform.update( data, target.member );\n\n\t\t}\n\n\t};\n\n\t// Camera\n\tfunction Camera() {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.technique = \"\";\n\n\t};\n\n\tCamera.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'optics':\n\n\t\t\t\t\tthis.parseOptics( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tCamera.prototype.parseOptics = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tif ( element.childNodes[ i ].nodeName === 'technique_common' ) {\n\n\t\t\t\tvar technique = element.childNodes[ i ];\n\n\t\t\t\tfor ( var j = 0; j < technique.childNodes.length; j ++ ) {\n\n\t\t\t\t\tthis.technique = technique.childNodes[ j ].nodeName;\n\n\t\t\t\t\tif ( this.technique === 'perspective' ) {\n\n\t\t\t\t\t\tvar perspective = technique.childNodes[ j ];\n\n\t\t\t\t\t\tfor ( var k = 0; k < perspective.childNodes.length; k ++ ) {\n\n\t\t\t\t\t\t\tvar param = perspective.childNodes[ k ];\n\n\t\t\t\t\t\t\tswitch ( param.nodeName ) {\n\n\t\t\t\t\t\t\t\tcase 'yfov':\n\t\t\t\t\t\t\t\t\tthis.yfov = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'xfov':\n\t\t\t\t\t\t\t\t\tthis.xfov = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'znear':\n\t\t\t\t\t\t\t\t\tthis.znear = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'zfar':\n\t\t\t\t\t\t\t\t\tthis.zfar = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\t\t\t\tthis.aspect_ratio = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( this.technique === 'orthographic' ) {\n\n\t\t\t\t\t\tvar orthographic = technique.childNodes[ j ];\n\n\t\t\t\t\t\tfor ( var k = 0; k < orthographic.childNodes.length; k ++ ) {\n\n\t\t\t\t\t\t\tvar param = orthographic.childNodes[ k ];\n\n\t\t\t\t\t\t\tswitch ( param.nodeName ) {\n\n\t\t\t\t\t\t\t\tcase 'xmag':\n\t\t\t\t\t\t\t\t\tthis.xmag = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'ymag':\n\t\t\t\t\t\t\t\t\tthis.ymag = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'znear':\n\t\t\t\t\t\t\t\t\tthis.znear = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'zfar':\n\t\t\t\t\t\t\t\t\tthis.zfar = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\t\t\t\tthis.aspect_ratio = param.textContent;\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction InstanceCamera() {\n\n\t\tthis.url = \"\";\n\n\t};\n\n\tInstanceCamera.prototype.parse = function ( element ) {\n\n\t\tthis.url = element.getAttribute('url').replace(/^#/, '');\n\n\t\treturn this;\n\n\t};\n\n\t// Light\n\n\tfunction Light() {\n\n\t\tthis.id = \"\";\n\t\tthis.name = \"\";\n\t\tthis.technique = \"\";\n\n\t};\n\n\tLight.prototype.parse = function ( element ) {\n\n\t\tthis.id = element.getAttribute( 'id' );\n\t\tthis.name = element.getAttribute( 'name' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'technique_common':\n\n\t\t\t\t\tthis.parseCommon( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'technique':\n\n\t\t\t\t\tthis.parseTechnique( child );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tLight.prototype.parseCommon = function ( element ) {\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tswitch ( element.childNodes[ i ].nodeName ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\tcase 'point':\n\t\t\t\tcase 'spot':\n\t\t\t\tcase 'ambient':\n\n\t\t\t\t\tthis.technique = element.childNodes[ i ].nodeName;\n\n\t\t\t\t\tvar light = element.childNodes[ i ];\n\n\t\t\t\t\tfor ( var j = 0; j < light.childNodes.length; j ++ ) {\n\n\t\t\t\t\t\tvar child = light.childNodes[j];\n\n\t\t\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\t\t\tcase 'color':\n\n\t\t\t\t\t\t\t\tvar rgba = _floats( child.textContent );\n\t\t\t\t\t\t\t\tthis.color = new THREE.Color(0);\n\t\t\t\t\t\t\t\tthis.color.setRGB( rgba[0], rgba[1], rgba[2] );\n\t\t\t\t\t\t\t\tthis.color.a = rgba[3];\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'falloff_angle':\n\n\t\t\t\t\t\t\t\tthis.falloff_angle = parseFloat( child.textContent );\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\t\t\tvar f = parseFloat( child.textContent );\n\t\t\t\t\t\t\t\tthis.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tLight.prototype.parseTechnique = function ( element ) {\n\n\t\tthis.profile = element.getAttribute( 'profile' );\n\n\t\tfor ( var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'intensity':\n\n\t\t\t\t\tthis.intensity = parseFloat(child.textContent);\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction InstanceLight() {\n\n\t\tthis.url = \"\";\n\n\t};\n\n\tInstanceLight.prototype.parse = function ( element ) {\n\n\t\tthis.url = element.getAttribute('url').replace(/^#/, '');\n\n\t\treturn this;\n\n\t};\n\n\tfunction KinematicsModel( ) {\n\n\t\tthis.id = '';\n\t\tthis.name = '';\n\t\tthis.joints = [];\n\t\tthis.links = [];\n\n\t}\n\n\tKinematicsModel.prototype.parse = function( element ) {\n\n\t\tthis.id = element.getAttribute('id');\n\t\tthis.name = element.getAttribute('name');\n\t\tthis.joints = [];\n\t\tthis.links = [];\n\n\t\tfor (var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'technique_common':\n\n\t\t\t\t\tthis.parseCommon(child);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tKinematicsModel.prototype.parseCommon = function( element ) {\n\n\t\tfor (var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( element.childNodes[ i ].nodeName ) {\n\n\t\t\t\tcase 'joint':\n\t\t\t\t\tthis.joints.push( (new Joint()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'link':\n\t\t\t\t\tthis.links.push( (new Link()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Joint( ) {\n\n\t\tthis.sid = '';\n\t\tthis.name = '';\n\t\tthis.axis = new THREE.Vector3();\n\t\tthis.limits = {\n\t\t\tmin: 0,\n\t\t\tmax: 0\n\t\t};\n\t\tthis.type = '';\n\t\tthis.static = false;\n\t\tthis.zeroPosition = 0.0;\n\t\tthis.middlePosition = 0.0;\n\n\t}\n\n\tJoint.prototype.parse = function( element ) {\n\n\t\tthis.sid = element.getAttribute('sid');\n\t\tthis.name = element.getAttribute('name');\n\t\tthis.axis = new THREE.Vector3();\n\t\tthis.limits = {\n\t\t\tmin: 0,\n\t\t\tmax: 0\n\t\t};\n\t\tthis.type = '';\n\t\tthis.static = false;\n\t\tthis.zeroPosition = 0.0;\n\t\tthis.middlePosition = 0.0;\n\n\t\tvar axisElement = element.querySelector('axis');\n\t\tvar _axis = _floats(axisElement.textContent);\n\t\tthis.axis = getConvertedVec3(_axis, 0);\n\n\t\tvar min = element.querySelector('limits min') ? parseFloat(element.querySelector('limits min').textContent) : -360;\n\t\tvar max = element.querySelector('limits max') ? parseFloat(element.querySelector('limits max').textContent) : 360;\n\n\t\tthis.limits = {\n\t\t\tmin: min,\n\t\t\tmax: max\n\t\t};\n\n\t\tvar jointTypes = [ 'prismatic', 'revolute' ];\n\t\tfor (var i = 0; i < jointTypes.length; i ++ ) {\n\n\t\t\tvar type = jointTypes[ i ];\n\n\t\t\tvar jointElement = element.querySelector(type);\n\n\t\t\tif ( jointElement ) {\n\n\t\t\t\tthis.type = type;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// if the min is equal to or somehow greater than the max, consider the joint static\n\t\tif ( this.limits.min >= this.limits.max ) {\n\n\t\t\tthis.static = true;\n\n\t\t}\n\n\t\tthis.middlePosition = (this.limits.min + this.limits.max) / 2.0;\n\t\treturn this;\n\n\t};\n\n\tfunction Link( ) {\n\n\t\tthis.sid = '';\n\t\tthis.name = '';\n\t\tthis.transforms = [];\n\t\tthis.attachments = [];\n\n\t}\n\n\tLink.prototype.parse = function( element ) {\n\n\t\tthis.sid = element.getAttribute('sid');\n\t\tthis.name = element.getAttribute('name');\n\t\tthis.transforms = [];\n\t\tthis.attachments = [];\n\n\t\tfor (var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'attachment_full':\n\t\t\t\t\tthis.attachments.push( (new Attachment()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\tcase 'translate':\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tthis.transforms.push( (new Transform()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction Attachment( ) {\n\n\t\tthis.joint = '';\n\t\tthis.transforms = [];\n\t\tthis.links = [];\n\n\t}\n\n\tAttachment.prototype.parse = function( element ) {\n\n\t\tthis.joint = element.getAttribute('joint').split('/').pop();\n\t\tthis.links = [];\n\n\t\tfor (var i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tvar child = element.childNodes[ i ];\n\t\t\tif ( child.nodeType != 1 ) continue;\n\n\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\tcase 'link':\n\t\t\t\t\tthis.links.push( (new Link()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\tcase 'translate':\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tthis.transforms.push( (new Transform()).parse(child) );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tfunction _source( element ) {\n\n\t\tvar id = element.getAttribute( 'id' );\n\n\t\tif ( sources[ id ] != undefined ) {\n\n\t\t\treturn sources[ id ];\n\n\t\t}\n\n\t\tsources[ id ] = ( new Source(id )).parse( element );\n\t\treturn sources[ id ];\n\n\t};\n\n\tfunction _nsResolver( nsPrefix ) {\n\n\t\tif ( nsPrefix === \"dae\" ) {\n\n\t\t\treturn \"http://www.collada.org/2005/11/COLLADASchema\";\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n\tfunction _bools( str ) {\n\n\t\tvar raw = _strings( str );\n\t\tvar data = [];\n\n\t\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n\t\t\tdata.push( (raw[i] === 'true' || raw[i] === '1') ? true : false );\n\n\t\t}\n\n\t\treturn data;\n\n\t};\n\n\tfunction _floats( str ) {\n\n\t\tvar raw = _strings(str);\n\t\tvar data = [];\n\n\t\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n\t\t\tdata.push( parseFloat( raw[ i ] ) );\n\n\t\t}\n\n\t\treturn data;\n\n\t};\n\n\tfunction _ints( str ) {\n\n\t\tvar raw = _strings( str );\n\t\tvar data = [];\n\n\t\tfor ( var i = 0, l = raw.length; i < l; i ++ ) {\n\n\t\t\tdata.push( parseInt( raw[ i ], 10 ) );\n\n\t\t}\n\n\t\treturn data;\n\n\t};\n\n\tfunction _strings( str ) {\n\n\t\treturn ( str.length > 0 ) ? _trimString( str ).split( /\\s+/ ) : [];\n\n\t};\n\n\tfunction _trimString( str ) {\n\n\t\treturn str.replace( /^\\s+/, \"\" ).replace( /\\s+$/, \"\" );\n\n\t};\n\n\tfunction _attr_as_float( element, name, defaultValue ) {\n\n\t\tif ( element.hasAttribute( name ) ) {\n\n\t\t\treturn parseFloat( element.getAttribute( name ) );\n\n\t\t} else {\n\n\t\t\treturn defaultValue;\n\n\t\t}\n\n\t};\n\n\tfunction _attr_as_int( element, name, defaultValue ) {\n\n\t\tif ( element.hasAttribute( name ) ) {\n\n\t\t\treturn parseInt( element.getAttribute( name ), 10) ;\n\n\t\t} else {\n\n\t\t\treturn defaultValue;\n\n\t\t}\n\n\t};\n\n\tfunction _attr_as_string( element, name, defaultValue ) {\n\n\t\tif ( element.hasAttribute( name ) ) {\n\n\t\t\treturn element.getAttribute( name );\n\n\t\t} else {\n\n\t\t\treturn defaultValue;\n\n\t\t}\n\n\t};\n\n\tfunction _format_float( f, num ) {\n\n\t\tif ( f === undefined ) {\n\n\t\t\tvar s = '0.';\n\n\t\t\twhile ( s.length < num + 2 ) {\n\n\t\t\t\ts += '0';\n\n\t\t\t}\n\n\t\t\treturn s;\n\n\t\t}\n\n\t\tnum = num || 2;\n\n\t\tvar parts = f.toString().split( '.' );\n\t\tparts[ 1 ] = parts.length > 1 ? parts[ 1 ].substr( 0, num ) : \"0\";\n\n\t\twhile ( parts[ 1 ].length < num ) {\n\n\t\t\tparts[ 1 ] += '0';\n\n\t\t}\n\n\t\treturn parts.join( '.' );\n\n\t};\n\n\tfunction loadTextureImage ( texture, url ) {\n\t\tvar Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\n\t\tMaterials.loadTextureImage( texture, {url: url});\n\t};\n\n\tfunction extractDoubleSided( obj, element ) {\n\n\t\tobj.doubleSided = false;\n\n\t\tvar node = element.querySelectorAll('extra double_sided')[0];\n\n\t\tif ( node ) {\n\n\t\t\tif ( node && parseInt( node.textContent, 10 ) === 1 ) {\n\n\t\t\t\tobj.doubleSided = true;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\t// Up axis conversion\n\n\tfunction setUpConversion() {\n\n\t\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n\t\t\tupConversion = null;\n\n\t\t} else {\n\n\t\t\tswitch ( colladaUp ) {\n\n\t\t\t\tcase 'X':\n\n\t\t\t\t\tupConversion = options.upAxis === 'Y' ? 'XtoY' : 'XtoZ';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Y':\n\n\t\t\t\t\tupConversion = options.upAxis === 'X' ? 'YtoX' : 'YtoZ';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Z':\n\n\t\t\t\t\tupConversion = options.upAxis === 'X' ? 'ZtoX' : 'ZtoY';\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tfunction fixCoords( data, sign ) {\n\n\t\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tswitch ( upConversion ) {\n\n\t\t\tcase 'XtoY':\n\n\t\t\t\tvar tmp = data[ 0 ];\n\t\t\t\tdata[ 0 ] = sign * data[ 1 ];\n\t\t\t\tdata[ 1 ] = tmp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'XtoZ':\n\n\t\t\t\tvar tmp = data[ 2 ];\n\t\t\t\tdata[ 2 ] = data[ 1 ];\n\t\t\t\tdata[ 1 ] = data[ 0 ];\n\t\t\t\tdata[ 0 ] = tmp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YtoX':\n\n\t\t\t\tvar tmp = data[ 0 ];\n\t\t\t\tdata[ 0 ] = data[ 1 ];\n\t\t\t\tdata[ 1 ] = sign * tmp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'YtoZ':\n\n\t\t\t\tvar tmp = data[ 1 ];\n\t\t\t\tdata[ 1 ] = sign * data[ 2 ];\n\t\t\t\tdata[ 2 ] = tmp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZtoX':\n\n\t\t\t\tvar tmp = data[ 0 ];\n\t\t\t\tdata[ 0 ] = data[ 1 ];\n\t\t\t\tdata[ 1 ] = data[ 2 ];\n\t\t\t\tdata[ 2 ] = tmp;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZtoY':\n\n\t\t\t\tvar tmp = data[ 1 ];\n\t\t\t\tdata[ 1 ] = data[ 2 ];\n\t\t\t\tdata[ 2 ] = sign * tmp;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t};\n\n\tfunction getConvertedTranslation( axis, data ) {\n\n\t\tif ( options.convertUpAxis !== true || colladaUp === options.upAxis ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tswitch ( axis ) {\n\t\t\tcase 'X':\n\t\t\t\tdata = upConversion === 'XtoY' ? data * -1 : data;\n\t\t\t\tbreak;\n\t\t\tcase 'Y':\n\t\t\t\tdata = upConversion === 'YtoZ' || upConversion === 'YtoX' ? data * -1 : data;\n\t\t\t\tbreak;\n\t\t\tcase 'Z':\n\t\t\t\tdata = upConversion === 'ZtoY' ? data * -1 : data ;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn data;\n\t};\n\n\tfunction getConvertedVec3( data, offset ) {\n\n\t\tvar arr = [ data[ offset ], data[ offset + 1 ], data[ offset + 2 ] ];\n\t\tfixCoords( arr, -1 );\n\t\treturn new THREE.Vector3( arr[ 0 ], arr[ 1 ], arr[ 2 ] );\n\n\t};\n\n\tfunction getConvertedMat4( data ) {\n\n\t\tif ( options.convertUpAxis ) {\n\n\t\t\t// First fix rotation and scale\n\n\t\t\t// Columns first\n\t\t\tvar arr = [ data[ 0 ], data[ 4 ], data[ 8 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 0 ] = arr[ 0 ];\n\t\t\tdata[ 4 ] = arr[ 1 ];\n\t\t\tdata[ 8 ] = arr[ 2 ];\n\t\t\tarr = [ data[ 1 ], data[ 5 ], data[ 9 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 1 ] = arr[ 0 ];\n\t\t\tdata[ 5 ] = arr[ 1 ];\n\t\t\tdata[ 9 ] = arr[ 2 ];\n\t\t\tarr = [ data[ 2 ], data[ 6 ], data[ 10 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 2 ] = arr[ 0 ];\n\t\t\tdata[ 6 ] = arr[ 1 ];\n\t\t\tdata[ 10 ] = arr[ 2 ];\n\t\t\t// Rows second\n\t\t\tarr = [ data[ 0 ], data[ 1 ], data[ 2 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 0 ] = arr[ 0 ];\n\t\t\tdata[ 1 ] = arr[ 1 ];\n\t\t\tdata[ 2 ] = arr[ 2 ];\n\t\t\tarr = [ data[ 4 ], data[ 5 ], data[ 6 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 4 ] = arr[ 0 ];\n\t\t\tdata[ 5 ] = arr[ 1 ];\n\t\t\tdata[ 6 ] = arr[ 2 ];\n\t\t\tarr = [ data[ 8 ], data[ 9 ], data[ 10 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 8 ] = arr[ 0 ];\n\t\t\tdata[ 9 ] = arr[ 1 ];\n\t\t\tdata[ 10 ] = arr[ 2 ];\n\n\t\t\t// Now fix translation\n\t\t\tarr = [ data[ 3 ], data[ 7 ], data[ 11 ] ];\n\t\t\tfixCoords( arr, -1 );\n\t\t\tdata[ 3 ] = arr[ 0 ];\n\t\t\tdata[ 7 ] = arr[ 1 ];\n\t\t\tdata[ 11 ] = arr[ 2 ];\n\n\t\t}\n\n\t\treturn new THREE.Matrix4().set(\n\t\t\tdata[0], data[1], data[2], data[3],\n\t\t\tdata[4], data[5], data[6], data[7],\n\t\t\tdata[8], data[9], data[10], data[11],\n\t\t\tdata[12], data[13], data[14], data[15]\n\t\t\t);\n\n\t};\n\n\tfunction getConvertedIndex( index ) {\n\n\t\tif ( index > -1 && index < 3 ) {\n\n\t\t\tvar members = [ 'X', 'Y', 'Z' ],\n\t\t\t\tindices = { X: 0, Y: 1, Z: 2 };\n\n\t\t\tindex = getConvertedMember( members[ index ] );\n\t\t\tindex = indices[ index ];\n\n\t\t}\n\n\t\treturn index;\n\n\t};\n\n\tfunction getConvertedMember( member ) {\n\n\t\tif ( options.convertUpAxis ) {\n\n\t\t\tswitch ( member ) {\n\n\t\t\t\tcase 'X':\n\n\t\t\t\t\tswitch ( upConversion ) {\n\n\t\t\t\t\t\tcase 'XtoY':\n\t\t\t\t\t\tcase 'XtoZ':\n\t\t\t\t\t\tcase 'YtoX':\n\n\t\t\t\t\t\t\tmember = 'Y';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'ZtoX':\n\n\t\t\t\t\t\t\tmember = 'Z';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Y':\n\n\t\t\t\t\tswitch ( upConversion ) {\n\n\t\t\t\t\t\tcase 'XtoY':\n\t\t\t\t\t\tcase 'YtoX':\n\t\t\t\t\t\tcase 'ZtoX':\n\n\t\t\t\t\t\t\tmember = 'X';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'XtoZ':\n\t\t\t\t\t\tcase 'YtoZ':\n\t\t\t\t\t\tcase 'ZtoY':\n\n\t\t\t\t\t\t\tmember = 'Z';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'Z':\n\n\t\t\t\t\tswitch ( upConversion ) {\n\n\t\t\t\t\t\tcase 'XtoZ':\n\n\t\t\t\t\t\t\tmember = 'X';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'YtoZ':\n\t\t\t\t\t\tcase 'ZtoX':\n\t\t\t\t\t\tcase 'ZtoY':\n\n\t\t\t\t\t\t\tmember = 'Y';\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn member;\n\n\t};\n\n\treturn {\n\n\t\tload: load,\n\t\tparse: parse,\n\t\tsetPreferredShading: setPreferredShading,\n\t\tapplySkin: applySkin,\n\t\tgeometries : geometries,\n\t\toptions: options\n\n\t};\n\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/ColladaLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/GLTFLoader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/GLTFLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * @author Rich Tibbett / https://github.com/richtr\n * @author mrdoob / http://mrdoob.com/\n * @author Tony Parisi / http://www.tonyparisi.com/\n * @author Takahiro / https://github.com/takahirox\n * @author Don McCurdy / https://www.donmccurdy.com\n */\n\nvar ImageUtil = __webpack_require__(/*! util/ImageUtil */ \"./js/lib/util/ImageUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nTHREE.GLTFLoader = ( function () {\n\n\tfunction GLTFLoader( manager ) {\n\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\t\tthis.dracoLoader = null;\n\n\t}\n\n\tGLTFLoader.prototype = {\n\n\t\tconstructor: GLTFLoader,\n\n\t\tcrossOrigin: 'anonymous',\n\n    // AXC: loader options\n    setOptions: function(options) {\n      this.options = options;\n    },\n\n    // AXC: Custom file loader\n    getFileLoader: function(responseType) {\n      var loader =  new THREE.FileLoader(this.manager);\n      loader.setResponseType(responseType);\n      return loader;\n    },\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = this.path !== undefined ? this.path : THREE.LoaderUtils.extractUrlBase( url );\n\n      var loader = this.getFileLoader('arraybuffer');\n\n\t\t\tloader.load( url, function ( data ) {\n\n\t\t\t\ttry {\n\n\t\t\t\t\tscope.parse( data, path, onLoad, onError );\n\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\tif ( onError !== undefined ) {\n\n\t\t\t\t\t\tonError( e );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow e;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tsetCrossOrigin: function ( value ) {\n\n\t\t\tthis.crossOrigin = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetPath: function ( value ) {\n\n\t\t\tthis.path = value;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetDRACOLoader: function ( dracoLoader ) {\n\n\t\t\tthis.dracoLoader = dracoLoader;\n\t\t\treturn this;\n\n\t\t},\n\n\t\tparse: function ( data, path, onLoad, onError ) {\n\n\t\t\tvar content;\n\t\t\tvar extensions = {};\n\n\t\t\tif ( typeof data === 'string' ) {\n\n\t\t\t\tcontent = data;\n\n\t\t\t} else {\n\n\t\t\t\tvar magic = THREE.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );\n\n\t\t\t\tif ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\t\t\ttry {\n\n\t\t\t\t\t\textensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );\n\n\t\t\t\t\t} catch ( error ) {\n\n\t\t\t\t\t\tif ( onError ) onError( error );\n\t\t\t\t\t\treturn;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tcontent = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcontent = THREE.LoaderUtils.decodeText( new Uint8Array( data ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar json = JSON.parse( content );\n\n\t\t\tif ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {\n\n\t\t\t\tif ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( json.extensionsUsed ) {\n\n\t\t\t\tfor ( var i = 0; i < json.extensionsUsed.length; ++ i ) {\n\n\t\t\t\t\tvar extensionName = json.extensionsUsed[ i ];\n\t\t\t\t\tvar extensionsRequired = json.extensionsRequired || [];\n\n\t\t\t\t\tswitch ( extensionName ) {\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_LIGHTS_PUNCTUAL:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFLightsExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_UNLIT:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsUnlitExtension( json );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n\t\t\t\t\t\t\textensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase EXTENSIONS.MSFT_TEXTURE_DDS:\n\t\t\t\t\t\t\textensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] = new GLTFTextureDDSExtension();\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tif ( extensionsRequired.indexOf( extensionName ) >= 0 ) {\n\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".' );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n      // AXC: set options\n      var options = {\n        path: path || this.path || '',\n        crossOrigin: this.crossOrigin,\n        manager: this.manager,\n        fileLoader:  this.getFileLoader('arraybuffer')\n      };\n      if (this.options) {\n        for (var key in this.options) {\n          if (this.options.hasOwnProperty(key) && !options.hasOwnProperty(key)) {\n            options[key] = this.options[key];\n          }\n        }\n      }\n      var parser = new GLTFParser( json, extensions, options ); // AXC: set options\n\n\t\t\tparser.parse( function ( scene, scenes, cameras, animations, json ) {\n\n\t\t\t\tvar glTF = {\n\t\t\t\t\tscene: scene,\n\t\t\t\t\tscenes: scenes,\n\t\t\t\t\tcameras: cameras,\n\t\t\t\t\tanimations: animations,\n\t\t\t\t\tasset: json.asset,\n\t\t\t\t\tparser: parser,\n\t\t\t\t\tuserData: {}\n\t\t\t\t};\n\n\t\t\t\taddUnknownExtensionsToUserData( extensions, glTF, json );\n\n\t\t\t\tonLoad( glTF );\n\n\t\t\t}, function(err) {\n        if (onError) {\n          onError(err);\n        } else {\n        \tconsole.error('Error loading gltf', err);\n\t\t\t\t}\n      } );\n\n\t\t}\n\n\t};\n\n\t/* GLTFREGISTRY */\n\n\tfunction GLTFRegistry() {\n\n\t\tvar objects = {};\n\n\t\treturn\t{\n\n\t\t\tget: function ( key ) {\n\n\t\t\t\treturn objects[ key ];\n\n\t\t\t},\n\n\t\t\tadd: function ( key, object ) {\n\n\t\t\t\tobjects[ key ] = object;\n\n\t\t\t},\n\n\t\t\tremove: function ( key ) {\n\n\t\t\t\tdelete objects[ key ];\n\n\t\t\t},\n\n\t\t\tremoveAll: function () {\n\n\t\t\t\tobjects = {};\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** EXTENSIONS ***********/\n\t/*********************************/\n\n\tvar EXTENSIONS = {\n\t\tKHR_BINARY_GLTF: 'KHR_binary_glTF',\n\t\tKHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',\n\t\tKHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',\n\t\tKHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',\n\t\tKHR_MATERIALS_UNLIT: 'KHR_materials_unlit',\n\t\tMSFT_TEXTURE_DDS: 'MSFT_texture_dds'\n\t};\n\n\t/**\n\t * DDS Texture Extension\n\t *\n\t * Specification:\n\t * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds\n\t *\n\t */\n\tfunction GLTFTextureDDSExtension() {\n\n\t\tif ( ! THREE.DDSLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.MSFT_TEXTURE_DDS;\n\t\tthis.ddsLoader = new THREE.DDSLoader();\n\n\t}\n\n\t/**\n\t * Lights Extension\n\t *\n\t * Specification: PENDING\n\t */\n\tfunction GLTFLightsExtension( json ) {\n\n\t\tthis.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n\n\t\tthis.lights = [];\n\n\t\tvar extension = ( json.extensions && json.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ] ) || {};\n\t\tvar lightDefs = extension.lights || [];\n\n\t\tfor ( var i = 0; i < lightDefs.length; i ++ ) {\n\n\t\t\tvar lightDef = lightDefs[ i ];\n\t\t\tvar lightNode;\n\n\t\t\tvar color = new THREE.Color( 0xffffff );\n\t\t\tif ( lightDef.color !== undefined ) color.fromArray( lightDef.color );\n\n\t\t\tvar range = lightDef.range !== undefined ? lightDef.range : 0;\n\n\t\t\tswitch ( lightDef.type ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlightNode = new THREE.DirectionalLight( color );\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlightNode = new THREE.PointLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlightNode = new THREE.SpotLight( color );\n\t\t\t\t\tlightNode.distance = range;\n\t\t\t\t\t// Handle spotlight properties.\n\t\t\t\t\tlightDef.spot = lightDef.spot || {};\n\t\t\t\t\tlightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;\n\t\t\t\t\tlightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;\n\t\t\t\t\tlightNode.angle = lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n\t\t\t\t\tlightNode.target.position.set( 0, 0, 1 );\n\t\t\t\t\tlightNode.add( lightNode.target );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Unexpected light type, \"' + lightDef.type + '\".' );\n\n\t\t\t}\n\n\t\t\tlightNode.decay = 2;\n\n\t\t\tif ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;\n\n\t\t\tlightNode.name = lightDef.name || ( 'light_' + i );\n\n\t\t\tthis.lights.push( lightNode );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Unlit Materials Extension (pending)\n\t *\n\t * PR: https://github.com/KhronosGroup/glTF/pull/1163\n\t */\n\tfunction GLTFMaterialsUnlitExtension( json ) {\n\n\t\tthis.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n\n\t}\n\n\tGLTFMaterialsUnlitExtension.prototype.getMaterialType = function ( material ) {\n\n\t\treturn THREE.MeshBasicMaterial;\n\n\t};\n\n\tGLTFMaterialsUnlitExtension.prototype.extendParams = function ( materialParams, material, parser ) {\n\n\t\tvar pending = [];\n\n\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\tmaterialParams.opacity = 1.0;\n\n\t\tvar metallicRoughness = material.pbrMetallicRoughness;\n\n\t\tif ( metallicRoughness ) {\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn Promise.all( pending );\n\n\t};\n\n\t/* BINARY EXTENSION */\n\n\tvar BINARY_EXTENSION_BUFFER_NAME = 'binary_glTF';\n\tvar BINARY_EXTENSION_HEADER_MAGIC = 'glTF';\n\tvar BINARY_EXTENSION_HEADER_LENGTH = 12;\n\tvar BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };\n\n\tfunction GLTFBinaryExtension( data ) {\n\n\t\tthis.name = EXTENSIONS.KHR_BINARY_GLTF;\n\t\tthis.content = null;\n\t\tthis.body = null;\n\n\t\tvar headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );\n\n\t\tthis.header = {\n\t\t\tmagic: THREE.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),\n\t\t\tversion: headerView.getUint32( 4, true ),\n\t\t\tlength: headerView.getUint32( 8, true )\n\t\t};\n\n\t\tif ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );\n\n\t\t} else if ( this.header.version < 2.0 ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.' );\n\n\t\t}\n\n\t\tvar chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );\n\t\tvar chunkIndex = 0;\n\n\t\twhile ( chunkIndex < chunkView.byteLength ) {\n\n\t\t\tvar chunkLength = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tvar chunkType = chunkView.getUint32( chunkIndex, true );\n\t\t\tchunkIndex += 4;\n\n\t\t\tif ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {\n\n\t\t\t\tvar contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );\n\t\t\t\tthis.content = THREE.LoaderUtils.decodeText( contentArray );\n\n\t\t\t} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {\n\n\t\t\t\tvar byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n\t\t\t\tthis.body = data.slice( byteOffset, byteOffset + chunkLength );\n\n\t\t\t}\n\n\t\t\t// Clients must ignore chunks with unknown types.\n\n\t\t\tchunkIndex += chunkLength;\n\n\t\t}\n\n\t\tif ( this.content === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: JSON content not found.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * DRACO Mesh Compression Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/pull/874\n\t */\n\tfunction GLTFDracoMeshCompressionExtension( json, dracoLoader ) {\n\n\t\tif ( ! dracoLoader ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );\n\n\t\t}\n\n\t\tthis.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n\t\tthis.json = json;\n\t\tthis.dracoLoader = dracoLoader;\n\n\t}\n\n\tGLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function ( primitive, parser ) {\n\n\t\tvar json = this.json;\n\t\tvar dracoLoader = this.dracoLoader;\n\t\tvar bufferViewIndex = primitive.extensions[ this.name ].bufferView;\n\t\tvar gltfAttributeMap = primitive.extensions[ this.name ].attributes;\n\t\tvar threeAttributeMap = {};\n\t\tvar attributeNormalizedMap = {};\n\t\tvar attributeTypeMap = {};\n\n\t\tfor ( var attributeName in gltfAttributeMap ) {\n\n\t\t\tif ( ! ( attributeName in ATTRIBUTES ) ) continue;\n\n\t\t\tthreeAttributeMap[ ATTRIBUTES[ attributeName ] ] = gltfAttributeMap[ attributeName ];\n\n\t\t}\n\n\t\tfor ( attributeName in primitive.attributes ) {\n\n\t\t\tif ( ATTRIBUTES[ attributeName ] !== undefined && gltfAttributeMap[ attributeName ] !== undefined ) {\n\n\t\t\t\tvar accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];\n\t\t\t\tvar componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t\tattributeTypeMap[ ATTRIBUTES[ attributeName ] ] = componentType;\n\t\t\t\tattributeNormalizedMap[ ATTRIBUTES[ attributeName ] ] = accessorDef.normalized === true;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {\n\n\t\t\treturn new Promise( function ( resolve ) {\n\n\t\t\t\tdracoLoader.decodeDracoFile( bufferView, function ( geometry ) {\n\n\t\t\t\t\tfor ( var attributeName in geometry.attributes ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes[ attributeName ];\n\t\t\t\t\t\tvar normalized = attributeNormalizedMap[ attributeName ];\n\n\t\t\t\t\t\tif ( normalized !== undefined ) attribute.normalized = normalized;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve( geometry );\n\n\t\t\t\t}, threeAttributeMap, attributeTypeMap );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specular-Glossiness Extension\n\t *\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\n\t */\n\tfunction GLTFMaterialsPbrSpecularGlossinessExtension() {\n\n\t\treturn {\n\n\t\t\tname: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,\n\n\t\t\tspecularGlossinessParams: [\n\t\t\t\t'color',\n\t\t\t\t'map',\n\t\t\t\t'lightMap',\n\t\t\t\t'lightMapIntensity',\n\t\t\t\t'aoMap',\n\t\t\t\t'aoMapIntensity',\n\t\t\t\t'emissive',\n\t\t\t\t'emissiveIntensity',\n\t\t\t\t'emissiveMap',\n\t\t\t\t'bumpMap',\n\t\t\t\t'bumpScale',\n\t\t\t\t'normalMap',\n\t\t\t\t'displacementMap',\n\t\t\t\t'displacementScale',\n\t\t\t\t'displacementBias',\n\t\t\t\t'specularMap',\n\t\t\t\t'specular',\n\t\t\t\t'glossinessMap',\n\t\t\t\t'glossiness',\n\t\t\t\t'alphaMap',\n\t\t\t\t'envMap',\n\t\t\t\t'envMapIntensity',\n\t\t\t\t'refractionRatio',\n\t\t\t],\n\n\t\t\tgetMaterialType: function () {\n\n\t\t\t\treturn THREE.ShaderMaterial;\n\n\t\t\t},\n\n\t\t\textendParams: function ( params, material, parser ) {\n\n\t\t\t\tvar pbrSpecularGlossiness = material.extensions[ this.name ];\n\n\t\t\t\tvar shader = THREE.ShaderLib[ 'standard' ];\n\n\t\t\t\tvar uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\t\t\tvar specularMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tuniform sampler2D specularMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapParsFragmentChunk = [\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tuniform sampler2D glossinessMap;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar specularMapFragmentChunk = [\n\t\t\t\t\t'vec3 specularFactor = specular;',\n\t\t\t\t\t'#ifdef USE_SPECULARMAP',\n\t\t\t\t\t'\tvec4 texelSpecular = texture2D( specularMap, vUv );',\n\t\t\t\t\t'\ttexelSpecular = sRGBToLinear( texelSpecular );',\n\t\t\t\t\t'\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tspecularFactor *= texelSpecular.rgb;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar glossinessMapFragmentChunk = [\n\t\t\t\t\t'float glossinessFactor = glossiness;',\n\t\t\t\t\t'#ifdef USE_GLOSSINESSMAP',\n\t\t\t\t\t'\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );',\n\t\t\t\t\t'\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',\n\t\t\t\t\t'\tglossinessFactor *= texelGlossiness.a;',\n\t\t\t\t\t'#endif'\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar lightPhysicalFragmentChunk = [\n\t\t\t\t\t'PhysicalMaterial material;',\n\t\t\t\t\t'material.diffuseColor = diffuseColor.rgb;',\n\t\t\t\t\t'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );',\n\t\t\t\t\t'material.specularColor = specularFactor.rgb;',\n\t\t\t\t].join( '\\n' );\n\n\t\t\t\tvar fragmentShader = shader.fragmentShader\n\t\t\t\t\t.replace( 'uniform float roughness;', 'uniform vec3 specular;' )\n\t\t\t\t\t.replace( 'uniform float metalness;', 'uniform float glossiness;' )\n\t\t\t\t\t.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )\n\t\t\t\t\t.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )\n\t\t\t\t\t.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );\n\n\t\t\t\tdelete uniforms.roughness;\n\t\t\t\tdelete uniforms.metalness;\n\t\t\t\tdelete uniforms.roughnessMap;\n\t\t\t\tdelete uniforms.metalnessMap;\n\n\t\t\t\tuniforms.specular = { value: new THREE.Color().setHex( 0x111111 ) };\n\t\t\t\tuniforms.glossiness = { value: 0.5 };\n\t\t\t\tuniforms.specularMap = { value: null };\n\t\t\t\tuniforms.glossinessMap = { value: null };\n\n\t\t\t\tparams.vertexShader = shader.vertexShader;\n\t\t\t\tparams.fragmentShader = fragmentShader;\n\t\t\t\tparams.uniforms = uniforms;\n\t\t\t\tparams.defines = { 'STANDARD': '' };\n\n\t\t\t\tparams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\t\tparams.opacity = 1.0;\n\n\t\t\t\tvar pending = [];\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {\n\n\t\t\t\t\tvar array = pbrSpecularGlossiness.diffuseFactor;\n\n\t\t\t\t\tparams.color.fromArray( array );\n\t\t\t\t\tparams.opacity = array[ 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {\n\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'map', pbrSpecularGlossiness.diffuseTexture.index ) );\n\n\t\t\t\t}\n\n\t\t\t\tparams.emissive = new THREE.Color( 0.0, 0.0, 0.0 );\n\t\t\t\tparams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;\n\t\t\t\tparams.specular = new THREE.Color( 1.0, 1.0, 1.0 );\n\n\t\t\t\tif ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {\n\n\t\t\t\t\tparams.specular.fromArray( pbrSpecularGlossiness.specularFactor );\n\n\t\t\t\t}\n\n\t\t\t\tif ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {\n\n\t\t\t\t\tvar specGlossIndex = pbrSpecularGlossiness.specularGlossinessTexture.index;\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'glossinessMap', specGlossIndex ) );\n\t\t\t\t\tpending.push( parser.assignTexture( params, 'specularMap', specGlossIndex ) );\n\n\t\t\t\t}\n\n\t\t\t\treturn Promise.all( pending );\n\n\t\t\t},\n\n\t\t\tcreateMaterial: function ( params ) {\n\n\t\t\t\t// setup material properties based on MeshStandardMaterial for Specular-Glossiness\n\n\t\t\t\tvar material = new THREE.ShaderMaterial( {\n\t\t\t\t\tdefines: params.defines,\n\t\t\t\t\tvertexShader: params.vertexShader,\n\t\t\t\t\tfragmentShader: params.fragmentShader,\n\t\t\t\t\tuniforms: params.uniforms,\n\t\t\t\t\tfog: true,\n\t\t\t\t\tlights: true,\n\t\t\t\t\topacity: params.opacity,\n\t\t\t\t\ttransparent: params.transparent\n\t\t\t\t} );\n\n\t\t\t\tmaterial.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tmaterial.color = params.color;\n\n\t\t\t\tmaterial.map = params.map === undefined ? null : params.map;\n\n\t\t\t\tmaterial.lightMap = null;\n\t\t\t\tmaterial.lightMapIntensity = 1.0;\n\n\t\t\t\tmaterial.aoMap = params.aoMap === undefined ? null : params.aoMap;\n\t\t\t\tmaterial.aoMapIntensity = 1.0;\n\n\t\t\t\tmaterial.emissive = params.emissive;\n\t\t\t\tmaterial.emissiveIntensity = 1.0;\n\t\t\t\tmaterial.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;\n\n\t\t\t\tmaterial.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;\n\t\t\t\tmaterial.bumpScale = 1;\n\n\t\t\t\tmaterial.normalMap = params.normalMap === undefined ? null : params.normalMap;\n\t\t\t\tif ( params.normalScale ) material.normalScale = params.normalScale;\n\n\t\t\t\tmaterial.displacementMap = null;\n\t\t\t\tmaterial.displacementScale = 1;\n\t\t\t\tmaterial.displacementBias = 0;\n\n\t\t\t\tmaterial.specularMap = params.specularMap === undefined ? null : params.specularMap;\n\t\t\t\tmaterial.specular = params.specular;\n\n\t\t\t\tmaterial.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;\n\t\t\t\tmaterial.glossiness = params.glossiness;\n\n\t\t\t\tmaterial.alphaMap = null;\n\n\t\t\t\tmaterial.envMap = params.envMap === undefined ? null : params.envMap;\n\t\t\t\tmaterial.envMapIntensity = 1.0;\n\n\t\t\t\tmaterial.refractionRatio = 0.98;\n\n\t\t\t\tmaterial.extensions.derivatives = true;\n\n\t\t\t\treturn material;\n\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can\n\t\t\t * copy only properties it knows about or inherits, and misses many properties that would\n\t\t\t * normally be defined by MeshStandardMaterial.\n\t\t\t *\n\t\t\t * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of\n\t\t\t * loading a glTF model, but cloning later (e.g. by the user) would require these changes\n\t\t\t * AND also updating `.onBeforeRender` on the parent mesh.\n\t\t\t *\n\t\t\t * @param  {THREE.ShaderMaterial} source\n\t\t\t * @return {THREE.ShaderMaterial}\n\t\t\t * @private\n\t\t\t */\n\t\t\tcloneMaterial: function ( source ) {\n\n\t\t\t\tvar target = source.clone();\n\n\t\t\t\ttarget.isGLTFSpecularGlossinessMaterial = true;\n\n\t\t\t\tvar params = this.specularGlossinessParams;\n\n\t\t\t\tfor ( var i = 0, il = params.length; i < il; i ++ ) {\n\n\t\t\t\t\ttarget[ params[ i ] ] = source[ params[ i ] ];\n\n\t\t\t\t}\n\n\t\t\t\treturn target;\n\n\t\t\t},\n\n\t\t\t// Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.\n\t\t\trefreshUniforms: function ( renderer, scene, camera, geometry, material, group ) {\n\n\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial !== true ) {\n\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar uniforms = material.uniforms;\n\t\t\t\tvar defines = material.defines;\n\n\t\t\t\tuniforms.opacity.value = material.opacity;\n\n\t\t\t\tuniforms.diffuse.value.copy( material.color );\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\n\n\t\t\t\tuniforms.map.value = material.map;\n\t\t\t\tuniforms.specularMap.value = material.specularMap;\n\t\t\t\tuniforms.alphaMap.value = material.alphaMap;\n\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\n\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\n\n\t\t\t\t// uv repeat and offset setting priorities\n\t\t\t\t// 1. color map\n\t\t\t\t// 2. specular map\n\t\t\t\t// 3. normal map\n\t\t\t\t// 4. bump map\n\t\t\t\t// 5. alpha map\n\t\t\t\t// 6. emissive map\n\n\t\t\t\tvar uvScaleMap;\n\n\t\t\t\tif ( material.map ) {\n\n\t\t\t\t\tuvScaleMap = material.map;\n\n\t\t\t\t} else if ( material.specularMap ) {\n\n\t\t\t\t\tuvScaleMap = material.specularMap;\n\n\t\t\t\t} else if ( material.displacementMap ) {\n\n\t\t\t\t\tuvScaleMap = material.displacementMap;\n\n\t\t\t\t} else if ( material.normalMap ) {\n\n\t\t\t\t\tuvScaleMap = material.normalMap;\n\n\t\t\t\t} else if ( material.bumpMap ) {\n\n\t\t\t\t\tuvScaleMap = material.bumpMap;\n\n\t\t\t\t} else if ( material.glossinessMap ) {\n\n\t\t\t\t\tuvScaleMap = material.glossinessMap;\n\n\t\t\t\t} else if ( material.alphaMap ) {\n\n\t\t\t\t\tuvScaleMap = material.alphaMap;\n\n\t\t\t\t} else if ( material.emissiveMap ) {\n\n\t\t\t\t\tuvScaleMap = material.emissiveMap;\n\n\t\t\t\t}\n\n\t\t\t\tif ( uvScaleMap !== undefined ) {\n\n\t\t\t\t\t// backwards compatibility\n\t\t\t\t\tif ( uvScaleMap.isWebGLRenderTarget ) {\n\n\t\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( uvScaleMap.matrixAutoUpdate === true ) {\n\n\t\t\t\t\t\tuvScaleMap.updateMatrix();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\n\n\t\t\t\t}\n\n\t\t\t\tuniforms.envMap.value = material.envMap;\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\n\t\t\t\tuniforms.flipEnvMap.value = ( material.envMap && material.envMap.isCubeTexture ) ? - 1 : 1;\n\n\t\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\n\n\t\t\t\tuniforms.specular.value.copy( material.specular );\n\t\t\t\tuniforms.glossiness.value = material.glossiness;\n\n\t\t\t\tuniforms.glossinessMap.value = material.glossinessMap;\n\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\n\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\n\n\t\t\t\tif ( uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined ) {\n\n\t\t\t\t\tdefines.USE_GLOSSINESSMAP = '';\n\t\t\t\t\t// set USE_ROUGHNESSMAP to enable vUv\n\t\t\t\t\tdefines.USE_ROUGHNESSMAP = '';\n\n\t\t\t\t}\n\n\t\t\t\tif ( uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined ) {\n\n\t\t\t\t\tdelete defines.USE_GLOSSINESSMAP;\n\t\t\t\t\tdelete defines.USE_ROUGHNESSMAP;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\t/*********************************/\n\t/********** INTERPOLATION ********/\n\t/*********************************/\n\n\t// Spline Interpolation\n\t// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\n\tfunction GLTFCubicSplineInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\n\n\t\tTHREE.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\n\n\t}\n\n\tGLTFCubicSplineInterpolant.prototype = Object.create( THREE.Interpolant.prototype );\n\tGLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;\n\n\tGLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {\n\n\t\tvar result = this.resultBuffer;\n\t\tvar values = this.sampleValues;\n\t\tvar stride = this.valueSize;\n\n\t\tvar stride2 = stride * 2;\n\t\tvar stride3 = stride * 3;\n\n\t\tvar td = t1 - t0;\n\n\t\tvar p = ( t - t0 ) / td;\n\t\tvar pp = p * p;\n\t\tvar ppp = pp * p;\n\n\t\tvar offset1 = i1 * stride3;\n\t\tvar offset0 = offset1 - stride3;\n\n\t\tvar s0 = 2 * ppp - 3 * pp + 1;\n\t\tvar s1 = ppp - 2 * pp + p;\n\t\tvar s2 = - 2 * ppp + 3 * pp;\n\t\tvar s3 = ppp - pp;\n\n\t\t// Layout of keyframe output values for CUBICSPLINE animations:\n\t\t//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\n\t\tfor ( var i = 0; i !== stride; i ++ ) {\n\n\t\t\tvar p0 = values[ offset0 + i + stride ]; // splineVertex_k\n\t\t\tvar m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)\n\t\t\tvar p1 = values[ offset1 + i + stride ]; // splineVertex_k+1\n\t\t\tvar m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)\n\n\t\t\tresult[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n\n\t\t}\n\n\t\treturn result;\n\n\t};\n\n\t/*********************************/\n\t/********** INTERNALS ************/\n\t/*********************************/\n\n\t/* CONSTANTS */\n\n\tvar WEBGL_CONSTANTS = {\n\t\tFLOAT: 5126,\n\t\t//FLOAT_MAT2: 35674,\n\t\tFLOAT_MAT3: 35675,\n\t\tFLOAT_MAT4: 35676,\n\t\tFLOAT_VEC2: 35664,\n\t\tFLOAT_VEC3: 35665,\n\t\tFLOAT_VEC4: 35666,\n\t\tLINEAR: 9729,\n\t\tREPEAT: 10497,\n\t\tSAMPLER_2D: 35678,\n\t\tPOINTS: 0,\n\t\tLINES: 1,\n\t\tLINE_LOOP: 2,\n\t\tLINE_STRIP: 3,\n\t\tTRIANGLES: 4,\n\t\tTRIANGLE_STRIP: 5,\n\t\tTRIANGLE_FAN: 6,\n\t\tUNSIGNED_BYTE: 5121,\n\t\tUNSIGNED_SHORT: 5123\n\t};\n\n\tvar WEBGL_TYPE = {\n\t\t5126: Number,\n\t\t//35674: THREE.Matrix2,\n\t\t35675: THREE.Matrix3,\n\t\t35676: THREE.Matrix4,\n\t\t35664: THREE.Vector2,\n\t\t35665: THREE.Vector3,\n\t\t35666: THREE.Vector4,\n\t\t35678: THREE.Texture\n\t};\n\n\tvar WEBGL_COMPONENT_TYPES = {\n\t\t5120: Int8Array,\n\t\t5121: Uint8Array,\n\t\t5122: Int16Array,\n\t\t5123: Uint16Array,\n\t\t5125: Uint32Array,\n\t\t5126: Float32Array\n\t};\n\n\tvar WEBGL_FILTERS = {\n\t\t9728: THREE.NearestFilter,\n\t\t9729: THREE.LinearFilter,\n\t\t9984: THREE.NearestMipMapNearestFilter,\n\t\t9985: THREE.LinearMipMapNearestFilter,\n\t\t9986: THREE.NearestMipMapLinearFilter,\n\t\t9987: THREE.LinearMipMapLinearFilter\n\t};\n\n\tvar WEBGL_WRAPPINGS = {\n\t\t33071: THREE.ClampToEdgeWrapping,\n\t\t33648: THREE.MirroredRepeatWrapping,\n\t\t10497: THREE.RepeatWrapping\n\t};\n\n\tvar WEBGL_SIDES = {\n\t\t1028: THREE.BackSide, // Culling front\n\t\t1029: THREE.FrontSide // Culling back\n\t\t//1032: THREE.NoSide   // Culling front and back, what to do?\n\t};\n\n\tvar WEBGL_DEPTH_FUNCS = {\n\t\t512: THREE.NeverDepth,\n\t\t513: THREE.LessDepth,\n\t\t514: THREE.EqualDepth,\n\t\t515: THREE.LessEqualDepth,\n\t\t516: THREE.GreaterEqualDepth,\n\t\t517: THREE.NotEqualDepth,\n\t\t518: THREE.GreaterEqualDepth,\n\t\t519: THREE.AlwaysDepth\n\t};\n\n\tvar WEBGL_BLEND_EQUATIONS = {\n\t\t32774: THREE.AddEquation,\n\t\t32778: THREE.SubtractEquation,\n\t\t32779: THREE.ReverseSubtractEquation\n\t};\n\n\tvar WEBGL_BLEND_FUNCS = {\n\t\t0: THREE.ZeroFactor,\n\t\t1: THREE.OneFactor,\n\t\t768: THREE.SrcColorFactor,\n\t\t769: THREE.OneMinusSrcColorFactor,\n\t\t770: THREE.SrcAlphaFactor,\n\t\t771: THREE.OneMinusSrcAlphaFactor,\n\t\t772: THREE.DstAlphaFactor,\n\t\t773: THREE.OneMinusDstAlphaFactor,\n\t\t774: THREE.DstColorFactor,\n\t\t775: THREE.OneMinusDstColorFactor,\n\t\t776: THREE.SrcAlphaSaturateFactor\n\t\t// The followings are not supported by Three.js yet\n\t\t//32769: CONSTANT_COLOR,\n\t\t//32770: ONE_MINUS_CONSTANT_COLOR,\n\t\t//32771: CONSTANT_ALPHA,\n\t\t//32772: ONE_MINUS_CONSTANT_COLOR\n\t};\n\n\tvar WEBGL_TYPE_SIZES = {\n\t\t'SCALAR': 1,\n\t\t'VEC2': 2,\n\t\t'VEC3': 3,\n\t\t'VEC4': 4,\n\t\t'MAT2': 4,\n\t\t'MAT3': 9,\n\t\t'MAT4': 16\n\t};\n\n\tvar ATTRIBUTES = {\n\t\tPOSITION: 'position',\n\t\tNORMAL: 'normal',\n\t\tTEXCOORD_0: 'uv',\n\t\tTEXCOORD0: 'uv', // deprecated\n\t\tTEXCOORD: 'uv', // deprecated\n\t\tTEXCOORD_1: 'uv2',\n\t\tCOLOR_0: 'color',\n\t\tCOLOR0: 'color', // deprecated\n\t\tCOLOR: 'color', // deprecated\n\t\tWEIGHTS_0: 'skinWeight',\n\t\tWEIGHT: 'skinWeight', // deprecated\n\t\tJOINTS_0: 'skinIndex',\n\t\tJOINT: 'skinIndex' // deprecated\n\t};\n\n\tvar PATH_PROPERTIES = {\n\t\tscale: 'scale',\n\t\ttranslation: 'position',\n\t\trotation: 'quaternion',\n\t\tweights: 'morphTargetInfluences'\n\t};\n\n\tvar INTERPOLATION = {\n\t\tCUBICSPLINE: THREE.InterpolateSmooth, // We use custom interpolation GLTFCubicSplineInterpolation for CUBICSPLINE.\n\t\t                                      // KeyframeTrack.optimize() can't handle glTF Cubic Spline output values layout,\n\t\t                                      // using THREE.InterpolateSmooth for KeyframeTrack instantiation to prevent optimization.\n\t\t                                      // See KeyframeTrack.optimize() for the detail.\n\t\tLINEAR: THREE.InterpolateLinear,\n\t\tSTEP: THREE.InterpolateDiscrete\n\t};\n\n\tvar STATES_ENABLES = {\n\t\t2884: 'CULL_FACE',\n\t\t2929: 'DEPTH_TEST',\n\t\t3042: 'BLEND',\n\t\t3089: 'SCISSOR_TEST',\n\t\t32823: 'POLYGON_OFFSET_FILL',\n\t\t32926: 'SAMPLE_ALPHA_TO_COVERAGE'\n\t};\n\n\tvar ALPHA_MODES = {\n\t\tOPAQUE: 'OPAQUE',\n\t\tMASK: 'MASK',\n\t\tBLEND: 'BLEND'\n\t};\n\n\t/* UTILITY FUNCTIONS */\n\n\tfunction resolveURL( url, path ) {\n\n\t\t// Invalid URL\n\t\tif ( typeof url !== 'string' || url === '' ) return '';\n\n\t\t// Absolute URL http://,https://,//\n\t\tif ( /^(https?:)?\\/\\//i.test( url ) ) return url;\n\n\t\t// Data URI\n\t\tif ( /^data:.*,.*$/i.test( url ) ) return url;\n\n\t\t// Blob URL\n\t\tif ( /^blob:.*$/i.test( url ) ) return url;\n\n\t\t// Relative URL\n\t\treturn path + url;\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\n\t */\n\tfunction createDefaultMaterial(materialType) {\n\n    //AXC: Have materialType as parameter\n    materialType = materialType || THREE.MeshStandardMaterial;\n    return new materialType( {\n\t\t\tcolor: 0xFFFFFF,\n\t\t\temissive: 0x000000,\n\t\t\tmetalness: 1,\n\t\t\troughness: 1,\n\t\t\ttransparent: false,\n\t\t\tdepthTest: true,\n\t\t\tside: THREE.FrontSide\n\t\t} );\n\n\t}\n\n\tfunction addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {\n\n\t\t// Add unknown glTF extensions to an object's userData.\n\n\t\tfor ( var name in objectDef.extensions ) {\n\n\t\t\tif ( knownExtensions[ name ] === undefined ) {\n\n\t\t\t\tobject.userData.gltfExtensions = object.userData.gltfExtensions || {};\n\t\t\t\tobject.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object\n\t * @param {GLTF.definition} def\n\t */\n\tfunction assignExtrasToUserData( object, gltfDef ) {\n\n\t\tif ( gltfDef.extras !== undefined ) {\n\n\t\t\tif ( typeof gltfDef.extras === 'object' ) {\n\n\t\t\t\tobject.userData = gltfDef.extras;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\n\t *\n\t * @param {THREE.BufferGeometry} geometry\n\t * @param {Array<GLTF.Target>} targets\n\t * @param {Array<THREE.BufferAttribute>} accessors\n\t */\n\tfunction addMorphTargets( geometry, targets, accessors ) {\n\n\t\tvar hasMorphPosition = false;\n\t\tvar hasMorphNormal = false;\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\n\t\t\tif ( target.POSITION !== undefined ) hasMorphPosition = true;\n\t\t\tif ( target.NORMAL !== undefined ) hasMorphNormal = true;\n\n\t\t\tif ( hasMorphPosition && hasMorphNormal ) break;\n\n\t\t}\n\n\t\tif ( ! hasMorphPosition && ! hasMorphNormal ) return;\n\n\t\tvar morphPositions = [];\n\t\tvar morphNormals = [];\n\n\t\tfor ( var i = 0, il = targets.length; i < il; i ++ ) {\n\n\t\t\tvar target = targets[ i ];\n\t\t\tvar attributeName = 'morphTarget' + i;\n\n\t\t\tif ( hasMorphPosition ) {\n\n\t\t\t\t// Three.js morph position is absolute value. The formula is\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * ( morphPosition0 - basePosition )\n\t\t\t\t//     + weight1 * ( morphPosition1 - basePosition )\n\t\t\t\t//     ...\n\t\t\t\t// while the glTF one is relative\n\t\t\t\t//   basePosition\n\t\t\t\t//     + weight0 * glTFmorphPosition0\n\t\t\t\t//     + weight1 * glTFmorphPosition1\n\t\t\t\t//     ...\n\t\t\t\t// then we need to convert from relative to absolute here.\n\n\t\t\t\tif ( target.POSITION !== undefined ) {\n\n\t\t\t\t\t// Cloning not to pollute original accessor\n\t\t\t\t\tvar positionAttribute = cloneBufferAttribute( accessors[ target.POSITION ] );\n\t\t\t\t\tpositionAttribute.name = attributeName;\n\n\t\t\t\t\tvar position = geometry.attributes.position;\n\n\t\t\t\t\tfor ( var j = 0, jl = positionAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\tpositionAttribute.setXYZ(\n\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\tpositionAttribute.getX( j ) + position.getX( j ),\n\t\t\t\t\t\t\tpositionAttribute.getY( j ) + position.getY( j ),\n\t\t\t\t\t\t\tpositionAttribute.getZ( j ) + position.getZ( j )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpositionAttribute = geometry.attributes.position;\n\n\t\t\t\t}\n\n\t\t\t\tmorphPositions.push( positionAttribute );\n\n\t\t\t}\n\n\t\t\tif ( hasMorphNormal ) {\n\n\t\t\t\t// see target.POSITION's comment\n\n\t\t\t\tvar normalAttribute;\n\n\t\t\t\tif ( target.NORMAL !== undefined ) {\n\n\t\t\t\t\tvar normalAttribute = cloneBufferAttribute( accessors[ target.NORMAL ] );\n\t\t\t\t\tnormalAttribute.name = attributeName;\n\n\t\t\t\t\tvar normal = geometry.attributes.normal;\n\n\t\t\t\t\tfor ( var j = 0, jl = normalAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\tnormalAttribute.setXYZ(\n\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\tnormalAttribute.getX( j ) + normal.getX( j ),\n\t\t\t\t\t\t\tnormalAttribute.getY( j ) + normal.getY( j ),\n\t\t\t\t\t\t\tnormalAttribute.getZ( j ) + normal.getZ( j )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnormalAttribute = geometry.attributes.normal;\n\n\t\t\t\t}\n\n\t\t\t\tmorphNormals.push( normalAttribute );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;\n\t\tif ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;\n\n\t}\n\n\t/**\n\t * @param {THREE.Mesh} mesh\n\t * @param {GLTF.Mesh} meshDef\n\t */\n\tfunction updateMorphTargets( mesh, meshDef ) {\n\n\t\tmesh.updateMorphTargets();\n\n\t\tif ( meshDef.weights !== undefined ) {\n\n\t\t\tfor ( var i = 0, il = meshDef.weights.length; i < il; i ++ ) {\n\n\t\t\t\tmesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\t// .extras has user-defined data, so check that .extras.targetNames is an array.\n\t\tif ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {\n\n\t\t\tvar targetNames = meshDef.extras.targetNames;\n\n\t\t\tif ( mesh.morphTargetInfluences.length === targetNames.length ) {\n\n\t\t\t\tmesh.morphTargetDictionary = {};\n\n\t\t\t\tfor ( var i = 0, il = targetNames.length; i < il; i ++ ) {\n\n\t\t\t\t\tmesh.morphTargetDictionary[ targetNames[ i ] ] = i;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction isPrimitiveEqual( a, b ) {\n\n\t\tif ( a.indices !== b.indices ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\treturn isObjectEqual( a.attributes, b.attributes );\n\n\t}\n\n\tfunction isObjectEqual( a, b ) {\n\n\t\tif ( Object.keys( a ).length !== Object.keys( b ).length ) return false;\n\n\t\tfor ( var key in a ) {\n\n\t\t\tif ( a[ key ] !== b[ key ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction isArrayEqual( a, b ) {\n\n\t\tif ( a.length !== b.length ) return false;\n\n\t\tfor ( var i = 0, il = a.length; i < il; i ++ ) {\n\n\t\t\tif ( a[ i ] !== b[ i ] ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\tfunction getCachedGeometry( cache, newPrimitive ) {\n\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\n\n\t\t\tvar cached = cache[ i ];\n\n\t\t\tif ( isPrimitiveEqual( cached.primitive, newPrimitive ) ) return cached.promise;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction getCachedCombinedGeometry( cache, geometries ) {\n\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\n\n\t\t\tvar cached = cache[ i ];\n\n\t\t\tif ( isArrayEqual( geometries, cached.baseGeometries ) ) return cached.geometry;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction getCachedMultiPassGeometry( cache, geometry, primitives ) {\n\n\t\tfor ( var i = 0, il = cache.length; i < il; i ++ ) {\n\n\t\t\tvar cached = cache[ i ];\n\n\t\t\tif ( geometry === cached.baseGeometry && isArrayEqual( primitives, cached.primitives ) ) return cached.geometry;\n\n\t\t}\n\n\t\treturn null;\n\n\t}\n\n\tfunction cloneBufferAttribute( attribute ) {\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tvar count = attribute.count;\n\t\t\tvar itemSize = attribute.itemSize;\n\t\t\tvar array = attribute.array.slice( 0, count * itemSize );\n\n\t\t\tfor ( var i = 0; i < count; ++ i ) {\n\n\t\t\t\tarray[ i ] = attribute.getX( i );\n\t\t\t\tif ( itemSize >= 2 ) array[ i + 1 ] = attribute.getY( i );\n\t\t\t\tif ( itemSize >= 3 ) array[ i + 2 ] = attribute.getZ( i );\n\t\t\t\tif ( itemSize >= 4 ) array[ i + 3 ] = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\treturn new THREE.BufferAttribute( array, itemSize, attribute.normalized );\n\n\t\t}\n\n\t\treturn attribute.clone();\n\n\t}\n\n\t/**\n\t * Checks if we can build a single Mesh with MultiMaterial from multiple primitives.\n\t * Returns true if all primitives use the same attributes/morphAttributes/mode\n\t * and also have index. Otherwise returns false.\n\t *\n\t * @param {Array<GLTF.Primitive>} primitives\n\t * @return {Boolean}\n\t */\n\tfunction isMultiPassGeometry( primitives ) {\n\n\t\tif ( primitives.length < 2 ) return false;\n\n\t\tvar primitive0 = primitives[ 0 ];\n\t\tvar targets0 = primitive0.targets || [];\n\n\t\tif ( primitive0.indices === undefined ) return false;\n\n\t\tfor ( var i = 1, il = primitives.length; i < il; i ++ ) {\n\n\t\t\tvar primitive = primitives[ i ];\n\n\t\t\tif ( primitive0.mode !== primitive.mode ) return false;\n\t\t\tif ( primitive.indices === undefined ) return false;\n\t\t\tif ( ! isObjectEqual( primitive0.attributes, primitive.attributes ) ) return false;\n\n\t\t\tvar targets = primitive.targets || [];\n\n\t\t\tif ( targets0.length !== targets.length ) return false;\n\n\t\t\tfor ( var j = 0, jl = targets0.length; j < jl; j ++ ) {\n\n\t\t\t\tif ( ! isObjectEqual( targets0[ j ], targets[ j ] ) ) return false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/* GLTF PARSER */\n\n\tfunction GLTFParser( json, extensions, options ) {\n\n\t\tthis.json = json || {};\n\t\tthis.extensions = extensions || {};\n\t\tthis.options = options || {};\n\n\t\t// loader object cache\n\t\tthis.cache = new GLTFRegistry();\n\n\t\t// BufferGeometry caching\n\t\tthis.primitiveCache = [];\n\t\tthis.multiplePrimitivesCache = [];\n\t\tthis.multiPassGeometryCache = [];\n\n\t\tthis.textureLoader = new THREE.TextureLoader( this.options.manager );\n\t\tthis.textureLoader.setCrossOrigin( this.options.crossOrigin );\n\n    this.fileLoader = this.options.fileLoader;\n    this.manager = options.manager;\n\n\t}\n\n\tGLTFParser.prototype.parse = function ( onLoad, onError ) {\n\n\t\tvar json = this.json;\n\n\t\t// Clear the loader cache\n\t\tthis.cache.removeAll();\n\n\t\t// Mark the special nodes/meshes in json for efficient parse\n\t\tthis.markDefs();\n\n\t\t// Fire the callback on complete\n\t\tthis.getMultiDependencies( [\n\n\t\t\t'scene',\n\t\t\t'animation',\n\t\t\t'camera'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar scenes = dependencies.scenes || [];\n\t\t\tvar scene = scenes[ json.scene || 0 ];\n\t\t\tvar animations = dependencies.animations || [];\n\t\t\tvar cameras = dependencies.cameras || [];\n\n\t\t\tassignExtrasToUserData( scene, json );\n\n\t\t\tonLoad( scene, scenes, cameras, animations, json );\n\n\t\t} ).catch( onError );\n\n\t};\n\n\t/**\n\t * Marks the special nodes/meshes in json for efficient parse.\n\t */\n\tGLTFParser.prototype.markDefs = function () {\n\n\t\tvar nodeDefs = this.json.nodes || [];\n\t\tvar skinDefs = this.json.skins || [];\n\t\tvar meshDefs = this.json.meshes || [];\n\n\t\tvar meshReferences = {};\n\t\tvar meshUses = {};\n\n\t\t// Nothing in the node definition indicates whether it is a Bone or an\n\t\t// Object3D. Use the skins' joint references to mark bones.\n\t\tfor ( var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {\n\n\t\t\tvar joints = skinDefs[ skinIndex ].joints;\n\n\t\t\tfor ( var i = 0, il = joints.length; i < il; i ++ ) {\n\n\t\t\t\tnodeDefs[ joints[ i ] ].isBone = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Meshes can (and should) be reused by multiple nodes in a glTF asset. To\n\t\t// avoid having more than one THREE.Mesh with the same name, count\n\t\t// references and rename instances below.\n\t\t//\n\t\t// Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\n\t\tfor ( var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {\n\n\t\t\tvar nodeDef = nodeDefs[ nodeIndex ];\n\n\t\t\tif ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] === undefined ) {\n\n\t\t\t\t\tmeshReferences[ nodeDef.mesh ] = meshUses[ nodeDef.mesh ] = 0;\n\n\t\t\t\t}\n\n\t\t\t\tmeshReferences[ nodeDef.mesh ] ++;\n\n\t\t\t\t// Nothing in the mesh definition indicates whether it is\n\t\t\t\t// a SkinnedMesh or Mesh. Use the node's mesh reference\n\t\t\t\t// to mark SkinnedMesh if node has skin.\n\t\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\t\tmeshDefs[ nodeDef.mesh ].isSkinnedMesh = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.json.meshReferences = meshReferences;\n\t\tthis.json.meshUses = meshUses;\n\n\t};\n\n\t/**\n\t * Requests the specified dependency asynchronously, with caching.\n\t * @param {string} type\n\t * @param {number} index\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.getDependency = function ( type, index ) {\n\n\t\tvar cacheKey = type + ':' + index;\n\t\tvar dependency = this.cache.get( cacheKey );\n\n\t\tif ( ! dependency ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'scene':\n\t\t\t\t\tdependency = this.loadScene( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'node':\n\t\t\t\t\tdependency = this.loadNode( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'mesh':\n\t\t\t\t\tdependency = this.loadMesh( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'accessor':\n\t\t\t\t\tdependency = this.loadAccessor( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'bufferView':\n\t\t\t\t\tdependency = this.loadBufferView( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'buffer':\n\t\t\t\t\tdependency = this.loadBuffer( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'material':\n\t\t\t\t\tdependency = this.loadMaterial( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'texture':\n\t\t\t\t\tdependency = this.loadTexture( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'skin':\n\t\t\t\t\tdependency = this.loadSkin( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'animation':\n\t\t\t\t\tdependency = this.loadAnimation( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'camera':\n\t\t\t\t\tdependency = this.loadCamera( index );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error( 'Unknown type: ' + type );\n\n\t\t\t}\n\n\t\t\tthis.cache.add( cacheKey, dependency );\n\n\t\t}\n\n\t\treturn dependency;\n\n\t};\n\n\t/**\n\t * Requests all dependencies of the specified type asynchronously, with caching.\n\t * @param {string} type\n\t * @return {Promise<Array<Object>>}\n\t */\n\tGLTFParser.prototype.getDependencies = function ( type ) {\n\n\t\tvar dependencies = this.cache.get( type );\n\n\t\tif ( ! dependencies ) {\n\n\t\t\tvar parser = this;\n\t\t\tvar defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];\n\n\t\t\tdependencies = Promise.all( defs.map( function ( def, index ) {\n\n\t\t\t\treturn parser.getDependency( type, index );\n\n\t\t\t} ) );\n\n\t\t\tthis.cache.add( type, dependencies );\n\n\t\t}\n\n\t\treturn dependencies;\n\n\t};\n\n\t/**\n\t * Requests all multiple dependencies of the specified types asynchronously, with caching.\n\t * @param {Array<string>} types\n\t * @return {Promise<Object<Array<Object>>>}\n\t */\n\tGLTFParser.prototype.getMultiDependencies = function ( types ) {\n\n\t\tvar results = {};\n\t\tvar pendings = [];\n\n\t\tfor ( var i = 0, il = types.length; i < il; i ++ ) {\n\n\t\t\tvar type = types[ i ];\n\t\t\tvar value = this.getDependencies( type );\n\n\t\t\tvalue = value.then( function ( key, value ) {\n\n\t\t\t\tresults[ key ] = value;\n\n\t\t\t}.bind( this, type + ( type === 'mesh' ? 'es' : 's' ) ) );\n\n\t\t\tpendings.push( value );\n\n\t\t}\n\n\t\treturn Promise.all( pendings ).then( function () {\n\n\t\t\treturn results;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBuffer = function ( bufferIndex ) {\n\n\t\tvar bufferDef = this.json.buffers[ bufferIndex ];\n\t\tvar loader = this.fileLoader;\n\n\t\tif ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );\n\n\t\t}\n\n\t\t// If present, GLB container is required to be the first buffer.\n\t\tif ( bufferDef.uri === undefined && bufferIndex === 0 ) {\n\n      if (this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ]) {\n\t\t\t\treturn Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );\n\t\t\t} else {\n      \tthrow new Error( 'THREE.GLTFLoader: No KHR_binary_glTF');\n\t\t\t}\n\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tloader.load( resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {\n\n\t\t\t\treject( new Error( 'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".' ) );\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\n\t * @param {number} bufferViewIndex\n\t * @return {Promise<ArrayBuffer>}\n\t */\n\tGLTFParser.prototype.loadBufferView = function ( bufferViewIndex ) {\n\n\t\tvar bufferViewDef = this.json.bufferViews[ bufferViewIndex ];\n\n\t\treturn this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {\n\n\t\t\tvar byteLength = bufferViewDef.byteLength || 0;\n\t\t\tvar byteOffset = bufferViewDef.byteOffset || 0;\n\t\t\treturn buffer.slice( byteOffset, byteOffset + byteLength );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\n\t * @param {number} accessorIndex\n\t * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}\n\t */\n\tGLTFParser.prototype.loadAccessor = function ( accessorIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\n\t\tvar accessorDef = this.json.accessors[ accessorIndex ];\n\n\t\tif ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {\n\n\t\t\t// Ignore empty accessors, which may be used to declare runtime\n\t\t\t// information about attributes coming from another source (e.g. Draco\n\t\t\t// compression extension).\n\t\t\treturn null;\n\n\t\t}\n\n\t\tvar pendingBufferViews = [];\n\n\t\tif ( accessorDef.bufferView !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );\n\n\t\t} else {\n\n\t\t\tpendingBufferViews.push( null );\n\n\t\t}\n\n\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );\n\t\t\tpendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );\n\n\t\t}\n\n\t\treturn Promise.all( pendingBufferViews ).then( function ( bufferViews ) {\n\n\t\t\tvar bufferView = bufferViews[ 0 ];\n\n\t\t\tvar itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];\n\t\t\tvar TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];\n\n\t\t\t// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n\t\t\tvar elementBytes = TypedArray.BYTES_PER_ELEMENT;\n\t\t\tvar itemBytes = elementBytes * itemSize;\n\t\t\tvar byteOffset = accessorDef.byteOffset || 0;\n\t\t\tvar byteStride = json.bufferViews[ accessorDef.bufferView ].byteStride;\n\t\t\tvar normalized = accessorDef.normalized === true;\n\t\t\tvar array, bufferAttribute;\n\n\t\t\t// The buffer is not interleaved if the stride is the item size in bytes.\n\t\t\tif ( byteStride && byteStride !== itemBytes ) {\n\n\t\t\t\tvar ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType;\n\t\t\t\tvar ib = parser.cache.get( ibCacheKey );\n\n\t\t\t\tif ( ! ib ) {\n\n\t\t\t\t\t// Use the full buffer if it's interleaved.\n\t\t\t\t\tarray = new TypedArray( bufferView );\n\n\t\t\t\t\t// Integer parameters to IB/IBA are in array elements, not bytes.\n\t\t\t\t\tib = new THREE.InterleavedBuffer( array, byteStride / elementBytes );\n\n\t\t\t\t\tparser.cache.add( ibCacheKey, ib );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.InterleavedBufferAttribute( ib, itemSize, byteOffset / elementBytes, normalized );\n\n\t\t\t} else {\n\n\t\t\t\tif ( bufferView === null ) {\n\n\t\t\t\t\tarray = new TypedArray( accessorDef.count * itemSize );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tarray = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );\n\n\t\t\t\t}\n\n\t\t\t\tbufferAttribute = new THREE.BufferAttribute( array, itemSize, normalized );\n\n\t\t\t}\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\n\t\t\tif ( accessorDef.sparse !== undefined ) {\n\n\t\t\t\tvar itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n\t\t\t\tvar TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];\n\n\t\t\t\tvar byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n\t\t\t\tvar byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n\n\t\t\t\tvar sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );\n\t\t\t\tvar sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );\n\n\t\t\t\tif ( bufferView !== null ) {\n\n\t\t\t\t\t// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\n\t\t\t\t\tbufferAttribute.setArray( bufferAttribute.array.slice() );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0, il = sparseIndices.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar index = sparseIndices[ i ];\n\n\t\t\t\t\tbufferAttribute.setX( index, sparseValues[ i * itemSize ] );\n\t\t\t\t\tif ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );\n\t\t\t\t\tif ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );\n\t\t\t\t\tif ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );\n\t\t\t\t\tif ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn bufferAttribute;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n\t * @param {number} textureIndex\n\t * @return {Promise<THREE.Texture>}\n\t */\n  /**\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\n   * @param {number} textureIndex\n   * @return {Promise<THREE.Texture>}\n   */\n  GLTFParser.prototype.loadTexture = function ( textureIndex ) {\n    if (typeof Blob !== 'undefined') {\n      return this.__loadTextureWeb( textureIndex );\n    } else {\n      return this.__loadTextureNode( textureIndex );\n    }\n  };\n\n  GLTFParser.prototype.__loadTextureNode = function ( textureIndex ) {\n    var parser = this;\n    var json = this.json;\n    var options = this.options;\n    var textureLoader = this.textureLoader;\n\n    var textureDef = json.textures[ textureIndex ];\n    var source = json.images[ textureDef.source ];\n    var sourceURI = source.uri;\n\n    if ( source.bufferView !== undefined ) {\n\n      // Load binary image data from bufferView, if provided.\n      sourceURI = parser.getDependency( 'bufferView', source.bufferView )\n\n        .then( function ( bufferView ) {\n          sourceURI = { type: 'bufferView', key: 'bufferView' + '-' + source.bufferView, buffer: bufferView, mimeType: source.mimeType };\n          return sourceURI;\n\n        } );\n\n    } else {\n\n    }\n\n    var manager = this.manager;\n    return Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n      // Load Texture resource.\n\n      var loader = manager.getHandler( sourceURI ) || textureLoader;\n\n      return new Promise( function ( resolve, reject ) {\n\n        loader.load( (typeof sourceURI === 'string')? resolveURL( sourceURI, options.path ) : sourceURI, resolve, undefined, reject );\n\n      } );\n\n    } ).then( function ( texture ) {\n\n      // Clean up resources and configure Texture.\n\n      texture.flipY = false;\n\n      if ( textureDef.name !== undefined ) texture.name = textureDef.name;\n\n      texture.format = textureDef.format !== undefined ? WEBGL_TEXTURE_FORMATS[ textureDef.format ] : THREE.RGBAFormat;\n\n      if ( textureDef.internalFormat !== undefined && texture.format !== WEBGL_TEXTURE_FORMATS[ textureDef.internalFormat ] ) {\n\n        console.warn( 'THREE.GLTFLoader: Three.js does not support texture internalFormat which is different from texture format. ' +\n          'internalFormat will be forced to be the same value as format.' );\n\n      }\n\n      texture.type = textureDef.type !== undefined ? WEBGL_TEXTURE_DATATYPES[ textureDef.type ] : THREE.UnsignedByteType;\n\n      var samplers = json.samplers || {};\n      var sampler = samplers[ textureDef.sampler ] || {};\n\n      texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n      return texture;\n\n    } ).then( function(texture) {\n      return  _.toPromise(function(cb) {\n        ImageUtil.ensurePowerOfTwo(texture.image, texture, cb);\n      }).then((image) => {\n        texture.image = image;\n        return texture;\n      });\n    });\n  };\n\n  GLTFParser.prototype.__loadTextureWeb = function ( textureIndex ) {\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar options = this.options;\n\t\tvar textureLoader = this.textureLoader;\n\n\t\tvar URL = window.URL || window.webkitURL;\n\n\t\tvar textureDef = json.textures[ textureIndex ];\n\n\t\tvar textureExtensions = textureDef.extensions || {};\n\n\t\tvar source;\n\n\t\tif ( textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ] ) {\n\n\t\t\tsource = json.images[ textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].source ];\n\n\t\t} else {\n\n\t\t\tsource = json.images[ textureDef.source ];\n\n\t\t}\n\n\t\tvar sourceURI = source.uri;\n\t\tvar isObjectURL = false;\n\n\t\tif ( source.bufferView !== undefined ) {\n\n\t\t\t// Load binary image data from bufferView, if provided.\n\n\t\t\tsourceURI = parser.getDependency( 'bufferView', source.bufferView ).then( function ( bufferView ) {\n\n\t\t\t\tisObjectURL = true;\n\t\t\t\tvar blob = new Blob( [ bufferView ], { type: source.mimeType } );\n\t\t\t\tsourceURI = URL.createObjectURL( blob );\n\t\t\t\treturn sourceURI;\n\n\t\t\t} );\n\n\t\t}\n\n\t\tvar manager = this.manager;\n\t\treturn Promise.resolve( sourceURI ).then( function ( sourceURI ) {\n\n\t\t\t// Load Texture resource.\n\n\t\t\tvar loader = manager.getHandler( sourceURI );\n\n\t\t\tif ( ! loader ) {\n\n\t\t\t\tloader = textureExtensions[ EXTENSIONS.MSFT_TEXTURE_DDS ]\n\t\t\t\t\t? parser.extensions[ EXTENSIONS.MSFT_TEXTURE_DDS ].ddsLoader\n\t\t\t\t\t: textureLoader;\n\n\t\t\t}\n\n\t\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\t\tloader.load( resolveURL( sourceURI, options.path ), resolve, undefined, reject );\n\n\t\t\t} );\n\n\t\t} ).then( function ( texture ) {\n\n\t\t\t// Clean up resources and configure Texture.\n\n\t\t\tif ( isObjectURL === true ) {\n\n\t\t\t\tURL.revokeObjectURL( sourceURI );\n\n\t\t\t}\n\n\t\t\ttexture.flipY = false;\n\n\t\t\tif ( textureDef.name !== undefined ) texture.name = textureDef.name;\n\n\t\t\tvar samplers = json.samplers || {};\n\t\t\tvar sampler = samplers[ textureDef.sampler ] || {};\n\n\t\t\ttexture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || THREE.LinearFilter;\n\t\t\ttexture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || THREE.LinearMipMapLinearFilter;\n\t\t\ttexture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || THREE.RepeatWrapping;\n\t\t\ttexture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || THREE.RepeatWrapping;\n\n\t\t\treturn texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Asynchronously assigns a texture to the given material parameters.\n\t * @param {Object} materialParams\n\t * @param {string} textureName\n\t * @param {number} textureIndex\n\t * @return {Promise}\n\t */\n\tGLTFParser.prototype.assignTexture = function ( materialParams, textureName, textureIndex ) {\n\n\t\treturn this.getDependency( 'texture', textureIndex ).then( function ( texture ) {\n\n\t\t\tmaterialParams[ textureName ] = texture;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\n\t * @param {number} materialIndex\n\t * @return {Promise<THREE.Material>}\n\t */\n\tGLTFParser.prototype.loadMaterial = function ( materialIndex ) {\n\n\t\tvar parser = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\t\tvar materialDef = this.json.materials[ materialIndex ];\n    var ignoreOcclusionTexture = parser.options? parser.options.ignoreOcclusionTexture : false; // AXC: option to ignoreOcclusionTexture\n\n\t\tvar materialType;\n\t\tvar materialParams = {};\n\t\tvar materialExtensions = materialDef.extensions || {};\n\n\t\tvar pending = [];\n\n\t\tif ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {\n\n\t\t\tvar sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];\n\t\t\tmaterialType = sgExtension.getMaterialType( materialDef );\n\t\t\tpending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {\n\n\t\t\tvar kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];\n\t\t\tmaterialType = kmuExtension.getMaterialType( materialDef );\n\t\t\tpending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );\n\n\t\t} else {\n\n\t\t\t// Specification:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\n\n\t\t\tmaterialType = THREE.MeshStandardMaterial;\n\n\t\t\tvar metallicRoughness = materialDef.pbrMetallicRoughness || {};\n\n\t\t\tmaterialParams.color = new THREE.Color( 1.0, 1.0, 1.0 );\n\t\t\tmaterialParams.opacity = 1.0;\n\n\t\t\tif ( Array.isArray( metallicRoughness.baseColorFactor ) ) {\n\n\t\t\t\tvar array = metallicRoughness.baseColorFactor;\n\n\t\t\t\tmaterialParams.color.fromArray( array );\n\t\t\t\tmaterialParams.opacity = array[ 3 ];\n\n\t\t\t}\n\n\t\t\tif ( metallicRoughness.baseColorTexture !== undefined ) {\n\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture.index ) );\n\n\t\t\t}\n\n\t\t\tmaterialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;\n\t\t\tmaterialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;\n\n\t\t\tif ( metallicRoughness.metallicRoughnessTexture !== undefined ) {\n\n\t\t\t\tvar textureIndex = metallicRoughness.metallicRoughnessTexture.index;\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'metalnessMap', textureIndex ) );\n\t\t\t\tpending.push( parser.assignTexture( materialParams, 'roughnessMap', textureIndex ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.doubleSided === true ) {\n\n\t\t\tmaterialParams.side = THREE.DoubleSide;\n\n\t\t}\n\n\t\tvar alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n\n\t\tif ( alphaMode === ALPHA_MODES.BLEND ) {\n\n\t\t\tmaterialParams.transparent = true;\n\n\t\t} else {\n\n\t\t\tmaterialParams.transparent = false;\n\n\t\t\tif ( alphaMode === ALPHA_MODES.MASK ) {\n\n\t\t\t\tmaterialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture.index ) );\n\n\t\t\tmaterialParams.normalScale = new THREE.Vector2( 1, 1 );\n\n\t\t\tif ( materialDef.normalTexture.scale !== undefined ) {\n\n\t\t\t\tmaterialParams.normalScale.set( materialDef.normalTexture.scale, materialDef.normalTexture.scale );\n\n\t\t\t}\n\n\t\t}\n\n    if ( !ignoreOcclusionTexture && materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) { // AXC: option to ignoreOcclusionTexture\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture.index ) );\n\n\t\t\tif ( materialDef.occlusionTexture.strength !== undefined ) {\n\n\t\t\t\tmaterialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tmaterialParams.emissive = new THREE.Color().fromArray( materialDef.emissiveFactor );\n\n\t\t}\n\n\t\tif ( materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial ) {\n\n\t\t\tpending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture.index ) );\n\n\t\t}\n\n    var overrideMaterialType = parser.options? parser.options.overrideMaterialType : null; // AXC: Override materialType\n    if (overrideMaterialType) { // AXC: Override materialType\n      materialType = overrideMaterialType;\n      //console.log(material, materialParams);\n    }\n\n\t\treturn Promise.all( pending ).then( function () {\n\n\t\t\tvar material;\n\n\t\t\tif ( materialType === THREE.ShaderMaterial ) {\n\n\t\t\t\tmaterial = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );\n\n\t\t\t} else {\n\n\t\t\t\tmaterial = new materialType( materialParams );\n\n\t\t\t}\n\n\t\t\tif ( materialDef.name !== undefined ) material.name = materialDef.name;\n\n\t\t\t// Normal map textures use OpenGL conventions:\n\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#materialnormaltexture\n\t\t\tif ( material.normalScale ) {\n\n\t\t\t\tmaterial.normalScale.y = - material.normalScale.y;\n\n\t\t\t}\n\n\t\t\t// baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\n\t\t\tif ( material.map ) material.map.encoding = THREE.sRGBEncoding;\n\t\t\tif ( material.emissiveMap ) material.emissiveMap.encoding = THREE.sRGBEncoding;\n\t\t\tif ( material.specularMap ) material.specularMap.encoding = THREE.sRGBEncoding;\n\n\t\t\tassignExtrasToUserData( material, materialDef );\n\n\t\t\tif ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );\n\n\t\t\treturn material;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * @param  {THREE.BufferGeometry} geometry\n\t * @param  {GLTF.Primitive} primitiveDef\n\t * @param  {Array<THREE.BufferAttribute>} accessors\n\t */\n\tfunction addPrimitiveAttributes( geometry, primitiveDef, accessors ) {\n\n\t\tvar attributes = primitiveDef.attributes;\n\n\t\tfor ( var gltfAttributeName in attributes ) {\n\n\t\t\tvar threeAttributeName = ATTRIBUTES[ gltfAttributeName ];\n\t\t\tvar bufferAttribute = accessors[ attributes[ gltfAttributeName ] ];\n\n\t\t\t// Skip attributes already provided by e.g. Draco extension.\n\t\t\tif ( ! threeAttributeName ) continue;\n\t\t\tif ( threeAttributeName in geometry.attributes ) continue;\n\n\t\t\tgeometry.setAttribute( threeAttributeName, bufferAttribute );\n\n\t\t}\n\n\t\tif ( primitiveDef.indices !== undefined && ! geometry.index ) {\n\n\t\t\tgeometry.setIndex( accessors[ primitiveDef.indices ] );\n\n\t\t}\n\n\t\tif ( primitiveDef.targets !== undefined ) {\n\n\t\t\taddMorphTargets( geometry, primitiveDef.targets, accessors );\n\n\t\t}\n\n\t\tassignExtrasToUserData( geometry, primitiveDef );\n\n\t}\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\n\t *\n\t * Creates BufferGeometries from primitives.\n\t * If we can build a single BufferGeometry with .groups from multiple primitives, returns one BufferGeometry.\n\t * Otherwise, returns BufferGeometries without .groups as many as primitives.\n\t *\n\t * @param {Array<Object>} primitives\n\t * @return {Promise<Array<THREE.BufferGeometry>>}\n\t */\n\tGLTFParser.prototype.loadGeometries = function ( primitives ) {\n\n\t\tvar parser = this;\n\t\tvar extensions = this.extensions;\n\t\tvar cache = this.primitiveCache;\n\n\t\tvar isMultiPass = isMultiPassGeometry( primitives );\n\t\tvar originalPrimitives;\n\n\t\tif ( isMultiPass ) {\n\n\t\t\toriginalPrimitives = primitives; // save original primitives and use later\n\n\t\t\t// We build a single BufferGeometry with .groups from multiple primitives\n\t\t\t// because all primitives share the same attributes/morph/mode and have indices.\n\n\t\t\tprimitives = [ primitives[ 0 ] ];\n\n\t\t\t// Sets .groups and combined indices to a geometry later in this method.\n\n\t\t}\n\n\t\treturn this.getDependencies( 'accessor' ).then( function ( accessors ) {\n\n\t\t\tvar pending = [];\n\n\t\t\tfor ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t// See if we've already created this geometry\n\t\t\t\tvar cached = getCachedGeometry( cache, primitive );\n\n\t\t\t\tif ( cached ) {\n\n\t\t\t\t\t// Use the cached geometry if it exists\n\t\t\t\t\tpending.push( cached );\n\n\t\t\t\t} else if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {\n\n\t\t\t\t\t// Use DRACO geometry if available\n\t\t\t\t\tvar geometryPromise = extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]\n\t\t\t\t\t\t.decodePrimitive( primitive, parser )\n\t\t\t\t\t\t.then( function ( geometry ) {\n\n\t\t\t\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\n\n\t\t\t\t\t\t\treturn geometry;\n\n\t\t\t\t\t\t} );\n\n\t\t\t\t\tcache.push( { primitive: primitive, promise: geometryPromise } );\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Otherwise create a new geometry\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\taddPrimitiveAttributes( geometry, primitive, accessors );\n\n\t\t\t\t\tvar geometryPromise = Promise.resolve( geometry );\n\n\t\t\t\t\t// Cache this geometry\n\t\t\t\t\tcache.push( { primitive: primitive, promise: geometryPromise } );\n\n\t\t\t\t\tpending.push( geometryPromise );\n\n\t\t\t\t}\n\n\t\t\t}\n\n      var computeNormals = this.options && this.options.computeNormals; // AXC: Compute normals\n\t\t\treturn Promise.all( pending ).then( function ( geometries ) {\n\n\t\t\t\tif ( isMultiPass ) {\n\n\t\t\t\t\tvar baseGeometry = geometries[ 0 ];\n\n\t\t\t\t\t// See if we've already created this combined geometry\n\t\t\t\t\tvar cache = parser.multiPassGeometryCache;\n\t\t\t\t\tvar cached = getCachedMultiPassGeometry( cache, baseGeometry, originalPrimitives );\n\n\t\t\t\t\tif ( cached !== null ) return [ cached.geometry ];\n\n\t\t\t\t\t// Cloning geometry because of index override.\n\t\t\t\t\t// Attributes can be reused so cloning by myself here.\n\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t\t\tgeometry.name = baseGeometry.name;\n\t\t\t\t\tgeometry.userData = baseGeometry.userData;\n\n\t\t\t\t\tfor ( var key in baseGeometry.attributes ) geometry.setAttribute( key, baseGeometry.attributes[ key ] );\n\t\t\t\t\tfor ( var key in baseGeometry.morphAttributes ) geometry.morphAttributes[ key ] = baseGeometry.morphAttributes[ key ];\n\n\t\t\t\t\tvar indices = [];\n\t\t\t\t\tvar offset = 0;\n\n\t\t\t\t\tfor ( var i = 0, il = originalPrimitives.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tvar accessor = accessors[ originalPrimitives[ i ].indices ];\n\n\t\t\t\t\t\tfor ( var j = 0, jl = accessor.count; j < jl; j ++ ) indices.push( accessor.array[ j ] );\n\n\t\t\t\t\t\tgeometry.addGroup( offset, accessor.count, i );\n\n\t\t\t\t\t\toffset += accessor.count;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgeometry.setIndex( indices );\n\n          // AXC: computeNormals\n          if (computeNormals) {\n            geometry.computeFaceNormals();\n            geometry.computeVertexNormals();\n          }\n\n          cache.push( { geometry: geometry, baseGeometry: baseGeometry, primitives: originalPrimitives } );\n\n\t\t\t\t\treturn [ geometry ];\n\n\t\t\t\t} else if ( geometries.length > 1 && THREE.BufferGeometryUtils !== undefined ) {\n\n\t\t\t\t\t// Tries to merge geometries with BufferGeometryUtils if possible\n\n\t\t\t\t\tfor ( var i = 1, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\t\t\t// can't merge if draw mode is different\n\t\t\t\t\t\tif ( primitives[ 0 ].mode !== primitives[ i ].mode ) return geometries;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// See if we've already created this combined geometry\n\t\t\t\t\tvar cache = parser.multiplePrimitivesCache;\n\t\t\t\t\tvar cached = getCachedCombinedGeometry( cache, geometries );\n\n\t\t\t\t\tif ( cached ) {\n\n\t\t\t\t\t\tif ( cached.geometry !== null ) return [ cached.geometry ];\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvar geometry = THREE.BufferGeometryUtils.mergeBufferGeometries( geometries, true );\n\n\t\t\t\t\t\tcache.push( { geometry: geometry, baseGeometries: geometries } );\n\n\t\t\t\t\t\tif ( geometry !== null ) return [ geometry ];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn geometries;\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\n\t * @param {number} meshIndex\n\t * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}\n\t */\n\tGLTFParser.prototype.loadMesh = function ( meshIndex ) {\n\n\t\tvar scope = this;\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshDef = this.json.meshes[ meshIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'accessor',\n\t\t\t'material'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar primitives = meshDef.primitives;\n\t\t\tvar originalMaterials = [];\n\n      var defaultMaterial = scope.options? scope.options.defaultMaterial : null; // AXC: Default material\n      var defaultMaterialType = scope.options? scope.options.defaultMaterialType : null; // AXC: Default material\n      var overrideMaterial = scope.options? scope.options.overrideMaterial : null; // AXC: Override material\n\n      for ( var i = 0, il = primitives.length; i < il; i ++ ) {\n\n\t\t\t\toriginalMaterials[ i ] = primitives[ i ].material === undefined\n          ? defaultMaterial || createDefaultMaterial(defaultMaterialType)  // AXC: Default material\n\t\t\t\t\t: dependencies.materials[ primitives[ i ].material ];\n\n        if (overrideMaterial) {\n          originalMaterials[ i ] = overrideMaterial; // AXC: override material\n        }\n\t\t\t}\n\n   \t\treturn scope.loadGeometries( primitives ).then( function ( geometries ) {\n\n\t\t\t\tvar isMultiMaterial = geometries.length === 1 && geometries[ 0 ].groups.length > 0;\n\n\t\t\t\tvar meshes = [];\n\n\t\t\t\tfor ( var i = 0, il = geometries.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar geometry = geometries[ i ];\n\t\t\t\t\tvar primitive = primitives[ i ];\n\n\t\t\t\t\t// 1. create Mesh\n\n\t\t\t\t\tvar mesh;\n\n\t\t\t\t\tvar material = isMultiMaterial ? originalMaterials : originalMaterials[ i ];\n\n\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\n\t\t\t\t\t\tprimitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\n\t\t\t\t\t\tprimitive.mode === undefined ) {\n\n\t\t\t\t\t\t// .isSkinnedMesh isn't in glTF spec. See .markDefs()\n\t\t\t\t\t\tmesh = meshDef.isSkinnedMesh === true\n\t\t\t\t\t\t\t? new THREE.SkinnedMesh( geometry, material )\n\t\t\t\t\t\t\t: new THREE.Mesh( geometry, material );\n\n\t\t\t\t\t\tif ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleStripDrawMode;\n\n\t\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {\n\n\t\t\t\t\t\t\tmesh.drawMode = THREE.TriangleFanDrawMode;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineSegments( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {\n\n\t\t\t\t\t\tmesh = new THREE.Line( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {\n\n\t\t\t\t\t\tmesh = new THREE.LineLoop( geometry, material );\n\n\t\t\t\t\t} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {\n\n\t\t\t\t\t\tmesh = new THREE.Points( geometry, material );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthrow new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {\n\n\t\t\t\t\t\tupdateMorphTargets( mesh, meshDef );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.name = meshDef.name || ( 'mesh_' + meshIndex );\n\n\t\t\t\t\tif ( geometries.length > 1 ) mesh.name += '_' + i;\n\n\t\t\t\t\tassignExtrasToUserData( mesh, meshDef );\n\n\t\t\t\t\tmeshes.push( mesh );\n\n\t\t\t\t\t// 2. update Material depending on Mesh and BufferGeometry\n\n\t\t\t\t\tvar materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\n\t\t\t\t\tvar useVertexColors = geometry.attributes.color !== undefined;\n\t\t\t\t\tvar useFlatShading = geometry.attributes.normal === undefined;\n\t\t\t\t\tvar useSkinning = mesh.isSkinnedMesh === true;\n\t\t\t\t\tvar useMorphTargets = Object.keys( geometry.morphAttributes ).length > 0;\n\t\t\t\t\tvar useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;\n\n\t\t\t\t\tfor ( var j = 0, jl = materials.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar material = materials[ j ];\n\n\t\t\t\t\t\tif ( mesh.isPoints ) {\n\n\t\t\t\t\t\t\tvar cacheKey = 'PointsMaterial:' + material.uuid;\n\n\t\t\t\t\t\t\tvar pointsMaterial = scope.cache.get( cacheKey );\n\n\t\t\t\t\t\t\tif ( ! pointsMaterial ) {\n\n\t\t\t\t\t\t\t\tpointsMaterial = new THREE.PointsMaterial();\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( pointsMaterial, material );\n\t\t\t\t\t\t\t\tpointsMaterial.color.copy( material.color );\n\t\t\t\t\t\t\t\tpointsMaterial.map = material.map;\n\t\t\t\t\t\t\t\tpointsMaterial.lights = false; // PointsMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, pointsMaterial );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = pointsMaterial;\n\n\t\t\t\t\t\t} else if ( mesh.isLine ) {\n\n\t\t\t\t\t\t\tvar cacheKey = 'LineBasicMaterial:' + material.uuid;\n\n\t\t\t\t\t\t\tvar lineMaterial = scope.cache.get( cacheKey );\n\n\t\t\t\t\t\t\tif ( ! lineMaterial ) {\n\n\t\t\t\t\t\t\t\tlineMaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call( lineMaterial, material );\n\t\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\t\t\t\t\tlineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet\n\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, lineMaterial );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = lineMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Clone the material if it will be modified\n\t\t\t\t\t\tif ( useVertexColors || useFlatShading || useSkinning || useMorphTargets ) {\n\n\t\t\t\t\t\t\tvar cacheKey = 'ClonedMaterial:' + material.uuid + ':';\n\n\t\t\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';\n\t\t\t\t\t\t\tif ( useSkinning ) cacheKey += 'skinning:';\n\t\t\t\t\t\t\tif ( useVertexColors ) cacheKey += 'vertex-colors:';\n\t\t\t\t\t\t\tif ( useFlatShading ) cacheKey += 'flat-shading:';\n\t\t\t\t\t\t\tif ( useMorphTargets ) cacheKey += 'morph-targets:';\n\t\t\t\t\t\t\tif ( useMorphNormals ) cacheKey += 'morph-normals:';\n\n\t\t\t\t\t\t\tvar cachedMaterial = scope.cache.get( cacheKey );\n\n\t\t\t\t\t\t\tif ( ! cachedMaterial ) {\n\n\t\t\t\t\t\t\t\tcachedMaterial = material.isGLTFSpecularGlossinessMaterial\n\t\t\t\t\t\t\t\t\t? extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].cloneMaterial( material )\n\t\t\t\t\t\t\t\t\t: material.clone();\n\n\t\t\t\t\t\t\t\tif ( useSkinning ) cachedMaterial.skinning = true;\n\t\t\t\t\t\t\t\tif ( useVertexColors ) cachedMaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\t\tif ( useFlatShading ) cachedMaterial.flatShading = true;\n\t\t\t\t\t\t\t\tif ( useMorphTargets ) cachedMaterial.morphTargets = true;\n\t\t\t\t\t\t\t\tif ( useMorphNormals ) cachedMaterial.morphNormals = true;\n\n\t\t\t\t\t\t\t\tscope.cache.add( cacheKey, cachedMaterial );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tmaterial = cachedMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaterials[ j ] = material;\n\n\t\t\t\t\t\t// workarounds for mesh and geometry\n\n\t\t\t\t\t\tif ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {\n\n\t\t\t\t\t\t\t//console.log( 'THREE.GLTFLoader: Duplicating UVs to support aoMap.' );\n\t\t\t\t\t\t\tgeometry.setAttribute( 'uv2', new THREE.BufferAttribute( geometry.attributes.uv.array, 2 ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( material.isGLTFSpecularGlossinessMaterial ) {\n\n\t\t\t\t\t\t\t// for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update\n\t\t\t\t\t\t\tmesh.onBeforeRender = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].refreshUniforms;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.material = isMultiMaterial ? materials : materials[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( meshes.length === 1 ) {\n\n\t\t\t\t\treturn meshes[ 0 ];\n\n\t\t\t\t}\n\n\t\t\t\tvar group = new THREE.Group();\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tgroup.add( meshes[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\treturn group;\n\n\t\t\t} );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\n\t * @param {number} cameraIndex\n\t * @return {Promise<THREE.Camera>}\n\t */\n\tGLTFParser.prototype.loadCamera = function ( cameraIndex ) {\n\n\t\tvar camera;\n\t\tvar cameraDef = this.json.cameras[ cameraIndex ];\n\t\tvar params = cameraDef[ cameraDef.type ];\n\n\t\tif ( ! params ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFLoader: Missing camera parameters.' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( cameraDef.type === 'perspective' ) {\n\n\t\t\tcamera = new THREE.PerspectiveCamera( THREE.Math.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );\n\n\t\t} else if ( cameraDef.type === 'orthographic' ) {\n\n\t\t\tcamera = new THREE.OrthographicCamera( params.xmag / - 2, params.xmag / 2, params.ymag / 2, params.ymag / - 2, params.znear, params.zfar );\n\n\t\t}\n\n\t\tif ( cameraDef.name !== undefined ) camera.name = cameraDef.name;\n\n\t\tassignExtrasToUserData( camera, cameraDef );\n\n\t\treturn Promise.resolve( camera );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\n\t * @param {number} skinIndex\n\t * @return {Promise<Object>}\n\t */\n\tGLTFParser.prototype.loadSkin = function ( skinIndex ) {\n\n\t\tvar skinDef = this.json.skins[ skinIndex ];\n\n\t\tvar skinEntry = { joints: skinDef.joints };\n\n\t\tif ( skinDef.inverseBindMatrices === undefined ) {\n\n\t\t\treturn Promise.resolve( skinEntry );\n\n\t\t}\n\n\t\treturn this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {\n\n\t\t\tskinEntry.inverseBindMatrices = accessor;\n\n\t\t\treturn skinEntry;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\n\t * @param {number} animationIndex\n\t * @return {Promise<THREE.AnimationClip>}\n\t */\n\tGLTFParser.prototype.loadAnimation = function ( animationIndex ) {\n\n\t\tvar json = this.json;\n\n\t\tvar animationDef = this.json.animations[ animationIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'accessor',\n\t\t\t'node'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar tracks = [];\n\n\t\t\tfor ( var i = 0, il = animationDef.channels.length; i < il; i ++ ) {\n\n\t\t\t\tvar channel = animationDef.channels[ i ];\n\t\t\t\tvar sampler = animationDef.samplers[ channel.sampler ];\n\n\t\t\t\tif ( sampler ) {\n\n\t\t\t\t\tvar target = channel.target;\n\t\t\t\t\tvar name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\n\t\t\t\t\tvar input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;\n\t\t\t\t\tvar output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;\n\n\t\t\t\t\tvar inputAccessor = dependencies.accessors[ input ];\n\t\t\t\t\tvar outputAccessor = dependencies.accessors[ output ];\n\n\t\t\t\t\tvar node = dependencies.nodes[ name ];\n\n\t\t\t\t\tif ( node ) {\n\n\t\t\t\t\t\tnode.updateMatrix();\n\t\t\t\t\t\tnode.matrixAutoUpdate = true;\n\n\t\t\t\t\t\tvar TypedKeyframeTrack;\n\n\t\t\t\t\t\tswitch ( PATH_PROPERTIES[ target.path ] ) {\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.weights:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.NumberKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.rotation:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.QuaternionKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.position:\n\t\t\t\t\t\t\tcase PATH_PROPERTIES.scale:\n\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\tTypedKeyframeTrack = THREE.VectorKeyframeTrack;\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar targetName = node.name ? node.name : node.uuid;\n\n\t\t\t\t\t\tvar interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : THREE.InterpolateLinear;\n\n\t\t\t\t\t\tvar targetNames = [];\n\n\t\t\t\t\t\tif ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {\n\n\t\t\t\t\t\t\t// node can be THREE.Group here but\n\t\t\t\t\t\t\t// PATH_PROPERTIES.weights(morphTargetInfluences) should be\n\t\t\t\t\t\t\t// the property of a mesh object under group.\n\n\t\t\t\t\t\t\tnode.traverse( function ( object ) {\n\n\t\t\t\t\t\t\t\tif ( object.isMesh === true && object.morphTargetInfluences ) {\n\n\t\t\t\t\t\t\t\t\ttargetNames.push( object.name ? object.name : object.uuid );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttargetNames.push( targetName );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// KeyframeTrack.optimize() will modify given 'times' and 'values'\n\t\t\t\t\t\t// buffers before creating a truncated copy to keep. Because buffers may\n\t\t\t\t\t\t// be reused by other tracks, make copies here.\n\t\t\t\t\t\tfor ( var j = 0, jl = targetNames.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tvar track = new TypedKeyframeTrack(\n\t\t\t\t\t\t\t\ttargetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],\n\t\t\t\t\t\t\t\tTHREE.AnimationUtils.arraySlice( inputAccessor.array, 0 ),\n\t\t\t\t\t\t\t\tTHREE.AnimationUtils.arraySlice( outputAccessor.array, 0 ),\n\t\t\t\t\t\t\t\tinterpolation\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// Here is the trick to enable custom interpolation.\n\t\t\t\t\t\t\t// Overrides .createInterpolant in a factory method which creates custom interpolation.\n\t\t\t\t\t\t\tif ( sampler.interpolation === 'CUBICSPLINE' ) {\n\n\t\t\t\t\t\t\t\ttrack.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {\n\n\t\t\t\t\t\t\t\t\t// A CUBICSPLINE keyframe in glTF has three output values for each input value,\n\t\t\t\t\t\t\t\t\t// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\n\t\t\t\t\t\t\t\t\t// must be divided by three to get the interpolant's sampleSize argument.\n\n\t\t\t\t\t\t\t\t\treturn new GLTFCubicSplineInterpolant( this.times, this.values, this.getValueSize() / 3, result );\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t// Workaround, provide an alternate way to know if the interpolant type is cubis spline to track.\n\t\t\t\t\t\t\t\t// track.getInterpolation() doesn't return valid value for custom interpolant.\n\t\t\t\t\t\t\t\ttrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttracks.push( track );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;\n\n\t\t\treturn new THREE.AnimationClip( name, undefined, tracks );\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\n\t * @param {number} nodeIndex\n\t * @return {Promise<THREE.Object3D>}\n\t */\n\tGLTFParser.prototype.loadNode = function ( nodeIndex ) {\n\n\t\tvar json = this.json;\n\t\tvar extensions = this.extensions;\n\n\t\tvar meshReferences = this.json.meshReferences;\n\t\tvar meshUses = this.json.meshUses;\n\n\t\tvar nodeDef = this.json.nodes[ nodeIndex ];\n\n\t\treturn this.getMultiDependencies( [\n\n\t\t\t'mesh',\n\t\t\t'skin',\n\t\t\t'camera',\n\t\t\t'light'\n\n\t\t] ).then( function ( dependencies ) {\n\n\t\t\tvar node;\n\n\t\t\t// .isBone isn't in glTF spec. See .markDefs\n\t\t\tif ( nodeDef.isBone === true ) {\n\n\t\t\t\tnode = new THREE.Bone();\n\n\t\t\t} else if ( nodeDef.mesh !== undefined ) {\n\n\t\t\t\tvar mesh = dependencies.meshes[ nodeDef.mesh ];\n\n\t\t\t\tif ( meshReferences[ nodeDef.mesh ] > 1 ) {\n\n\t\t\t\t\tvar instanceNum = meshUses[ nodeDef.mesh ] ++;\n\n\t\t\t\t\tnode = mesh.clone();\n\t\t\t\t\tnode.name += '_instance_' + instanceNum;\n\n\t\t\t\t\t// onBeforeRender copy for Specular-Glossiness\n\t\t\t\t\tnode.onBeforeRender = mesh.onBeforeRender;\n\n\t\t\t\t\tfor ( var i = 0, il = node.children.length; i < il; i ++ ) {\n\n\t\t\t\t\t\tnode.children[ i ].name += '_instance_' + instanceNum;\n\t\t\t\t\t\tnode.children[ i ].onBeforeRender = mesh.children[ i ].onBeforeRender;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnode = mesh;\n\n\t\t\t\t}\n\n\t\t\t} else if ( nodeDef.camera !== undefined ) {\n\n\t\t\t\tnode = dependencies.cameras[ nodeDef.camera ];\n\n\t\t\t} else if ( nodeDef.extensions\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ]\n\t\t\t\t\t && nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light !== undefined ) {\n\n\t\t\t\tvar lights = extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].lights;\n\t\t\t\tnode = lights[ nodeDef.extensions[ EXTENSIONS.KHR_LIGHTS_PUNCTUAL ].light ];\n\n\t\t\t} else {\n\n\t\t\t\tnode = new THREE.Object3D();\n\n\t\t\t}\n\n\t\t\tif ( nodeDef.name !== undefined ) {\n\n\t\t\t\tnode.name = THREE.PropertyBinding.sanitizeNodeName( nodeDef.name );\n\n\t\t\t}\n\n\t\t\tassignExtrasToUserData( node, nodeDef );\n\n\t\t\tif ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );\n\n\t\t\tif ( nodeDef.matrix !== undefined ) {\n\n\t\t\t\tvar matrix = new THREE.Matrix4();\n\t\t\t\tmatrix.fromArray( nodeDef.matrix );\n\t\t\t\tnode.applyMatrix( matrix );\n\n\t\t\t} else {\n\n\t\t\t\tif ( nodeDef.translation !== undefined ) {\n\n\t\t\t\t\tnode.position.fromArray( nodeDef.translation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.rotation !== undefined ) {\n\n\t\t\t\t\tnode.quaternion.fromArray( nodeDef.rotation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( nodeDef.scale !== undefined ) {\n\n\t\t\t\t\tnode.scale.fromArray( nodeDef.scale );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn node;\n\n\t\t} );\n\n\t};\n\n\t/**\n\t * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\n\t * @param {number} sceneIndex\n\t * @return {Promise<THREE.Scene>}\n\t */\n\tGLTFParser.prototype.loadScene = function () {\n\n\t\t// scene node hierachy builder\n\n\t\tfunction buildNodeHierachy( nodeId, parentObject, json, allNodes, skins ) {\n\n\t\t\tvar node = allNodes[ nodeId ];\n\t\t\tvar nodeDef = json.nodes[ nodeId ];\n\n\t\t\t// build skeleton here as well\n\n\t\t\tif ( nodeDef.skin !== undefined ) {\n\n\t\t\t\tvar meshes = node.isGroup === true ? node.children : [ node ];\n\n\t\t\t\tfor ( var i = 0, il = meshes.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar mesh = meshes[ i ];\n\t\t\t\t\tvar skinEntry = skins[ nodeDef.skin ];\n\n\t\t\t\t\tvar bones = [];\n\t\t\t\t\tvar boneInverses = [];\n\n\t\t\t\t\tfor ( var j = 0, jl = skinEntry.joints.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\tvar jointId = skinEntry.joints[ j ];\n\t\t\t\t\t\tvar jointNode = allNodes[ jointId ];\n\n\t\t\t\t\t\tif ( jointNode ) {\n\n\t\t\t\t\t\t\tbones.push( jointNode );\n\n\t\t\t\t\t\t\tvar mat = new THREE.Matrix4();\n\n\t\t\t\t\t\t\tif ( skinEntry.inverseBindMatrices !== undefined ) {\n\n\t\t\t\t\t\t\t\tmat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tboneInverses.push( mat );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.GLTFLoader: Joint \"%s\" could not be found.', jointId );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmesh.bind( new THREE.Skeleton( bones, boneInverses ), mesh.matrixWorld );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build node hierachy\n\n\t\t\tparentObject.add( node );\n\n\t\t\tif ( nodeDef.children ) {\n\n\t\t\t\tvar children = nodeDef.children;\n\n\t\t\t\tfor ( var i = 0, il = children.length; i < il; i ++ ) {\n\n\t\t\t\t\tvar child = children[ i ];\n\t\t\t\t\tbuildNodeHierachy( child, node, json, allNodes, skins );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn function loadScene( sceneIndex ) {\n\n\t\t\tvar json = this.json;\n\t\t\tvar extensions = this.extensions;\n\t\t\tvar sceneDef = this.json.scenes[ sceneIndex ];\n\n\t\t\treturn this.getMultiDependencies( [\n\n\t\t\t\t'node',\n\t\t\t\t'skin'\n\n\t\t\t] ).then( function ( dependencies ) {\n\n\t\t\t\tvar scene = new THREE.Scene();\n\t\t\t\tif ( sceneDef.name !== undefined ) scene.name = sceneDef.name;\n\n\t\t\t\tassignExtrasToUserData( scene, sceneDef );\n\n\t\t\t\tif ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );\n\n\t\t\t\tvar nodeIds = sceneDef.nodes || [];\n\n\t\t\t\tfor ( var i = 0, il = nodeIds.length; i < il; i ++ ) {\n\n\t\t\t\t\tbuildNodeHierachy( nodeIds[ i ], scene, json, dependencies.nodes, dependencies.skins );\n\n\t\t\t\t}\n\n\t\t\t\treturn scene;\n\n\t\t\t} );\n\n\t\t};\n\n\t}();\n\n\treturn GLTFLoader;\n\n} )();\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/GLTFLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/HouseTxtLoader.js":
/*!******************************************!*\
  !*** ./js/lib/loaders/HouseTxtLoader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar BBox = __webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\");\nvar OBB = __webpack_require__(/*! geo/OBB */ \"./js/lib/geo/OBB.js\");\nvar Index = __webpack_require__(/*! ds/Index */ \"./js/lib/ds/Index.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Loader for house txt files\n * @param params\n * @param params.fs {{readAsync: function(name, encoding, callback)}} API to File system to use for loading house files\n * @constructor\n * @memberOf loaders\n */\nfunction HouseLoader(params) {\n  this.fs = params.fs;\n  this.debug = params.debug;\n}\n\n/**\n * Load and parses house file\n * @param file\n * @param callback {function(err, House)}\n */\nHouseLoader.prototype.load = function(file, callback) {\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        var parsed = scope.parse(filename, data);\n        callback(null, parsed);\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\n/**\n * Parses house file\n * @param filename {string}\n * @param data {string}\n * @return {House}\n */\nHouseLoader.prototype.parse = function(filename, data) {\n  var house;\n  if (filename.endsWith('.json')) {\n    house = new House(JSON.parse(data));\n  } else {\n    house = new House(this.__parseHouseFormat(data));\n  }\n  if (this.debug) {\n    checkHouse(house);\n  }\n  return house;\n};\n\nfunction parseString(str) {\n  return (str === '-')? undefined : str;\n}\n\nfunction parseVector3(array) {\n  var values = array.map(function(x) { return parseFloat(x); });\n  return new THREE.Vector3(values[0], values[1], values[2]);\n}\n\nfunction parseBBox(array) {\n  var values = array.map(function(x) { return parseFloat(x); });\n  return new BBox(\n    new THREE.Vector3(values[0], values[1], values[2]),\n    new THREE.Vector3(values[3], values[4], values[5])\n  );\n}\n\nfunction parseObb(array) {\n  var center = parseVector3(array.slice(0,3));\n  var a1 = parseVector3(array.slice(3,6));\n  var a2 = parseVector3(array.slice(6,9));\n  var a3 = new THREE.Vector3();\n  a3.crossVectors(a1, a2);\n  var radius = parseVector3(array.slice(9,12));\n  var basis = new THREE.Matrix4();\n  basis.set(\n    a1.x, a2.x, a3.x, 0,\n    a1.y, a2.y, a3.y, 0,\n    a1.z, a2.z, a3.z, 0,\n    0, 0, 0, 1\n  );\n  return new OBB(center, radius, basis);\n}\n\nfunction parseMatrix4(array) {\n  var m = new THREE.Matrix4();\n  m.set.apply(m, array);\n  return m;\n}\n\nvar regionCodes = {\n  'a': 'bathroom', // with toilet and sink\n  'b': 'bedroom',\n  'c': 'closet',\n  'd': 'dining room',  // includes breakfast rooms other rooms people mainly eat in\n  'e': 'entryway/foyer/lobby', // should be the front door, not any door\n  'f': 'familyroom/lounge', // should be a room that a family hangs out in, not any area with couches\n  'g': 'garage',\n  'h': 'hallway',\n  'i': 'library', // should be room like a library at a university, not an individual study\n  'j': 'laundryroom/mudroom', // place where people do laundry, etc.\n  'k': 'kitchen',\n  'l': 'living room', // should be the main showcase living room in a house, not any area with couches\n  'm': 'meetingroom/conferenceroom',\n  'n': 'lounge', // any area where people relax in comfy chairs/couches that is not the family room or living room\n  'o': 'office', // usually for an individual, or a small set of people\n  'p': 'porch/terrace/deck', // must be outdoors on ground level\n  'r': 'rec/game', // should have recreational objects, like pool table, etc.\n  's': 'stairs',\n  't': 'toilet',  // should be a small room with ONLY a toilet\n  'u': 'utilityroom/toolroom',\n  'v': 'tv', // must have theater-style seating\n  'w': 'workout/gym/exercise',\n  'x': 'outdoor', // outdoor areas containing grass, plants, bushes, trees, etc.\n  'y': 'balcony', // must be outside and must not be on ground floor\n  'z': 'other room', // it is clearly a room, but the function is not clear\n  'B': 'bar',\n  'C': 'classroom',\n  'D': 'dining booth',\n  'S': 'spa/sauna',\n  'Z': 'junk' // reflections of mirrors, random points floating in space, etc.\n};\n\nvar surfaceCodes = {\n  'F': { name: 'Floor', normal: new THREE.Vector3(0,0,1) }\n};\n\nHouseLoader.prototype.__parseHouseFormat = function(data) {\n  var lines = data.split('\\n');\n  // Check first line is ASCII 1.0\n  var header_parts = lines[0].split(/\\s+/);\n  var header_type = header_parts[0];\n  var header_version = header_parts[1];\n  if (header_type !== 'ASCII') {\n    throw 'Invalid house format';\n  }\n  if (header_version === '1.0') {\n    return this.__parseHouseFormatv10(lines);\n  } else if (header_version === '1.1') {\n    return this.__parseHouseFormatv11(lines);\n  } else {\n    throw 'Unsupported house version';\n  }\n};\n\nHouseLoader.prototype.__parseHouseFormatv10 = function(lines) {\n  var house = null;\n  var levels = [];\n  var regions = [];\n  var surfaces = [];\n  var vertices = [];\n  // ASCII 1.0\n  // H  -  -  0 0 56 10 10 1  -11.5795 -2.88429 -0.0415621  5.99388 5.84667 2.6074  0 0 0 0 0 0 0 0\n  // L  0  10  -  -2.92031 0.50208 0.00312996  -11.2995 -2.84965 -0.00842175  4.65722 5.32133 2.6074  0 0 0 0 0\n  // R  0 0  0 1  b  -8.84465 1.00624 -0.00842175  -11.0959 0.517162 0.0898792  -6.7388 4.80697 2.2792  0 0 0 0 0\n  // S  0 0  6  F  -9.26133 2.13581 -0.00842175  0 0 1  -11.0959 0.517162 -0.00842175  -6.7388 4.80697 0.0898792  0 0 0 0 0\n  // V  0 0  F  -10.1414 0.587867 0.0898792  0 0 1  0 0 0\n  // Parse house file\n  for (var i = 1; i < lines.length; i++) {\n    var lineno = i + 1;\n    var line = lines[i];\n    line = line.trim();\n    if (line.length === 0) { continue; }\n    var parts = line.split(/\\s+/);\n    if (parts.length > 0) {\n      var cmd = parts[0];\n      switch (cmd) {\n        case 'H':\n          house = {\n            name: parseString(parts[1]),\n            label: parseString(parts[2]),\n            nimages: parseInt(parts[3]),\n            npanoramas: parseInt(parts[4]),\n            nvertices: parseInt(parts[5]),\n            nsurfaces: parseInt(parts[6]),\n            nregions: parseInt(parts[7]),\n            nlevels: parseInt(parts[8]),\n            bbox: parseBBox(parts.slice(9, 15)),\n            levels: levels,\n            regions: regions,\n            surfaces: surfaces,\n            vertices: vertices\n          };\n          break;\n        case 'L':\n          var level = {\n            index: parseInt(parts[1]),\n            //nregions: parseInt(parts[2]),\n            labelCode: parseString(parts[3]),\n            position: parseVector3(parts.slice(4, 7)),\n            bbox: parseBBox(parts.slice(7, 13)),\n            regions: []\n          };\n          levels.push(level);\n          break;\n        case 'R':\n          // Each region belongs to a level\n          var region = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            //npanoramas: parseInt(parts[3]),\n            //nsurfaces: parseInt(parts[4]),\n            labelCode: parseString(parts[5]),\n            position: parseVector3(parts.slice(6, 9)),\n            bbox: parseBBox(parts.slice(9, 15)),\n            surfaces: []\n          };\n          region.regionType = regionCodes[region.labelCode];\n          regions.push(region);\n          levels[region.parentIndex].regions.push(region);\n          break;\n        case 'S':\n          // Each surface belong to a region\n          // Each region should have one surface (the floor)\n          var surface = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            //nvertices: parseInt(parts[3]),\n            labelCode: parseString(parts[4]),\n            position: parseVector3(parts.slice(5, 8)),\n            normal: parseVector3(parts.slice(8, 11)),\n            bbox: parseBBox(parts.slice(11, 17)),\n            vertices: []\n          };\n          surfaces.push(surface);\n          if (surface.parentIndex >= 0) {\n            regions[surface.parentIndex].surfaces.push(surface);\n          } else {\n            console.warn('Surface not associated with a region', Constants.isBrowser? surface : surface.index);\n          }\n          break;\n        case 'V':\n          // Each vertex belongs to a surface\n          var vertex = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            labelCode: parseString(parts[3]),\n            position: parseVector3(parts.slice(4, 7)),\n            normal: parseVector3(parts.slice(7, 13))\n          };\n          vertices.push(vertex);\n          surfaces[vertex.parentIndex].vertices.push(vertex);\n          break;\n        default:\n          console.warn('Ignoring line ' + lineno + ' with unknown command ', line);\n      }\n    }\n  }\n  house.statistics = computeStatistics(house);\n  return house;\n};\n\nHouseLoader.prototype.__parseHouseFormatv11 = function(lines) {\n  var house = null;\n  var levels = [];\n  var regions = [];\n  var surfaces = [];\n  var vertices = [];\n  var panoramas = [];\n  var images = [];\n  var segments = [];\n  var objects = [];\n  var categories = [];\n  var portals = [];\n  // ASCII 1.1\n  // Parse house file\n  for (var i = 1; i < lines.length; i++) {\n    var lineno = i + 1;\n    var line = lines[i];\n    line = line.trim();\n    if (line.length === 0) { continue; }\n    var parts = line.split(/\\s+/);\n    if (parts.length > 0) {\n      var cmd = parts[0];\n      switch (cmd) {\n        case 'H':\n          //H name label #images #panoramas #vertices #surfaces #segments #objects #categories #regions #portals #levels  0 0 0 0 0  xlo ylo zlo xhi yhi zhi  0 0 0 0 0\n          house = {\n            name: parseString(parts[1]),\n            label: parseString(parts[2]),\n            nimages: parseInt(parts[3]),\n            npanoramas: parseInt(parts[4]),\n            nvertices: parseInt(parts[5]),\n            nsurfaces: parseInt(parts[6]),\n            nsegments: parseInt(parts[7]),\n            nobjects: parseInt(parts[8]),\n            ncategories: parseInt(parts[9]),\n            nregions: parseInt(parts[10]),\n            nportals: parseInt(parts[11]),\n            nlevels: parseInt(parts[12]),\n            bbox: parseBBox(parts.slice(13, 19)),\n            levels: levels,\n            regions: regions,\n            surfaces: surfaces,\n            vertices: vertices,\n            objects: objects,\n            segments: segments,\n            portals: portals,\n            categories: categories,\n            panoramas: panoramas,\n            images: images\n          };\n          break;\n        case 'L':\n          //L level_index #regions label  px py pz  xlo ylo zlo xhi yhi zhi  0 0 0 0 0\n          var level = {\n            index: parseInt(parts[1]),\n            //nregions: parseInt(parts[2]),\n            labelCode: parseString(parts[3]),\n            position: parseVector3(parts.slice(4, 7)),\n            bbox: parseBBox(parts.slice(7, 13)),\n            regions: []\n          };\n          levels.push(level);\n          break;\n        case 'R':\n          //R region_index level_index 0 0 label  px py pz  xlo ylo zlo xhi yhi zhi  0 0 0 0 0\n          // Each region belongs to a level\n          var region = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            //npanoramas: parseInt(parts[3]),\n            //nsurfaces: parseInt(parts[4]),\n            labelCode: parseString(parts[5]),\n            position: parseVector3(parts.slice(6, 9)),\n            bbox: parseBBox(parts.slice(9, 15)),\n            surfaces: [],\n            objects: [],\n            panoramas: []\n          };\n          region.regionType = regionCodes[region.labelCode];\n          regions.push(region);\n          levels[region.parentIndex].regions.push(region);\n          break;\n        case 'S':\n          //S surface_index region_index 0 label px py pz  nx ny nz  xlo ylo zlo xhi yhi zhi  0 0 0 0 0\n          // Each surface belong to a region\n          // Each region should have one surface (the floor)\n          var surface = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            //nvertices: parseInt(parts[3]),\n            labelCode: parseString(parts[4]),\n            position: parseVector3(parts.slice(5, 8)),\n            normal: parseVector3(parts.slice(8, 11)),\n            bbox: parseBBox(parts.slice(11, 17)),\n            vertices: []\n          };\n          surfaces.push(surface);\n          if (surface.parentIndex >= 0) {\n            regions[surface.parentIndex].surfaces.push(surface);\n          } else {\n            console.warn('Surface not associated with a region', Constants.isBrowser? surface : surface.index);\n          }\n          break;\n        case 'V':\n          //V vertex_index surface_index label  px py pz  nx ny nz  0 0 0\n          // Each vertex belongs to a surface\n          var vertex = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            labelCode: parseString(parts[3]),\n            position: parseVector3(parts.slice(4, 7)),\n            normal: parseVector3(parts.slice(7, 13))\n          };\n          vertices.push(vertex);\n          surfaces[vertex.parentIndex].vertices.push(vertex);\n          break;\n        case 'P':\n          if (portals.length < house.nportals) {\n            // Could be P or could be R!\n            //P portal_index region0_index region1_index label  xlo ylo zlo xhi yhi zhi  0 0 0 0\n            var portal = {\n              index: parseInt(parts[1]),\n              regionIndex0: parseInt(parts[2]),\n              regionIndex1: parseInt(parts[3]),\n              labelCode: parseString(parts[4]),\n              bbox: parseBBox(parts.slice(5, 11))\n            };\n            portals.push(portal);\n            regions[portal.regionIndex0].portals.push(portal);\n            regions[portal.regionIndex1].portals.push(portal);\n          } else {\n            //P name  panorama_index region_index 0  px py pz  0 0 0 0 0\n            var panorama = {\n              name: parseString(parts[1]),\n              index: parseInt(parts[2]),\n              regionIndex: parseInt(parts[3]),\n              // skip dummy\n              position: parseVector3(parts.slice(5, 8)),\n              images: []\n            };\n            panoramas.push(panorama);\n            if (panorama.regionIndex >= 0) {\n              regions[panorama.regionIndex].panoramas.push(panorama);\n            } else {\n              console.warn('Panorama not associated with a region', Constants.isBrowser? panorama : panorama.index);\n            }\n          }\n          break;\n        case 'C':\n          // Class categories (subset of information in full category mapping file)\n          //C category_index category_mapping_index category_mapping_name mpcat40_index mpcat40_name 0 0 0 0 0\n          var category = {\n            index: parseInt(parts[1]),\n            categoryMappingIndex: parseInt(parts[2]),\n            categoryMappingName: parseString(parts[3]).replace('#', ' '),\n            mpcat40Index: parseInt(parts[4]),\n            mpcat40Name: parseString(parts[5])\n          };\n          categories[category.index] = category;\n          break;\n        case 'O':\n          // Object\n          //O object_index region_index category_index px py pz  a0x a0y a0z  a1x a1y a1z  r0 r1 r2 0 0 0 0 0 0 0 0\n          var object = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            categoryIndex: parseInt(parts[3]),\n            obb: parseObb(parts.slice(4,16)),\n            segments: []\n          };\n          objects.push(object);\n          if (object.parentIndex >= 0) {\n            regions[object.parentIndex].objects.push(object);\n          } else {\n            console.warn('Object not associated with a region', object);\n          }\n          break;\n        case 'I':\n          //I image_index panorama_index  name camera_index yaw_index e00 e01 e02 e03 e10 e11 e12 e13 e20 e21 e22 e23 e30 e31 e32 e33  i00 i01 i02  i10 i11 i12 i20 i21 i22  width height  px py pz  0 0 0 0 0\n          var image = {\n            index: parseInt(parts[1]),\n            panoramaIndex: parseInt(parts[2]),\n            name: parseString(parts[3]),\n            cameraIndex: parseInt(parts[4]),\n            yawIndex: parseInt(parts[5]),\n            extrinsicMatrix: parseMatrix4(parts.slice(6,22)),\n            intrinsicMatrix: parseMatrix4(parts.slice(22,38)),\n            width: parseInt(parts[38]),\n            height: parseInt(parts[39]),\n            position: parseVector3(parts.slice(40, 43))\n          };\n          images.push(image);\n          panoramas[image.panoramaIndex].images.push(image);\n          break;\n        case 'E':\n          //E segment_index object_index id area px py pz xlo ylo zlo xhi yhi zhi  0 0 0 0 0\n          var segment = {\n            index: parseInt(parts[1]),\n            parentIndex: parseInt(parts[2]),\n            id: parseInt(parts[3]),\n            area: parseFloat(parts[4]),\n            position: parseVector3(parts.slice(5,8)),\n            bbox: parseBBox(parts.slice(8,14))\n          };\n          segments.push(segment);\n          objects[segment.parentIndex].segments.push(segment);\n          break;\n        default:\n          console.warn('Ignoring line ' + lineno + ' with unknown command ', line);\n      }\n    }\n  }\n  house.statistics = computeStatistics(house);\n  return house;\n};\n\nfunction checkHouse(house) {\n  function checkLength(array, expectedLength, desc) {\n    array = array || [];\n    expectedLength = expectedLength || 0;\n    if (array.length !== expectedLength) {\n      console.warn('Mismatch ' + desc + ', expected ' + expectedLength + ', got ' + array.length);\n    }\n  }\n  checkLength(house.images, house.nimages, 'images');\n  checkLength(house.panoramas, house.npanoramas, 'panoramas');\n  checkLength(house.vertices, house.nvertices, 'vertices');\n  checkLength(house.surfaces, house.nsurfaces, 'surfaces');\n  checkLength(house.segments, house.nsegments, 'segments');\n  checkLength(house.objects, house.nobjects, 'objects');\n  checkLength(house.categories, house.ncategories, 'categories');\n  checkLength(house.regions, house.nregions, 'regions');\n  checkLength(house.portals, house.nportals, 'portals');\n  checkLength(house.levels, house.nlevels, 'levels');\n}\n\nfunction computeStatistics(house) {\n  var statistics = {};\n  if (house.regions) {\n    var regionTypeCounts = {};\n    _.each(house.regions, function (region) {\n      regionTypeCounts[region.regionType] = (regionTypeCounts[region.regionType] || 0) + 1;\n    });\n    statistics.regionTypes = regionTypeCounts;\n  }\n  if (house.objects) {\n    var objectTypeCounts = {};\n    var mpr40Counts = {};\n    var objectTypeCountsByRegion = {};\n    var mpr40CountsByRegion = {};\n    _.each(house.objects, function (object) {\n      var category = house.categories[object.categoryIndex];\n      if (category) {\n        var objectType = category.categoryMappingName;\n        var mpr40name = category.mpcat40Name;\n        object.category = objectType;\n        object.mpr40 = mpr40name;\n        objectTypeCounts[objectType] = (objectTypeCounts[objectType] || 0) + 1;\n        mpr40Counts[mpr40name] = (mpr40Counts[mpr40name] || 0) + 1;\n        objectTypeCountsByRegion[object.parentIndex] = objectTypeCountsByRegion[object.parentIndex] || {};\n        objectTypeCountsByRegion[object.parentIndex][objectType] = (objectTypeCountsByRegion[object.parentIndex][objectType] || 0) + 1;\n        mpr40CountsByRegion[object.parentIndex] = mpr40CountsByRegion[object.parentIndex] || {};\n        mpr40CountsByRegion[object.parentIndex] = (mpr40CountsByRegion[object.parentIndex][objectType] || 0) + 1;\n      }\n    });\n    statistics.categoryCounts = objectTypeCounts;\n    statistics.mpr40Counts = mpr40Counts;\n    statistics.categoryCountsByRegion = objectTypeCountsByRegion;\n    statistics.mpr40CountsByRegion = mpr40CountsByRegion;\n  }\n  return statistics;\n}\n\nfunction checkSurface(surface) {\n  var checkOkay = true;\n  var surfaceType = surfaceCodes[surface.labelCode];\n  var expectedNormal = surfaceType.normal;\n  var vertices = surface.vertices;\n  if (vertices.length < 3) {\n    console.warn('Not enough points for ' + surfaceType.name + ': ' + vertices.length, Constants.isBrowser? surface : surface.index);\n    return false;\n  }\n  if (surfaceType.name === 'Floor') {\n    // Floor - assume z is constant and normal is z-up\n    var minZ = _.minBy(vertices, 'position.z').position.z;\n    var maxZ = _.maxBy(vertices, 'position.z').position.z;\n    if (minZ !== maxZ) {\n      console.warn(surfaceType.name + ' at different heights: ' + minZ + ' to ' + maxZ, Constants.isBrowser? surface : surface.index);\n      //checkOkay = false;\n    }\n  }\n\n  for (var k = 0; k < vertices.length; k++) {\n    var v = vertices[k];\n    if (!v.normal.equals(expectedNormal)) {\n      console.warn(surfaceType.name + ' normal is not oriented correctly!', v, expectedNormal);\n      checkOkay = false;\n    }\n  }\n  return checkOkay;\n}\n\nHouseLoader.prototype.createHouseGeometry = function(house) {\n  return house.createGeometry();\n};\n\n/**\n * House - most fabulous house\n * @param opts\n * @constructor\n */\nfunction House(opts) {\n  _.extend(this, opts);\n}\n\nHouse.prototype.getRegionTypeIndex = function() {\n  if (!House.__regionTypeIndex) {\n    var regionTypeIndex = new Index();\n    _.each(regionCodes, function(regionType, regionCode) {\n      regionTypeIndex.add(regionType);\n    });\n    House.__regionTypeIndex = regionTypeIndex;\n  }\n  return House.__regionTypeIndex;\n};\n\nHouse.prototype.__getColorFn = function(colorBy, palette) {\n  if (colorBy === 'regionType' || colorBy === 'roomType') {\n    var regionTypeIndex = this.getRegionTypeIndex();\n    return function(region) {\n      var colorIdx = regionTypeIndex.indexOf(region.regionType, true);\n      return Object3DUtil.createColor(colorIdx, palette);\n    };\n  } else if (colorBy === 'level') {\n    return function(region) {\n      return Object3DUtil.createColor(region.parentIndex, palette);\n    };\n  } else if (colorBy === 'regionId' || colorBy === 'roomId') {\n    return function(region) {\n      return Object3DUtil.createColor(region.index, palette);\n    };\n  } else {\n    console.warn('Ignoring unknown colorBy: ' + colorBy);\n  }\n};\n\nHouse.prototype.setBBoxOpacity = function(opacity) {\n  Object3DUtil.traverseMeshes(this.object3D, false, function(mesh) {\n    if (mesh.userData.type === 'BBox') {\n      mesh.material.opacity = opacity;\n    }\n  });\n};\n\nHouse.prototype.setRegionOpacity = function(opacity) {\n  Object3DUtil.traverseMeshes(this.object3D, false, function(mesh) {\n    if (mesh.userData.type === 'RegionShape') {\n      mesh.material.opacity = opacity;\n    }\n  });\n};\n\nHouse.prototype.setObjectsVisible = function(flag) {\n  Object3DUtil.traverse(this.object3D, function(obj) {\n    if (obj.userData.type === 'Object') {\n      Object3DUtil.setVisible(obj, flag);\n      return false;\n    } else {\n      return true;\n    }\n  });\n};\n\nHouse.prototype.recolor = function(colorFn, palette) {\n  if (typeof colorFn === 'string') {\n    colorFn = this.__getColorFn(colorFn, palette);\n    if (!colorFn) { return; }\n  }\n  var house = this;\n  for (var i = 0; i < house.regions.length; i++) {\n    var region = house.regions[i];\n    if (region.object3D) {\n      var color = colorFn(region);\n      Object3DUtil.traverseMeshes(region.object3D, false, function(mesh) {\n        mesh.material.color.copy(color);\n      });\n    }\n  }\n};\n\nHouse.prototype.createGeometry = function(opts) {\n  opts = _.defaultsDeep(Object.create(null), opts || {}, {\n    includeParts: { 'BBox': true, 'RegionShape': true, 'Surface': true, 'Object': true }\n  });\n  var house = this;\n  var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n  var MeshHelpers = __webpack_require__(/*! geo/MeshHelpers */ \"./js/lib/geo/MeshHelpers.js\");\n  for (var i = 0; i < house.regions.length; i++) {\n    var region = house.regions[i];\n    var level = house.levels[region.parentIndex];\n\n    var regionObject = new THREE.Group();\n    regionObject.name = 'region' + i;\n    regionObject.userData.id = 'R' + i;\n    regionObject.userData.index = region.index;\n    regionObject.userData.type = 'Region';\n    regionObject.userData.regionType = region.regionType;\n    regionObject.userData.level = region.parentIndex;\n    if (region.regionType) {\n      regionObject.name = regionObject.name + ' (' + region.regionType + ')';\n    }\n\n    // Surfaces\n    if (region.surfaces) {\n      var regionFloorShapes = [];\n      var regionFloorHeight = Infinity;\n      var regionArea = 0;\n      for (var j = 0; j < region.surfaces.length; j++) {\n        var surface = region.surfaces[j];\n        if (surface.labelCode === 'F') {\n          var surfaceOkay = checkSurface(surface);\n          if (surfaceOkay) {\n            var vertices = surface.vertices;\n            var shape = new THREE.Shape();\n            var v = vertices[0];\n            shape.moveTo(v.position.x, v.position.y);\n            for (var k = 1; k < vertices.length; k++) {\n              v = vertices[k];\n              shape.lineTo(v.position.x, v.position.y);\n            }\n            v = vertices[0];\n            shape.lineTo(v.position.x, v.position.y);\n\n            if (opts.includeParts['Surface']) {\n              var geometry = new THREE.ShapeGeometry([shape]);\n              //geometry.addShape(shape, { material: j});\n              geometry.computeFaceNormals();\n              var mesh = new THREE.Mesh(geometry, Object3DUtil.getSimpleFalseColorMaterial(i));\n              mesh.name = 'Surface' + j;\n              mesh.userData.id = 'S' + j;\n              mesh.userData.index = surface.index;\n              mesh.userData.type = 'Floor';\n              mesh.userData.region = surface.parentIndex;\n              mesh.userData.level = region.parentIndex;\n              mesh.position.z = /*level.position.z + */surface.position.z;\n              regionObject.add(mesh);\n              surface.area = Object3DUtil.getSurfaceArea(mesh);\n              regionArea += surface.area;\n            }\n            regionFloorHeight = Math.min(surface.position.z, regionFloorHeight);\n            regionFloorShapes.push(shape);\n          }\n        } else {\n          console.warn('Ignoring unknown surface type: ' + surface.labelCode);\n        }\n\n        if (regionFloorShapes.length > 0 && opts.includeParts['RegionShape']) {\n          var height = region.bbox.max.z - regionFloorHeight;\n          var extrudeGeom = new THREE.ExtrudeGeometry(regionFloorShapes, { depth: height, bevelEnabled: false });\n          var mat2 = Object3DUtil.getSimpleFalseColorMaterial(i);\n          mat2.transparent = true;\n          mat2.opacity = 0.25;\n          var prism = new THREE.Mesh(extrudeGeom, mat2);\n          prism.name = 'RegionShape' + i;\n          prism.userData.type = 'RegionShape';\n          prism.position.z = regionFloorHeight;\n          regionObject.add(prism);\n        }\n      }\n      region.area = regionArea;\n    }\n\n    if (region.objects && region.objects.length && opts.includeParts['Object']) {\n      var objectsGroup = new THREE.Group();\n      objectsGroup.name = 'Objects';\n      regionObject.add(objectsGroup);\n      for (var j = 0; j < region.objects.length; j++) {\n        var object = region.objects[j];\n        // TODO: color (instance, category, mpr40)\n        var objectOBBSolid = new MeshHelpers.OBB(object.obb, 'yellow');\n//        var objectOBB = objectOBBSolid.toWireFrame(0.001*Constants.metersToVirtualUnit);\n        var objectOBB = objectOBBSolid.toWireFrame(0);\n        objectOBB.name = 'Object' + j + ' (' + object.category +')';\n        objectOBB.userData.id = 'O' + j;\n        objectOBB.userData.index = object.index;\n        objectOBB.userData.type = 'Object';\n        objectOBB.userData.category = object.category;\n        objectOBB.userData.mpr40 = object.mpr40;\n        objectsGroup.add(objectOBB);\n      }\n    }\n\n    if (opts.includeParts['BBox']) {\n      var mat = Object3DUtil.getSimpleFalseColorMaterial(i);\n      mat.transparent = true;\n      mat.opacity = 0.25;\n      var regionBBox = new MeshHelpers.BoxMinMax(region.bbox.min, region.bbox.max, mat);\n      regionBBox.name = 'BBox' + i;\n      regionBBox.userData.type = 'BBox';\n      regionObject.add(regionBBox);\n    }\n    region.object3D = regionObject;\n  }\n  house.object3D = new THREE.Group();\n  for (var i = 0; i < house.levels.length; i++) {\n    var level = house.levels[i];\n    var group = new THREE.Group();\n    for (var j = 0; j < level.regions.length; j++) {\n      var region = level.regions[j];\n      group.add(region.object3D);\n    }\n    group.name = 'Level' + i;\n    group.userData.id = 'L' + i;\n    group.userData.type = 'Level';\n    level.object3D = group;\n    house.object3D.add(level.object3D);\n  }\n  house.object3D.name = house.name;\n  house.object3D.userData.id = house.name;\n  return house.object3D;\n};\n\nmodule.exports = HouseLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/HouseTxtLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/LabeledGridLoader.js":
/*!*********************************************!*\
  !*** ./js/lib/loaders/LabeledGridLoader.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BinaryView = __webpack_require__(/*! util/BinaryView */ \"./js/lib/util/BinaryView.js\");\n\n/**\n * Labeled Grid Loader.\n * @constructor\n * @memberof loaders\n */\nvar LabeledGridLoader = function () {\n};\n\n/**\n * Parses a file containing a labeled grid\n * @param filename Name of file (used for debug messages)\n * @param binary {jbinary} jbinary object containing the data of the file\n * @returns {*}\n */\nLabeledGridLoader.prototype.parse = function (filename, binary) {\n  // here you can use `binary` instance to parse data\n  //console.log(binary);\n  //! Read an occupancy grid file. File starts with ASCII header of following format (excluding comments after #):\n  //!   labeledgrid\\t1\n  //!   dimensions\\tdimX dimY dimZ  # vec3ul\n  //!   worldToGrid\\tfloat00 float01 float02 float03 float10 ... float33  # mat4f\n  //!   voxelSize\\tfloat\n  //!   labels\\tId1,Id2,Id3,...\n  //!   numVoxels\\tsize_t\n  //!   data:\n  //! Binary section follows with 4-tuples of int16_t (x, y, z, label) in little endian\n\n  var voxData = binary.view;\n  //\n  // read header\n  //\n  var grid = {\n    type: 'labeledgrid',\n    worldToGrid: new THREE.Matrix4(),\n    gridToWorld: new THREE.Matrix4(),\n    labels: [],\n    voxelSize: 1,\n    numVoxels: 0\n  };\n  var offset = 0;\n  var lineData = BinaryView.getLine(voxData, offset);\n  if (!lineData) {\n    console.error('Parsing labeledgrid ' + filename + ': Empty voxel data');\n    return false;\n  }\n  var line = lineData.string;\n  if (!line.startsWith('labeledgrid')) {\n    console.error('Parsing labeledgrid ' + filename + ': first line reads [' + line + '] instead of [labeledgrid]');\n    return false;\n  }\n\n  var versionString = line.substring(12);\n  var version = parseInt(versionString);\n  console.log('Parsing labeledgrid ' + filename + ': Reading labeledgrid version ' + version);\n\n  grid.depth = grid.height = grid.width = 0;\n  var done = false;\n  while (!done) {\n    lineData = BinaryView.getLine(voxData, lineData.next);\n    line = lineData.string;\n    if (line.startsWith('data')) done = true;\n    else {\n      var fields = line.split('\\t');\n      var name = fields[0];\n      var value = fields[1];\n      if (name == 'dimensions') {\n        var dimensions = value.split(' ');\n        grid.depth = parseInt(dimensions[0]);\n        grid.width = parseInt(dimensions[1]);\n        grid.height = parseInt(dimensions[2]);\n      } else if (name == 'worldToGrid') {\n        var m = value.split(' ');\n        m = m.map(function (a) { return parseFloat(a); });\n        grid.worldToGrid.set(\n          m[0], m[1], m[2], m[3],\n          m[4], m[5], m[6], m[7],\n          m[8], m[9], m[10], m[11],\n          m[12], m[13], m[14], m[15]\n        );\n        grid.gridToWorld.getInverse(grid.worldToGrid);\n      } else if (name == 'voxelSize') {\n        grid.voxelSize = parseFloat(value);\n      } else if (name == 'numVoxels') {\n        grid.numVoxels = parseInt(value);\n      } else if (name == 'labels') {\n        grid.labels = value.split(',');\n      } else {\n        console.warn('Parsing labeledgrid ' + filename + ': unrecognized keyword [' + line + '], skipping');\n      }\n    }\n  }  // while\n\n  if (!done) {\n    console.error('Parsing labeledgrid ' + filename + ':  error reading header');\n    return false;\n  }\n  if (grid.depth === 0) {\n    console.error('Parsing labeledgrid ' + filename + ':  missing dimensions in header');\n    return false;\n  }\n\n  grid.size = grid.width * grid.height * grid.depth;\n  grid.dims = [grid.depth, grid.width, grid.height];\n\n  // Store voxels as bit array backed by UInt8Array\n  // Number of bytes to allocate for voxels\n  grid.voxels = (grid.labels.length < 255) ? new Uint8Array(grid.size) : new Uint16Array(grid.size);\n  //grid.voxels = new Map();\n  grid.getKey = function (x, y, z) {\n    return x * grid.width * grid.height + z * grid.width + y;\n  };\n  grid.isVoxelSet = function (x, y, z) {\n    return grid.getVoxel(x,y,z);\n  };\n  grid.getVoxel = function (x, y, z) {\n    var vi = grid.getKey(x,y,z);\n    if (vi >= 0 && vi < grid.size) {\n      return grid.voxels[vi];\n    }\n  };\n  grid.setVoxel = function (x, y, z, flag) {\n    var vi = grid.getKey(x,y,z);\n    if (vi >= 0 && vi < grid.size) {\n      grid.voxels[vi] = flag;\n    }\n  };\n\n  //\n  // read voxel data\n  //\n  voxData.seek(lineData.next);\n  var nVoxelsRead = 0;\n  while (nVoxelsRead < grid.numVoxels) {\n    // read uint16s in little endian\n    var x = voxData.getUint16(undefined, true);\n    var y = voxData.getUint16(undefined, true);\n    var z = voxData.getUint16(undefined, true);\n    var label = voxData.getUint16(undefined, true);\n    grid.setVoxel(x,y,z,label + 1);\n\n    //if (nVoxelsRead < 16) {\n    //  console.log(nVoxelsRead + ' ' + x + ' ' + y + ' ' + z + ' ' + label);\n    //}\n    nVoxelsRead++;\n  }  // while\n\n  console.log('Parsing labeledgrid ' + filename + ':  read ' + nVoxelsRead + ' voxels');\n  //console.log(grid);\n  return grid;\n};\n\nmodule.exports = LabeledGridLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/LabeledGridLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/MTLLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/MTLLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\n\n/**\n * Modified version of THREE.MTLLoader from three.js\n * Loads a Wavefront .mtl file specifying materials\n *\n * @author angelxuanchang\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n * @constructor\n * @memberOf loaders\n */\nTHREE.MTLLoader = function( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.MTLLoader.prototype, THREE.EventDispatcher.prototype, {\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t//loader.setCrossOrigin( this.crossOrigin );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetBaseUrl: function( value ) {\n\n\t\tthis.baseUrl = value;\n\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tsetMaterialOptions: function ( value ) {\n\n\t\tthis.materialOptions = value;\n\n\t},\n\n\t/**\n\t * Parses loaded MTL file\n\t * @param text - Content of MTL file\n\t * @return {THREE.MTLLoader.MaterialCreator}\n\t * @private\n\t */\n\tparse: function ( text ) {\n\n\t\tvar lines = text.split( \"\\n\" );\n\t\tvar info = {};\n\t\tvar delimiter_pattern = /\\s+/;\n\t\tvar materialInfos = [];\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\t// Blank line or comment ignore\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tvar pos = line.indexOf( ' ' );\n\n\t\t\tvar key = ( pos >= 0 ) ? line.substring( 0, pos ) : line;\n\t\t\tkey = key.toLowerCase();\n\n\t\t\tvar value = ( pos >= 0 ) ? line.substring( pos + 1 ) : \"\";\n\t\t\tvalue = value.trim();\n\n\t\t\tif ( key === \"newmtl\" ) {\n\n\t\t\t\t// New material\n\n\t\t\t\tinfo = { name: value, index: materialInfos.length };\n\t\t\t\tmaterialInfos.push(info);\n\n\t\t\t} else if ( info ) {\n\n\t\t\t\tif ( key === \"ka\" || key === \"kd\" || key === \"ks\" ) {\n\n\t\t\t\t\tvar ss = value.split( delimiter_pattern, 3 );\n\t\t\t\t\tinfo[ key ] = [ parseFloat( ss[ 0 ] ), parseFloat( ss[ 1 ] ), parseFloat( ss[ 2 ] ) ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tinfo[ key ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( this.baseUrl, this.materialOptions );\n\t\tmaterialCreator.setCrossOrigin( this.crossOrigin );\n\t\tmaterialCreator.setManager( this.manager );\n\t\tmaterialCreator.setMaterials( materialInfos );\n\t\treturn materialCreator;\n\n\t}\n\n} );\n\n/**\n * Create a new THREE-MTLLoader.MaterialCreator\n * @param baseUrl - Url relative to which textures are loaded\n * @param options - Set of options on how to construct the materials\n *                  side: Which side to apply the material\n *                        THREE.FrontSide (default), THREE.BackSide, THREE.DoubleSide\n *                  wrap: What type of wrapping to apply for textures\n *                        THREE.RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping\n *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255\n *                                Default: false, assumed to be already normalized\n *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's\n *                                  Default: false\n *                  invertTransparency: If transparency need to be inverted (inversion is needed if d = 0 is fully opaque)\n *                                      Default: false (d = 1 is fully opaque)\n *                  useRelativeTexturePath: If true ignores materialBase and resolves texture path relative to MTL file\n * @constructor\n */\n\nTHREE.MTLLoader.MaterialCreator = function( baseUrl, options ) {\n\n\tthis.baseUrl = baseUrl;\n\tthis.options = options;\n\tthis.materialsInfo = {}; // Material Infos keyed by name\n\tthis.materialInfosArray = []; // Array of material infos\n\tthis.materials = {};\n\tthis.materialsArray = [];\n\tthis.nameLookup = {};\n\tthis.defaultMaterialType = options.defaultMaterialType || THREE.MeshPhongMaterial; // AXC: Set default material\n\t//console.log('got defaultMaterialType', this.defaultMaterialType);\n\n\tthis.side = ( this.options && this.options.side ) ? this.options.side : THREE.FrontSide;\n\tthis.wrap = ( this.options && this.options.wrap ) ? this.options.wrap : THREE.RepeatWrapping;\n\n\t// AXC: Allow for different url for textures than baseUrl\n\tthis.textureUrl = baseUrl;\n\tif (options && options.materialBase && !options.useRelativeTexturePath) {\n\t\tthis.textureUrl = options.materialBase;\n\t}\n\tif (this.textureUrl && this.textureUrl.charAt(this.textureUrl.length-1) != '/') {\n\t\tthis.textureUrl = this.textureUrl + \"/\";\n\t}\n};\n\nTHREE.MTLLoader.MaterialCreator.prototype = {\n\n\tconstructor: THREE.MTLLoader.MaterialCreator,\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\tsetManager: function ( value ) {\n\n\t\tthis.manager = value;\n\n\t},\n\n\tsetMaterials: function( materialInfos ) {\n\t\tif (Array.isArray(materialInfos)) {\n      this.materialInfosArray = this.convert(materialInfos);\n      this.materialsInfo = {};\n      this.nameLookup = {};\n      for (var i = 0; i < this.materialInfosArray.length; i++) {\n        var m = this.materialInfosArray[i];\n        this.materialsInfo[m.name] = m;\n        this.nameLookup[m.name] = i;\n      }\n    } else {\n      this.materialInfosArray = [];\n      this.materialsInfo = this.convert(materialInfos);\n      this.nameLookup = {};\n      for (var k in this.materialsInfo) {\n      \tif (this.materialsInfo.hasOwnProperty(k)) {\n          var m = this.materialsInfo[k];\n          this.nameLookup[m.name] = this.materialInfosArray.length;\n          this.materialInfosArray.push(m);\n        }\n      }\n\t\t}\n\t\tthis.materials = {};\n\t\tthis.materialsArray = null;\n\n\t},\n\n\tconvert: function( materialsInfo ) {\n\n\t\tif ( ! this.options ) return materialsInfo;\n\n\t\tvar converted = Array.isArray(materialsInfo)? [] : {};\n\n\t\tvar hasKd = false; // AXC: for defaultColor\n\t\tfor ( var mn in materialsInfo ) {\n\t\t\tif (!materialsInfo.hasOwnProperty(mn)) continue; // skip\n\n\t\t\t// Convert materials info into normalized form based on options\n\n\t\t\tvar mat = materialsInfo[ mn ];\n\n\t\t\tvar covmat = {};\n\n\t\t\tconverted[ mn ] = covmat;\n\n\t\t\tfor ( var prop in mat ) {\n\n\t\t\t\tvar save = true;\n\t\t\t\tvar value = mat[ prop ];\n\t\t\t\tvar lprop = prop.toLowerCase();\n\n\t\t\t\tswitch ( lprop ) {\n\n\t\t\t\t\tcase 'kd':\n\t\t\t\t\t\thasKd = true; // AXC: for defaultColor\n\t\t\t\t\tcase 'ka':\n\t\t\t\t\tcase 'ks':\n\n\t\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\t\tif ( this.options && this.options.normalizeRGB ) {\n\n\t\t\t\t\t\t\tvalue = [ value[ 0 ] / 255, value[ 1 ] / 255, value[ 2 ] / 255 ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( this.options && this.options.ignoreZeroRGBs ) {\n\n\t\t\t\t\t\t\tif ( value[ 0 ] === 0 && value[ 1 ] === 0 && value[ 1 ] === 0 ) {\n\n\t\t\t\t\t\t\t\t// ignore\n\n\t\t\t\t\t\t\t\tsave = false;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'd':\n\n\t\t\t\t\t\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\n\t\t\t\t\t\t//   d is dissolve for current material\n\t\t\t\t\t\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n\n\t\t\t\t\t\tif ( this.options && this.options.invertTransparency ) {\n\n\t\t\t\t\t\t\tvalue = 1 - value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( save ) {\n\n\t\t\t\t\tcovmat[ lprop ] = value;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// AXC: Handle options.defaultColor\n\t\t\t// Set if we haven't set any material/color but saw a kd that was ignored...\n\t\t\t// Needed for wss models that have kd set to 0 but actually has a material...\n\t\t\tif (this.options && this.options.defaultColor ) {\n\t\t\t\tvar hasColorOrMaterial = covmat['map_kd'] || covmat['kd'];\n\t\t\t\tif (!hasColorOrMaterial && hasKd) {\n\t\t\t\t\tcovmat['kd'] = this.options.defaultColor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn converted;\n\n\t},\n\n\tpreload: function () {\n\n\t\tfor ( var mn in this.materialsInfo ) {\n\n\t\t\tthis.create( mn );\n\n\t\t}\n\n\t},\n\n\tgetIndex: function( materialName ) {\n\n\t\treturn this.nameLookup[ materialName ];\n\n\t},\n\n\tgetAsArray: function() {\n\n\t\tif  (!this.materialsArray) {\n\t\t\tvar scope = this;\n\t\t\tthis.materialsArray = this.materialInfosArray.map( function(m) {\n\t\t\t\treturn scope.create(m);\n\t\t\t});\n\t\t}\n\n\t\treturn this.materialsArray;\n\n\t},\n\n\tcreate: function ( materialName ) {\n\n\t\tif ( this.materials[ materialName ] === undefined ) {\n\n\t\t\tthis.createMaterial_( materialName );\n\n\t\t}\n\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\tcreateMaterial_: function ( materialName ) {\n\n\t\t// Create material\n\n\t\tvar mat = this.materialsInfo[ materialName ];\n\t\tvar params = {\n\n\t\t\tname: materialName,\n\t\t\tside: this.side\n\n\t\t};\n\n\t\tfor ( var prop in mat ) {\n\n\t\t\tvar value = mat[ prop ];\n\n\t\t\tswitch ( prop.toLowerCase() ) {\n\n\t\t\t\t// Ns is material specular exponent\n\n\t\t\t\tcase 'kd':\n\n\t\t\t\t\t// Diffuse color (color under white light) using RGB values\n\n\t\t\t\t\tparams[ 'diffuse' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ka':\n\n\t\t\t\t\t// Ambient color (color under shadow) using RGB values\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ks':\n\n\t\t\t\t\t// Specular color (color when light is reflected from shiny surface) using RGB values\n\t\t\t\t\tparams[ 'specular' ] = new THREE.Color().fromArray( value );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_kd':\n\n\t\t\t\t\t// Diffuse texture map\n\t\t\t\t\t// AXC: Allow for different url for textures than baseUrl\n\t\t\t\t\tparams[ 'map' ] = this.loadTexture( this.textureUrl + value );\n\t\t\t\t\tparams[ 'map' ].wrapS = this.wrap;\n\t\t\t\t\tparams[ 'map' ].wrapT = this.wrap;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ns':\n\n\t\t\t\t\t// The specular exponent (defines the focus of the specular highlight)\n\t\t\t\t\t// A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.\n\n\t\t\t\t\tparams[ 'shininess' ] = value;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'd':\n\n\t\t\t\t\t// According to MTL format (http://paulbourke.net/dataformats/mtl/):\n\t\t\t\t\t//   d is dissolve for current material\n\t\t\t\t\t//   factor of 1.0 is fully opaque, a factor of 0 is fully dissolved (completely transparent)\n\n\t\t\t\t\tif ( value < 1 ) {\n\n\t\t\t\t\t\tparams[ 'transparent' ] = true;\n\t\t\t\t\t\tparams[ 'opacity' ] = value;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'map_bump':\n\t\t\t\tcase 'bump':\n\n\t\t\t\t\t// Bump texture map\n\n\t\t\t\t\tif ( params[ 'bumpMap' ] ) break; // Avoid loading twice.\n                                        // AXC: Allow for different url for textures than baseUrl\n\t\t\t\t\tparams[ 'bumpMap' ] = this.loadTexture( this.textureUrl + value );\n\t\t\t\t\tparams[ 'bumpMap' ].wrapS = this.wrap;\n\t\t\t\t\tparams[ 'bumpMap' ].wrapT = this.wrap;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( params[ 'diffuse' ] ) {\n\n\t\t\tparams[ 'color' ] = params[ 'diffuse' ];\n\n\t\t}\n\n\t\tdelete params.ambient;  // AXC: THREE.js now warns about extra params, ambient is no longer supported\n\t\tdelete params.diffuse;  // AXC: THREE.js now warns about extra params, diffuse is mapped to color\n\n\t\tparams = Materials.updateMaterialParams(this.defaultMaterialType, params);\n\t\t// AXC: Use defaultMaterial\n\t\tthis.materials[ materialName ] = new this.defaultMaterialType( params );\n\t\tif (mat) {  // AXC: Add index\n\t\t\tthis.materials[materialName].index = mat.index;\n\t\t}\n\t\treturn this.materials[ materialName ];\n\n\t},\n\n\n\tloadTexture: function ( url, mapping, onLoad, onProgress, onError ) {\n\t\t//console.log('loadTexture',this.options);\n\t\t// AXC: custom loadTexture\n\t\tif (this.options.loadTexture) {\n\t\t\treturn this.options.loadTexture(url,mapping,onLoad,onProgress,onError);\n\t\t}\n\t\treturn Materials.loadTexture({ url: url, mapping: mapping,\n\t\t\tonLoad: onLoad, onProgress: onProgress, onError: onError,\n\t\t\tmanager: this.manager, crossOrigin: this.crossOrigin,\n\t\t\tisDataTexture: this.options.isDataTexture });\n\t}\n\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/MTLLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/MTLLoaderWrapper.js":
/*!********************************************!*\
  !*** ./js/lib/loaders/MTLLoaderWrapper.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BasicLoader = __webpack_require__(/*! loaders/BasicLoader */ \"./js/lib/loaders/BasicLoader.js\");\n__webpack_require__(/*! loaders/MTLLoader */ \"./js/lib/loaders/MTLLoader.js\");\n\n/**\n * MTLLoaderWrapper\n * @constructor\n * @memberof loaders\n */\nvar MTLLoaderWrapper = function (params) {\n  this.fs = params.fs;\n  this.mtlLoader = new THREE.MTLLoader();\n  this.mtlLoader.setCrossOrigin(params.crossOrigin);\n  this.mtlLoader.setMaterialOptions(params);\n};\n\nMTLLoaderWrapper.prototype = Object.create(BasicLoader.prototype);\nMTLLoaderWrapper.prototype.constructor = MTLLoaderWrapper;\n\n/**\n * Parses Wavefront .MTL files\n * @param mtlurl url to mtl file\n * @param callback function(err, parsedMaterialsCreator)\n * @returns {*}\n */\nMTLLoaderWrapper.prototype.load = function (mtlurl, callback) {\n  var scope = this;\n  this.fs.readAsync(mtlurl, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        scope.mtlLoader.setBaseUrl(mtlurl.substr(0, mtlurl.lastIndexOf( \"/\" ) + 1));\n        var materialsCreator = scope.mtlLoader.parse(data);\n        materialsCreator.preload();\n        // console.log(materialsCreator);\n        callback(null, materialsCreator);\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\nmodule.exports = MTLLoaderWrapper;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/MTLLoaderWrapper.js?");

/***/ }),

/***/ "./js/lib/loaders/NRRDLoader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/NRRDLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//var BinaryView = require('util/BinaryView');\nvar zlib = __webpack_require__(/*! pako */ \"../node_modules/pako/index.js\");\nvar Grid = __webpack_require__(/*! geo/Grid */ \"./js/lib/geo/Grid.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * NRRDLoader\n * @constructor\n * @memberof loaders\n */\nvar NRRDLoader = function (params) {\n  this.GridType = params.GridType || Grid;\n};\n\n/**\n * Parses an nrrd file\n * @param filename Name of file (used for debug messages)\n * @param binary {jbinary} jbinary object containing the data of the file\n * @returns {*}\n */\nNRRDLoader.prototype.parse = function (filename, binary) {\n  // here you can use `binary` instance to parse data\n  //console.log(binary);\n  //! Read NRRD file\n  //! NRRD0005\n  //! # STK.NRRDExporter\n  //! type: uint32\n  //! dimension: 3\n  //! sizes: 128 128 128\n  //! encoding: raw\n  //! endian: little\n  //! content: wss.4b3a74dafc46557febd9519cf318fef5_rgba.vox\n  //! space: 3D-right-handed\n  //! space dimension: 3\n  //! space origin: (69.08380126953125,194.42100524902344,0.3859890103340149)\n  //! space directions: (0,0.32062655687332153,0) (0,0,0.32062655687332153) (0.32062655687332153,0,0)\n  //!\n  //! Binary section follows with stored data\n\n  //var voxData = binary.view;\n  return this.__parse(filename, binary.view.buffer);\n};\n\n// Move to NRRD Loader\nNRRDLoader.GridToNRRDTypes = Object.freeze({\n  'int8': [ 'int8', 'int8_t', 'signed char'],\n  'uint8': [ 'uint8', 'uint8_t' ],\n  'uchar': [ 'uchar', 'unsigned char' ],\n  'int16': [ 'int16', 'int16_t', 'short', 'short int', 'signed short', 'signed short int' ],\n  'uint16': [ 'uint16', 'uint16_t', 'ushort', 'unsigned short', 'unsigned short int' ],\n  'int32': [ 'int32', 'int32_t', 'int', 'signed int' ],\n  'uint32': [ 'uint32', 'uint32_t', 'uint', 'unsigned int'],\n  'int64': [ 'int64', 'int64_t', 'longlong', 'long long', 'long long int', 'signed long long', 'signed long long int' ],\n  'uint64': [ 'uint64', 'uint64_t', 'ulonglong', 'unsigned long long', 'unsigned long long int'],\n  'float32': ['float32', 'float32_t', 'float'],\n  'float64': ['float64', 'float64_t', 'double']\n});\n\nNRRDLoader.NRRDToGridDataType = Object.freeze(_.invertMulti(NRRDLoader.GridToNRRDTypes));\n\nNRRDLoader.prototype.load = function ( url, onLoad, onProgress, onError ) {\n  var scope = this;\n  var loader = new THREE.XHRLoader( scope.manager );\n  loader.setResponseType( 'arraybuffer' );\n  loader.load( url, function ( data ) {\n    onLoad( scope.__parse( url, data ) );\n  }, onProgress, onError );\n};\n\n// Parser taken from THREE.js example NRRDLoader\nNRRDLoader.prototype.__parse = function ( filename, data ) {\n  // this parser is largely inspired from the XTK NRRD parser : https://github.com/xtk/X\n  var _data = data;\n  var _dataPointer = 0;\n  var _nativeLittleEndian = new Int8Array( new Int16Array( [ 1 ] ).buffer )[ 0 ] > 0;\n  var _littleEndian = true;\n  var headerObject = {};\n\n  function scan( type, chunks ) {\n    if ( chunks === undefined || chunks === null ) {\n      chunks = 1;\n    }\n\n    var _chunkSize = 1;\n    var _array_type = Uint8Array;\n    switch ( type ) {\n      // 1 byte data types\n      case 'uchar':\n        break;\n      case 'schar':\n        _array_type = Int8Array;\n        break;\n      // 2 byte data types\n      case 'ushort':\n        _array_type = Uint16Array;\n        _chunkSize = 2;\n        break;\n      case 'sshort':\n        _array_type = Int16Array;\n        _chunkSize = 2;\n        break;\n      // 4 byte data types\n      case 'uint':\n        _array_type = Uint32Array;\n        _chunkSize = 4;\n        break;\n      case 'sint':\n        _array_type = Int32Array;\n        _chunkSize = 4;\n        break;\n      case 'float':\n        _array_type = Float32Array;\n        _chunkSize = 4;\n        break;\n      case 'complex':\n        _array_type = Float64Array;\n        _chunkSize = 8;\n        break;\n      case 'double':\n        _array_type = Float64Array;\n        _chunkSize = 8;\n        break;\n\n    }\n\n    // increase the data pointer in-place\n    var _bytes = new _array_type( _data.slice( _dataPointer,\n      _dataPointer += chunks * _chunkSize ) );\n\n    // if required, flip the endianness of the bytes\n    if ( _nativeLittleEndian != _littleEndian ) {\n      // we need to flip here since the format doesn't match the native endianness\n      _bytes = flipEndianness( _bytes, _chunkSize );\n    }\n\n    if ( chunks == 1 ) {\n      // if only one chunk was requested, just return one value\n      return _bytes[ 0 ];\n    }\n\n    // return the byte array\n    return _bytes;\n  }\n\n  //Flips typed array endianness in-place. Based on https://github.com/kig/DataStream.js/blob/master/DataStream.js.\n  function flipEndianness( array, chunkSize ) {\n    var u8 = new Uint8Array( array.buffer, array.byteOffset, array.byteLength );\n    for ( var i = 0; i < array.byteLength; i += chunkSize ) {\n      for ( var j = i + chunkSize - 1, k = i; j > k; j --, k ++ ) {\n        var tmp = u8[ k ];\n        u8[ k ] = u8[ j ];\n        u8[ j ] = tmp;\n      }\n    }\n    return array;\n  }\n\n  //parse the header\n  function parseHeader( header ) {\n    var data, field, fn, i, l, lines, m, _i, _len;\n    lines = header.split( /\\r?\\n/ );\n    for ( _i = 0, _len = lines.length; _i < _len; _i ++ ) {\n      l = lines[ _i ];\n      if ( l.match( /NRRD\\d+/ ) ) {\n        headerObject.isNrrd = true;\n      } else if ( l.match( /^#/ ) ) {\n      } else if ( m = l.match( /(.*):(.*)/ ) ) {\n        field = m[1].trim();\n        data = m[2].trim();\n        fn = __parseFieldFunctions[ field ];\n        if ( fn ) {\n          fn.call( headerObject, data );\n        } else {\n          headerObject[ field ] = data;\n        }\n      }\n    }\n    if (!headerObject.isNrrd) {\n      throw new Error( 'Not an NRRD file' );\n    }\n    if ( headerObject.encoding === 'bz2' || headerObject.encoding === 'bzip2' ) {\n      throw new Error( 'Bzip is not supported' );\n    }\n    if (!headerObject.space_directions) {\n      //if no space direction is set, let's use the identity for the last three dimensions\n      headerObject.space_directions = headerObject.sizes.map(function() { return null; });\n      var start = headerObject.sizes.length - 3;\n      headerObject.space_directions[start] = [1,0,0];\n      headerObject.space_directions[start+1] = [0,1,0];\n      headerObject.space_directions[start+2] = [0,0,1];\n    }\n    headerObject.space_dimensions = headerObject.sizes.filter(function(x, i) {\n      return headerObject.space_directions[i];\n    });\n    headerObject.space_vectors = headerObject.space_directions.filter(function(x) {\n      return x;\n    });\n    // //apply spacing if defined\n    // if (headerObject.spacings) {\n    //   for ( i = 0; i <= 2; i ++ ) {\n    //     if (!isNaN(headerObject.spacings[i])) {\n    //       headerObject.vectors[ i ].multiplyScalar( headerObject.spacings[ i ] );\n    //     }\n    //   }\n    // }\n\n  }\n\n  //parse the data when registered as one of this type : 'text', 'ascii', 'txt'\n  function parseDataAsText( data, start, end ) {\n    var number = '';\n    start = start || 0;\n    end = end || data.length;\n    var value;\n    //length of the result is the product of the sizes\n    var lengthOfTheResult = headerObject.sizes.reduce( function ( previous, current ) {\n      return previous * current;\n    }, 1 );\n\n    var base = 10;\n    if ( headerObject.encoding === 'hex' ) {\n      base = 16;\n    }\n\n    var result = new headerObject.__array( lengthOfTheResult );\n    var resultIndex = 0;\n    var parsingFunction = parseInt;\n    if (headerObject.__array === Float32Array || headerObject.__array === Float64Array) {\n      parsingFunction = parseFloat;\n    }\n    for (var i = start; i < end; i++) {\n      value = data[ i ];\n      //if value is not a space\n      if ((value < 9 || value > 13) && value !== 32) {\n        number += String.fromCharCode( value );\n      } else {\n        if (number !== '') {\n          result[ resultIndex ] = parsingFunction( number, base );\n          resultIndex ++;\n        }\n        number = '';\n      }\n    }\n    if (number !== '') {\n      result[ resultIndex ] = parsingFunction( number, base );\n      resultIndex ++;\n    }\n    return result;\n  }\n\n  var _bytes = scan( 'uchar', data.byteLength );\n  var _length = _bytes.length;\n  var _header = null;\n  var _data_start = 0;\n  for (var i = 1; i < _length; i++ ) {\n    // TODO: Handle \\r\\n\n    if ( _bytes[i - 1] === 10 && _bytes[i] === 10) {\n      // we found two line breaks in a row\n      // now we know what the header is\n      _header = __parseChars(_bytes, 0, i - 1);\n      // this is where the data starts\n      _data_start = i + 1;\n      break;\n    }\n  }\n  // parse the header\n  parseHeader( _header );\n\n  var _data = _bytes.subarray(_data_start); // the data without header\n  if ( headerObject.encoding === 'gzip' || headerObject.encoding === 'gz' ) {\n    // we need to decompress the datastream\n    // here we start the unzipping and get a typed Uint8Array back\n    //var inflate = new Zlib.Gunzip( new Uint8Array( _data ) );\n    //_data = inflate.decompress();\n    _data = zlib.ungzip(new Uint8Array(_data));\n  } else if ( headerObject.encoding === 'ascii' || headerObject.encoding === 'text' || headerObject.encoding === 'txt' || headerObject.encoding === 'hex' ) {\n    _data = parseDataAsText( _data );\n  } else if ( headerObject.encoding === 'raw' ) {\n    //we need to copy the array to create a new array buffer, else we retrieve the original arraybuffer with the header\n    var _copy = new Uint8Array( _data.length );\n    for (var i = 0; i < _data.length; i++) {\n      _copy[i] = _data[i];\n    }\n    _data = _copy;\n  }\n  // .. let's use the underlying array buffer\n  _data = _data.buffer;\n\n  var volume = new this.GridType({ dataType: headerObject.dataType });\n  volume.init({ orderedDims: headerObject.space_dimensions, data: _data });\n  volume.header = headerObject;\n\n  // spacing\n  // var spacingX = ( new THREE.Vector3( headerObject.vectors[ 0 ][ 0 ], headerObject.vectors[ 0 ][ 1 ],\n  //   headerObject.vectors[ 0 ][ 2 ] ) ).length();\n  // var spacingY = ( new THREE.Vector3( headerObject.vectors[ 1 ][ 0 ], headerObject.vectors[ 1 ][ 1 ],\n  //   headerObject.vectors[ 1 ][ 2 ] ) ).length();\n  // var spacingZ = ( new THREE.Vector3( headerObject.vectors[ 2 ][ 0 ], headerObject.vectors[ 2 ][ 1 ],\n  //   headerObject.vectors[ 2 ][ 2 ] ) ).length();\n  // volume.spacing = [ spacingX, spacingY, spacingZ ];\n\n  // Create gridToWorld (IJKtoRAS) matrix\n  var _spaceX = 1;\n  var _spaceY = 1;\n  var _spaceZ = 1;\n\n  if ( headerObject.space == \"left-posterior-superior\" ) {\n    _spaceX = - 1;\n    _spaceY = - 1;\n  } else if ( headerObject.space === 'left-anterior-superior' ) {\n    _spaceX = - 1;\n  }\n\n  var origin = headerObject.space_origin;\n  if ( ! origin ) {\n    origin = [ 0, 0, 0 ];\n  }\n  if ( ! headerObject.space_vectors ) {\n    volume.gridToWorld.set(\n      _spaceX, 0, 0, origin[0],\n      0, _spaceY, 0, origin[1],\n      0, 0, _spaceZ, origin[2],\n      0, 0, 0, 1 );\n  } else {\n    var v = headerObject.space_vectors;\n    // NOTE: Weird ordering of z, x, y\n    volume.gridToWorld.set(\n      _spaceX * v[ 2 ][ 0 ], _spaceX * v[ 0 ][ 0 ], _spaceX * v[ 1 ][ 0 ], origin[0],\n      _spaceY * v[ 2 ][ 1 ], _spaceY * v[ 0 ][ 1 ], _spaceY * v[ 1 ][ 1 ], origin[1],\n      _spaceZ * v[ 2 ][ 2 ], _spaceZ * v[ 0 ][ 2 ], _spaceZ * v[ 1 ][ 2 ], origin[2],\n      0, 0, 0, 1 );\n  }\n\n  volume.worldToGrid = new THREE.Matrix4();\n  volume.worldToGrid.getInverse( volume.gridToWorld );\n  //volume.RASDimensions = ( new THREE.Vector3( volume.xLength, volume.yLength, volume.zLength ) ).applyMatrix4( volume.matrix ).round().toArray().map( Math.abs );\n  return volume;\n};\n\nfunction __parseChars ( array, start, end ) {\n  // without borders, use the whole array\n  if ( start === undefined ) {\n    start = 0;\n  }\n  if ( end === undefined ) {\n    end = array.length;\n  }\n\n  var output = '';\n  // create and append the chars\n  for (var i = start; i < end; ++ i ) {\n    output += String.fromCharCode( array[ i ] );\n  }\n  return output;\n}\n\nvar __parseFieldFunctions = {\n  type: function ( data ) {\n    this.dataType = NRRDLoader.NRRDToGridDataType[data];\n    if (!this.dataType) {\n        throw new Error( 'Unsupported NRRD data type: ' + data );\n    }\n    this.__array = Grid.Types[this.dataType].array;\n    if (!this.__array) {\n      throw new Error( 'Unsupported grid data type: ' + this.dataType );\n    }\n    return this.type = data;\n  },\n\n  endian: function ( data ) {\n    return this.endian = data;\n  },\n\n  encoding: function ( data ) {\n    return this.encoding = data;\n  },\n\n  dimension: function ( data ) {\n    return this.dim = parseInt( data, 10 );\n  },\n\n  sizes: function ( data ) {\n    var parsed = data.split(/\\s+/).map(function(x) { return parseInt(x, 10); });\n    return this.sizes = parsed;\n  },\n\n  space: function ( data ) {\n    return this.space = data;\n  },\n\n  'space origin': function ( data ) {\n    return this.space_origin = data.split('(')[ 1 ].split(')')[ 0 ].split(',');\n  },\n\n  'space directions': function ( data ) {\n    var parts = data.match( /\\(.*?\\)|none/g );\n    var parsed = parts.map(function(v) {\n      if (v === 'none') {\n        return null;\n      } else {\n        return v.slice(1, -1).split(/,/).map(function (x) {\n          return parseFloat(x);\n        });\n      }\n    });\n    return this.space_directions = parsed;\n  },\n\n  spacings: function ( data ) {\n    var parsed = data.split(/\\s+/).map(function(x) { return parseFloat(x); });\n    return this.spacings = parsed;\n  }\n};\n\nmodule.exports = NRRDLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/NRRDLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/NavMeshLoader.js":
/*!*****************************************!*\
  !*** ./js/lib/loaders/NavMeshLoader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// Loads NavMeshSet from https://github.com/recastnavigation/recastnavigation\nvar FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\nvar jBinary = __webpack_require__(/*! jbinary */ \"./js/vendor/jbinary/jbinary.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction Mask(nbits, shift) {\n  this.nbits = nbits;\n  this.shift = shift || 0;\n  this.mask = (1 << this.nbits) -1;\n}\n\nMask.prototype.decode = function(v) {\n  if (this.shift) {\n    return (v >>> this.shift) & this.mask;\n  } else {\n    return v & this.mask;\n  }\n};\n\nfunction NavMesh(opts) {\n  _.extend(this, opts);\n  var nTileBits = Math.log2(THREE.Math.nextPowerOfTwo(this.maxTiles));\n  var nPolyBits = Math.log2(THREE.Math.nextPowerOfTwo(this.maxPolys));\n  // Only allow 31 salt bits, since the salt mask is calculated using 32bit uint and it will overflow.\n  var nSaltBits = Math.min(31, 32 - nTileBits - nPolyBits);\n\n  this.saltMask = new Mask(nSaltBits, nTileBits + nPolyBits);\n  this.tileMask = new Mask(nTileBits, nPolyBits);\n  this.polyMask = new Mask(nPolyBits, 0);\n\n  //var scope = this;\n  this.tiles = _.map(this.tiles, function(t) {\n    //t.index = scope.tileMask.decode(t.tileRef);\n    //t.salt = scope.saltMask.decode(t.tileRef);\n    return new MeshTile(t);\n  });\n  this.tilesByPosition = _.groupBy(this.tiles, function(t) {\n    return t.x + '-' + t.y;\n  });\n}\n\nNavMesh.prototype.getTileAt = function(x,y,layer) {\n  var tiles = this.tilesByPosition[x + '-' + y];\n  if (tiles) {\n    // filter to tile with layer\n    return _.find(tiles, function(t) { return t.layer === layer; });\n  }\n};\n\nNavMesh.prototype.getTilesAt = function(x,y) {\n  var tiles = this.tilesByPosition[x + '-' + y];\n  return tiles;\n};\n\nfunction MeshTile(opts) {\n  _.extend(this, opts);\n}\n\nfunction NavMeshLoader() {\n\n}\n\nNavMeshLoader.prototype.load = function (path, callback) {\n  var loader = new FileLoader();\n  var scope = this;\n  loader.load(path, 'arraybuffer', function(data) {\n    scope.parse(path.name || path, data, callback);\n  }, null, function(err) {\n    callback(err);\n  });\n};\n\n// NavMeshFile format\n// navmeshset header:\n//   int32_t magic;     // MSET (will indicate endianness)\n//   int32_t version;   // 1\n//   int32_t numTiles;  // number of tiles\n// navmesh params:\n//   float orig[3];\t\t\t// The world space origin of the navigation mesh's tile space. [(x, y, z)]\n//   float tileWidth;\t  // The width of each tile. (Along the x-axis.)\n//   float tileHeight;\t// The height of each tile. (Along the z-axis.)\n//   int32_t maxTiles;\t// The maximum number of tiles the navigation mesh can contain.\n//   int32_t maxPolys;\t// The maximum number of polygons each tile can contain.\n// array of navmesh tiles (numTiles), each consisting of a navmesh tile\n//\n// navmesh tile:\n// navmeshtile header:\n//   dtTileRef tileRef;  // reference to tile\n//   int32_t  dataSize;  // number of bytes that follow that belongs to this tile\n// navmeshtile data starts with\n// dtMeshHeader\n//   int32_t magic;\t\t\t\t// Tile magic number. (Used to identify the data format.)\n//   int32_t version;\t\t\t// Tile data format version number.\n//   int32_t x;\t\t\t\t\t  // The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n//   int32_t y;\t\t\t\t\t  // The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n//   int32_t layer;\t\t\t\t// The layer of the tile within the dtNavMesh tile grid. (x, y, layer)\n//   uint32_t userId;\t    // The user defined id of the tile.\n//   int32_t polyCount;\t\t// The number of polygons in the tile.\n//   int32_t vertCount;\t\t// The number of vertices in the tile.\n//   int32_t maxLinkCount;\t\t// The number of allocated links.\n//   int32_t detailMeshCount;\t// The number of sub-meshes in the detail mesh.\n//   int32_t detailVertCount; // The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)\n//   int32_t detailTriCount;\t// The number of triangles in the detail mesh.\n//   int32_t bvNodeCount;\t\t\t// The number of bounding volume nodes. (Zero if bounding volumes are disabled.)\n//   int32_t offMeshConCount;\t// The number of off-mesh connections.\n//   int32_t offMeshBase;\t\t\t// The index of the first polygon which is an off-mesh connection.\n//   float walkableHeight;\t\t// The height of the agents using the tile.\n//   float walkableRadius;\t\t// The radius of the agents using the tile.\n//   float walkableClimb;\t\t  // The maximum climb height of the agents using the tile.\n//   float bmin[3];\t\t\t\t    // The minimum bounds of the tile's AABB. [(x, y, z)]\n//   float bmax[3];\t\t\t\t    // The maximum bounds of the tile's AABB. [(x, y, z)]\n//   float bvQuantFactor;     // The bounding volume quantization factor.\n// followed by (after 4 byte alignments):\n//   float  verts[3*vertCount]   // The tile vertex positions\n//   dtPoly polys[polyCount]     // The tile polygons\n//   dtLink links[maxLinkCount]  // The tile links\n//   dtPolyDetail detailMeshes[detailMeshCount]  // The tile detail submeshes\n//   float  detailVerts[3*detailVertCount]       // The detail mesh's unique vertex positions (x,y,z)\n//   uint8_t detailTris[4*detailTriCount]        // The detail mesh's triangle indices (vertA, vertB, vertC)\n//   dtBVHNode bvTree[bvNodeCount]               // The tile bounding volume nodes\n//   dtOffMeshConnection offMeshCons[offMeshConCount] // The tile off-mesh connections\n// dtPoly (32 bytes with DT_VERTS_PER_POLYGON = 6)\n//   uint32_t firstLink;                        // Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)\n//   uint16_t verts[DT_VERTS_PER_POLYGON];      // The indices of the polygon's vertices (actual vertex positions in tile verts).\n//   uint16_t neighbors[DT_VERTS_PER_POLYGON];  // Packed data representing neighbor polygons references and flags for each edge.\n//   uint16_t flags;                            // The user defined polygon flags.\n//   uint8_t  vertCount;                        // The number of vertices in the polygon.\n//   uint8_t  areaAndType;                      // The bit packed area id and polygon type.\n// dtLink (12 bytes with uint32_t dtPolyRef)\n//   dtPolyRef ref;\t\t\t\t// Neighbour reference. (The neighbor that is linked to)\n//   uint32_t next;\t\t\t\t// Index of the next link.\n//   uint8_t edge;\t\t\t\t// Index of the polygon edge that owns this link.\n//   uint8_t side;\t\t\t\t// If a boundary link, defines on which side the link is.\n//   uint8_t bmin;\t\t\t\t// If a boundary link, defines the minimum sub-edge area.\n//   uint8_t bmax;\t\t\t\t// If a boundary link, defines the maximum sub-edge area.\n// dtPolyDetail (10 bytes, 12 aligned)\n//   uint32_t vertBase;\t\t\t// The offset of the vertices in the dtMeshTile::detailVerts array.\n//   uint32_t triBase;\t\t\t// The offset of the triangles in the dtMeshTile::detailTris array.\n//   uint8_t  vertCount;\t\t// The number of vertices in the sub-mesh.\n//   uint8_t  triCount;\t\t\t// The number of triangles in the sub-mesh.\n// dtBVHNode (16 bytes)\n//   uint16_t bmin[3];\t\t\t// Minimum bounds of the node's AABB. [(x, y, z)]\n//   uint16_t bmax[3];\t\t\t// Maximum bounds of the node's AABB. [(x, y, z)]\n//   uint32_t i;\t\t\t\t\t\t// The node's index. (Negative for escape sequence.)\n// dtOffMeshConnection (36 bytes)\n//   float    pos[6];       // The endpoints of the connection. [(ax, ay, az, bx, by, bz)]\n//   float    rad;          // The radius of the endpoints. [Limit: >= 0]\n//   uint16_t poly;         // The polygon reference of the connection within the tile.\n//   uint8_t  flags;        // Link flags (internal)\n//   uint8_t  side;         // End point side.\n//   uint32_t userId;       // The id of the offmesh connection. (User assigned when the navigation mesh is built.)\n// NOTE: dtTileRef and dtPolyRef are either uint32_t (default) or uint64_t depending on the recast binary\n\n// NavMesh Header constants\nvar __NMS_MAGIC_STRING = 'MSET';\nvar __NMS_MAGIC_BE = _.toCharCodes(__NMS_MAGIC_STRING);\nvar __NMS_MAGIC_LE = _.clone(__NMS_MAGIC_BE).reverse();\nvar __NMS_VERSION = 1;\n\n// NavMesh constants\nvar __NM_MAGIC_STRING = 'DNAV';\nvar __NM_MAGIC = _.strToInt32(__NM_MAGIC_STRING);\nvar __NM_VERSION = 7;\n\n// Tile constants\nvar __DT_VERTS_PER_POLYGON = 6;\n\nvar __NMS_BINARY_DEF = {\n  'jBinary.all': 'NavMeshSet',\n  'jBinary.littleEndian': true,\n\n  Vector3f: ['array', 'float32', 3],\n  // dtPoly (32 bytes with DT_VERTS_PER_POLYGON = 6)\n  Poly: {\n    firstLink: 'uint32',                                     // Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)\n    verts: ['array', 'uint16', __DT_VERTS_PER_POLYGON],      // The indices of the polygon's vertices (actual vertex positions in tile verts).\n    neighbors: ['array', 'uint16', __DT_VERTS_PER_POLYGON],  // Packed data representing neighbor polygons references and flags for each edge.\n    flags:  'uint16',                                        // The user defined polygon flags.\n    vertCount: 'uint8',                                      // The number of vertices in the polygon.\n    areaAndType: 'uint8'                                     // The bit packed area id and polygon type.\n  },\n  // dtLink (12 bytes with uint32_t dtPolyRef)\n  Link: {\n    ref:  'uint32',   \t\t\t// Neighbour reference (dtPolyRef) giving the neighbor that is linked to.\n    next: 'uint32',   \t\t\t// Index of the next link.\n    edge: 'uint8',    \t\t\t// Index of the polygon edge that owns this link.\n    side: 'uint8',    \t\t\t// If a boundary link, defines on which side the link is.\n    bmin: 'uint8',    \t\t\t// If a boundary link, defines the minimum sub-edge area.\n    bmax: 'uint8'     \t\t\t// If a boundary link, defines the maximum sub-edge area.\n  },\n  // dtPolyDetail (10 bytes, 12 aligned)\n  PolyDetail: {\n    vertBase: 'uint32',\t\t\t// The offset of the vertices in the dtMeshTile::detailVerts array.\n    triBase: 'uint32',\t\t\t// The offset of the triangles in the dtMeshTile::detailTris array.\n    vertCount: 'uint8',\t\t  // The number of vertices in the sub-mesh.\n    triCount: 'uint8',\t\t\t  // The number of triangles in the sub-mesh.\n    pad1: 'uint8',\n    pad2: 'uint8'\n  },\n  // dtBVHNode (16 bytes)\n  BVHNode: {\n    bmin: ['array', 'uint16', 3],\t\t\t// Minimum bounds of the node's AABB. [(x, y, z)]\n    bmax: ['array', 'uint16', 3],\t\t\t// Maximum bounds of the node's AABB. [(x, y, z)]\n    index: 'uint32'\t\t\t\t\t\t// The node's index. (Negative for escape sequence.)\n  },\n  // dtOffMeshConnection (36 bytes)\n  OffMeshConnection: {\n    position: ['array', 'Vector3f', 2],    // The endpoints of the connection. [(ax, ay, az, bx, by, bz)]\n    rad: 'float32',                        // The radius of the endpoints. [Limit: >= 0]\n    poly: 'uint16',                        // The polygon reference of the connection within the tile.\n    flags: 'uint8',                        // Link flags (internal)\n    side: 'uint8',                         // End point side.\n    userId: 'uint32'                       // The id of the offmesh connection. (User assigned when the navigation mesh is built.)\n  },\n  NavMeshTile: {\n    tileRef:  'int32',         // reference to tile (dtTileRef)\n    dataSize: 'int32',         // number of bytes that follow that belongs to this tile\n    // NavMeshTile header\n    magic: 'int32',            // Tile magic number. (Used to identify the data format.)\n    version: 'int32',          // Tile data format version number.\n    x: 'int32',                // The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n    y: 'int32',                // The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)\n    layer: 'int32',            // The layer of the tile within the dtNavMesh tile grid. (x, y, layer)\n    userId: 'uint32',          // The user defined id of the tile.\n    polyCount: 'int32',        // The number of polygons in the tile.\n    vertCount: 'int32',        // The number of vertices in the tile.\n    maxLinkCount: 'int32',     // The number of allocated links.\n    detailMeshCount: 'int32',  // The number of sub-meshes in the detail mesh.\n    detailVertCount: 'int32',  // The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)\n    detailTriCount: 'int32',   // The number of triangles in the detail mesh.\n    bvNodeCount: 'int32',      // The number of bounding volume nodes. (Zero if bounding volumes are disabled.)\n    offMeshConCount: 'int32',  // The number of off-mesh connections.\n    offMeshBase: 'int32',      // The index of the first polygon which is an off-mesh connection.\n    walkableHeight: 'float32', // The height of the agents using the tile.\n    walkableRadius: 'float32', // The radius of the agents using the tile.\n    walkableClimb: 'float32',  // The maximum climb height of the agents using the tile.\n    bmin: 'Vector3f',          // The minimum bounds of the tile's AABB. [(x, y, z)]\n    bmax: 'Vector3f',          // The maximum bounds of the tile's AABB. [(x, y, z)]\n    bvQuatFactor: 'float32',   // The bounding volume quantization factor.\n    // Variable length data (each are 4 byte aligned)\n    verts: ['array', 'Vector3f', 'vertCount'],   // The tile vertex positions\n    polys: ['array', 'Poly', 'polyCount'],       // The tile polygons\n    links: ['array', 'Link', 'maxLinkCount'],    // The tile links\n    detailMeshes: ['array',  'PolyDetail', 'detailMeshCount'],  // The tile detail submeshes\n    detailVerts: ['array', 'Vector3f', 'detailVertCount'],      // The detail mesh's unique vertex positions (x,y,z)\n    detailTris: ['array', 'uint8', function(context)            // The detail mesh's triangle indices (vertA, vertB, vertC)\n      { return context.detailTriCount * 4; }],\n    btTree: ['array', 'BVHNode', 'bvNodeCount'],                // The tile bounding volume nodes\n    offMeshConnections: ['array', 'OffMeshConnection', 'offMeshConCount']  // The tile off-mesh connections\n  },\n  NavMeshSet: {\n    // NavMeshSet header\n    magic: 'int32',            // NavMeshSet magic number  (MSET encoded as integer, can be used to determine endianness)\n    version: 'int32',          // NavMeshSet version (1)\n    numTiles: 'int32',         // number of tiles\n    // NavMeshParams\n    origin: 'Vector3f',        // The world space origin of the navigation mesh's tile space. [(x, y, z)]\n    tileWidth: 'float32',      // The width of each tile. (Along the x-axis.)\n    tileHeight: 'float32',     // The height of each tile. (Along the z-axis.)\n    maxTiles: 'int32',         // The maximum number of tiles the navigation mesh can contain.\n    maxPolys: 'int32',         // The maximum number of polygons each tile can contain.\n    tiles: ['array', 'NavMeshTile', 'numTiles']  // Array of tiles follows\n  }\n};\n\nNavMeshLoader.prototype.parse = function (filename, data, callback) {\n  // Parse navmeshset file\n  // Check endianness\n  var magic = Array.from(new Uint8Array(data, 0, 4));\n  var littleEndian;\n  if (_.isEqual(magic, __NMS_MAGIC_BE)) {\n    littleEndian = false;\n  } else if (_.isEqual(magic, __NMS_MAGIC_LE)) {\n    littleEndian = true;\n  } else {\n    callback('Invalid NavMesh file', null);\n    return;\n  }\n  // Okay, we know our endianness.  Let's parse!\n  __NMS_BINARY_DEF['jbinary.littleEndian'] = littleEndian;\n  var binary = new jBinary(data, __NMS_BINARY_DEF);\n  var parsed = binary.read('NavMeshSet');\n  // Check the navMeshSet\n  if (parsed.version !== __NMS_VERSION) {\n    callback('Unsupported NavMeshSet version: ' + parsed.version, null);\n    return;\n  }\n  var navMesh = new NavMesh(parsed);\n  console.log('navMeshSet', navMesh);\n  callback(null, navMesh);\n};\n\nmodule.exports = NavMeshLoader;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/NavMeshLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/OBJLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/OBJLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Modified version of THREE.OBJLoader from three.js\n * @author mrdoob / http://mrdoob.com/\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\nTHREE.OBJLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n\tthis.materials = null;\n\n\tthis.regexp = {\n\t\t// v float float float\n\t\tvertex_pattern           : /^v\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// v float float float float float float\n\t\tvertex_color_pattern     : /^v( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)( +[\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// vn float float float\n\t\tnormal_pattern           : /^vn\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// vt float float\n\t\tuv_pattern               : /^vt\\s+([\\d|\\.|\\+|\\-|e|E]+)\\s+([\\d|\\.|\\+|\\-|e|E]+)/,\n\t\t// f vertex vertex vertex\n\t\tface_vertex              : /^f\\s+(-?\\d+)\\s+(-?\\d+)\\s+(-?\\d+)(?:\\s+(-?\\d+))?/,\n\t\t// f vertex/uv vertex/uv vertex/uv\n\t\tface_vertex_uv           : /^f\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+))?/,\n\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t\tface_vertex_uv_normal    : /^f\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+)(?:\\s+(-?\\d+)\\/(-?\\d+)\\/(-?\\d+))?/,\n\t\t// f vertex//normal vertex//normal vertex//normal\n\t\tface_vertex_normal       : /^f\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)\\s+(-?\\d+)\\/\\/(-?\\d+)(?:\\s+(-?\\d+)\\/\\/(-?\\d+))?/,\n\t\t// o object_name | g group_name\n\t\tobject_pattern           : /^[og]\\s*(.+)?/,\n\t\t// s boolean\n\t\tsmoothing_pattern        : /^s\\s+(\\d+|on|off)/,\n\t\t// mtllib file_reference\n\t\tmaterial_library_pattern : /^mtllib /,\n\t\t// usemtl material_name\n\t\tmaterial_use_pattern     : /^usemtl /\n\t};\n\n};\n\nTHREE.OBJLoader.prototype = {\n\n\tconstructor: THREE.OBJLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\t\tif (this.mtlOptions) {\n\t\t\tthis._loadWithMtl(url, this.mtlOptions, onLoad, onProgress, onError);\n\t\t} else {\n\t\t\tthis._loadSimple(url, onLoad, onProgress, onError);\n\t\t}\n\t},\n\n\t// AXC: Custom file loader\n\tgetFileLoader: function() {\n\t\treturn new THREE.FileLoader(this.manager);\n\t},\n\t/**\n\t * Load a Wavefront OBJ file with materials (MTL file)\n\t *\n\t * If the MTL file cannot be loaded, then a MeshLambertMaterial is used as a default\n\t * @param url - Location of OBJ file to load\n\t * @param mtlurl - MTL file to load (optional, if not specified, attempts to use MTL specified in OBJ file)\n\t * @param options - Options on how to interpret the material (see THREE.MTLLoader.MaterialCreator )\n\t */\n\t_loadWithMtl: function ( url, options, onLoad, onProgress, onError ) {\n\t\tvar scope = this;\n\n\t\t// AXC: Custom file loader\n\t\tvar mtlurl = options.mtl;\n\t\tvar mtlLoader = options.mtlLoader || new THREE.MTLLoader( this.manager );\n\t\tif (typeof url === 'string') {\n\t\t\tmtlLoader.setBaseUrl( url.substr( 0, url.lastIndexOf( \"/\" ) + 1 ) );\n\t\t}\n\t\tmtlLoader.setCrossOrigin( this.crossOrigin );\n\t\t// AXC: Set material options\n\t\tmtlLoader.setMaterialOptions( options );\n\n\t\tvar loader = this.getFileLoader();\n\t\t//loader.setCrossOrigin(scope.crossOrigin);\n\t\tloader.load(url, function (text) {\n\t\t\t// Look for mtllib\n\t\t\tif (!mtlurl) {\n\t\t\t\tvar mtllibIndex = text.indexOf('mtllib');\n\t\t\t\tif (mtllibIndex >= 0) {\n\t\t\t\t\tvar mltlibLineEndIndex = text.indexOf('\\n', mtllibIndex);\n\t\t\t\t\tmtlurl = mtlLoader.baseUrl + text.substring(mtllibIndex + 6, mltlibLineEndIndex).trim();\n\t\t\t\t\tconsole.log('mtlurl is ' + mtlurl);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar object;\n\t\t\tif (mtlurl) {\n\t\t\t\t// Load mtl and then parse\n\t\t\t\tmtlLoader.load(mtlurl, function (materialsCreator) {\n\t\t\t\t\tmaterialsCreator.preload();\n\t\t\t\t\tscope.setMaterials(materialsCreator);\n\t\t\t\t\tobject = scope.parse(text);\n\t\t\t\t\tonLoad(object);\n\t\t\t\t}, onProgress, onError);\n\t\t\t} else {\n\t\t\t\tobject = scope.parse(text);\n\t\t\t\tonLoad(object);\n\t\t\t}\n\t\t}, onProgress, onError);\n\t},\n\n\t_loadSimple: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = this.getFileLoader();\n\t\tloader.setPath( this.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPath: function ( value ) {\n\n\t\tthis.path = value;\n\n\t},\n\n\tsetMaterials: function ( materials ) {\n\n\t\tthis.materials = materials;\n\n\t},\n\n\t// AXC: loader options\n\tsetOptions: function(options) {\n\t\tthis.options = options;\n\t},\n\n\tsetMtlOptions: function (mtlOptions) {\n\t\tthis.mtlOptions = mtlOptions;\n\t},\n\n\t_createParserState : function () {\n\n\t\tvar options = this.options;\n\t\tvar state = {\n\t\t\tobjects  : [],\n\t\t\tobject   : {},\n\n\t\t\tvertices : [],\n\t\t\tnormals  : [],\n\t\t\tcolors  : [],\n\t\t\tuvs      : [],\n\n\t\t\tmaterialLibraries : [],\n\n\t\t\tstartObject: function ( name, fromDeclaration ) {\n\n\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\tif ( this.object && this.object.fromDeclaration === false ) {\n\n\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\tthis.object.fromDeclaration = ( fromDeclaration !== false );\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\tvar previousMaterial = ( this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined );\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t\tthis.object = {\n\t\t\t\t\tname : name || '',\n\t\t\t\t\tfromDeclaration : ( fromDeclaration !== false ),\n\n\t\t\t\t\tgeometry : {\n\t\t\t\t\t\tvertices : [],\n\t\t\t\t\t\tnormals  : [],\n\t\t\t\t\t\tcolors   : [],\n\t\t\t\t\t\tuvs      : [],\n\t\t\t\t\t\torigVertIndices : []\n\t\t\t\t\t},\n\t\t\t\t\tmaterials : [],\n\t\t\t\t\tsmooth : true,\n\n\t\t\t\t\tstartMaterial : function( name, libraries ) {\n\n\t\t\t\t\t\tvar previous = this._finalize( false );\n\n\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\tif ( previous && ( previous.inherited || previous.groupCount <= 0 ) ) {\n\n\t\t\t\t\t\t\tthis.materials.splice( previous.index, 1 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\tindex      : this.materials.length,\n\t\t\t\t\t\t\tname       : name || '',\n\t\t\t\t\t\t\tmtllib     : ( Array.isArray( libraries ) && libraries.length > 0 ? libraries[ libraries.length - 1 ] : '' ),\n\t\t\t\t\t\t\tsmooth     : ( previous !== undefined ? previous.smooth : this.smooth ),\n\t\t\t\t\t\t\tgroupStart : ( previous !== undefined ? previous.groupEnd : 0 ),\n\t\t\t\t\t\t\tgroupEnd   : -1,\n\t\t\t\t\t\t\tgroupCount : -1,\n\t\t\t\t\t\t\tinherited  : false,\n\n\t\t\t\t\t\t\tclone : function( index ) {\n\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\tindex      : ( typeof index === 'number' ? index : this.index ),\n\t\t\t\t\t\t\t\t\tname       : this.name,\n\t\t\t\t\t\t\t\t\tmtllib     : this.mtllib,\n\t\t\t\t\t\t\t\t\tsmooth     : this.smooth,\n\t\t\t\t\t\t\t\t\tgroupStart : 0,\n\t\t\t\t\t\t\t\t\tgroupEnd   : -1,\n\t\t\t\t\t\t\t\t\tgroupCount : -1,\n\t\t\t\t\t\t\t\t\tinherited  : false\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tthis.materials.push( material );\n\n\t\t\t\t\t\treturn material;\n\n\t\t\t\t\t},\n\n\t\t\t\t\tcurrentMaterial : function() {\n\n\t\t\t\t\t\tif ( this.materials.length > 0 ) {\n\t\t\t\t\t\t\treturn this.materials[ this.materials.length - 1 ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn undefined;\n\n\t\t\t\t\t},\n\n\t\t\t\t\t_finalize : function( end ) {\n\n\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\tif ( lastMultiMaterial && lastMultiMaterial.groupEnd === -1 ) {\n\n\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\tif ( end && this.materials.length > 1 ) {\n\n\t\t\t\t\t\t\tfor ( var mi = this.materials.length - 1; mi >= 0; mi-- ) {\n\t\t\t\t\t\t\t\tif ( this.materials[mi].groupCount <= 0 ) {\n\t\t\t\t\t\t\t\t\tthis.materials.splice( mi, 1 );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\tif ( end && this.materials.length === 0 ) {\n\n\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\tname   : '',\n\t\t\t\t\t\t\t\tsmooth : this.smooth\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn lastMultiMaterial;\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Inherit previous objects material.\n\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\tif ( previousMaterial && previousMaterial.name && typeof previousMaterial.clone === \"function\" ) {\n\n\t\t\t\t\tvar declared = previousMaterial.clone( 0 );\n\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\tthis.object.materials.push( declared );\n\n\t\t\t\t}\n\n\t\t\t\tthis.objects.push( this.object );\n\n\t\t\t},\n\n\t\t\tfinalize : function() {\n\n\t\t\t\tif ( this.object && typeof this.object._finalize === 'function' ) {\n\n\t\t\t\t\tthis.object._finalize( true );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tparseVertexIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseNormalIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 3 ) * 3;\n\n\t\t\t},\n\n\t\t\tparseUVIndex: function ( value, len ) {\n\n\t\t\t\tvar index = parseInt( value, 10 );\n\t\t\t\treturn ( index >= 0 ? index - 1 : index + len / 2 ) * 2;\n\n\t\t\t},\n\n\t\t\taddVertex: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\t\t\t\tdst.push( src[ c + 2 ] );\n\n\t\t\t\t// AXC: Add reference to original vertex positions\n\t\t\t\tif (options && options.keepVertIndices) {\n\t\t\t\t\tvar vertIndices = this.object.geometry.origVertIndices;\n\t\t\t\t\tvertIndices.push(Math.floor(a/3));\n\t\t\t\t\tvertIndices.push(Math.floor(b/3));\n\t\t\t\t\tvertIndices.push(Math.floor(c/3));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddVertexLine: function ( a ) {\n\n\t\t\t\tvar src = this.vertices;\n\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\n\t\t\t\t// AXC: Add reference to original vertex positions\n\t\t\t\tif (options && options.keepVertIndices) {\n\t\t\t\t\tvar vertIndices = this.object.geometry.origVertIndices;\n\t\t\t\t\tvertIndices.push(Math.floor(a/3));\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddNormal : function ( a, b, c ) {\n\n\t\t\t\tvar src = this.normals;\n\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\t\t\t\tdst.push( src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddColor: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.colors;\n\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\tdst.push( src[ a + 0 ], src[ a + 1 ], src[ a + 2 ] );\n\t\t\t\tdst.push( src[ b + 0 ], src[ b + 1 ], src[ b + 2 ] );\n\t\t\t\tdst.push( src[ c + 0 ], src[ c + 1 ], src[ c + 2 ] );\n\n\t\t\t},\n\n\t\t\taddUV: function ( a, b, c ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\t\t\t\tdst.push( src[ b + 0 ] );\n\t\t\t\tdst.push( src[ b + 1 ] );\n\t\t\t\tdst.push( src[ c + 0 ] );\n\t\t\t\tdst.push( src[ c + 1 ] );\n\n\t\t\t},\n\n\t\t\taddUVLine: function ( a ) {\n\n\t\t\t\tvar src = this.uvs;\n\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\tdst.push( src[ a + 0 ] );\n\t\t\t\tdst.push( src[ a + 1 ] );\n\n\t\t\t},\n\n\t\t\taddFace: function ( a, b, c, d, ua, ub, uc, ud, na, nb, nc, nd ) {\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tvar ia = this.parseVertexIndex( a, vLen );\n\t\t\t\tvar ib = this.parseVertexIndex( b, vLen );\n\t\t\t\tvar ic = this.parseVertexIndex( c, vLen );\n\t\t\t\tvar id;\n\n\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\tthis.addVertex( ia, ib, ic );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tid = this.parseVertexIndex( d, vLen );\n\n\t\t\t\t\tthis.addVertex( ia, ib, id );\n\t\t\t\t\tthis.addVertex( ib, ic, id );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ua !== undefined ) {\n\n\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\tia = this.parseUVIndex( ua, uvLen );\n\t\t\t\t\tib = this.parseUVIndex( ub, uvLen );\n\t\t\t\t\tic = this.parseUVIndex( uc, uvLen );\n\n\t\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\t\tthis.addUV( ia, ib, ic );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tid = this.parseUVIndex( ud, uvLen );\n\n\t\t\t\t\t\tthis.addUV( ia, ib, id );\n\t\t\t\t\t\tthis.addUV( ib, ic, id );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( na !== undefined ) {\n\n\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\tia = this.parseNormalIndex( na, nLen );\n\n\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex( nb, nLen );\n\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex( nc, nLen );\n\n\t\t\t\t\tif ( d === undefined ) {\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, ic );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tid = this.parseNormalIndex( nd, nLen );\n\n\t\t\t\t\t\tthis.addNormal( ia, ib, id );\n\t\t\t\t\t\tthis.addNormal( ib, ic, id );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( this.colors.length > 0 ) {\n\n\t\t\t\t\tthis.addColor( ia, ib, ic );\n\n\t\t\t\t}\n\t\t\t},\n\n\t\t\taddPointGeometry: function ( vertices ) {\n\n\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexPoint( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\taddLineGeometry: function ( vertices, uvs ) {\n\n\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\tfor ( var vi = 0, l = vertices.length; vi < l; vi ++ ) {\n\n\t\t\t\t\tthis.addVertexLine( this.parseVertexIndex( vertices[ vi ], vLen ) );\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var uvi = 0, l = uvs.length; uvi < l; uvi ++ ) {\n\n\t\t\t\t\tthis.addUVLine( this.parseUVIndex( uvs[ uvi ], uvLen ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t\tstate.startObject( '', false );\n\n\t\treturn state;\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tconsole.time( 'OBJLoader' );\n\n\t\tvar state = this._createParserState();\n\n\t\tif ( text.indexOf( '\\r\\n' ) !== - 1 ) {\n\n\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\ttext = text.replace( /\\r\\n/g, '\\n' );\n\n\t\t}\n\n\t\tif ( text.indexOf( '\\\\\\n' ) !== - 1) {\n\n\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\ttext = text.replace( /\\\\\\n/g, '' );\n\n\t\t}\n\n\t\tvar lines = text.split( '\\n' );\n\t\tvar line = '', lineFirstChar = '', lineSecondChar = '';\n\t\tvar lineLength = 0;\n\t\tvar result = [];\n\n\t\t// Faster to just trim left side of the line. Use if available.\n\t\tvar trimLeft = ( typeof ''.trimLeft === 'function' );\n\n\t\tfor ( var i = 0, l = lines.length; i < l; i ++ ) {\n\n\t\t\tline = lines[ i ];\n\n\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\tlineLength = line.length;\n\n\t\t\tif ( lineLength === 0 ) continue;\n\n\t\t\tlineFirstChar = line.charAt( 0 );\n\n\t\t\t// @todo invoke passed in handler if any\n\t\t\tif ( lineFirstChar === '#' ) continue;\n\n\t\t\tif ( lineFirstChar === 'v' ) {\n\n\t\t\t\tlineSecondChar = line.charAt( 1 );\n\n\t\t\t\tif ( lineSecondChar === ' ' && ( result = this.regexp.vertex_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0                  1      2      3\n\t\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\tparseFloat(result[1]),\n\t\t\t\t\t\tparseFloat(result[2]),\n\t\t\t\t\t\tparseFloat(result[3])\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( lineSecondChar === ' ' && ( result = this.regexp.vertex_color_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0                  1      2      3\n\t\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\t\tstate.vertices.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t\t);\n\n\t\t\t\t\tstate.colors.push(\n\t\t\t\t\t\tparseFloat( result[ 4 ] ),\n\t\t\t\t\t\tparseFloat( result[ 5 ] ),\n\t\t\t\t\t\tparseFloat( result[ 6 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( lineSecondChar === 'n' && ( result = this.regexp.normal_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0                   1      2      3\n\t\t\t\t\t// [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\t\tstate.normals.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( lineSecondChar === 't' && ( result = this.regexp.uv_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// 0               1      2\n\t\t\t\t\t// [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n\t\t\t\t\tstate.uvs.push(\n\t\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\t\tparseFloat( result[ 2 ] )\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( \"Unexpected vertex/normal/uv line: '\" + line  + \"'\" );\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === \"f\" ) {\n\n\t\t\t\tif ( ( result = this.regexp.face_vertex_uv_normal.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal\n\t\t\t\t\t// 0                        1    2    3    4    5    6    7    8    9   10         11         12\n\t\t\t\t\t// [\"f 1/1/1 2/2/2 3/3/3\", \"1\", \"1\", \"1\", \"2\", \"2\", \"2\", \"3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 4 ], result[ 7 ], result[ 10 ],\n\t\t\t\t\t\tresult[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ],\n\t\t\t\t\t\tresult[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_uv.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex/uv vertex/uv vertex/uv\n\t\t\t\t\t// 0                  1    2    3    4    5    6   7          8\n\t\t\t\t\t// [\"f 1/1 2/2 3/3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex_normal.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex//normal vertex//normal vertex//normal\n\t\t\t\t\t// 0                     1    2    3    4    5    6   7          8\n\t\t\t\t\t// [\"f 1//1 2//2 3//3\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", undefined, undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 3 ], result[ 5 ], result[ 7 ],\n\t\t\t\t\t\tundefined, undefined, undefined, undefined,\n\t\t\t\t\t\tresult[ 2 ], result[ 4 ], result[ 6 ], result[ 8 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else if ( ( result = this.regexp.face_vertex.exec( line ) ) !== null ) {\n\n\t\t\t\t\t// f vertex vertex vertex\n\t\t\t\t\t// 0            1    2    3   4\n\t\t\t\t\t// [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n\t\t\t\t\tstate.addFace(\n\t\t\t\t\t\tresult[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ]\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( \"Unexpected face line: '\" + line  + \"'\" );\n\n\t\t\t\t}\n\n\t\t\t} else if ( lineFirstChar === \"l\" ) {\n\n\t\t\t\tvar lineParts = line.substring( 1 ).trim().split( \" \" );\n\t\t\t\tvar lineVertices = [], lineUVs = [];\n\n\t\t\t\tif ( line.indexOf( \"/\" ) === - 1 ) {\n\n\t\t\t\t\tlineVertices = lineParts;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tfor ( var li = 0, llen = lineParts.length; li < llen; li ++ ) {\n\n\t\t\t\t\t\tvar parts = lineParts[ li ].split( \"/\" );\n\n\t\t\t\t\t\tif ( parts[ 0 ] !== \"\" ) lineVertices.push( parts[ 0 ] );\n\t\t\t\t\t\tif ( parts[ 1 ] !== \"\" ) lineUVs.push( parts[ 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tstate.addLineGeometry( lineVertices, lineUVs );\n\n\t\t\t} else if ( lineFirstChar === 'p' ) {\n\n\t\t\t\tvar lineData = line.substr( 1 ).trim();\n\t\t\t\tvar pointData = lineData.split( \" \" );\n\n\t\t\t\tstate.addPointGeometry( pointData );\n\t\t\t} else if ( ( result = this.regexp.object_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// o object_name\n\t\t\t\t// or\n\t\t\t\t// g group_name\n\n\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\tvar name = ( \" \" + result[ 0 ].substr( 1 ).trim() ).substr( 1 );\n\n\t\t\t\tstate.startObject( name );\n\n\t\t\t} else if ( this.regexp.material_use_pattern.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tstate.object.startMaterial( line.substring( 7 ).trim(), state.materialLibraries );\n\n\t\t\t} else if ( this.regexp.material_library_pattern.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tstate.materialLibraries.push( line.substring( 7 ).trim() );\n\n\t\t\t} else if ( ( result = this.regexp.smoothing_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// smooth shading\n\n\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\tvar value = result[ 1 ].trim().toLowerCase();\n\t\t\t\tstate.object.smooth = ( value === '1' || value === 'on' );\n\n\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\tif ( material ) {\n\n\t\t\t\t\tmaterial.smooth = state.object.smooth;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Handle null terminated files without exception\n\t\t\t\tif ( line === '\\0' ) continue;\n\n\t\t\t\tthrow new Error( \"Unexpected line: '\" + line  + \"'\" );\n\n\t\t\t}\n\n\t\t}\n\n\t\tstate.finalize();\n\n\t\tvar container = new THREE.Group();\n\t\tcontainer.materialLibraries = [].concat( state.materialLibraries );\n\n\t\tvar index = 0;\n\t\tfor ( var i = 0, l = state.objects.length; i < l; i ++ ) {\n\n\t\t\tvar object = state.objects[ i ];\n\t\t\tvar geometry = object.geometry;\n\t\t\tvar materials = object.materials;\n\t\t\tvar isLine = ( geometry.type === 'Line' );\n\t\t\tvar isPoints = ( geometry.type === 'Points' );\n\t\t\tvar hasVertexColors = false;\n\n\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\tif ( geometry.vertices.length === 0 ) continue;\n\n\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\tbuffergeometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( geometry.vertices ), 3 ) );\n\n\t\t\tif ( geometry.normals.length > 0 ) {\n\n\t\t\t\tbuffergeometry.setAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( geometry.normals ), 3 ) );\n\n\t\t\t} else {\n\n\t\t\t\tbuffergeometry.computeVertexNormals();\n\n\t\t\t}\n\n\t\t\tif ( geometry.colors.length > 0 ) {\n\n\t\t\t\thasVertexColors = true;\n\t\t\t\tbuffergeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( geometry.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tif ( geometry.uvs.length > 0 ) {\n\n\t\t\t\tbuffergeometry.setAttribute( 'uv', new THREE.BufferAttribute( new Float32Array( geometry.uvs ), 2 ) );\n\n\t\t\t}\n\n\t\t\t// AXC: Add reference to original vertex positions\n\t\t\tif (geometry.origVertIndices.length > 0) {\n\t\t\t\tbuffergeometry.setAttribute( 'vertIndices', new THREE.BufferAttribute( new Uint32Array( geometry.origVertIndices ), 1));\n\t\t\t}\n\n\t\t\t// Create materials\n\n\t\t\tvar createdMaterials = [];\n\n\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\n\n\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\tvar material = undefined;\n\n\t\t\t\tif ( this.materials !== null ) {\n\n\t\t\t\t\tmaterial = this.materials.create( sourceMaterial.name );\n\n\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\tif ( isLine && material && ! ( material instanceof THREE.LineBasicMaterial ) ) {\n\n\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\tmaterialLine.copy( material );\n\t\t\t\t\t\tmaterialLine.lights = false; // TODO: UNHACK\n\t\t\t\t\t\tmaterial = materialLine;\n\n\t\t\t\t\t} else if ( isPoints && material && ! ( material instanceof THREE.PointsMaterial ) ) {\n\n\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\t\t\t\t\t\tmaterialPoints.copy( material );\n\t\t\t\t\t\tmaterialPoints.lights = false; // TODO: UNHACK\n\t\t\t\t\t\tmaterial = materialPoints;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( ! material ) {\n\n\t\t\t\t\tif ( isLine ) {\n\n\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\n\t\t\t\t\t} else if ( isPoints ) {\n\n\t\t\t\t\t\tmaterial = new THREE.PointsMaterial( { size: 1, sizeAttenuation: false } );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\n\t\t\t\t}\n\n\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? THREE.SmoothShading : THREE.FlatShading;\n\t\t\t\tmaterial.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n\n\t\t\t\tcreatedMaterials.push(material);\n\n\t\t\t}\n\n\t\t\t// Create mesh\n\n\t\t\tvar mesh;\n\n\t\t\tif ( createdMaterials.length > 1 ) {\n\n\t\t\t\tfor ( var mi = 0, miLen = materials.length; mi < miLen ; mi++ ) {\n\n\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\tbuffergeometry.addGroup( sourceMaterial.groupStart, sourceMaterial.groupCount, mi );\n\n\t\t\t\t}\n\n\t\t\t\tvar multiMaterial = new THREE.MultiMaterial( createdMaterials );\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, multiMaterial ) : new THREE.LineSegments( buffergeometry, multiMaterial ) );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = ( ! isLine ? new THREE.Mesh( buffergeometry, createdMaterials[ 0 ] ) : new THREE.LineSegments( buffergeometry, createdMaterials[ 0 ] ) );\n\t\t\t}\n\n\t\t\tmesh.name = object.name;\n\n\t\t\t// AXC: Give this mesh an index and id\n\t\t\tmesh.userData.index = index;\n\t\t\tmesh.userData.id = object.name;\n\t\t\tindex++;\n\n\t\t\tcontainer.add( mesh );\n\n\t\t}\n\n\t\tconsole.timeEnd( 'OBJLoader' );\n\n\t\treturn container;\n\n\t}\n\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/OBJLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/OBJMTLLoader.js":
/*!****************************************!*\
  !*** ./js/lib/loaders/OBJMTLLoader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Modified version of THREE.OBJMTLLoader from three.js\n * Loads a Wavefront .obj file with materials\n *\n * @author mrdoob / http://mrdoob.com/\n * @author angelxuanchang\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n * @constructor\n * @memberOf loaders\n */\n\nTHREE.OBJMTLLoader = function ( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\n};\n\nObject.assign( THREE.OBJMTLLoader.prototype, THREE.EventDispatcher.prototype, {\n\n\t/**\n\t * Load a Wavefront OBJ file with materials (MTL file)\n\t *\n\t * If the MTL file cannot be loaded, then a MeshLambertMaterial is used as a default\n\t * @param url - Location of OBJ file to load\n\t * @param mtlurl - MTL file to load (optional, if not specified, attempts to use MTL specified in OBJ file)\n\t * @param options - Options on how to interpret the material (see THREE.MTLLoader.MaterialCreator )\n\t * @private\n\t */\n  load: function ( url, mtlurl, options, onLoad, onProgress, onError ) {\n  \tthis.loadWithMtl(url, mtlurl, options, onLoad, onProgress, onError);\n  },\n\n\tloadWithMtl: function ( url, mtlurl, options, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar mtlLoader = options.mtlLoader || new THREE.MTLLoader( this.manager );\n\t\t// AXC: Handle url that is not a string\n\t\tif (typeof url === 'string') {\n\t\t\tmtlLoader.setBaseUrl( url.substr( 0, url.lastIndexOf( \"/\" ) + 1 ) );\n\t\t}\n\t\tmtlLoader.setCrossOrigin( this.crossOrigin );\n    // AXC: Set material options\n    mtlLoader.setMaterialOptions( options );\n\n\t\t// AXC: Redo load so relative MTL references from OBJ file are okay\n\t\tfunction applyMaterials(object, materialsCreator) {\n\t\t\tobject.traverse(function (object) {\n\t\t\t\tif (object instanceof THREE.Mesh) {\n\t\t\t\t\tif (object.material.name) {\n\t\t\t\t\t\tvar material = materialsCreator.create(object.material.name);\n\t\t\t\t\t\tif (material) object.material = material;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tfunction loadObj(materialsCreator) {\n\t\t\tvar loader = scope.getFileLoader();\n\t\t\t//loader.setCrossOrigin( scope.crossOrigin );\n\t\t\tloader.load( url, function ( text ) {\n\t\t\t\tvar object = scope.parse(text, undefined, options);\n\t\t\t\tapplyMaterials(object, materialsCreator);\n\t\t\t\tonLoad( object );\n\t\t\t}, onProgress, onError );\n\t\t}\n\n\t\t\tfunction loadObjWithMTLCallback() {\n\t\t\t\tvar hasMtl = false;\n\t\t\t\tvar object = null;\n\t\t\t\tvar materialsCreator = null;\n\t\t\t\tfunction mtllibCallback(mtlfile) {\n\t\t\t\t\thasMtl = true;\n\t\t\t\t\tmtlLoader.load(mtlLoader.baseUrl + mtlfile, function (materials) {\n\t\t\t\t\t\tvar mc = materials;\n\t\t\t\t\t\tmc.preload();\n\t\t\t\t\t\tif (object) {\n\t\t\t\t\t\t\tapplyMaterials(object, mc);\n\t\t\t\t\t\t\tonLoad(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaterialsCreator = mc;\n\t\t\t\t\t}, onProgress, onError);\n\t\t\t\t}\n\t\t\t\tvar loader = scope.getFileLoader();\n\t\t\t\t//loader.setCrossOrigin(scope.crossOrigin);\n\t\t\t\tloader.load(url, function (text) {\n\t\t\t\t\tobject = scope.parse(text, mtllibCallback, options);\n\t\t\t\t\tif (hasMtl) {\n\t\t\t\t\t\tif (materialsCreator) {\n\t\t\t\t\t\t\tapplyMaterials(object, materialsCreator);\n\t\t\t\t\t\t\tonLoad(object);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tonLoad(object);\n\t\t\t\t\t}\n\t\t\t\t}, onProgress, onError);\n\t\t\t}\n\n\t\t\tif (mtlurl) {\n\t\t\t\tmtlLoader.load(mtlurl, function (materials) {\n\t\t\t\t\tvar materialsCreator = materials;\n\t\t\t\t\tmaterialsCreator.preload();\n\t\t\t\t\tloadObj(materialsCreator);\n\t\t\t\t}, onProgress, onError);\n\t\t\t} else {\n\t\t\t\tloadObjWithMTLCallback();\n\t\t\t}\n\n\t},\n\n\t// AXC: Custom file loader\n\tgetFileLoader: function() {\n\t\treturn new THREE.FileLoader(this.manager);\n\t},\n\n\tsetCrossOrigin: function ( value ) {\n\n\t\tthis.crossOrigin = value;\n\n\t},\n\n\t/**\n\t * Parses loaded .obj file\n\t * @param data - content of .obj file\n\t * @param mtllibCallback - callback to handle mtllib declaration (optional)\n\t * @return {THREE.Object3D} - Object3D (with default material)\n\t * @private\n\t */\n\n\tparse: function ( data, mtllibCallback, options) {\n\n\t\t//console.log('options', options);\n        function color( r, g, b ) {\n            // NOTE: The THREE.Color constructor is buggy\n            var c = new THREE.Color();\n            c.setRGB( parseFloat( r ), parseFloat( g ), parseFloat( b ) );\n            return c;\n        }\n\n\t\tfunction vector( x, y, z ) {\n\n\t\t\treturn new THREE.Vector3( x, y, z );\n\n\t\t}\n\n\t\tfunction uv( u, v ) {\n\n\t\t\treturn new THREE.Vector2( isFinite(u) ? u : 0, isFinite(v) ? v : 0 );\n\n\t\t}\n\n\t\tfunction face3( a, b, c, normals ) {\n\n\t\t\treturn new THREE.Face3( a, b, c, normals );\n\n\t\t}\n\n\t\tvar face_offset = 0;\n\n\t\tfunction meshN( meshName, materialName ) {\n\n\t\t\tif ( vertices.length > 0 && geometry.faces.length > 0 ) {\n\t\t\t\tgeometry.vertices = vertices;\n\t\t\t\tgeometry.colors = colors;\n\n\t\t\t\tvar origStats = { nverts: geometry.vertices.length, nfaces: geometry.faces.length };\n\t\t\t\tgeometry.mergeVertices();\n\n\t\t\t\tif (geometry.vertices.length === 0 || geometry.faces.length === 0) {\n\t\t\t\t\tconsole.warn('No vertices/faces after merging: before (v='\n\t\t\t\t\t\t+ origStats.nverts + ',f=' + origStats.nfaces + '), after (v='\n\t\t\t\t\t\t+ geometry.vertices.length + ',f=' + geometry.faces.length + ')');\n\t\t\t\t}\n\t\t\t}\n\n  \t\tif ( geometry.vertices.length > 0 && geometry.faces.length > 0 ) {\n\t\t\t\tif (options.computeNormals) {\n\t\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t\t}\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tif (options.useBuffers) {\n\t\t\t\t\tvar bufferGeom = new THREE.BufferGeometry();\n\t\t\t\t\tbufferGeom.fromGeometry(geometry);\n\t\t\t\t\tmesh.geometry = bufferGeom;\n\t\t\t\t}\n\n\t\t\t\tobject.add(mesh);\n\n\t\t\t\tgeometry = new THREE.Geometry();\n\t\t\t\tif (options.smooth) {\n\t\t\t\t\tmaterial.shading = THREE.SmoothShading;\n\t\t\t\t}\n\t\t\t\tmesh = new THREE.Mesh(geometry, material);\n\t\t\t\tmeshCount++;\n\t\t\t}\n\n\t\t\tif ( meshName !== undefined ) {\n\t\t\t\tmesh.name = meshName;\n\t\t\t} else if (mesh.name === undefined) {\n\t\t\t\tmesh.name = 'mesh' + meshCount;\n\t\t\t}\n\t\t\tmesh.userData = {\n\t\t\t\tindex: meshCount\n\t\t\t};\n\n\t\t\tif ( materialName !== undefined ) {\n\n\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tmesh.material = material;\n\n\t\t\t}\n\t\t}\n\n\t\tvar group = new THREE.Group();\n\t\tvar object = group;\n\n\t\tvar geometry = new THREE.Geometry();\n\t\tvar material = new THREE.MeshLambertMaterial();\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n        var meshCount = 0;\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\t\tvar uvs = [];\n    var colors = [];\n\n\t\tfunction add_face( a, b, c, normals_inds ) {\n\n\t\t\tif ( normals_inds === undefined ) {\n\n\t\t\t\tgeometry.faces.push( face3(\n\t\t\t\t\tparseInt( a ) - ( face_offset + 1 ),\n\t\t\t\t\tparseInt( b ) - ( face_offset + 1 ),\n\t\t\t\t\tparseInt( c ) - ( face_offset + 1 )\n\t\t\t\t) );\n\n\t\t\t} else {\n\n\t\t\t\tgeometry.faces.push( face3(\n\t\t\t\t\tparseInt( a ) - ( face_offset + 1 ),\n\t\t\t\t\tparseInt( b ) - ( face_offset + 1 ),\n\t\t\t\t\tparseInt( c ) - ( face_offset + 1 ),\n\t\t\t\t\t[\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 0 ] ) - 1 ].clone(),\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 1 ] ) - 1 ].clone(),\n\t\t\t\t\t\tnormals[ parseInt( normals_inds[ 2 ] ) - 1 ].clone()\n\t\t\t\t\t]\n\t\t\t\t) );\n\n\t\t\t}\n\n\t\t\tif (colors.length > 0) {\n\t\t\t\tvar face = geometry.faces[geometry.faces.length - 1];\n\t\t\t\tvar indices = [face.a, face.b, face.c];\n\t\t\t\tfor (var j = 0; j < 3; j++) {\n\t\t\t\t\tvar vertexIndex = indices[j];\n\t\t\t\t\tface.vertexColors[j] = colors[vertexIndex];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction add_uvs( a, b, c ) {\n\n\t\t\tvar zero = new THREE.Vector2(0, 0);\n\t\t\tvar uva = uvs[ parseInt( a ) - 1 ] || zero;\n\t\t\tvar uvb = uvs[ parseInt( b ) - 1 ] || zero;\n\t\t\tvar uvc = uvs[ parseInt( c ) - 1 ] || zero;\n\t\t\tgeometry.faceVertexUvs[ 0 ].push( [\n\t\t\t\tuva.clone(),\n\t\t\t\tuvb.clone(),\n\t\t\t\tuvc.clone()\n\t\t\t] );\n\n\t\t}\n\n\t\tfunction handle_face_line( faces, uvs, normals_inds ) {\n\n\t\t\tif ( faces[ 3 ] === undefined ) {\n\n\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 2 ], normals_inds );\n\n\t\t\t\tif ( ! ( uvs === undefined ) && uvs.length > 3 ) {\n\n\t\t\t\t\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( ! ( normals_inds === undefined ) && normals_inds.length > 0 ) {\n\n\t\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ], [ normals_inds[ 0 ], normals_inds[ 1 ], normals_inds[ 3 ] ] );\n\t\t\t\t\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ], [ normals_inds[ 1 ], normals_inds[ 2 ], normals_inds[ 3 ] ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tadd_face( faces[ 0 ], faces[ 1 ], faces[ 3 ] );\n\t\t\t\t\tadd_face( faces[ 1 ], faces[ 2 ], faces[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( uvs === undefined ) && uvs.length > 0 ) {\n\n\t\t\t\t\tadd_uvs( uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] );\n\t\t\t\t\tadd_uvs( uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\t\t// v float float float\n\n\t\tvar vertex_pattern = /v( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// v float float float float float float\n\n\t\tvar vertex_color_pattern = /v( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// vn float float float\n\n\t\tvar normal_pattern = /vn( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)( +[\\d|\\.|\\+|\\-|e]+)/;\n\n\t\t// vt float float\n\n\t\tvar uv_pattern = /vt( +[\\d|\\.|\\+|\\-|e]+| NaN)( +[\\d|\\.|\\+|\\-|e]+)| NaN/;\n\n\t\t// f vertex vertex vertex ...\n\n\t\tvar face_pattern1 = /f( +\\d+)( +\\d+)( +\\d+)( +\\d+)?/;\n\n\t\t// f vertex/uv vertex/uv vertex/uv ...\n\n\t\tvar face_pattern2 = /f( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))?/;\n\n\t\t// f vertex/uv/normal vertex/uv/normal vertex/uv/normal ...\n\n\t\tvar face_pattern3 = /f( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+)\\/(\\d+))?/;\n\n\t\t// f vertex//normal vertex//normal vertex//normal ...\n\n\t\tvar face_pattern4 = /f( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))( +(\\d+)\\/\\/(\\d+))?/;\n\n\t\t// AXC: Warn lines not handled just once\n\t\t// l vertex vertex ... (not currently handled)\n\t\tvar line_pattern1 = /l( +\\d+)( +\\d+)/;\n\n\t\tvar line_pattern2 = /l( +(\\d+)\\/(\\d+))( +(\\d+)\\/(\\d+))/;\n\n\t\tvar line_warning_emitted = false;\n\t\t//\n\n\t\tvar lines = data.split( \"\\n\" );\n\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\tvar line = lines[ i ];\n\t\t\tline = line.trim();\n\t\t\tvar origLine = line;\n\t\t\tline = line.toLowerCase();\n\n\t\t\t// AXC: handle QNANs\n\t\t\tvar newline = line.replace(\"1.#qnan\", \"0\");\n\t\t\tif (newline !== line) {\n\t\t\t\tconsole.log(\"THREE.OBJMTLLoader: NAN encountered: \" + line);\n\t\t\t\tline = newline;\n\t\t\t}\n\n\t\t\tvar result;\n\n\t\t\tif ( line.length === 0 || line.charAt( 0 ) === '#' ) {\n\n\t\t\t\tcontinue;\n\n\t\t\t} else if (( result = vertex_color_pattern.exec(line) ) !== null) {\n\t\t\t\tvertices.push(\n\t\t\t\t\tvector(\n\t\t\t\t\t\tparseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])\n\t\t\t\t\t)\n\t\t\t\t);\n\n\t\t\t\tcolors.push(\n\t\t\t\t\tcolor(\n\t\t\t\t\t\tresult[4], result[5], result[6]\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else if ( ( result = vertex_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"v 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\tvertices.push( vector(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = normal_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n\n\t\t\t\tnormals.push( vector(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] ),\n\t\t\t\t\tparseFloat( result[ 3 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = uv_pattern.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"vt 0.1 0.2\", \"0.1\", \"0.2\"]\n\n\t\t\t\tuvs.push( uv(\n\t\t\t\t\tparseFloat( result[ 1 ] ),\n\t\t\t\t\tparseFloat( result[ 2 ] )\n\t\t\t\t) );\n\n\t\t\t} else if ( ( result = face_pattern1.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1 2 3\", \"1\", \"2\", \"3\", undefined]\n\n\t\t\t\thandle_face_line( [ result[ 1 ], result[ 2 ], result[ 3 ], result[ 4 ] ] );\n\n\t\t\t} else if ( ( result = face_pattern2.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1/1 2/2 3/3\", \" 1/1\", \"1\", \"1\", \" 2/2\", \"2\", \"2\", \" 3/3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\n\t\t\t\t\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //uv\n\t\t\t\t);\n\n\t\t\t} else if ( ( result = face_pattern3.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1/1/1 2/2/2 3/3/3\", \" 1/1/1\", \"1\", \"1\", \"1\", \" 2/2/2\", \"2\", \"2\", \"2\", \" 3/3/3\", \"3\", \"3\", \"3\", undefined, undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 6 ], result[ 10 ], result[ 14 ] ], //faces\n\t\t\t\t\t[ result[ 3 ], result[ 7 ], result[ 11 ], result[ 15 ] ], //uv\n\t\t\t\t\t[ result[ 4 ], result[ 8 ], result[ 12 ], result[ 16 ] ] //normal\n\t\t\t\t);\n\n\t\t\t} else if ( ( result = face_pattern4.exec( line ) ) !== null ) {\n\n\t\t\t\t// [\"f 1//1 2//2 3//3\", \" 1//1\", \"1\", \"1\", \" 2//2\", \"2\", \"2\", \" 3//3\", \"3\", \"3\", undefined, undefined, undefined]\n\n\t\t\t\thandle_face_line(\n\t\t\t\t\t[ result[ 2 ], result[ 5 ], result[ 8 ], result[ 11 ] ], //faces\n\t\t\t\t\t[ ], //uv\n\t\t\t\t\t[ result[ 3 ], result[ 6 ], result[ 9 ], result[ 12 ] ] //normal\n\t\t\t\t);\n\n\t\t\t} else if ( /^o /.test( line ) ) {\n\n\t\t\t\t// object\n\n\t\t\t\tmeshN();\n\t\t\t\tobject = new THREE.Object3D();\n\t\t\t\tobject.name = origLine.substring( 2 ).trim();\n\t\t\t\tgroup.add( object );\n\n\t\t\t} else if ( /^g /.test( line ) ) {\n\n\t\t\t\t// group\n\n\t\t\t\tmeshN( origLine.substring( 2 ).trim(), undefined );\n\n\t\t\t} else if ( /^usemtl /.test( line ) ) {\n\n\t\t\t\t// material\n\n\t\t\t\tmeshN( undefined, origLine.substring( 7 ).trim() );\n\n\t\t\t} else if ( /^mtllib /.test( line ) ) {\n\n\t\t\t\t// mtl file\n\n\t\t\t\tif ( mtllibCallback ) {\n\n\t\t\t\t\tvar mtlfile = origLine.substring( 7 );\n\t\t\t\t\tmtlfile = mtlfile.trim();\n\t\t\t\t\tmtllibCallback( mtlfile );\n\n\t\t\t\t}\n\n\t\t\t} else if ( /^s /.test( line ) ) {\n\n\t\t\t\t// Smooth shading\n\n\t\t\t} else if ( ( result = line_pattern1.exec( line ) ) !== null ) {\n\t\t\t\t// AXC: Warn lines not handled just once\n\t\t\t\tif (!line_warning_emitted) {\n\t\t\t\t\tconsole.log( \"THREE.OBJMTLLoader: Support for lines not implemented: \" + line );\n\t\t\t\t\tline_warning_emitted = true;\n\t\t\t\t}\n\t\t\t} else if ( ( result = line_pattern2.exec( line ) ) !== null ) {\n\t\t\t\t// AXC: Warn lines not handled just once\n\t\t\t\tif (!line_warning_emitted) {\n\t\t\t\t\tconsole.log( \"THREE.OBJMTLLoader: Support for lines not implemented: \" + line );\n\t\t\t\t\tline_warning_emitted = true;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tconsole.log( \"THREE.OBJMTLLoader: Unhandled line: \" + line );\n\n\t\t\t}\n\n\t\t}\n\n\t\t//Add last object\n\t\tmeshN( undefined, undefined );\n\n\t\treturn group;\n\n\t}\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/OBJMTLLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/OBJPartLoader.js":
/*!*****************************************!*\
  !*** ./js/lib/loaders/OBJPartLoader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst PartHierarchy = __webpack_require__(/*! parts/PartHierarchy */ \"./js/lib/parts/PartHierarchy.js\");\nconst async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nclass SimpleObjLoader {\n  constructor() {}\n\n  load(info, callback) {\n    if (info.loadMtl) {\n      const objLoader = new THREE.OBJMTLLoader();\n      objLoader.load(info.file, null, {}, function (object3D) {\n        callback(null, object3D);\n      }, null, function (err) {\n        console.error('Error loading path ' + info.file);\n        callback(err);\n      });\n    } else {\n      const objLoader = new THREE.OBJLoader();\n      objLoader.load(info.file, function (object3D) {\n        callback(null, object3D);\n      }, null, function (err) {\n        console.error('Error loading path ' + info.file);\n        callback(err);\n      });\n    }\n  }\n}\n\n/**\n * Loader for part annotations that consists of a json file describing the part hierarchy with pointers to obj files\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction OBJPartLoader(params) {\n  this.fs = params.fs;\n  this.debug = params.debug;\n  this.meshPath = params.meshPath;\n  this.objectLoadOptions = params.objectLoadOptions || {};\n  this.objectLoader = params.objectLoader || new SimpleObjLoader();\n}\n\nOBJPartLoader.prototype.constructor = OBJPartLoader;\n\nOBJPartLoader.prototype.parse = function(data) {\n  var json = JSON.parse(data);\n  if (json.nodes) {\n    // Convert from nodes\n    var converted = _.map(json.nodes, function(node) {\n      return {\n        \"id\": node.id,\n        \"text\": node.name,\n        \"name\": node.name,\n        // \"transformation\": node.transformation,\n      }\n    });\n    var convertedById = _.keyBy(converted, 'id');\n    for (var i = 0; i < converted.length; i++) {\n      var node = json.nodes[i];\n      var c = converted[i];\n      if (node.children) {\n        c['children'] = _.map(node.children, function(id) {\n          return convertedById[id];\n        });\n      } else {\n        c['objs'] = [node.id];\n      }\n      //if (node.meshes) {\n      //c['objs'] = _.map(node.meshes, function(id) { return id; });\n      //}\n    }\n    json = convertedById[0];\n    if (this.meshPath == undefined) {\n      this.meshPath = 'leaf_part_obj/';\n    }\n  } else {\n    // Assume this format:\n    // {\n    //   \"text\": \"xyz\",\n    //   \"children\": {\n    //     \"text\": \"abc\",\n    //     \"name\": \"abc\",\n    //     \"id\": 11\n    //     \"objs\": [\"new-45\"]\n    //   }\n    // }\n    if (this.meshPath == undefined) {\n      this.meshPath = 'objs/';\n    }\n  }\n  return json;\n};\n\n/**\n * Load and parses object parts file\n * @param file\n * @param callback {function(err, Object)}\n */\nOBJPartLoader.prototype.load = function(file, callback) {\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        var json = scope.parse(data);\n        var children = _.isArray(json) ? json : [json];\n        var root = {children: children, name: \"root\", text: \"Root\", id: -1};\n        var partHierarchy = new PartHierarchy(root);\n\n        var objNodes = partHierarchy.getNodes(function(x) { return x.objs; });\n        var dirname = _.getPath(_.getDirname(filename), scope.meshPath);\n        async.mapLimit(objNodes, Constants.MAX_ASYNC_REQS, function(objNode, cb) {\n          scope.__loadObjs(dirname, objNode.objs, cb);\n        }, function(err, results) {\n          // Do some surgery on the results\n          if (err) {\n            callback(err);\n          } else {\n            try {\n              for (var i = 0; i < objNodes.length; i++) {\n                var objNode = objNodes[i];\n                var objs = results[i];\n                if (objNode && objs) {\n                  var g = partHierarchy.createObjectGroup(objNode, objs);\n                  objNode.object3D = g;\n                }\n              }\n              partHierarchy.attachChildObject3Ds();\n              callback(null, partHierarchy);\n            } catch(e) {\n              callback(e);\n            }\n          }\n        });\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\nOBJPartLoader.prototype.__loadObjs = function(path, objnames, callback) {\n  const loadOptions = this.objectLoadOptions;\n  const objectLoader = this.objectLoader;\n  async.mapLimit(objnames, Constants.MAX_ASYNC_REQS, function(objname, cb) {\n    const objpath = _.getPath(path, objname + \".obj\");\n    const modelinfo = { file: objpath, format: 'obj', options: loadOptions };\n    objectLoader.load(modelinfo, obj => { obj.userData.id = objname; return cb(null, obj); },\n        err => {\n          if (loadOptions.ignoreLoadErrors) {\n            console.warn('Error loading ' + objpath + ', ignoring');\n            callback(null);\n          } else {\n            callback(err, null);\n          }\n        });\n  }, callback);\n};\n\nOBJPartLoader.prototype.loadMobility = function(file, callback) {\n  const scope = this;\n  const tmpVec3 = new THREE.Vector3();\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        const json = scope.parse(data);\n        const toArticulationType = {\n          \"free\": \"free\",\n          \"heavy\": \"none\",\n          \"static\": \"none\",\n          \"junk\": \"none\",\n          \"hinge\": \"rotation\",\n          \"slider\": \"translation\"\n        };\n        const articulations = [];\n        const mobilityParts = _.map(json, (d) => {\n          const artType = toArticulationType[d.joint];\n          const limitInfo = _.get(d, ['jointData', 'limit']);\n          let range = (limitInfo && !limitInfo.noLimit)? [limitInfo.a, limitInfo.b] : null;\n          if (range && range[0] > range[1]) {\n            range = [range[1], range[0]];\n          }\n          if (range && artType === 'rotation') {\n            range = range.map(r => r * Math.PI/180);\n          }\n          const origin = d.jointData.axis? d.jointData.axis.origin : null;\n          let axis = d.jointData.axis? d.jointData.axis.direction : null;\n          if (axis) {\n            tmpVec3.fromArray(axis);\n            if (Math.abs(tmpVec3.lengthSq() - 1) > 0.00000001) {\n              // Not normalized (normalize)\n              console.warn('Warning: Normalizing axis ', axis, d.joint);\n              tmpVec3.normalize();\n              axis = tmpVec3.toArray();\n            }\n          }\n          articulations.push({\n            \"pid\": d.id,\n            \"type\": artType,\n            \"axis\": axis,\n            \"origin\": origin,\n            \"rangeMin\": range? range[0] : null,\n            \"rangeMax\": range? range[1] : null,\n            \"base\": (d.parent >= 0)? [d.parent] : null\n          });\n          if (limitInfo && limitInfo.rotates) {\n            range = limitInfo.noRotationLimit? null : [0, limitInfo.rotationLimit * Math.PI/180];\n            articulations.push({\n              \"pid\": d.id,\n              \"type\": \"rotation\",\n              \"axis\": axis,\n              \"origin\": origin,\n              \"rangeMin\": range? range[0] : null,\n              \"rangeMax\": range? range[1] : null,\n              \"base\": (d.parent >= 0)? [d.parent] : null\n            });\n          }\n          return {\n            \"name\": d.name,\n            \"pid\": d.id,\n            \"nodeIds\": d.parts.map(p => p.id)\n          };\n        });\n        callback(null, { parts: mobilityParts, articulations: articulations });\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\nOBJPartLoader.prototype.createArticulated = function(artData, partHierarchy) {\n  const ArticulatedObject = __webpack_require__(/*! articulations/ArticulatedObject */ \"./js/lib/articulations/ArticulatedObject.js\");\n  const PartConnectivityGraph = __webpack_require__(/*! parts/PartConnectivityGraph */ \"./js/lib/parts/PartConnectivityGraph.js\");\n  const articulations = artData.articulations;\n  const partInfos = artData.parts;\n  const filteredArticulations = _.filter(articulations, art =>\n    art.type === 'rotation' || art.type === 'translation'\n  );\n  const partNodes = partHierarchy.getNodes();\n  const partNodesById = [];\n  for (let p of partNodes) {\n    if (p.id >= 0) {\n      partNodesById[p.id] = p;\n    }\n  }\n  const parts = [];\n  console.log('articulations', articulations);\n  for (let art of partInfos) {\n    if (art.nodeIds.length === 1) {\n      const p = partNodesById[art.nodeIds[0]];\n      parts[art.pid] = new Part(art.pid, art.name, art.name, null, p.object3D.clone());\n      parts[art.pid].object3D.userData.pid = art.pid;\n      parts[art.pid].object3D.userData.ids = [p.object3D.userData.id];\n      delete parts[art.pid].object3D.userData.id;\n    } else {\n      console.log('Creating combined part', art.nodeIds);\n      const ps = art.nodeIds.map(n => partNodesById[n].object3D? partNodesById[n].object3D.clone() : null).filter(x => x);\n      const obj3D = new THREE.Group();\n      const objs = [];\n      const ids = [];\n      for (let p of ps) {\n        obj3D.add(p);\n        ids.push(p.userData.id);\n        if (p.userData.objs) {\n          objs.push(...p.userData.objs);\n        }\n      }\n      obj3D.userData.partId = art.pid;\n      obj3D.userData.pid = art.pid;\n      obj3D.userData.name = art.name;\n      obj3D.userData.ids = ids;\n      obj3D.userData.objs = objs;\n      parts[art.pid] = new Part(art.pid, art.name, art.name, null, obj3D);\n    }\n  }\n  const metadata = { modelId: partHierarchy.root.object3D.userData.modelId };\n  const connectivityGraph = new PartConnectivityGraph([], parts, metadata);\n  for (let art of articulations) {\n    if (art.base) {\n      for (let b of art.base) {\n        connectivityGraph.add(art.pid, b, true);\n      }\n    }\n  }\n  return new ArticulatedObject(filteredArticulations, connectivityGraph);\n};\n\n\nmodule.exports = OBJPartLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/OBJPartLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/Object3DLoader.js":
/*!******************************************!*\
  !*** ./js/lib/loaders/Object3DLoader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar AssetLoader = __webpack_require__(/*! assets/AssetLoader */ \"./js/lib/assets/AssetLoader.js\");\nvar Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar PartNetOBJPartLoader = __webpack_require__(/*! loaders/OBJPartLoader */ \"./js/lib/loaders/OBJPartLoader.js\");\nvar Shape2MotionOBJPartLoader = __webpack_require__(/*! loaders/Shape2MotionOBJPartLoader */ \"./js/lib/loaders/Shape2MotionOBJPartLoader.js\");\nvar P5DTextureLoader = __webpack_require__(/*! loaders/P5DTextureLoader */ \"./js/lib/loaders/P5DTextureLoader.js\");\nvar URDFLoader = __webpack_require__(/*! loaders/URDFLoader */ \"./js/lib/loaders/URDFLoader.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n__webpack_require__(/*! three-loaders */ \"./js/lib/loaders/index.js\");\n\n// Wrapper for THREE loaders for loading a single mesh\nvar Object3DLoader = function(assetManager) {\n  this.assetManager = assetManager;\n};\n\nfunction getExtension(path) {\n  var lastDot = path.lastIndexOf('.');\n  if (lastDot >= 0) {\n    return path.substr(lastDot+1);\n  }\n}\n\nfunction getExtensionEx(path, ignoreExtensions) {\n  var extension = getExtension(path);\n  if (ignoreExtensions) {\n    var p = path;\n    while (_.indexOf(ignoreExtensions, extension) >= 0) {\n      p = p.substr(0, p.length - extension.length-1);\n      var ext2 = getExtension(p);\n      if (ext2.length >= p.length) {\n        return extension;\n      }\n      extension = ext2;\n    }\n  }\n  return extension;\n}\n\nObject3DLoader.prototype.loadErrorFirst = function (modelinfo, callback) {\n  // Load with node.js error first style callback(err, result)\n  this.load(modelinfo,\n      function(data) { callback(null, data); },\n      function(err) { callback(err, null); }\n  );\n};\n\nObject3DLoader.prototype.load = function(modelinfo, onsuccess, onerror) {\n  if (modelinfo.file) {\n    if (modelinfo.file instanceof File) {\n      if (modelinfo.format === undefined) {\n        modelinfo.format = getExtensionEx(modelinfo.file.name, ['zip']);\n      }\n      modelinfo.isZipped = modelinfo.file.name.endsWith('.zip');\n    } else if (typeof modelinfo.file === 'string') {\n      if (modelinfo.format === undefined) {\n        modelinfo.format = getExtensionEx(modelinfo.file, ['zip']);\n      }\n      modelinfo.isZipped = modelinfo.file.endsWith('.zip');\n    }\n  }\n\n  if (modelinfo.extractType != null) {\n    if (modelinfo.options && modelinfo.options.handleExtractTypes &&\n        modelinfo.options.handleExtractTypes.indexOf(modelinfo.extractType) >= 0) {\n      return this.__loadAndExtractModel(modelinfo, onsuccess, onerror);\n    }\n  }\n\n  if (modelinfo.format === 'three.js') {\n    return this.__loadThreeJsModel(modelinfo, onsuccess, onerror);\n  } else if (modelinfo.format === 'obj') {\n    if (modelinfo.texture || (modelinfo.options && modelinfo.options.skipMtl)) {\n      return this.__loadObjModel(modelinfo, onsuccess, onerror);\n    } else {\n      return this.__loadObjMtlModel(modelinfo, onsuccess, onerror);\n    }\n  } else if (!modelinfo.isZipped) {\n    if (modelinfo.format === 'ply') {\n      return this.__loadPlyModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'kmz') {\n      return this.__loadKmzModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'p5d') {\n      return this.__loadP5dModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'collada' || modelinfo.format === 'dae') {\n      return this.__loadColladaModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'utf8') {\n      return this.__loadUTF8Model(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'utf8v2') {\n      return this.__loadUTF8v2Model(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'glb') {\n      return this.__loadGLTFModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'gltf') {\n      return this.__loadGLTFModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'urdf') {\n      return this.__loadURDFModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'objparts' || modelinfo.format === 'partnet_objparts') {\n      return this.__loadPartNetObjPartsModel(modelinfo, onsuccess, onerror);\n    } else if (modelinfo.format === 'shape2motion_objparts') {\n      return this.__loadShape2MotionObjPartsModel(modelinfo, onsuccess, onerror);\n    } else {\n      var message = (modelinfo.format == undefined) ? 'Unspecified format' : ('Unsupported format ' + modelinfo.format);\n      console.warn(message);\n      onerror(message);\n    }\n  } else {\n    var message = (modelinfo.format == undefined) ? 'Unspecified format' : ('Unsupported zipped format ' + modelinfo.format);\n    console.warn(message);\n    onerror(message);\n  }\n};\n\nObject3DLoader.prototype.__loadAndExtractModel = function(modelinfo, onsuccess, onerror) {\n  var message;\n  if (modelinfo.extractType === 'simple') {\n    var requiredFields = ['extractType', 'sourceModelId', 'extractOperation', 'extractNodeIds'];\n    var missingFields = requiredFields.filter(function(name) { return modelinfo[name] == null; });\n    if (missingFields.length === 0) {\n      var validOps = ['keep', 'remove'];\n      var extractInfo = _.pick(modelinfo, requiredFields);\n      extractInfo.extractNodeIds = extractInfo.extractNodeIds.split(';');\n\n      if (validOps.indexOf(extractInfo.extractOperation) < 0) {\n        message = 'Unsupported extractOperation: ' + extractInfo.extractOperation;\n      } else {\n        var sourceModelInfo = _.omit(_.cloneDeep(modelinfo), ['extractType', 'sourceModelId', 'extractOperation', 'extractNodeIds']);\n        sourceModelInfo.id = modelinfo.sourceModelId;\n        sourceModelInfo.fullId = this.assetManager.toFullId(sourceModelInfo.source, sourceModelInfo.id);\n        this.assetManager.loadModel(sourceModelInfo, function (err, sourceModelInstance) {\n          if (err) {\n            onerror(err);\n          } else {\n            try {\n              var object3d = sourceModelInstance.modelObject3D.children[0].clone();\n              var extracted = Object3DUtil.extractNodes(object3d, extractInfo.extractOperation, extractInfo.extractNodeIds);\n              onsuccess(extracted);\n            } catch (error) {\n              onerror(error);\n            }\n          }\n        });\n        return;\n      }\n    } else {\n      message = 'Missing fields for extractType=simple: ' + missingFields.join(',');\n    }\n  } else {\n    message = 'Unsupported extractType: ' + modelinfo.extractType;\n  }\n  if (message) {\n    console.warn(message);\n    onerror(message);\n  }\n};\n\nObject3DLoader.prototype.__loadPartNetObjPartsModel = function(modelInfo, callback, onerror) {\n  var options = _.defaults(Object.create(null), modelInfo.options || {});\n  options.loadMtl = (options.loadMtl != undefined) ? options.loadMtl : modelInfo.loadMtl;\n  var loader = new PartNetOBJPartLoader({fs: Constants.sys.fs, meshPath: modelInfo.meshPath, objectLoadOptions: options, objectLoader: this });\n  var supportArticulated = this.assetManager.supportArticulated;\n  loader.load(modelInfo.file, function(err, partHierarchy) {\n    if (err) {\n      onerror(err);\n    } else {\n      if (modelInfo.mobility && supportArticulated) {\n        loader.loadMobility(modelInfo.mobility, (err2, articulations) => {\n          if (err2) {\n            console.error('Error loading mobility', err2);\n            callback(partHierarchy.root.object3D);\n          } else {\n            var articulated = loader.createArticulated(articulations, partHierarchy);\n            callback(articulated);\n          }\n        });\n      } else {\n        callback(partHierarchy.root.object3D);\n      }\n    }\n  }, options);\n};\n\nObject3DLoader.prototype.__loadShape2MotionObjPartsModel = function(modelInfo, callback, onerror) {\n  var ArticulatedObject = __webpack_require__(/*! articulations/ArticulatedObject */ \"./js/lib/articulations/ArticulatedObject.js\");\n  var options = _.defaults(Object.create(null), modelInfo.options || {});\n  options.loadMtl = (options.loadMtl != undefined) ? options.loadMtl : modelInfo.loadMtl;\n  var loader = new Shape2MotionOBJPartLoader({fs: Constants.sys.fs, objectLoadOptions: options, objectLoader: this} );\n  loader.load(modelInfo.file, function(err, partHierarchy) {\n    if (err) {\n      onerror(err);\n    } else {\n      // non articulated version: partHierarchy.root.object3D\n      var articulated = new ArticulatedObject(null, null, partHierarchy);\n      //console.log(articulated);\n      callback(articulated);\n    }\n  }, options);\n};\n\nObject3DLoader.prototype.__loadObjMtlModel = function (modelInfo, callback, onerror) {\n  var objFile = modelInfo.file;\n  var mtlFile = modelInfo.mtl;\n  // TODO: Move this material options to be less format specific\n  var side = this.assetManager.__getMaterialSide(modelInfo);\n  var options = _.defaults(Object.create(null), { side: side }, modelInfo.options || {});\n  this.assetManager.__updateMaterialOptions(modelInfo, options, Materials.DefaultMaterialType);\n\n  var onLoad = function (object) {\n    callback(object);\n  };\n\n  //console.log('modelInfo', modelInfo);\n  options.mtl = mtlFile;\n  if (options.preserveMeshes == undefined || options.preserveMeshes) {\n    // Use old OBJMTLLoader so we have same number of meshes as something...\n    // console.log('Using old OBJMTLLoader (slow)');\n    var loader = modelInfo.isZipped? new THREE.ZippedObjMtlLoader(options) : new THREE.OBJMTLLoader();\n    if (modelInfo.isZipped) {\n      return loader.load(objFile, onLoad, undefined, onerror);\n    } else {\n      return loader.load(objFile, mtlFile, options, onLoad, undefined, onerror);\n    }\n  } else {\n    // Use new OBJLoader\n    // console.log('Using new OBJLoader');\n    var loader = modelInfo.isZipped? new THREE.ZippedObjLoader(options) : new THREE.OBJLoader();\n    if (!modelInfo.isZipped) {\n      loader.setOptions(options);\n      loader.setMtlOptions(options);\n    }\n    return loader.load(objFile, onLoad, undefined, onerror);\n  }\n};\n\nObject3DLoader.prototype.__loadPlyModel = function (modelInfo, callback, onerror) {\n  // Tested to work for ASCII and BINARY ply files\n  var plyFile = modelInfo.file;\n  var options = modelInfo.options || {};\n  // TODO: Move more of this logic to be less format specific\n  // TODO: Check modelInfo use vertex colors\n  var materialType = modelInfo.defaultMaterialType || THREE.MeshBasicMaterial;\n  if (_.isString(materialType)) {\n    materialType = Materials.getMaterialType(materialType);\n  }\n  var side = this.assetManager.__getMaterialSide(modelInfo);\n  var vertexColorMaterial = new materialType(\n    { name: 'vertexColors', vertexColors: THREE.VertexColors, side: side });\n  var material = (options.defaultMaterial) ? options.defaultMaterial : vertexColorMaterial;\n  var computeNormals = (options.computeNormals != undefined) ? options.computeNormals : modelInfo.computeNormals;\n  var loader = new THREE.PLYLoader({\n    computeNormals: computeNormals,\n    propertyNameMapping: options.propertyNameMapping,\n    customFaceAttributes: options.customFaceAttributes,\n    customVertexAttributes: options.customVertexAttributes\n  });\n  var onLoad = function (geometry) {\n    if (geometry.index) {\n      var mesh = new THREE.Mesh(geometry, material);\n      callback(mesh);\n    } else {\n      // NO faces!  TODO: have reasonable size....\n      var size = 1;//0.1*(modelInfo.unit || 1.0) / Constants.virtualUnitToMeters ;\n      //console.log('using size', size, 'for points material', modelInfo.unit, Constants.virtualUnitToMeters);\n      material = new THREE.PointsMaterial({ size: size, vertexColors: THREE.VertexColors });\n      var points = new THREE.Points(geometry, material);\n      callback(points);\n    }\n  };\n  this.assetManager.assetLoader.load(plyFile, 'arraybuffer',\n    function (data) {\n      onLoad(loader.parse(data));\n    }, undefined, onerror);\n};\n\nObject3DLoader.prototype.__loadObjModel = function (modelInfo, callback, onerror) {\n  var objFile = modelInfo.file;\n  var textureFile = modelInfo.texture;\n  var side = this.assetManager.__getMaterialSide(modelInfo);\n  var material;\n  if (textureFile) {\n    material = new Materials.DefaultMaterialType({\n      map: Object3DUtil.loadTexture(textureFile), side: side\n    });\n  } else if (modelInfo.options && modelInfo.options.defaultMaterial) {\n    material = modelInfo.options.defaultMaterial;\n  } else {\n    material = new Materials.DefaultMaterialType({ side: side });\n  }\n\n  // model\n  var loader = modelInfo.isZipped? new THREE.ZippedObjLoader() : new THREE.OBJLoader();\n  var onload = function (object) {\n    Object3DUtil.setMaterial(object, material, Object3DUtil.MaterialsAll);\n    callback(object);\n  };\n  return loader.load(objFile, onload, undefined, onerror);\n};\n\nObject3DLoader.prototype.__loadThreeJsModel = function (modelInfo, callback, onerror) {\n  var file = modelInfo.file;\n  // model\n  if (file.endsWith('.zip')) {\n    var zipLoader = new THREE.ZippedJsonLoader();\n    var onload = function (object) {\n      callback(object);\n    };\n    zipLoader.load(file, onload);\n  } else {\n    var loader = new THREE.LegacyJSONLoader();\n    loader.setResourcePath(modelInfo.texturePath || modelInfo.materialBase);\n    var onload = function (geometry, materials) {\n      var mesh = new THREE.Mesh(geometry, new THREE.MultiMaterial(materials));\n      callback(mesh);\n    };\n    return loader.load(file, onload, undefined, onerror);\n  }\n};\n\nObject3DLoader.prototype.__loadP5dModel = function (modelInfo, callback, onerror) {\n  var loader = new P5DTextureLoader();\n  var scope = this;\n  if (this.assetManager.autoLoadVideo) {\n    loader.loadVideoTexture = function (path) {\n      return scope.loadVideoTexture(path);\n    };\n  }\n  var newCallback = function (object3D) {\n    var meshes = Object3DUtil.getMeshList(object3D);\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      //var objectType = 'unknown';\n      var config = {};\n      loader.updateMaterials(mesh, config);\n    }\n    if (modelInfo.category) {\n      if (((modelInfo.category.indexOf('hanging_kitchen_cabinet') >= 0) ||\n        (modelInfo.category.indexOf('range_oven_with_hood') >=0) ||\n        (modelInfo.category.indexOf('range_hood') >=0)) &&\n        (modelInfo.category.indexOf('kitchen_cabinet') < 0)) {\n        modelInfo.category = _.concat(['kitchen_cabinet'], modelInfo.category);\n      }\n    }\n    callback(object3D);\n  };\n  if (modelInfo.file.endsWith('.obj')) {\n    return this.__loadObjMtlModel(modelInfo, newCallback, onerror);\n  } else {\n    return this.__loadThreeJsModel(modelInfo, newCallback, onerror);\n  }\n};\n\n// Kmz = zipped collada model\nObject3DLoader.prototype.__loadKmzModel = function (modelInfo, callback, onerror) {\n  // var loader = new THREE.KMZLoader(modelInfo.options);\n  var loader = new THREE.KMZLoader(_.pick(modelInfo.options || {}, ['textureCacheOpts']));\n  return this.__loadColladaOrKmzModel(loader, modelInfo, callback, onerror);\n};\n\nObject3DLoader.prototype.__loadColladaModel = function (modelInfo, callback, onerror) {\n  var loader = new THREE.ColladaLoader();\n  return this.__loadColladaOrKmzModel(loader, modelInfo, callback, onerror);\n};\n\nObject3DLoader.prototype.__loadColladaOrKmzModel = function (loader, modelInfo, callback, onerror) {\n  var scope = this;\n  function colladaReady(collada) {\n    var object = collada.scene;\n    // Copy out some collada info into the userData so it is kept\n    Object3DUtil.traverse(object, function (node) {\n      if (!node.hasOwnProperty('userData')) {\n        node['userData'] = {};\n      }\n      if (node.hasOwnProperty('colladaId')) {\n        // Use collada id as the id\n        node.userData.id = node.colladaId;\n      } else if (node instanceof THREE.Mesh) {\n        if (node.geometry.hasOwnProperty('colladaId')) {\n          node.userData.id = node.geometry.colladaId;\n        }\n      }\n      if (node.hasOwnProperty('layer')) {\n        node.userData.layer = node.layer;\n      }\n      return true;\n    });\n    // TODO: Improve control over whether the collada scale is used\n    if (scope.useColladaScale || (scope.useColladaScale == null && modelInfo.options && modelInfo.options.applyScale)) {\n      // Assumes to be scaled with collada to meters\n      modelInfo.formatOptions['applyScale'] = true;\n      modelInfo.unit = 1.0;\n    } else {\n      // Unset any object scale that was set by the ColladaLoader so we can set and scale it in our framework\n      object.scale.set(1, 1, 1);\n      if (!modelInfo.unit) {\n        modelInfo.unit = collada.dae.unit;\n      }\n    }\n    //console.log('Unit for model ' + modelInfo.fullId + ': ' + modelInfo.unit);\n    callback(object);\n  }\n\n  var file = modelInfo.file;\n  modelInfo.formatOptions = {};\n  this.assetManager.__updateMaterialOptions(modelInfo, loader.options, Materials.DefaultMaterialType);\n  // TODO: Beware some weird automatic setting of convertUpAxis\n  if (scope.convertUpAxis != null) {\n    loader.options.convertUpAxis = scope.convertUpAxis;\n  } else if (modelInfo.options && modelInfo.options.convertUpAxis != null) {\n    loader.options.convertUpAxis = modelInfo.options.convertUpAxis;\n  } else {\n    if (!modelInfo.source) {\n      loader.options.convertUpAxis = true;\n    } else {\n      loader.options.convertUpAxis = false;\n    }\n  }\n  modelInfo.formatOptions['applyUp'] = loader.options.convertUpAxis;\n  var skipLines = _.get(modelInfo, ['options', 'skipLines']);\n  if (skipLines != undefined) {\n    loader.options.skipLines = skipLines;\n  }\n  return loader.load(file, colladaReady, undefined, onerror);\n};\n\nObject3DLoader.prototype.__loadUTF8Model = function (modelInfo, callback, onerror) {\n  var file = modelInfo.file;\n  var texture = modelInfo.texture;\n  var metadata = modelInfo.metadata;\n  var loader = new THREE.UTF8Loader();\n  var side = this.assetManager.__getMaterialSide(modelInfo);\n  return loader.load(file, function (geometry) {\n    var material = new Materials.DefaultMaterialType({\n      map: Object3DUtil.loadTexture(texture),\n      side: side\n    });\n\n    var object = new THREE.Mesh(geometry, material);\n    callback(object);\n  }, onerror, metadata);\n};\n\nObject3DLoader.prototype.__loadUTF8v2Model = function (modelInfo, callback, onerror) {\n  var loader = new THREE.UTF8Loader();\n  var side = this.assetManager.__getMaterialSide(modelInfo);\n  return loader.load(modelInfo.file, function (object) {\n    callback(object);\n  }, onerror, _.defaults(Object.create(null), { side: side }, modelInfo.options));\n};\n\nObject3DLoader.prototype.__loadGLTFModel = function (modelInfo, callback, onerror) {\n  var loader = new THREE.GLTFLoader();\n  if (Constants.isBrowser) {\n    loader.getFileLoader = function(responseType) {\n      var ldr = new AssetLoader({ manager: loader.manager });\n      return {\n        load: function(url, onLoad, onProgress, onError) {\n          return ldr.load(url, responseType, onLoad, onProgress, onError);\n        }\n      }\n    }\n  }\n  if (!_.isString(modelInfo.file)) {\n    loader.setPath('');\n  }\n  var options = _.defaults({}, modelInfo.options || {});\n  options.computeNormals = (options.computeNormals != undefined) ? options.computeNormals : modelInfo.computeNormals;\n  this.assetManager.__updateMaterialOptions(modelInfo, options, Materials.DefaultMaterialType);\n  loader.setOptions(options);\n  return loader.load(modelInfo.file, function (object) {\n    //console.log(object);\n    callback(object.scene);\n  }, function(progress) {}, onerror, modelInfo.options);\n};\n\nObject3DLoader.prototype.__loadURDFModel = function (modelInfo, callback, onerror) {\n  var manager = new THREE.LoadingManager();\n  var loader = new URDFLoader(manager);\n  var scope = this;\n  return loader.load(modelInfo.file, function (object) {\n    callback(object);\n  }, {\n    loadMeshCb: function(path, manager, done) {\n      scope.assetManager.__loadObject3D({ file: path }, done, function(err) {\n        done(null, err);\n        onerror(err);\n      });\n    }\n  });\n};\n\nmodule.exports = Object3DLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/Object3DLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/P5DLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/P5DLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("THREE.p5dLoader = function () {\n  THREE.Loader.call(this);\n};\nTHREE.p5dLoader.prototype = new THREE.Loader();\nTHREE.p5dLoader.prototype.constructor = THREE.p5dLoader;\n\n\nTHREE.p5dLoader.prototype.load = function (url, onLoad, onProgress, onError) {\n\n  var scope = this;\n\n  var loader = new THREE.FileLoader(scope.manager);\n  //loader.setCrossOrigin(this.crossOrigin);\n  loader.load(url, function (text) {\n    var res = scope.parse(JSON.parse(text));\n    onLoad(res);\n  }, onProgress, onError);\n};\n\nTHREE.p5dLoader.prototype.parse = function (json) {\n  return this.createModel(json, this.texturePath);\n};\n\nTHREE.p5dLoader.prototype.createModel = function (json, texturePath) {\n  if (json == undefined) {\n    console.log(this);\n    return this;\n  }\n  var scope = this,\n    geometry = new THREE.Geometry(),\n    scale = (json.scale !== undefined) ? 1.0 / json.scale : 1.0;\n  geometry.dynamic = false;\n  parseModel(scale);\n  geometry.computeFaceNormals();\n  geometry.computeBoundingSphere();\n\n  function parseModel(scale) {\n    function isBitSet(value, position) {\n      return value & (1 << position);\n    }\n    var i, j, fi, offset, zLength, colorIndex, normalIndex, uvIndex, materialIndex, type, isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor, vertex, face, faceA, faceB, hex, normal, uvLayer, uv, u, v, faces = json.faces,\n      vertices = json.vertices,\n      normals = json.normals,\n      colors = json.colors,\n      nUvLayers = 0;\n    if (json.uvs !== undefined) {\n      for (i = 0; i < json.uvs.length; i++) {\n        if (json.uvs[i].length) nUvLayers++;\n      }\n      for (i = 0; i < nUvLayers; i++) {\n        geometry.faceVertexUvs[i] = [];\n      }\n    }\n    offset = 0;\n    zLength = vertices.length;\n    while (offset < zLength) {\n      vertex = new THREE.Vector3();\n      vertex.x = vertices[offset++] * scale;\n      vertex.y = vertices[offset++] * scale;\n      vertex.z = vertices[offset++] * scale;\n      geometry.vertices.push(vertex);\n    }\n    offset = 0;\n    zLength = faces.length;\n    while (offset < zLength) {\n      type = faces[offset++];\n      isQuad = isBitSet(type, 0);\n      hasMaterial = isBitSet(type, 1);\n      hasFaceVertexUv = isBitSet(type, 3);\n      hasFaceNormal = isBitSet(type, 4);\n      hasFaceVertexNormal = isBitSet(type, 5);\n      hasFaceColor = isBitSet(type, 6);\n      hasFaceVertexColor = isBitSet(type, 7);\n      if (isQuad) {\n        faceA = new THREE.Face3();\n        faceA.a = faces[offset];\n        faceA.b = faces[offset + 1];\n        faceA.c = faces[offset + 3];\n        faceB = new THREE.Face3();\n        faceB.a = faces[offset + 1];\n        faceB.b = faces[offset + 2];\n        faceB.c = faces[offset + 3];\n        offset += 4;\n        if (hasMaterial) {\n          materialIndex = faces[offset++];\n          faceA.materialIndex = materialIndex;\n          faceB.materialIndex = materialIndex;\n        }\n        fi = geometry.faces.length;\n        if (hasFaceVertexUv) {\n          for (i = 0; i < nUvLayers; i++) {\n            uvLayer = json.uvs[i];\n            geometry.faceVertexUvs[i][fi] = [];\n            geometry.faceVertexUvs[i][fi + 1] = [];\n            for (j = 0; j < 4; j++) {\n              uvIndex = faces[offset++];\n              u = uvLayer[uvIndex * 2];\n              v = uvLayer[uvIndex * 2 + 1];\n              uv = new THREE.Vector2(u, v);\n              if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);\n              if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);\n            }\n          }\n        }\n        if (hasFaceNormal) {\n          normalIndex = faces[offset++] * 3;\n          faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n          faceB.normal.copy(faceA.normal);\n        }\n        if (hasFaceVertexNormal) {\n          for (i = 0; i < 4; i++) {\n            normalIndex = faces[offset++] * 3;\n            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n            if (i !== 2) faceA.vertexNormals.push(normal);\n            if (i !== 0) faceB.vertexNormals.push(normal);\n          }\n        }\n        if (hasFaceColor) {\n          colorIndex = faces[offset++];\n          hex = colors[colorIndex];\n          faceA.color.setHex(hex);\n          faceB.color.setHex(hex);\n        }\n        if (hasFaceVertexColor) {\n          for (i = 0; i < 4; i++) {\n            colorIndex = faces[offset++];\n            hex = colors[colorIndex];\n            if (i !== 2) faceA.vertexColors.push(new THREE.Color(hex));\n            if (i !== 0) faceB.vertexColors.push(new THREE.Color(hex));\n          }\n        }\n        geometry.faces.push(faceA);\n        geometry.faces.push(faceB);\n      } else {\n        face = new THREE.Face3();\n        face.a = faces[offset++];\n        face.b = faces[offset++];\n        face.c = faces[offset++];\n        if (hasMaterial) {\n          materialIndex = faces[offset++];\n          face.materialIndex = materialIndex;\n        }\n        fi = geometry.faces.length;\n        if (hasFaceVertexUv) {\n          for (i = 0; i < nUvLayers; i++) {\n            uvLayer = json.uvs[i];\n            geometry.faceVertexUvs[i][fi] = [];\n            for (j = 0; j < 3; j++) {\n              uvIndex = faces[offset++];\n              u = uvLayer[uvIndex * 2];\n              v = uvLayer[uvIndex * 2 + 1];\n              uv = new THREE.Vector2(u, v);\n              geometry.faceVertexUvs[i][fi].push(uv);\n            }\n          }\n        }\n        if (hasFaceNormal) {\n          normalIndex = faces[offset++] * 3;\n          face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n        }\n        if (hasFaceVertexNormal) {\n          for (i = 0; i < 3; i++) {\n            normalIndex = faces[offset++] * 3;\n            normal = new THREE.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);\n            face.vertexNormals.push(normal);\n          }\n        }\n        if (hasFaceColor) {\n          colorIndex = faces[offset++];\n          face.color.setHex(colors[colorIndex]);\n        }\n        if (hasFaceVertexColor) {\n          for (i = 0; i < 3; i++) {\n            colorIndex = faces[offset++];\n            face.vertexColors.push(new THREE.Color(colors[colorIndex]));\n          }\n        }\n        geometry.faces.push(face);\n      }\n    }\n  }\n  for (var m in json.materials) {\n    if (json.materials[m].colorAmbient) {\n      delete(json.materials[m].colorAmbient);\n    }\n    if (json.materials[m].transparency !== undefined) {\n      if (json.materials[m].transparency == 1) {\n        json.materials[m].opacity = 1;\n      } else {\n        json.materials[m].opacity = json.materials[m].transparency;\n      }\n    }\n    if (json.materials[m].transparency != undefined) {\n      delete(json.materials[m].transparency);\n    }\n  }\n  var materials = this.initMaterials(json.materials, texturePath);\n  if (this.needsTangents && this.needsTangents(materials)) geometry.computeTangents();\n  return [geometry, materials];\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/P5DLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/P5DTextureLoader.js":
/*!********************************************!*\
  !*** ./js/lib/loaders/P5DTextureLoader.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\n\nfunction __loadTexture(path, onLoad, onProgress, onError)  {\n  var loader = new THREE.TextureLoader();\n  return loader.load(path, onLoad);\n}\n\nvar __defaultEnvmap = null;\nfunction __getDefaultEnvmap() {\n  if (!__defaultEnvmap) {\n    __defaultEnvmap = __loadTexture(Constants.imagesDir + '/envmap-lat-lon.png');\n    __defaultEnvmap.mapping = THREE.SphericalReflectionMapping;\n  }\n  return __defaultEnvmap;\n}\n\nvar TextureLoader = function () {\n  this.loadTexture = __loadTexture;\n  this.loadVideoTexture = null;\n};\n\nTextureLoader.prototype.getTexturePath = function(name, origExt) {\n  var digits = /^\\d+$/;\n  var ext = '.' + (origExt || 'jpg');\n  if (!origExt) {\n    if (name.substr(0, 6) === 'leaves' || name.substr(0, 6) === 'flower' ||\n      name.substr(0, 5) === 'leaf_' || name.substr(0, 6) === 'spruce' || name === 'Settler') {\n      ext = '.png';\n    }\n  }\n  if (name.match(digits)) {\n    return 's/' + name + ext;\n  } else {\n    return name + ext;\n  }\n};\n\nTextureLoader.prototype.updateMaterials = function (mesh, config) {\n  if (Array.isArray(mesh.material)) {\n    for (var i = 0, l = mesh.material.length; i < l; i++) {\n      var meshMaterial = mesh.material[i];\n      mesh.material[i] = this.updateMaterial(meshMaterial, config, i);\n    }\n  } else if (mesh.material instanceof THREE.MultiMaterial) {\n    for (var i = 0, l = mesh.material.materials.length; i < l; i++) {\n      var meshMaterial = mesh.material.materials[i];\n      mesh.material.materials[i] = this.updateMaterial(meshMaterial, config, i);\n    }\n  } else if (mesh.material.index != undefined) {\n    mesh.material = this.updateMaterial(mesh.material, config, mesh.material.index);\n  } else {\n    console.warn('Skipping applyMaterial for model ' + config.id + ': not MultiMaterial');\n  }\n};\n\nTextureLoader.prototype.updateMaterial = function (meshMaterial, config, matIndex) {\n  meshMaterial.side = THREE.DoubleSide;\n  var matConfig = (config.materials? config.materials[matIndex] : null) || {};\n  var matname = (meshMaterial.name || matConfig.name).toLowerCase();\n  // if (matConfig.name && (meshMaterial.name !== matConfig.name)) {\n  //   console.warn('Mismatched material name: orig=' + meshMaterial.name + ', config=' + matConfig.name + \", index=\" + matIndex);\n  //   console.log('Material and config', meshMaterial, config);\n  // }\n  var objectType = config.className;\n  if ((objectType === 'Window' || objectType === 'Door') && matname === 'color_1') {\n    meshMaterial.opacity = 0.3;\n    meshMaterial.transparent = true;\n    meshMaterial.envMap = config.reflectionCube;\n    meshMaterial.metal = true;\n    meshMaterial.shininess = 200;\n    meshMaterial.reflectivity = 1;\n    meshMaterial.refractionRatio = 0.8;\n    meshMaterial.combine = THREE.MixOperation;\n  }\n  if (meshMaterial.map != null || matConfig.texture) {\n    if (matname.startsWith('material_')) {\n      // Tweak to matname based on the image src (for obj/mtl models)\n      var texture = matConfig.texture || meshMaterial.map;\n      var imgSrc = texture.name || (texture.image? texture.image.src : null);\n      if (imgSrc) {\n        var parts = imgSrc.split('/');\n        matname = parts[parts.length-1].split('.')[0].toLowerCase();\n      }\n    }\n    var alphaTweak = false;\n    if (matname.substr(0, 6) === 'leaves' || matname.substr(0, 6) === 'flower' ||\n      matname.substr(0, 5) === 'leaf_' || matname.substr(0, 6) === 'spruce') {\n      alphaTweak = true;\n    }\n    if (matConfig.texture) {\n      // Only load texture if the texture is different from the current one\n      var textureName = this.getTexturePath(matConfig.texture);\n      var textureChanged = !meshMaterial.map;\n      if (meshMaterial.map) {\n        // Clone so async loading of image textures don't affect our copy\n        var name = meshMaterial.map.name; // not cloned for some reason\n        if (textureName !== name) {\n          meshMaterial.map = meshMaterial.map.clone();\n          meshMaterial.map.name = name;\n          textureChanged = true;\n        }\n        // } else {\n        //   console.log(\"New texture: \" + newMat.texture, mesh);\n      }\n      if (textureChanged) {\n//        console.log('Replacing texture ' + origTexName + ' with ' + textureName + ' on model ' + config.id + ', material ' + material.name);\n        var loadedTexture = this.loadTexture(textureName, function (material, name, texture) {\n          material.map.name = name;\n          material.map.image = texture.image;\n          material.map.needsUpdate = true;\n        }.bind(this, meshMaterial, textureName));\n        if (!meshMaterial.map) {\n          meshMaterial.map = loadedTexture;\n        }\n      }\n      meshMaterial.color = new THREE.Color(matConfig.diffuse || matConfig.tcolor || 0xffffff);\n    }\n    if (alphaTweak) {\n      meshMaterial.opacity = 1;\n      meshMaterial.alphaTest = 0.6;\n      //meshMaterial.depthWrite = false;\n    }\n  } else if (!meshMaterial.map && matname === 'video' && this.loadVideoTexture) {\n    var vt = this.loadVideoTexture();\n    meshMaterial = new THREE.MeshBasicMaterial( {\n      name: \"video\",\n      map: vt.texture,\n      overdraw: 0.5 // TODO: what is right value here?\n    });\n    meshMaterial.video = vt.video;\n  } else {\n    if (matConfig.color) {\n      meshMaterial.color = new THREE.Color(matConfig.color);\n    } else if (matConfig.diffuse) {\n      meshMaterial.color = new THREE.Color(matConfig.diffuse);\n    }\n    if (matname.substr(0, 6) == 'chrome' || matname === 'mirror') {\n      meshMaterial.envMap = config.reflectionCube;\n      meshMaterial.metal = true;\n      meshMaterial.shininess = 200;\n      meshMaterial.reflectivity = 1;\n      meshMaterial.refractionRatio = 0.8;\n      meshMaterial.ambient = new THREE.Color(0xFFFFFF);\n    }\n  }\n  if (meshMaterial instanceof THREE.MeshPhysicalMaterial) {\n    if (meshMaterial.metal) {\n      meshMaterial.metalness = 1;\n      // TODO(MS): Use a less hacky environment map\n      meshMaterial.envMap = this.envMap || __getDefaultEnvmap();\n      delete meshMaterial.metal;\n    }\n    if (meshMaterial.shininess) {\n      meshMaterial.roughness = 1 - THREE.Math.clamp(meshMaterial.shininess / 200, 0, 1);\n      delete meshMaterial.shininess;\n    }\n    delete meshMaterial.specular;\n  }\n  return meshMaterial;\n};\n\nmodule.exports = TextureLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/P5DTextureLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/PLYLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/PLYLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Modified version of THREE.PLYLoader from three.js\n * @author Wei Meng / http://about.me/menway\n *\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tvar loader = new THREE.PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * diffuse_(red|green|blue) in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\n\nTHREE.PLYLoader = function ( params ) {\n\tvar manager = ( params ) ? params.manager : undefined;\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\n\tthis.computeNormals = params.computeNormals;\n\n\tthis.propertyNameMapping = params.propertyNameMapping || {};\n\tthis.customFaceAttributes = params.customFaceAttributes;\n  this.customVertexAttributes = params.customVertexAttributes;\n};\n\nTHREE.PLYLoader.prototype = {\n\n\tconstructor: THREE.PLYLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\tloader.setResponseType( 'arraybuffer' );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tsetPropertyNameMapping: function ( mapping ) {\n\n\t\tthis.propertyNameMapping = mapping;\n\n\t},\n\n\tparse: function ( data ) {\n\n\t\tfunction isASCII( data ) {\n\t\t\tvar header = parseHeader( bin2str_header( data ) );\n\t\t\treturn header.format === 'ascii';\n\n\t\t}\n\n\t\tfunction bin2str( buf ) {\n\n\t\t\tvar array_buffer = new Uint8Array( buf );\n\t\t\tvar str = '';\n\n\t\t\tfor ( var i = 0; i < buf.byteLength; i ++ ) {\n\n\t\t\t\tstr += String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian\n\n\t\t\t}\n\n\t\t\treturn str;\n\n\t\t}\n\n\t\t// Convert header to string\n\t\tfunction bin2str_header ( buf ) {\n\n\t\t\tvar array_buffer = new Uint8Array( buf );\n\t\t\tvar str = '';\n\t\t\tfor ( var i = 0; i < buf.byteLength; i ++ ) {\n\t\t\t\tvar ch = String.fromCharCode( array_buffer[ i ] ); // implicitly assumes little-endian\n\t\t\t\tstr += ch;\n\t\t\t\tif (ch === '\\n') {\n\t\t\t\t\t// Check if header ended\n\t\t\t\t\tif (str.indexOf('end_header') >= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn str;\n\n\t\t}\n\n\t\tfunction parseHeader( data ) {\n\n\t\t\tvar patternHeader = /ply([\\s\\S]*)end_header\\s/;\n\t\t\tvar headerText = '';\n\t\t\tvar headerLength = 0;\n\t\t\tvar result = patternHeader.exec( data );\n\n\t\t\tif ( result !== null ) {\n\n\t\t\t\theaderText = result [ 1 ];\n\t\t\t\theaderLength = result[ 0 ].length;\n\n\t\t\t}\n\n\t\t\tvar header = {\n\t\t\t\tcomments: [],\n\t\t\t\telements: [],\n\t\t\t\theaderLength: headerLength\n\t\t\t};\n\n\t\t\tvar lines = headerText.split( '\\n' );\n\t\t\tvar currentElement;\n\t\t\tvar lineType, lineValues;\n\n\t\t\tfunction make_ply_element_property( propertValues, propertyNameMapping ) {\n\n\t\t\t\tvar property = { type: propertValues[ 0 ] };\n\n\t\t\t\tif ( property.type === 'list' ) {\n\n\t\t\t\t\tproperty.name = propertValues[ 3 ];\n\t\t\t\t\tproperty.countType = propertValues[ 1 ];\n\t\t\t\t\tproperty.itemType = propertValues[ 2 ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tproperty.name = propertValues[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t\tif ( property.name in propertyNameMapping ) {\n\n\t\t\t\t\tproperty.name = propertyNameMapping[ property.name ];\n\n\t\t\t\t}\n\n\t\t\t\treturn property;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\n\t\t\t\tif ( line === '' ) continue;\n\n\t\t\t\tlineValues = line.split( /\\s+/ );\n\t\t\t\tlineType = lineValues.shift();\n\t\t\t\tline = lineValues.join( ' ' );\n\n\t\t\t\tswitch ( lineType ) {\n\n\t\t\t\t\tcase 'format':\n\n\t\t\t\t\t\theader.format = lineValues[ 0 ];\n\t\t\t\t\t\theader.version = lineValues[ 1 ];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'comment':\n\n\t\t\t\t\t\theader.comments.push( line );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'element':\n\n\t\t\t\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcurrentElement = {};\n\t\t\t\t\t\tcurrentElement.name = lineValues[ 0 ];\n\t\t\t\t\t\tcurrentElement.count = parseInt( lineValues[ 1 ] );\n\t\t\t\t\t\tcurrentElement.properties = [];\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'property':\n\n\t\t\t\t\t\tcurrentElement.properties.push( make_ply_element_property( lineValues, scope.propertyNameMapping ) );\n\n\t\t\t\t\t\tbreak;\n\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tconsole.log( 'unhandled', lineType, lineValues );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( currentElement !== undefined ) {\n\n\t\t\t\theader.elements.push( currentElement );\n\n\t\t\t}\n\n      var elementsByName = {};\n      for (var i = 0; i < header.elements.length; i++) {\n      \tvar element = header.elements[i];\n        elementsByName[element.name] = element;\n\n      \tvar propertiesByName = {};\n      \tfor (var j = 0; j < element.properties.length; j++) {\n      \t\tvar prop = element.properties[j];\n      \t\tpropertiesByName[prop.name] = prop;\n        }\n        element.propertiesByName = propertiesByName;\n      }\n      header.elementsByName = elementsByName;\n\n      return header;\n\n\t\t}\n\n\t\tfunction parseASCIINumber( n, type ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\tcase 'char': case 'uchar': case 'short': case 'ushort': case 'int': case 'uint':\n\t\t\tcase 'int8': case 'uint8': case 'int16': case 'uint16': case 'int32': case 'uint32':\n\n\t\t\t\treturn parseInt( n );\n\n\t\t\tcase 'float': case 'double': case 'float32': case 'float64':\n\n\t\t\t\treturn parseFloat( n );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseASCIIElement( properties, line ) {\n\n\t\t\tvar values = line.split( /\\s+/ );\n\n\t\t\tvar element = {};\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\t\t\t\t\tvar n = parseASCIINumber( values.shift(), properties[ i ].countType );\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tlist.push( parseASCIINumber( values.shift(), properties[ i ].itemType ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\telement[ properties[ i ].name ] = parseASCIINumber( values.shift(), properties[ i ].type );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn element;\n\n\t\t}\n\n\t\tfunction createBuffer(header) {\n      //console.log(header);\n      var buffer = {\n        indices : [],\n        vertices : [],\n        normals : [],\n        uvs : [],\n        colors : []\n      };\n\n      // Additional attributes to keep\n      if (scope.customVertexAttributes) {\n      \tvar customVertexAttributes = scope.customVertexAttributes;\n        buffer.customVertexAttributes = {};\n        for (var i = 0; i < customVertexAttributes.length; i++) {\n\t\t\t\t\tbuffer.customVertexAttributes[customVertexAttributes[i]] = [];\n        }\n      }\n      if (scope.customFaceAttributes) {\n        var customFaceAttributes = scope.customFaceAttributes;\n      \tbuffer.customFaceAttributes = {};\n      \tfor (var i = 0; i < customFaceAttributes.length; i++) {\n          buffer.customFaceAttributes[customFaceAttributes[i]] = [];\n\t\t\t\t}\n\t\t\t}\n      return buffer;\n\t\t}\n\n\t\tfunction parseASCII( data ) {\n\n\t\t\t// PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      console.time('parseASCII');\n\t\t\tvar result;\n\n\t\t\tvar header = parseHeader( data );\n      var buffer = createBuffer(header);\n\t\t\t\n      var patternBody = /end_header\\s([\\s\\S]*)$/;\n\t\t\tvar body = '';\n\t\t\tif ( ( result = patternBody.exec( data ) ) !== null ) {\n\n\t\t\t\tbody = result [ 1 ];\n\n\t\t\t}\n\n\t\t\tvar lines = body.split( '\\n' );\n\t\t\tvar currentElement = 0;\n\t\t\tvar currentElementCount = 0;\n\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\n\n\t\t\t\tvar line = lines[ i ];\n\t\t\t\tline = line.trim();\n\t\t\t\tif ( line === '' ) {\n\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tif ( currentElementCount >= header.elements[ currentElement ].count ) {\n\n\t\t\t\t\tcurrentElement ++;\n\t\t\t\t\tcurrentElementCount = 0;\n\n\t\t\t\t}\n\n\t\t\t\tvar element = parseASCIIElement( header.elements[ currentElement ].properties, line );\n\n\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\tcurrentElementCount ++;\n\n\t\t\t}\n\n\t\t\tconsole.timeEnd('parseASCII');\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\tfunction postProcess( buffer ) {\n\n      console.time('postProcess');\n\t\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\t\t// mandatory buffer data\n\n\t\t\tif (buffer.indices.length > 0) {\n\t\t\t\tgeometry.setIndex( new ( (buffer.vertices.length/3) > 65535 ? THREE.Uint32BufferAttribute : THREE.Uint16BufferAttribute )( buffer.indices, 1 ) );\n\t\t\t}\n\t\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( buffer.vertices, 3 ) );\n\n\t\t\t// optional buffer data\n\t\t\tif (scope.computeNormals) {\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeVertexNormals();\n\t\t\t} else {\n\t\t\t\tif (buffer.normals.length > 0) {\n\n\t\t\t\t\tgeometry.setAttribute( 'normal', new THREE.Float32BufferAttribute( buffer.normals, 3 ) );\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( buffer.uvs.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( buffer.uvs, 2 ) );\n\n\t\t\t}\n\n\t\t\tif ( buffer.colors.length > 0 ) {\n\n\t\t\t\tgeometry.setAttribute( 'color', new THREE.Float32BufferAttribute( buffer.colors, 3 ) );\n\n\t\t\t}\n\n\t\t\tgeometry.computeBoundingSphere();\n\n      if (buffer.customVertexAttributes) {\n      \tgeometry.customVertexAttributes = buffer.customVertexAttributes;\n\t\t\t}\n      if (buffer.customFaceAttributes) {\n        geometry.customFaceAttributes = buffer.customFaceAttributes;\n      }\n\n      console.timeEnd('postProcess');\n\n\t\t\treturn geometry;\n\n\t\t}\n\n\t\tfunction handleElement( buffer, elementName, element ) {\n\n\t\t\tif ( elementName === 'vertex' ) {\n\n        buffer.vertices.push( element.x, element.y, element.z );\n\n\t\t\t\tif ( 'nx' in element && 'ny' in element && 'nz' in element ) {\n\n\t\t\t\t\tbuffer.normals.push( element.nx, element.ny, element.nz );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 's' in element && 't' in element ) {\n\n\t\t\t\t\tbuffer.uvs.push( element.s, element.t );\n\n\t\t\t\t}\n\n\t\t\t\tif ( 'red' in element && 'green' in element && 'blue' in element ) {\n\n\t\t\t\t\tbuffer.colors.push( element.red / 255.0, element.green / 255.0, element.blue / 255.0 );\n\n\t\t\t\t}\n\n        if (buffer.customVertexAttributes) {\n          for (var k in buffer.customVertexAttributes) {\n            if (buffer.customVertexAttributes.hasOwnProperty(k) && k in element) {\n              buffer.customVertexAttributes[k].push(element[k]);\n            }\n          }\n        }\n\n\t\t\t} else if ( elementName === 'face' ) {\n\n\t\t\t\tvar vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n\n\t\t\t\tif ( vertex_indices.length === 3 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 2 ] );\n\n\t\t\t\t} else if ( vertex_indices.length === 4 ) {\n\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 0 ], vertex_indices[ 1 ], vertex_indices[ 3 ] );\n\t\t\t\t\tbuffer.indices.push( vertex_indices[ 1 ], vertex_indices[ 2 ], vertex_indices[ 3 ] );\n\n\t\t\t\t}\n\n\t\t\t\tif (buffer.customFaceAttributes) {\n\t\t\t\t\tfor (var k in buffer.customFaceAttributes) {\n\t\t\t\t\t\tif (buffer.customFaceAttributes.hasOwnProperty(k) && k in element) {\n              if ( vertex_indices.length === 3 ) {\n                buffer.customFaceAttributes[k].push(element[k]);\n              } else if ( vertex_indices.length === 4) {\n                buffer.customFaceAttributes[k].push(element[k]);\n                buffer.customFaceAttributes[k].push(element[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryRead( dataview, at, type, little_endian ) {\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\t// correspondences for non-specific length types here match ply:\n\t\t\t\tcase 'int8':\t\tcase 'char':\t return [ dataview.getInt8( at ), 1 ];\n\t\t\t\tcase 'uint8':\t\tcase 'uchar':\t return [ dataview.getUint8( at ), 1 ];\n\t\t\t\tcase 'int16':\t\tcase 'short':\t return [ dataview.getInt16( at, little_endian ), 2 ];\n\t\t\t\tcase 'uint16':\tcase 'ushort': return [ dataview.getUint16( at, little_endian ), 2 ];\n\t\t\t\tcase 'int32':\t\tcase 'int':\t\t return [ dataview.getInt32( at, little_endian ), 4 ];\n\t\t\t\tcase 'uint32':\tcase 'uint':\t return [ dataview.getUint32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float32': case 'float':\t return [ dataview.getFloat32( at, little_endian ), 4 ];\n\t\t\t\tcase 'float64': case 'double': return [ dataview.getFloat64( at, little_endian ), 8 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction binaryReadElement( dataview, at, properties, little_endian ) {\n\n\t\t\tvar element = {};\n\t\t\tvar result, read = 0;\n\n\t\t\tfor ( var i = 0; i < properties.length; i ++ ) {\n\n\t\t\t\tif ( properties[ i ].type === 'list' ) {\n\n\t\t\t\t\tvar list = [];\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].countType, little_endian );\n\t\t\t\t\tvar n = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\tfor ( var j = 0; j < n; j ++ ) {\n\n\t\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].itemType, little_endian );\n\t\t\t\t\t\tlist.push( result[ 0 ] );\n\t\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t\t}\n\n\t\t\t\t\telement[ properties[ i ].name ] = list;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult = binaryRead( dataview, at + read, properties[ i ].type, little_endian );\n\t\t\t\t\telement[ properties[ i ].name ] = result[ 0 ];\n\t\t\t\t\tread += result[ 1 ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn [ element, read ];\n\n\t\t}\n\n\t\tfunction parseBinary( data ) {\n\n      console.time('parseBinary');\n\t\t\tvar header = parseHeader( bin2str_header( data ) );\n      var buffer = createBuffer(header);\n      var little_endian = ( header.format === 'binary_little_endian' );\n\t\t\tvar body = new DataView( data, header.headerLength );\n\t\t\tvar result, loc = 0;\n\n\t\t\tfor ( var currentElement = 0; currentElement < header.elements.length; currentElement ++ ) {\n\n\t\t\t\tfor ( var currentElementCount = 0; currentElementCount < header.elements[ currentElement ].count; currentElementCount ++ ) {\n\n\t\t\t\t\tresult = binaryReadElement( body, loc, header.elements[ currentElement ].properties, little_endian );\n\t\t\t\t\tloc += result[ 1 ];\n\t\t\t\t\tvar element = result[ 0 ];\n\n\t\t\t\t\thandleElement( buffer, header.elements[ currentElement ].name, element );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tconsole.timeEnd('parseBinary');\n\n\t\t\treturn postProcess( buffer );\n\n\t\t}\n\n\t\t//\n\n\t\tvar geometry;\n\t\tvar scope = this;\n\n\t\tif ( data instanceof ArrayBuffer ) {\n\n\t\t\tgeometry = isASCII( data ) ? parseASCII( bin2str( data ) ) : parseBinary( data );\n\n\t\t} else {\n\n\t\t\tgeometry = parseASCII( data );\n\n\t\t}\n\n\t\treturn geometry;\n\n\t}\n\n};\n\n//# sourceURL=webpack://STK/./js/lib/loaders/PLYLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/Shape2MotionOBJPartLoader.js":
/*!*****************************************************!*\
  !*** ./js/lib/loaders/Shape2MotionOBJPartLoader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nconst Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst PartHierarchy = __webpack_require__(/*! parts/PartHierarchy */ \"./js/lib/parts/PartHierarchy.js\");\nconst async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nclass SimpleObjLoader {\n  constructor() {}\n\n  load(info, callback) {\n    if (info.loadMtl) {\n      const objLoader = new THREE.OBJMTLLoader();\n      objLoader.load(info.file, null, {}, function (object3D) {\n        callback(null, object3D);\n      }, null, function (err) {\n        console.error('Error loading path ' + info.file);\n        callback(err);\n      });\n    } else {\n      const objLoader = new THREE.OBJLoader();\n      objLoader.load(info.file, function (object3D) {\n        callback(null, object3D);\n      }, null, function (err) {\n        console.error('Error loading path ' + info.file);\n        callback(err);\n      });\n    }\n  }\n}\n\n/**\n * Loader for part annotations that consists of a json file describing the part hierarchy with pointers to obj files\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction OBJPartLoader(params) {\n  this.fs = params.fs;\n  this.debug = params.debug;\n  this.meshPath = params.meshPath || 'part_objs/';\n  this.objectLoadOptions = params.objectLoadOptions || {};\n  this.objectLoader = params.objectLoader || new SimpleObjLoader();\n}\n\nOBJPartLoader.prototype.constructor = OBJPartLoader;\n\nOBJPartLoader.prototype.parse = function(data) {\n  const json = JSON.parse(data);\n  const tree = new PartHierarchy(json);\n  let index = 0;\n  const partHierarchy = tree.convert(n => {\n    const part = new Part(index, null, n.dof_name, null, null);\n    part.filename = (n.dof_name === 'dof_rootd')? 'none_motion' : n.dof_name;\n    // motion_type is translation, rotation, spiral, and none\n    if (n.motion_type && n.motion_type !== 'none') {\n      const articulation = {type: n.motion_type, axis: n.direction, origin: n.center};\n      // AXS: Arbitrary ranges for shape2motion based on javascript code\n      if (n.motion_type === 'translation') {\n        articulation.rangeMin = 0;\n        articulation.rangeMax = 0.005*60;\n        part.articulation = [articulation];\n      } else if (n.motion_type === 'rotation') {\n        articulation.rangeMin = 0;\n        articulation.rangeMax = 60*Math.PI/180;\n        part.articulation = [articulation];\n      } else if (n.motion_type === 'spiral') {\n        const art2 = _.clone(articulation);\n        articulation.type = 'translation';\n        articulation.rangeMin = 0;\n        articulation.rangeMax = 0.005*60;\n        art2.type = 'rotation';\n        art2.rangeMin = 0;\n        art2.rangeMax = 60*Math.PI/180;\n        part.articulation = [articulation, art2];\n      }\n    }\n    index++;\n    return part;\n  });\n  return partHierarchy;\n};\n\n/**\n * Load and parses object parts file\n * @param file\n * @param callback {function(err, Object)}\n */\nOBJPartLoader.prototype.load = function(file, callback) {\n  const filename = file.name || file;\n  const scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      try {\n        var partHierarchy = scope.parse(data);\n        var objNodes = partHierarchy.getNodes();\n        var dirname = _.getPath(_.getDirname(filename), scope.meshPath);\n        async.mapLimit(objNodes, Constants.MAX_ASYNC_REQS, function(objNode, cb) {\n          scope.__loadObjs(dirname, [objNode.filename], cb);\n        }, function(err, results) {\n          // Do some surgery on the results\n          if (err) {\n            callback(err);\n          } else {\n            try {\n              for (let i = 0; i < objNodes.length; i++) {\n                const objNode = objNodes[i];\n                const objs = results[i];\n                const g = partHierarchy.createObjectGroup(objNode, objs);\n                objNode.object3D = g;\n              }\n              partHierarchy.attachChildObject3Ds();\n              callback(null, partHierarchy);\n            } catch(e) {\n              callback(e);\n            }\n          }\n        });\n      } catch(e) {\n        callback(e);\n      }\n    }\n  });\n};\n\nOBJPartLoader.prototype.__loadObjs = function(path, objnames, callback) {\n  const loadOptions = this.objectLoadOptions;\n  const objectLoader = this.objectLoader;\n  async.mapLimit(objnames, Constants.MAX_ASYNC_REQS, function(objname, cb) {\n    const objpath = _.getPath(path, objname + \".obj\");\n    const modelinfo = { file: objpath, format: 'obj', options: loadOptions };\n    objectLoader.load(modelinfo, obj => { obj.userData.id = objname; return cb(null, obj); }, err => callback(err, null));\n  }, callback);\n};\n\nmodule.exports = OBJPartLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/Shape2MotionOBJPartLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/URDFLoader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/URDFLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const TaskQueue = __webpack_require__(/*! util/TaskQueue */ \"./js/lib/util/TaskQueue.js\");\n\nfunction URDFColliderClone(...args) {\n\n    const proto = Object.getPrototypeOf(this);\n    const result = proto.clone.call(this, ...args);\n    result.isURDFCollider = true;\n    return result;\n\n}\n\nfunction makeURDFCollider(object) {\n\n    object.isURDFCollider = true;\n    object.clone = URDFColliderClone;\n\n}\n\nclass URDFLink extends THREE.Object3D {\n\n    constructor(...args) {\n\n        super(...args);\n        this.isURDFLink = true;\n        this.type = 'URDFLink';\n        this.urdfNode = null;\n\n    }\n\n    copy(source, recursive) {\n\n        super.copy(source, recursive);\n        this.urdfNode = source.urdfNode;\n        return this;\n\n    }\n\n}\n\nclass URDFJoint extends THREE.Object3D {\n\n    get jointType() {\n\n        return this._jointType;\n\n    }\n    set jointType(v) {\n\n        if (this.jointType === v) return;\n        this._jointType = v;\n\n        switch (v) {\n\n            case 'fixed':\n            case 'continuous':\n            case 'revolute':\n            case 'prismatic':\n                this.jointValue = 0;\n                break;\n\n            case 'planar':\n                this.jointValue = new Array(2).fill(0);\n                break;\n\n            case 'floating':\n                this.jointValue = new Array(6).fill(0);\n                break;\n\n        }\n\n    }\n\n    get angle() {\n\n        return this.jointValue;\n\n    }\n\n    constructor(...args) {\n        super(...args);\n\n        this.isURDFJoint = true;\n        this.type = 'URDFJoint';\n\n        this.urdfNode = null;\n        this.jointValue = null;\n        this.jointType = 'fixed';\n        this.axis = null;\n        this.limit = { lower: 0, upper: 0 };\n        this.ignoreLimits = false;\n\n        this.origPosition = null;\n        this.origQuaternion = null;\n    }\n\n    /* Overrides */\n    copy(source, recursive) {\n\n        super.copy(source, recursive);\n\n        this.urdfNode = source.urdfNode;\n        this.jointType = source.jointType;\n        this.axis = source.axis ? source.axis.clone() : null;\n        this.limit.lower = source.limit.lower;\n        this.limit.upper = source.limit.upper;\n        this.ignoreLimits = false;\n\n        this.jointValue = Array.isArray(source.jointValue) ? [...source.jointValue] : source.jointValue;\n\n        this.origPosition = source.origPosition ? source.origPosition.clone() : null;\n        this.origQuaternion = source.origQuaternion ? source.origQuaternion.clone() : null;\n\n        return this;\n    }\n\n    /* Public Functions */\n    setAngle(...values) {\n        return this.setOffset(...values);\n    }\n\n    setOffset(...values) {\n\n        values = values.map(v => parseFloat(v));\n\n        if (!this.origPosition || !this.origQuaternion) {\n\n            this.origPosition = this.position.clone();\n            this.origQuaternion = this.quaternion.clone();\n\n        }\n\n        switch (this.jointType) {\n\n            case 'fixed': {\n                break;\n            }\n            case 'continuous':\n            case 'revolute': {\n\n                let angle = values[0];\n                if (angle == null) break;\n                if (angle === this.jointValue) break;\n\n                if (!this.ignoreLimits && this.jointType === 'revolute') {\n\n                    angle = Math.min(this.limit.upper, angle);\n                    angle = Math.max(this.limit.lower, angle);\n\n                }\n\n                // FromAxisAngle seems to rotate the opposite of the\n                // expected angle for URDF, so negate it here\n                const delta = new THREE.Quaternion().setFromAxisAngle(this.axis, angle);\n                this.quaternion.multiplyQuaternions(this.origQuaternion, delta);\n\n                this.jointValue = angle;\n                this.matrixWorldNeedsUpdate = true;\n\n                break;\n            }\n\n            case 'prismatic': {\n\n                let angle = values[0];\n                if (angle == null) break;\n                if (angle === this.jointValue) break;\n\n                if (!this.ignoreLimits) {\n\n                    angle = Math.min(this.limit.upper, angle);\n                    angle = Math.max(this.limit.lower, angle);\n\n                }\n\n                this.position.copy(this.origPosition);\n                this.position.addScaledVector(this.axis, angle);\n\n                this.jointValue = angle;\n                this.worldMatrixNeedsUpdate = true;\n                break;\n\n            }\n\n            case 'floating':\n            case 'planar':\n                // TODO: Support these joint types\n                console.warn(`'${ this.jointType }' joint not yet supported`);\n\n        }\n\n        return this.jointValue;\n\n    }\n\n}\n\nclass URDFRobot extends URDFLink {\n\n    constructor(...args) {\n\n        super(...args);\n        this.isURDFRobot = true;\n        this.urdfNode = null;\n\n        this.urdfRobotNode = null;\n        this.robotName = null;\n\n        this.links = null;\n        this.joints = null;\n\n    }\n\n    copy(source, recursive) {\n\n        super.copy(source, recursive);\n\n        this.urdfRobotNode = source.urdfRobotNode;\n        this.robotName = source.robotName;\n\n        this.links = {};\n        this.joints = {};\n\n        this.traverse(c => {\n\n            if (c.isURDFJoint && c.name in source.joints) {\n\n                this.joints[c.name] = c;\n\n            }\n\n            if (c.isURDFLink && c.name in source.links) {\n\n                this.links[c.name] = c;\n\n            }\n\n        });\n\n        return this;\n\n    }\n\n    setAngle(jointName, ...angle) {\n\n        const joint = this.joints[jointName];\n        if (joint) {\n\n            return joint.setAngle(...angle);\n\n        }\n\n        return null;\n    }\n\n    setAngles(angles) {\n\n        // TODO: How to handle other, multi-dimensional joint types?\n        for (const name in angles) this.setAngle(name, angles[name]);\n\n    }\n\n}\n\n/*\nReference coordinate frames for THREE.js and ROS.\nBoth coordinate systems are right handed so the URDF is instantiated without\nframe transforms. The resulting model can be rotated to rectify the proper up,\nright, and forward directions\n\nTHREE.js\n   Y\n   |\n   |\n   .-----X\n \nZ\n\nROS URDf\n       Z\n       |   X\n       | \n Y-----.\n\n*/\n\nconst tempQuaternion = new THREE.Quaternion();\nconst tempEuler = new THREE.Euler();\n\n// take a vector \"x y z\" and process it into\n// an array [x, y, z]\nfunction processTuple(val) {\n\n    if (!val) return [0, 0, 0];\n    return val.trim().split(/\\s+/g).map(num => parseFloat(num));\n\n}\n\n// applies a rotation a threejs object in URDF order\nfunction applyRotation(obj, rpy, additive = false) {\n\n    // if additive is true the rotation is applied in\n    // addition to the existing rotation\n    if (!additive) obj.rotation.set(0, 0, 0);\n\n    tempEuler.set(rpy[0], rpy[1], rpy[2], 'ZYX');\n    tempQuaternion.setFromEuler(tempEuler);\n    tempQuaternion.multiply(obj.quaternion);\n    obj.quaternion.copy(tempQuaternion);\n\n}\n\n/* URDFLoader Class */\n// Loads and reads a URDF file into a THREEjs Object3D format\nclass URDFLoader {\n\n    constructor(manager) {\n\n        this.manager = manager || THREE.DefaultLoadingManager;\n\n    }\n\n    /* Public API */\n    // urdf:    The path to the URDF within the package OR absolute\n    // onComplete:      Callback that is passed the model once loaded\n    load(urdf, onComplete, options) {\n\n        // Check if a full URI is specified before\n        // prepending the package info\n        const manager = this.manager;\n        const workingPath = THREE.LoaderUtils.extractUrlBase(urdf);\n        const urdfPath = this.manager.resolveURL(urdf);\n\n        options = Object.assign({\n            workingPath,\n        }, options);\n        // AXC: Have taskqueue so we can wait for all meshes to be loaded\n        options.taskQueue = new TaskQueue({ concurrency: 5});\n\n        manager.itemStart(urdfPath);\n        fetch(urdfPath, options.fetchOptions)\n            .then(res => res.text())\n            .then(data => {\n                const model = this.parse(data, options);\n                // AXC: Have taskqueue so we can wait for all meshes to be loaded\n                options.taskQueue.awaitAll(() => {\n                    onComplete(model);\n                    manager.itemEnd(urdfPath);\n                });\n            })\n            .catch(e => {\n\n                // TODO: Add onProgress and onError functions here\n                console.error('URDFLoader: Error parsing file.', e);\n                manager.itemError(urdfPath);\n                manager.itemEnd(urdfPath);\n\n            });\n\n    }\n\n    parse(content, options = {}) {\n\n        const packages = options.packages || '';\n        // AXC: Have taskqueue so we can wait for all meshes to be loaded\n        const taskQueue = options.taskQueue || new TaskQueue();\n        const loadMeshCb = options.loadMeshCb || this.defaultMeshLoader.bind(this);\n        const workingPath = options.workingPath || '';\n        const parseVisual = ('parseVisual' in options) ? options.parseVisual : true;\n        const parseCollision = options.parseCollision || false;\n        const manager = this.manager;\n        const linkMap = {};\n        const jointMap = {};\n        const materialMap = {};\n\n        // Resolves the path of mesh files\n        function resolvePath(path) {\n\n            if (!/^package:\\/\\//.test(path)) {\n\n                return workingPath ? workingPath + path : path;\n\n            }\n\n            // Remove \"package://\" keyword and split meshPath at the first slash\n            const [targetPkg, relPath] = path.replace(/^package:\\/\\//, '').split(/\\/(.+)/);\n\n            if (typeof packages === 'string') {\n\n                // \"pkg\" is one single package\n                if (packages.endsWith(targetPkg)) {\n\n                    // \"pkg\" is the target package\n                    return packages + '/' + relPath;\n\n                } else {\n\n                    // Assume \"pkg\" is the target package's parent directory\n                    return packages + '/' + targetPkg + '/' + relPath;\n\n                }\n\n            } else if (typeof packages === 'object') {\n\n                // \"pkg\" is a map of packages\n                if (targetPkg in packages) {\n\n                    return packages[targetPkg] + '/' + relPath;\n\n                } else {\n\n                    console.error(`URDFLoader : ${ targetPkg } not found in provided package list.`);\n                    return null;\n\n                }\n\n            }\n\n        }\n\n        // Process the URDF text format\n        function processUrdf(data) {\n\n            const parser = new DOMParser();\n            const urdf = parser.parseFromString(data, 'text/xml');\n            const children = [ ...urdf.children ];\n\n            const robotNode = children.filter(c => c.nodeName === 'robot').pop();\n            return processRobot(robotNode);\n\n        }\n\n        // Process the <robot> node\n        function processRobot(robot) {\n\n            const robotNodes = [ ...robot.children ];\n            const links = robotNodes.filter(c => c.nodeName.toLowerCase() === 'link');\n            const joints = robotNodes.filter(c => c.nodeName.toLowerCase() === 'joint');\n            const materials = robotNodes.filter(c => c.nodeName.toLowerCase() === 'material');\n            const obj = new URDFRobot();\n\n            obj.robotName = robot.getAttribute('name');\n            obj.urdfRobotNode = robot;\n\n            // Create the <material> map\n            materials.forEach(m => {\n\n                const name = m.getAttribute('name');\n                materialMap[name] = processMaterial(m);\n\n            });\n\n            // Create the <link> map\n            links.forEach(l => {\n\n                const name = l.getAttribute('name');\n                const isRoot = robot.querySelector(`child[link=\"${ name }\"]`) === null;\n                linkMap[name] = processLink(l, isRoot ? obj : null);\n\n            });\n\n            // Create the <joint> map\n            joints.forEach(j => {\n\n                const name = j.getAttribute('name');\n                jointMap[name] = processJoint(j);\n\n            });\n\n            obj.joints = jointMap;\n            obj.links = linkMap;\n\n            return obj;\n\n        }\n\n        // Process joint nodes and parent them\n        function processJoint(joint) {\n\n            const children = [ ...joint.children ];\n            const jointType = joint.getAttribute('type');\n            const obj = new URDFJoint();\n            obj.urdfNode = joint;\n            obj.name = joint.getAttribute('name');\n            obj.jointType = jointType;\n\n            let parent = null;\n            let child = null;\n            let xyz = [0, 0, 0];\n            let rpy = [0, 0, 0];\n\n            // Extract the attributes\n            children.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'origin') {\n\n                    xyz = processTuple(n.getAttribute('xyz'));\n                    rpy = processTuple(n.getAttribute('rpy'));\n\n                } else if (type === 'child') {\n\n                    child = linkMap[n.getAttribute('link')];\n\n                } else if (type === 'parent') {\n\n                    parent = linkMap[n.getAttribute('link')];\n\n                } else if (type === 'limit') {\n\n                    obj.limit.lower = parseFloat(n.getAttribute('lower') || obj.limit.lower);\n                    obj.limit.upper = parseFloat(n.getAttribute('upper') || obj.limit.upper);\n\n                }\n\n            });\n\n            // Join the links\n            parent.add(obj);\n            obj.add(child);\n            applyRotation(obj, rpy);\n            obj.position.set(xyz[0], xyz[1], xyz[2]);\n\n            // Set up the rotate function\n            const axisNode = children.filter(n => n.nodeName.toLowerCase() === 'axis')[0];\n\n            if (axisNode) {\n\n                const axisXYZ = axisNode.getAttribute('xyz').split(/\\s+/g).map(num => parseFloat(num));\n                obj.axis = new THREE.Vector3(axisXYZ[0], axisXYZ[1], axisXYZ[2]);\n                obj.axis.normalize();\n\n            }\n\n            return obj;\n\n        }\n\n        // Process the <link> nodes\n        function processLink(link, target = null) {\n\n            if (target === null) {\n\n                target = new URDFLink();\n\n            }\n\n            const children = [ ...link.children ];\n            target.name = link.getAttribute('name');\n            target.urdfNode = link;\n\n            if (parseVisual) {\n                const visualNodes = children.filter(n => n.nodeName.toLowerCase() === 'visual');\n                visualNodes.forEach(vn => processLinkElement(vn, target, materialMap));\n            }\n            if (parseCollision) {\n                const collisionNodes = children.filter(n => n.nodeName.toLowerCase() === 'collision');\n                collisionNodes.forEach(vn => processLinkElement(vn, target));\n            }\n\n            return target;\n\n        }\n\n        function processMaterial(node) {\n\n            const matNodes = [ ...node.children ];\n            const material = new THREE.MeshPhongMaterial();\n\n            material.name = node.getAttribute('name') || '';\n            matNodes.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'color') {\n\n                    const rgba =\n                        n\n                            .getAttribute('rgba')\n                            .split(/\\s/g)\n                            .map(v => parseFloat(v));\n\n                    material.color.setRGB(rgba[0], rgba[1], rgba[2]);\n                    material.opacity = rgba[3];\n                    material.transparent = rgba[3] < 1;\n\n                } else if (type === 'texture') {\n\n                    // The URDF spec does not require that the <texture/> tag include\n                    // a filename attribute so skip loading the texture if not provided.\n                    const filename = n.getAttribute('filename');\n                    if (filename) {\n\n                        const loader = new THREE.TextureLoader(manager);\n                        const filePath = resolvePath(filename);\n                        material.map = loader.load(filePath);\n\n                    }\n\n                }\n            });\n\n            return material;\n\n        }\n\n        // Process the visual and collision nodes into meshes\n        function processLinkElement(vn, linkObj, materialMap = {}) {\n\n            const isCollisionNode = vn.nodeName.toLowerCase() === 'collision';\n            let xyz = [0, 0, 0];\n            let rpy = [0, 0, 0];\n            let scale = [1, 1, 1];\n\n            const children = [ ...vn.children ];\n            let material = null;\n            let primitiveModel = null;\n\n            // get the material first\n            const materialNode = children.filter(n => n.nodeName.toLowerCase() === 'material')[0];\n            if (materialNode) {\n\n                const name = materialNode.getAttribute('name');\n                if (name && name in materialMap) {\n\n                    material = materialMap[name];\n\n                } else {\n\n                    material = processMaterial(materialNode);\n\n                }\n\n            } else {\n\n                material = new THREE.MeshPhongMaterial();\n\n            }\n\n            children.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'geometry') {\n\n                    const geoType = n.children[0].nodeName.toLowerCase();\n                    if (geoType === 'mesh') {\n\n                        const filename = n.children[0].getAttribute('filename');\n                        const filePath = resolvePath(filename);\n\n                        // file path is null if a package directory is not provided.\n                        if (filePath !== null) {\n\n                            const scaleAttr = n.children[0].getAttribute('scale');\n                            if (scaleAttr) scale = processTuple(scaleAttr);\n\n                            // AXC: Have taskqueue so we can wait for all meshes to be loaded\n                            taskQueue.push((cb) => {\n                              loadMeshCb(filePath, manager, (obj, err) => {\n\n                                if (err) {\n\n                                    console.error('URDFLoader: Error loading mesh.', err);\n\n                                } else if (obj) {\n\n                                    if (obj instanceof THREE.Mesh) {\n\n                                        obj.material = material;\n\n                                    }\n\n                                    linkObj.add(obj);\n\n                                    obj.position.set(xyz[0], xyz[1], xyz[2]);\n                                    obj.rotation.set(0, 0, 0);\n\n                                    // multiply the existing scale by the scale components because\n                                    // the loaded model could have important scale values already applied\n                                    // to the root. Collada files, for example, can load in with a scale\n                                    // to convert the model units to meters.\n                                    obj.scale.x *= scale[0];\n                                    obj.scale.y *= scale[1];\n                                    obj.scale.z *= scale[2];\n\n                                    applyRotation(obj, rpy);\n\n                                    if (isCollisionNode) {\n\n                                        makeURDFCollider(obj);\n\n                                    }\n\n                                  }\n                                  cb();\n                                });\n\n                            });\n\n                        }\n\n                    } else if (geoType === 'box') {\n\n                        primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.BoxBufferGeometry(1, 1, 1);\n                        primitiveModel.material = material;\n\n                        const size = processTuple(n.children[0].getAttribute('size'));\n\n                        linkObj.add(primitiveModel);\n                        primitiveModel.scale.set(size[0], size[1], size[2]);\n\n                        if (isCollisionNode) {\n\n                            makeURDFCollider(primitiveModel);\n\n                        }\n\n                    } else if (geoType === 'sphere') {\n\n                        primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.SphereBufferGeometry(1, 30, 30);\n                        primitiveModel.material = material;\n\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n                        primitiveModel.scale.set(radius, radius, radius);\n\n                        linkObj.add(primitiveModel);\n\n                        if (isCollisionNode) {\n\n                            makeURDFCollider(primitiveModel);\n\n                        }\n\n                    } else if (geoType === 'cylinder') {\n\n                        primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.CylinderBufferGeometry(1, 1, 1, 30);\n                        primitiveModel.material = material;\n\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n                        const length = parseFloat(n.children[0].getAttribute('length')) || 0;\n                        primitiveModel.scale.set(radius, length, radius);\n                        primitiveModel.rotation.set(Math.PI / 2, 0, 0);\n\n                        linkObj.add(primitiveModel);\n\n                        if (isCollisionNode) {\n\n                            makeURDFCollider(primitiveModel);\n\n                        }\n\n                    }\n\n                } else if (type === 'origin') {\n\n                    xyz = processTuple(n.getAttribute('xyz'));\n                    rpy = processTuple(n.getAttribute('rpy'));\n\n                }\n\n            });\n\n            // apply the position and rotation to the primitive geometry after\n            // the fact because it's guaranteed to have been scraped from the child\n            // nodes by this point\n            if (primitiveModel) {\n\n                applyRotation(primitiveModel, rpy, true);\n                primitiveModel.position.set(xyz[0], xyz[1], xyz[2]);\n\n            }\n\n        }\n\n        return processUrdf(content);\n\n    }\n\n    // Default mesh loading function\n    defaultMeshLoader(path, manager, done) {\n\n        if (/\\.stl$/i.test(path)) {\n\n            const loader = new THREE.STLLoader(manager);\n            loader.load(path, geom => {\n                const mesh = new THREE.Mesh(geom, new THREE.MeshPhongMaterial());\n                done(mesh);\n            });\n\n        } else if (/\\.dae$/i.test(path)) {\n\n            const loader = new THREE.ColladaLoader(manager);\n            loader.load(path, dae => done(dae.scene));\n\n        } else {\n\n            console.warn(`URDFLoader: Could not load model at ${ path }.\\nNo loader available`);\n\n        }\n\n    }\n\n}\n\nmodule.exports = URDFLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/URDFLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/UTF8Loader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/UTF8Loader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Modified version of THREE.UTF8Loader from three.js\n * Loader for UTF8 version2 (after r51) encoded models generated by:\n *\thttp://code.google.com/p/webgl-loader/\n *\n * Code to load/decompress mesh is taken from r100 of this webgl-loader\n * @author angelxuanchang\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\nTHREE.UTF8Loader = function () {};\n\n/**\n * Load UTF8 encoded model\n * @param jsonUrl - URL from which to load json containing information about model\n * @param callback - Callback(THREE.Object3D) on successful loading of model\n * @param options - options on how to load model (see THREE.MTLLoader.MaterialCreator for basic options)\n *                  Additional options include\n *                   geometryBase: Base url from which to load referenced geometries\n *                   materialBase: Base url from which to load referenced textures\n */\n\nTHREE.UTF8Loader.prototype.load = function ( jsonUrl, callback, onerror, options ) {\n\n    this.downloadModelJson( jsonUrl, callback, onerror, options );\n\n};\n\n// BufferGeometryCreator\n\nTHREE.UTF8Loader.BufferGeometryCreator = function (useDynamic) {\n    this.useDynamic = useDynamic;\n};\n\nTHREE.UTF8Loader.BufferGeometryCreator.prototype.create = function ( attribArray, indices ) {\n\n\tvar ntris = indices.length / 3;\n\n\tvar geometry = new THREE.BufferGeometry();\n    if (this.useDynamic) geometry.dynamic = true;\n\n\tvar positions = new Float32Array( ntris * 3 * 3 );\n\tvar normals = new Float32Array( ntris * 3 * 3 );\n\tvar uvs = new Float32Array( ntris * 3 * 2 );\n\n\tvar i, j, offset;\n\tvar x, y, z;\n\tvar u, v;\n\n\tvar end = attribArray.length;\n\tvar stride = 8;\n\n\t// extract positions\n\n\tj = 0;\n\toffset = 0;\n\n\tfor ( i = offset; i < end; i += stride ) {\n\n\t\tx = attribArray[ i ];\n\t\ty = attribArray[ i + 1 ];\n\t\tz = attribArray[ i + 2 ];\n\n\t\tpositions[ j ++ ] = x;\n\t\tpositions[ j ++ ] = y;\n\t\tpositions[ j ++ ] = z;\n\n\t}\n\n\t// extract uvs\n\n\tj = 0;\n\toffset = 3;\n\n\tfor ( i = offset; i < end; i += stride ) {\n\n\t\tu = attribArray[ i ];\n\t\tv = attribArray[ i + 1 ];\n\n\t\tuvs[ j ++ ] = u;\n\t\tuvs[ j ++ ] = v;\n\n\t}\n\n\t// extract normals\n\n\tj = 0;\n\toffset = 5;\n\n\tfor ( i = offset; i < end; i += stride ) {\n\n\t\tx = attribArray[ i ];\n\t\ty = attribArray[ i + 1 ];\n\t\tz = attribArray[ i + 2 ];\n\n\t\tnormals[ j ++ ] = x;\n\t\tnormals[ j ++ ] = y;\n\t\tnormals[ j ++ ] = z;\n\n\t}\n\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\n\tgeometry.setAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\n\tgeometry.setAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\n\n  geometry.groups.push( { start: 0, count: indices.length, index: 0 } );\n\n\tgeometry.computeBoundingSphere();\n\n\treturn geometry;\n\n};\n\n// GeometryCreator\n\nTHREE.UTF8Loader.GeometryCreator = function () {\n};\n\nTHREE.UTF8Loader.GeometryCreator.prototype = {\n\n    create: function ( attribArray, indexArray ) {\n\n        var geometry = new THREE.Geometry();\n\n        this.init_vertices( geometry, attribArray, 8, 0 );\n\n        var uvs = this.init_uvs( attribArray, 8, 3 );\n        var normals = this.init_normals( attribArray, 8, 5 );\n\n        this.init_faces( geometry, normals, uvs, indexArray );\n\n        geometry.computeFaceNormals();\n        geometry.computeVertexNormals();\n\n        return geometry;\n\n    },\n\n    init_vertices: function ( scope, data, stride, offset ) {\n\n        var i, x, y, z;\n        var end = data.length;\n\n        for( i = offset; i < end; i += stride ) {\n\n            x = data[ i ];\n            y = data[ i + 1 ];\n            z = data[ i + 2 ];\n\n            this.addVertex( scope, x, y, z );\n\n        }\n\n    },\n\n    init_normals: function( data, stride, offset ) {\n\n        var normals = [];\n\n        var i, x, y, z;\n        var end = data.length;\n\n        for( i = offset; i < end; i += stride ) {\n\n            // Assumes already normalized to <-1,1> (unlike previous version of UTF8Loader)\n\n            x = data[ i ];\n            y = data[ i + 1 ];\n            z = data[ i + 2 ];\n\n            normals.push( x, y, z );\n\n        }\n\n        return normals;\n\n    },\n\n    init_uvs: function( data, stride, offset ) {\n\n        var uvs = [];\n\n        var i, u, v;\n        var end = data.length;\n\n        for( i = offset; i < end; i += stride ) {\n\n            // Assumes uvs are already normalized (unlike previous version of UTF8Loader)\n            // uvs can be negative, need to set wrap for texture map later on ...\n\n            u = data[ i ];\n            v = data[ i + 1 ];\n\n            uvs.push( u, v );\n        }\n\n        return uvs;\n\n    },\n\n    init_faces: function( scope, normals, uvs, indices ) {\n\n        var i,\n            a, b, c,\n            u1, v1, u2, v2, u3, v3;\n\n        var end = indices.length;\n\n        var m = 0; // all faces defaulting to material 0\n\n        for( i = 0; i < end; i += 3 ) {\n\n            a = indices[ i ];\n            b = indices[ i + 1 ];\n            c = indices[ i + 2 ];\n\n            this.f3n( scope, normals, a, b, c, m, a, b, c );\n\n            u1 = uvs[ a * 2 ];\n            v1 = uvs[ a * 2 + 1 ];\n\n            u2 = uvs[ b * 2 ];\n            v2 = uvs[ b * 2 + 1 ];\n\n            u3 = uvs[ c * 2 ];\n            v3 = uvs[ c * 2 + 1 ];\n\n            this.uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );\n\n        }\n\n    },\n\n    addVertex: function ( scope, x, y, z ) {\n\n        scope.vertices.push( new THREE.Vector3( x, y, z ) );\n\n    },\n\n    f3n: function( scope, normals, a, b, c, mi, nai, nbi, nci ) {\n\n        var nax = normals[ nai * 3 ],\n            nay = normals[ nai * 3 + 1 ],\n            naz = normals[ nai * 3 + 2 ],\n\n            nbx = normals[ nbi * 3 ],\n            nby = normals[ nbi * 3 + 1 ],\n            nbz = normals[ nbi * 3 + 2 ],\n\n            ncx = normals[ nci * 3 ],\n            ncy = normals[ nci * 3 + 1 ],\n            ncz = normals[ nci * 3 + 2 ];\n\n        var na = new THREE.Vector3( nax, nay, naz ),\n            nb = new THREE.Vector3( nbx, nby, nbz ),\n            nc = new THREE.Vector3( ncx, ncy, ncz );\n\n        scope.faces.push( new THREE.Face3( a, b, c, [ na, nb, nc ], null, mi ) );\n\n    },\n\n    uv3: function ( where, u1, v1, u2, v2, u3, v3 ) {\n\n        var uv = [];\n        uv.push( new THREE.Vector2( u1, v1 ) );\n        uv.push( new THREE.Vector2( u2, v2 ) );\n        uv.push( new THREE.Vector2( u3, v3 ) );\n        where.push( uv );\n\n    }\n\n};\n\n\n// UTF-8 decoder from webgl-loader (r100)\n// http://code.google.com/p/webgl-loader/\n\n// Model manifest description. Contains objects like:\n// name: {\n//   materials: { 'material_name': { ... } ... },\n//   decodeParams: {\n//     decodeOffsets: [ ... ],\n//     decodeScales: [ ... ],\n//   },\n//   urls: {\n//     'url': [\n//       { material: 'material_name',\n//         attribRange: [#, #],\n//         indexRange: [#, #],\n//         names: [ 'object names' ... ],\n//         lengths: [#, #, # ... ]\n//       }\n//     ],\n//     ...\n//   }\n// }\n\nvar DEFAULT_DECODE_PARAMS = {\n\n    decodeOffsets: [ -4095, -4095, -4095, 0, 0, -511, -511, -511 ],\n    decodeScales: [ 1 / 8191, 1 / 8191, 1 / 8191, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023, 1 / 1023 ]\n\n    // TODO: normal decoding? (see walt.js)\n    // needs to know: input, output (from vertex format!)\n    //\n    // Should split attrib/index.\n    // 1) Decode position and non-normal attributes.\n    // 2) Decode indices, computing normals\n    // 3) Maybe normalize normals? Only necessary for refinement, or fixed?\n    // 4) Maybe refine normals? Should this be part of regular refinement?\n    // 5) Morphing\n\n};\n\n// Triangle strips!\n\n// TODO: will it be an optimization to specialize this method at\n// runtime for different combinations of stride, decodeOffset and\n// decodeScale?\n\nTHREE.UTF8Loader.prototype.decompressAttribsInner_ = function ( str, inputStart, inputEnd,\n                                                                  output, outputStart, stride,\n                                                                  decodeOffset, decodeScale ) {\n\n\tvar prev = 0;\n\n\tfor ( var j = inputStart; j < inputEnd; j ++ ) {\n\n\t\tvar code = str.charCodeAt( j );\n\t\tprev += ( code >> 1 ) ^ ( -( code & 1 ) );\n\n\t\toutput[ outputStart ] = decodeScale * ( prev + decodeOffset );\n\t\toutputStart += stride;\n\n\t}\n\n};\n\nTHREE.UTF8Loader.prototype.decompressIndices_ = function( str, inputStart, numIndices,\n                                                            output, outputStart ) {\n\n\tvar highest = 0;\n\n\tfor ( var i = 0; i < numIndices; i ++ ) {\n\n\t\tvar code = str.charCodeAt( inputStart ++ );\n\n\t\toutput[ outputStart ++ ] = highest - code;\n\n\t\tif ( code === 0 ) {\n\n\t\t\thighest ++;\n\n\t\t}\n\n\t}\n\n};\n\nTHREE.UTF8Loader.prototype.decompressAABBs_ = function ( str, inputStart, numBBoxen,\n                                                           decodeOffsets, decodeScales ) {\n\tvar numFloats = 6 * numBBoxen;\n\n\tvar inputEnd = inputStart + numFloats;\n\tvar outputStart = 0;\n\n\tvar bboxen = new Float32Array( numFloats );\n\n\tfor ( var i = inputStart; i < inputEnd; i += 6 ) {\n\n\t\tvar minX = str.charCodeAt(i + 0) + decodeOffsets[0];\n\t\tvar minY = str.charCodeAt(i + 1) + decodeOffsets[1];\n\t\tvar minZ = str.charCodeAt(i + 2) + decodeOffsets[2];\n\n\t\tvar radiusX = (str.charCodeAt(i + 3) + 1) >> 1;\n\t\tvar radiusY = (str.charCodeAt(i + 4) + 1) >> 1;\n\t\tvar radiusZ = (str.charCodeAt(i + 5) + 1) >> 1;\n\n\t\tbboxen[ outputStart ++ ] = decodeScales[0] * (minX + radiusX);\n\t\tbboxen[ outputStart ++ ] = decodeScales[1] * (minY + radiusY);\n\t\tbboxen[ outputStart ++ ] = decodeScales[2] * (minZ + radiusZ);\n\n\t\tbboxen[ outputStart ++ ] = decodeScales[0] * radiusX;\n\t\tbboxen[ outputStart ++ ] = decodeScales[1] * radiusY;\n\t\tbboxen[ outputStart ++ ] = decodeScales[2] * radiusZ;\n\n\t}\n\n\treturn bboxen;\n\n};\n\nTHREE.UTF8Loader.prototype.decompressMesh =  function ( str, meshParams, decodeParams, name, idx, callback ) {\n\n    // Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar attribStart = meshParams.attribRange[0];\n\tvar numVerts = meshParams.attribRange[1];\n\n    // Decode attributes.\n\n\tvar inputOffset = attribStart;\n\tvar attribsOut = new Float32Array( stride * numVerts );\n\n\tfor (var j = 0; j < stride; j ++ ) {\n\n\t\tvar end = inputOffset + numVerts;\n\n\t\tvar decodeScale = decodeScales[j];\n\n\t\tif ( decodeScale ) {\n\n            // Assume if decodeScale is never set, simply ignore the\n            // attribute.\n\n\t\t\tthis.decompressAttribsInner_( str, inputOffset, end,\n                attribsOut, j, stride,\n                decodeOffsets[j], decodeScale );\n\t\t}\n\n\t\tinputOffset = end;\n\n\t}\n\n\tvar indexStart = meshParams.indexRange[ 0 ];\n\tvar numIndices = 3 * meshParams.indexRange[ 1 ];\n\n\tvar indicesOut = new Uint16Array( numIndices );\n\n\tthis.decompressIndices_( str, inputOffset, numIndices, indicesOut, 0 );\n\n    // Decode bboxen.\n\n\tvar bboxen = undefined;\n\tvar bboxOffset = meshParams.bboxes;\n\n\tif ( bboxOffset ) {\n\n\t\tbboxen = this.decompressAABBs_( str, bboxOffset, meshParams.names.length, decodeOffsets, decodeScales );\n\t}\n\n\tcallback( name, idx, attribsOut, indicesOut, bboxen, meshParams );\n\n};\n\nTHREE.UTF8Loader.prototype.copyAttrib = function ( stride, attribsOutFixed, lastAttrib, index ) {\n\n\tfor ( var j = 0; j < stride; j ++ ) {\n\n\t\tlastAttrib[ j ] = attribsOutFixed[ stride * index + j ];\n\n\t}\n\n};\n\nTHREE.UTF8Loader.prototype.decodeAttrib2 = function ( str, stride, decodeOffsets, decodeScales, deltaStart,\n                                                        numVerts, attribsOut, attribsOutFixed, lastAttrib,\n                                                        index ) {\n\n\tfor ( var j = 0; j < 5; j ++ ) {\n\n\t\tvar code = str.charCodeAt( deltaStart + numVerts * j + index );\n\t\tvar delta = ( code >> 1) ^ (-(code & 1));\n\n\t\tlastAttrib[ j ] += delta;\n\t\tattribsOutFixed[ stride * index + j ] = lastAttrib[ j ];\n\t\tattribsOut[ stride * index + j ] = decodeScales[ j ] * ( lastAttrib[ j ] + decodeOffsets[ j ] );\n\t}\n\n};\n\nTHREE.UTF8Loader.prototype.accumulateNormal = function ( i0, i1, i2, attribsOutFixed, crosses ) {\n\n\tvar p0x = attribsOutFixed[ 8 * i0 ];\n\tvar p0y = attribsOutFixed[ 8 * i0 + 1 ];\n\tvar p0z = attribsOutFixed[ 8 * i0 + 2 ];\n\n\tvar p1x = attribsOutFixed[ 8 * i1 ];\n\tvar p1y = attribsOutFixed[ 8 * i1 + 1 ];\n\tvar p1z = attribsOutFixed[ 8 * i1 + 2 ];\n\n\tvar p2x = attribsOutFixed[ 8 * i2 ];\n\tvar p2y = attribsOutFixed[ 8 * i2 + 1 ];\n\tvar p2z = attribsOutFixed[ 8 * i2 + 2 ];\n\n\tp1x -= p0x;\n\tp1y -= p0y;\n\tp1z -= p0z;\n\n\tp2x -= p0x;\n\tp2y -= p0y;\n\tp2z -= p0z;\n\n\tp0x = p1y * p2z - p1z * p2y;\n\tp0y = p1z * p2x - p1x * p2z;\n\tp0z = p1x * p2y - p1y * p2x;\n\n\tcrosses[ 3 * i0 ]     += p0x;\n\tcrosses[ 3 * i0 + 1 ] += p0y;\n\tcrosses[ 3 * i0 + 2 ] += p0z;\n\n\tcrosses[ 3 * i1 ]     += p0x;\n\tcrosses[ 3 * i1 + 1 ] += p0y;\n\tcrosses[ 3 * i1 + 2 ] += p0z;\n\n\tcrosses[ 3 * i2 ]     += p0x;\n\tcrosses[ 3 * i2 + 1 ] += p0y;\n\tcrosses[ 3 * i2 + 2 ] += p0z;\n\n};\n\nTHREE.UTF8Loader.prototype.decompressMesh2 = function( str, meshParams, decodeParams, name, idx, callback ) {\n\n\tvar MAX_BACKREF = 96;\n\n    // Extract conversion parameters from attribArrays.\n\n\tvar stride = decodeParams.decodeScales.length;\n\n\tvar decodeOffsets = decodeParams.decodeOffsets;\n\tvar decodeScales = decodeParams.decodeScales;\n\n\tvar deltaStart = meshParams.attribRange[ 0 ];\n\tvar numVerts = meshParams.attribRange[ 1 ];\n\n\tvar codeStart = meshParams.codeRange[ 0 ];\n\tvar codeLength = meshParams.codeRange[ 1 ];\n\n\tvar numIndices = 3 * meshParams.codeRange[ 2 ];\n\n\tvar indicesOut = new Uint16Array( numIndices );\n\n\tvar crosses = new Int32Array( 3 * numVerts );\n\n\tvar lastAttrib = new Uint16Array( stride );\n\n\tvar attribsOutFixed = new Uint16Array( stride * numVerts );\n\tvar attribsOut = new Float32Array( stride * numVerts );\n\n\tvar highest = 0;\n\tvar outputStart = 0;\n\n\tfor ( var i = 0; i < numIndices; i += 3 ) {\n\n\t\tvar code = str.charCodeAt( codeStart ++ );\n\n\t\tvar max_backref = Math.min( i, MAX_BACKREF );\n\n\t\tif ( code < max_backref ) {\n\n            // Parallelogram\n\n\t\t\tvar winding = code % 3;\n\t\t\tvar backref = i - ( code - winding );\n\t\t\tvar i0, i1, i2;\n\n\t\t\tswitch ( winding ) {\n\n\t\t\t\tcase 0:\n\n\t\t\t\t\ti0 = indicesOut[ backref + 2 ];\n\t\t\t\t\ti1 = indicesOut[ backref + 1 ];\n\t\t\t\t\ti2 = indicesOut[ backref + 0 ];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:\n\n\t\t\t\t\ti0 = indicesOut[ backref + 0 ];\n\t\t\t\t\ti1 = indicesOut[ backref + 2 ];\n\t\t\t\t\ti2 = indicesOut[ backref + 1 ];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\n\t\t\t\t\ti0 = indicesOut[ backref + 1 ];\n\t\t\t\t\ti1 = indicesOut[ backref + 0 ];\n\t\t\t\t\ti2 = indicesOut[ backref + 2 ];\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tindicesOut[ outputStart ++ ] = i0;\n\t\t\tindicesOut[ outputStart ++ ] = i1;\n\n\t\t\tcode = str.charCodeAt( codeStart ++ );\n\n\t\t\tvar index = highest - code;\n\t\t\tindicesOut[ outputStart ++ ] = index;\n\n\t\t\tif ( code === 0 ) {\n\n\t\t\t\tfor (var j = 0; j < 5; j ++ ) {\n\n\t\t\t\t\tvar deltaCode = str.charCodeAt( deltaStart + numVerts * j + highest );\n\n\t\t\t\t\tvar prediction = ((deltaCode >> 1) ^ (-(deltaCode & 1))) +\n                        attribsOutFixed[stride * i0 + j] +\n                        attribsOutFixed[stride * i1 + j] -\n                        attribsOutFixed[stride * i2 + j];\n\n\t\t\t\t\tlastAttrib[j] = prediction;\n\n\t\t\t\t\tattribsOutFixed[ stride * highest + j ] = prediction;\n\t\t\t\t\tattribsOut[ stride * highest + j ] = decodeScales[ j ] * ( prediction + decodeOffsets[ j ] );\n\n\t\t\t\t}\n\n\t\t\t\thighest ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib( stride, attribsOutFixed, lastAttrib, index );\n\n\t\t\t}\n\n\t\t\tthis.accumulateNormal( i0, i1, index, attribsOutFixed, crosses );\n\n\t\t} else {\n\n            // Simple\n\n\t\t\tvar index0 = highest - ( code - max_backref );\n\n\t\t\tindicesOut[ outputStart ++ ] = index0;\n\n\t\t\tif ( code === max_backref ) {\n\n\t\t\t\tthis.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n                    highest ++ );\n\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib(stride, attribsOutFixed, lastAttrib, index0);\n\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt( codeStart ++ );\n\n\t\t\tvar index1 = highest - code;\n\t\t\tindicesOut[ outputStart ++ ] = index1;\n\n\t\t\tif ( code === 0 ) {\n\n\t\t\t\tthis.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n                    highest ++ );\n\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib( stride, attribsOutFixed, lastAttrib, index1 );\n\n\t\t\t}\n\n\t\t\tcode = str.charCodeAt( codeStart ++ );\n\n\t\t\tvar index2 = highest - code;\n\t\t\tindicesOut[ outputStart ++ ] = index2;\n\n\t\t\tif ( code === 0 ) {\n\n\t\t\t\tfor ( var j = 0; j < 5; j ++ ) {\n\n\t\t\t\t\tlastAttrib[ j ] = ( attribsOutFixed[ stride * index0 + j ] + attribsOutFixed[ stride * index1 + j ] ) / 2;\n\n\t\t\t\t}\n\n\t\t\t\tthis.decodeAttrib2( str, stride, decodeOffsets, decodeScales, deltaStart,\n                    numVerts, attribsOut, attribsOutFixed, lastAttrib,\n                    highest ++ );\n\n\t\t\t} else {\n\n\t\t\t\tthis.copyAttrib( stride, attribsOutFixed, lastAttrib, index2 );\n\n\t\t\t}\n\n\t\t\tthis.accumulateNormal( index0, index1, index2, attribsOutFixed, crosses );\n\n\t\t}\n\n\t}\n\n\tfor ( var i = 0; i < numVerts; i ++ ) {\n\n\t\tvar nx = crosses[ 3 * i ];\n\t\tvar ny = crosses[ 3 * i + 1 ];\n\t\tvar nz = crosses[ 3 * i + 2 ];\n\n\t\tvar norm = 511.0 / Math.sqrt( nx * nx + ny * ny + nz * nz );\n\n\t\tvar cx = str.charCodeAt( deltaStart + 5 * numVerts + i );\n\t\tvar cy = str.charCodeAt( deltaStart + 6 * numVerts + i );\n\t\tvar cz = str.charCodeAt( deltaStart + 7 * numVerts + i );\n\n\t\tattribsOut[ stride * i + 5 ] = norm * nx + ((cx >> 1) ^ (-(cx & 1)));\n\t\tattribsOut[ stride * i + 6 ] = norm * ny + ((cy >> 1) ^ (-(cy & 1)));\n\t\tattribsOut[ stride * i + 7 ] = norm * nz + ((cz >> 1) ^ (-(cz & 1)));\n\t}\n\n\tcallback( name, idx, attribsOut, indicesOut, undefined, meshParams );\n\n};\n\nTHREE.UTF8Loader.prototype.downloadMesh = function ( path, name, meshEntry, decodeParams, callback ) {\n\n\tvar loader = this;\n\tvar idx = 0;\n\n\tfunction onprogress( req, e ) {\n\n\t\twhile ( idx < meshEntry.length ) {\n\n\t\t\tvar meshParams = meshEntry[ idx ];\n\t\t\tvar indexRange = meshParams.indexRange;\n\n\t\t\tif ( indexRange ) {\n\n\t\t\t\tvar meshEnd = indexRange[ 0 ] + 3 * indexRange[ 1 ];\n\n\t\t\t\tif ( req.responseText.length < meshEnd ) break;\n\n\t\t\t\tloader.decompressMesh( req.responseText, meshParams, decodeParams, name, idx, callback );\n\n\t\t\t} else {\n\n\t\t\t\tvar codeRange = meshParams.codeRange;\n\t\t\t\tvar meshEnd = codeRange[ 0 ] + codeRange[ 1 ];\n\n\t\t\t\tif ( req.responseText.length < meshEnd ) break;\n\n\t\t\t\tloader.decompressMesh2( req.responseText, meshParams, decodeParams, name, idx, callback );\n\t\t\t}\n\n\t\t\t++ idx;\n\n\t\t}\n\n    }\n\n\tgetHttpRequest( path, function( req, e ) {\n\n\t\tif ( req.status === 200 || req.status === 0 ) {\n\n\t\t\tonprogress( req, e );\n\n\t\t}\n\n        // TODO: handle errors.\n\n\t}, onprogress );\n\n};\n\nTHREE.UTF8Loader.prototype.downloadMeshes = function ( path, meshUrlMap, decodeParams, callback ) {\n\n\tfor ( var url in meshUrlMap ) {\n\n\t\tvar meshEntry = meshUrlMap[url];\n\t\tthis.downloadMesh( path + url, url, meshEntry, decodeParams, callback );\n\n\t}\n\n};\n\nTHREE.UTF8Loader.prototype.createMeshCallback = function( materialBaseUrl, loadModelInfo, allDoneCallback ) {\n\n\tvar nCompletedUrls = 0;\n\tvar nExpectedUrls = 0;\n\n\tvar expectedMeshesPerUrl = {};\n\tvar decodedMeshesPerUrl = {};\n\n\tvar modelParts = {};\n\n\tvar meshUrlMap = loadModelInfo.urls;\n\n\tfor ( var url in meshUrlMap ) {\n\n\t\texpectedMeshesPerUrl[ url ] = meshUrlMap[ url ].length;\n\t\tdecodedMeshesPerUrl[ url ] = 0;\n\n\t\tnExpectedUrls ++;\n\n\t\tmodelParts[ url ] = new THREE.Object3D();\n\n\t}\n\n\tvar model = new THREE.Object3D();\n\n    // Prepare materials first...\n\n\tvar materialCreator = new THREE.MTLLoader.MaterialCreator( materialBaseUrl, loadModelInfo.options );\n\tmaterialCreator.setMaterials( loadModelInfo.materials );\n\n\tmaterialCreator.preload();\n\n\t// Create callback for creating mesh parts\n\n    var useDynamic = (loadModelInfo.options && loadModelInfo.options.useDynamic !== undefined) ? loadModelInfo.options.useDynamic : true;\n    var geometryCreator = new THREE.UTF8Loader.GeometryCreator();\n    var bufferGeometryCreator = new THREE.UTF8Loader.BufferGeometryCreator(useDynamic);\n\n\tvar meshCallback = function( name, idx, attribArray, indexArray, bboxen, meshParams ) {\n\n        // Got ourselves a new mesh\n\n        // name identifies this part of the model (url)\n        // idx is the mesh index of this mesh of the part\n        // attribArray defines the vertices\n        // indexArray defines the faces\n        // bboxen defines the bounding box\n        // meshParams contains the material info\n\n        var useBuffers = (loadModelInfo.options && loadModelInfo.options.useBuffers !== undefined) ? loadModelInfo.options.useBuffers : true;\n\n        if ( useBuffers ) {\n\n\t\tvar geometry = bufferGeometryCreator.create( attribArray, indexArray );\n\n        } else {\n\n            var geometry = geometryCreator.create( attribArray, indexArray );\n\n        }\n\n\t\tvar material = materialCreator.create( meshParams.material );\n\n\t\tvar mesh = new THREE.Mesh( geometry, material );\n        mesh.name = name + '-' + idx;\n        mesh.userData = {\n            index: idx\n        };\n\t\tmodelParts[ name ].add( mesh );\n\n        //model.add(new THREE.Mesh(geometry, material));\n\n\t\tdecodedMeshesPerUrl[ name ] ++;\n\n\t\tif ( decodedMeshesPerUrl[ name ] === expectedMeshesPerUrl[ name ] ) {\n\n\t\t\tnCompletedUrls ++;\n\n\t\t\tmodel.add( modelParts[ name ] );\n\n\t\t\tif ( nCompletedUrls === nExpectedUrls ) {\n\n                // ALL DONE!!!\n\n\t\t\t\tallDoneCallback( model );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\treturn meshCallback;\n\n};\n\nTHREE.UTF8Loader.prototype.downloadModel = function ( geometryBase, materialBase, model, callback ) {\n\n\tvar meshCallback = this.createMeshCallback( materialBase, model, callback );\n\tthis.downloadMeshes( geometryBase, model.urls, model.decodeParams, meshCallback );\n\n};\n\nTHREE.UTF8Loader.prototype.downloadModelJson = function ( jsonUrl, callback, onerror, options ) {\n\n\tgetJsonRequest( jsonUrl, function( loaded ) {\n\n\t\tif ( ! loaded.decodeParams ) {\n\n\t\t\tif ( options && options.decodeParams ) {\n\n\t\t\t\tloaded.decodeParams = options.decodeParams;\n\n\t\t\t} else {\n\n\t\t\t\tloaded.decodeParams = DEFAULT_DECODE_PARAMS;\n\n\t\t\t}\n\n\t\t}\n\n\t\tloaded.options = options;\n\n\t\tvar geometryBase = jsonUrl.substr( 0, jsonUrl.lastIndexOf( \"/\" ) + 1 );\n\t\tvar materialBase = geometryBase;\n\n\t\tif ( options && options.geometryBase ) {\n\n\t\t\tgeometryBase = options.geometryBase;\n\n\t\t\tif ( geometryBase.charAt( geometryBase.length - 1 ) !== \"/\" ) {\n\n\t\t\t\tgeometryBase = geometryBase + \"/\";\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( options && options.materialBase ) {\n\n\t\t\tmaterialBase = options.materialBase;\n\n\t\t\tif ( materialBase.charAt( materialBase.length - 1 ) !== \"/\" ) {\n\n\t\t\t\tmaterialBase = materialBase  + \"/\";\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.downloadModel( geometryBase, materialBase, loaded, callback );\n\n        }.bind( this ),\n        onerror );\n\n};\n\n// XMLHttpRequest stuff\n\nfunction getHttpRequest( url, onload, opt_onprogress ) {\n\n    var req = new XMLHttpRequest();\n\n\tvar LISTENERS = {\n\n        load: function( e ) { onload( req, e ); },\n        progress: function( e ) { opt_onprogress( req, e ); }\n\n    };\n\n\taddListeners( req, LISTENERS );\n\n\treq.open( 'GET', url, true );\n\treq.send( null );\n}\n\nfunction getJsonRequest( url, onjson, onerror ) {\n\tgetHttpRequest( url,\n        function( e ) {\n            if ( e.status === 200 || e.status === 0 ) {\n                onjson( JSON.parse( e.responseText ) );\n            } else {\n                var msg = 'Couldn\\'t load URL [' + url + ']';\n                if (onerror) onerror( msg );\n            }\n        },\n        function() {} );\n\n}\n\nfunction addListeners( dom, listeners ) {\n\n    // TODO: handle event capture, object binding.\n\n\tfor ( var key in listeners ) {\n\n\t\tdom.addEventListener( key, listeners[ key ] );\n\n\t}\n}\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/UTF8Loader.js?");

/***/ }),

/***/ "./js/lib/loaders/VoxelLoader.js":
/*!***************************************!*\
  !*** ./js/lib/loaders/VoxelLoader.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ColorGrid = __webpack_require__(/*! geo/ColorGrid */ \"./js/lib/geo/ColorGrid.js\");\nvar BinvoxLoader = __webpack_require__(/*! loaders/BinvoxLoader */ \"./js/lib/loaders/BinvoxLoader.js\");\nvar LabeledGridLoader = __webpack_require__(/*! loaders/LabeledGridLoader */ \"./js/lib/loaders/LabeledGridLoader.js\");\nvar NRRDLoader = __webpack_require__(/*! loaders/NRRDLoader */ \"./js/lib/loaders/NRRDLoader.js\");\nvar FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\nvar jBinary = __webpack_require__(/*! jbinary */ \"./js/vendor/jbinary/jbinary.js\");\n\n/**\n * Generic voxel loader that dispatches to the appropriate loader\n *  depending on format (NRRD, Binvox, LabeledGrid)\n * @constructor\n * @memberOf loaders\n */\nfunction VoxelLoader() {\n\n}\n\nVoxelLoader.prototype.load = function (path, callback) {\n  var loader = new FileLoader();\n  var scope = this;\n  loader.load(path, 'arraybuffer', function(data) {\n    var binary = new jBinary(data);\n    scope.__parseVoxels(path.name || path, binary, callback);\n  }, null, function(err) {\n    callback(err);\n  });\n};\n\nVoxelLoader.prototype.__parseVoxels = function (filename, data, callback) {\n  var parser;\n  if (filename.endsWith('binvox')) {\n    parser = new BinvoxLoader();\n  } else if (filename.endsWith('vox')) {\n    parser = new LabeledGridLoader();\n  } else if (filename.endsWith('nrrd')) {\n    parser = new NRRDLoader({ GridType: ColorGrid });\n  } else {\n    console.warn('Unknown grid type: ' + filename);\n    callback('Unknown grid type: ' + filename);\n    return;\n  }\n  console.time('parseVoxels');\n  var grid = parser.parse(filename, data);\n  console.timeEnd('parseVoxels');\n  callback(null, grid);\n};\n\nmodule.exports = VoxelLoader;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/VoxelLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/WallLoader.js":
/*!**************************************!*\
  !*** ./js/lib/loaders/WallLoader.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Loader for wall files\n * @param params\n * @constructor\n * @memberOf loaders\n */\nfunction WallLoader(params) {\n  this.fs = params.fs;\n}\n\n\nWallLoader.prototype.load = function(file, callback) {\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      callback(null, scope.parse(filename, data));\n    }\n  });\n};\n\nWallLoader.prototype.parse = function(filename, data) {\n  if (filename.endsWith('.json')) {\n    return JSON.parse(data);\n  } else {\n    return this.__parseWallFormat(data);\n  }\n};\n\nWallLoader.prototype.__parseWallFormat = function(data) {\n  // filetype wall\n  // wall 0 44.51 36.34 0 44.51 37.662479000000005 2.7 0 0\n  var lines = data.split('\\n');\n  var walls = [];\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var parts = line.split(/\\s+/);\n    if (parts.length > 0) {\n      if (parts[0] === 'wall') {\n        var f = parts.slice(1).map(function(x) { return parseFloat(x); });\n        walls.push({\n          id: f[0],\n          points: [[f[2], f[3], f[1]], [f[5], f[6], f[4]]]\n        });\n      }\n    }\n  }\n  return walls;\n};\n\nmodule.exports = WallLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/WallLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/ZIPLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/ZIPLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var JSZip = __webpack_require__(/*! jszip */ \"../node_modules/jszip/lib/index.js\");\nvar ImageUtil = __webpack_require__(/*! util/ImageUtil */ \"./js/lib/util/ImageUtil.js\");\nvar FileLoader = __webpack_require__(/*! io/FileLoader */ \"./js/lib/io/FileLoader.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction loadFile(zip, basePath, relPath, cacheOpts) {\n  var path = _.getPath(basePath, relPath);\n  path = path.replace(/^.\\//, '');\n  var file = zip.file(path);\n  if (file && cacheOpts) {\n    // Rewrite path\n    var p = cacheOpts.rewritePath? cacheOpts.rewritePath(path) : path;\n    var cachePath = cacheOpts.dir + '/' + p;\n    cacheOpts.fs.fsWriteToFileEnsureDir(cachePath, file._data);\n  }\n  return file;\n}\n\nfunction loadTextFile(zip, basePath, relPath, cacheOpts) {\n  var file = loadFile(zip, basePath, relPath, cacheOpts);\n  if (file) {\n    return file.asText();\n  }\n}\n\nfunction loadBinaryFile(zip, basePath, relPath, cacheOpts) {\n  var file = loadFile(zip, basePath, relPath, cacheOpts);\n  if (file) {\n    return file.asBinary();\n  }\n}\n\nfunction loadTexture(zip, basePath, relPath, images, cacheOpts) {\n  var path = _.getPath(basePath, relPath);\n  path = path.replace(/^.\\//, '');\n  var img = images[path];\n  var texture = new THREE.Texture();\n  texture.name = path;\n  texture.sourceFile = path;\n  if (!img) {\n    // console.log('load image', path);\n    var imgfile = zip.file(path);\n    if (imgfile) {\n      var imageData = imgfile.asBinary(); // Note: this is string\n      if (cacheOpts) {\n        var cachePath = cacheOpts.dir + '/' + path;\n        console.log('Save texture ' + path + ' to ' + cachePath);\n        cacheOpts.fs.fsWriteToFileEnsureDir(cachePath, imgfile._data);\n      }\n      // Let the file extension be the image type\n      var extIndex = relPath.lastIndexOf(\".\");\n      var imageType = (extIndex >= 0) ? relPath.substring(extIndex + 1) : \"jpg\";\n      // Base64 encode\n      var imageDataEncoded = btoa(imageData);\n      var datauri = \"data:image/\" + imageType + \";base64,\" + imageDataEncoded;\n      if (typeof Image !== 'undefined') {\n        // In browser with Image\n        img = new Image();\n        img.path = path;\n        img.src = datauri;\n        img.addEventListener('load', function() {\n          // Need to wait for image to load before there is width and height to use\n          ImageUtil.ensurePowerOfTwo(img, texture, function(err, resizedImage) {\n            if (err) {\n              console.warn('Error resizing image to power of two', err);\n            }\n            texture.image = resizedImage || img;\n            texture.needsUpdate = true;\n            images[path] = texture.image;\n          });\n        }, false);\n        //img = ImageUtil.ensurePowerOfTwo(img);\n      } else {\n        // Not in browser\n        var pixels = ImageUtil.getPixelsSync(datauri, 'image/' + imageType);\n        //var pixels = ImageUtil.bufferToRawPixelsSync(imgfile._data);\n        img = {\n          src: path,\n          data: pixels.data,\n          width: pixels.shape? pixels.shape[0] : pixels.width,\n          height: pixels.shape? pixels.shape[1] : pixels.height,\n          channels: pixels.shape? pixels.shape[2] : pixels.channels\n        };\n        ImageUtil.ensurePowerOfTwo(img, texture, function(err, resizedImage) {\n          if (err) {\n            console.warn('Error resizing image to power of two', err);\n          }\n          texture.image = resizedImage || img;\n          texture.needsUpdate = true;\n          images[path] = texture.image;\n        });\n      }\n    } else {\n      console.error('Error getting image ' + path + ' from ' + zip.name);\n    }\n  } else {\n    texture.image = img;\n    texture.needsUpdate = true;\n  }\n  // texture.sourceFile = url;\n  return texture;\n}\n\n/**\n * A loader for handling a zipped file\n * @param params\n * @param params.regex {string} Pattern of main file to match\n * @param params.loader Base loader with zippedLoad or load function\n * @constructor\n */\nvar ZIPLoader = function(params) {\n  this.options = params;\n  this.__cached = {};\n};\n\nZIPLoader.prototype = {\n\n  constructor: ZIPLoader,\n\n  load: function (fileOrUrl, readyCallback, progressCallback, errorCallback) {\n    var zipLoader = this;\n    var options = this.options;\n\n    var zipname = _.isString(fileOrUrl) ? fileOrUrl : fileOrUrl.name;\n    var loader = new FileLoader();\n    loader.load(fileOrUrl,\n      'arraybuffer',\n      function (data) {\n        var zip = new JSZip(data);\n        zipLoader.zip = zip;\n        var regex = options.regex;\n        var mainFile = null;\n        for (var filename in zip.files) {\n          var match = regex.exec(filename);\n          if (match) {\n            mainFile = filename;\n            break;\n          }\n        }\n\n        if (mainFile) {\n          var loader = options.loader;\n          // Push options into loader\n          if (loader.options) {\n            for (var n in options) {\n              loader.options[n] = options[n];\n            }\n          }\n          if (loader.zippedLoad) {\n            loader.zippedLoad(zipLoader, mainFile, readyCallback, progressCallback, errorCallback);\n          } else {\n            loader.load(mainFile, readyCallback, progressCallback, errorCallback);\n          }\n        } else {\n          console.error(\"Cannot find file matching regex \" + regex + \" in zip: \" + zipname);\n          if (errorCallback) {\n            errorCallback(\"Cannot find file matching regex \" + regex + \" in zip: \" + zipname);\n          }\n        }\n      },\n      progressCallback,\n      function (err) {\n        console.log('Error loading ' + zipname, err);\n        if (errorCallback) {\n          errorCallback(err);\n        }\n      }\n    );\n  },\n\n\n  loadFile: function(basePath, relPath) {\n    return loadFile(this.zip, basePath, relPath, this.options.cacheOpts);\n  },\n\n  loadBinaryFile: function(basePath, relPath) {\n    return loadBinaryFile(this.zip, basePath, relPath, this.options.cacheOpts);\n  },\n\n  loadTextFile: function(basePath, relPath) {\n    return loadTextFile(this.zip, basePath, relPath, this.options.cacheOpts);\n  },\n\n  loadTexture: function(basePath, relPath) {\n    return loadTexture(this.zip, basePath, relPath, this.__cached, this.options.textureCacheOpts || this.options.cacheOpts);\n  }\n};\n\nmodule.exports = ZIPLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/ZIPLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/ZippedLoaders.js":
/*!*****************************************!*\
  !*** ./js/lib/loaders/ZippedLoaders.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var ZIPLoader = __webpack_require__(/*! loaders/ZIPLoader */ \"./js/lib/loaders/ZIPLoader.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nTHREE.ZIPloader = ZIPLoader;\n\nTHREE.ZippedJsonLoader = function (params) {\n  params = _.defaults(params || {}, { regex: /^.*\\.js$/ });\n  var baseLoader = params.loader || new THREE.LegacyJSONLoader();\n\n  function load ( ziploader, url, readyCallback, progressCallback, errorCallback ) {\n    var text = ziploader.zip.file(url).asText();\n    var json = JSON.parse(text);\n    var result = baseLoader.parse(json);\n    var zmesh = new THREE.Mesh(result.geometry, new THREE.MeshFaceMaterial(result.materials));\n    readyCallback(zmesh);\n  }\n\n  baseLoader.zippedLoad = load;\n\n  params.loader = baseLoader;\n  ZIPLoader.call(this, params);\n};\n\nTHREE.ZippedJsonLoader.prototype = Object.create(ZIPLoader.prototype);\nTHREE.ZippedJsonLoader.prototype.constructor = THREE.ZippedJsonLoader;\n\nTHREE.KMZLoader = function(params) {\n  params = _.defaults(params || {}, { regex: /^.*\\.dae$/ });\n\n  var scope = this;\n  var colladaLoader = params.loader || new THREE.ColladaLoader();\n  colladaLoader.options.loadTextureCallback = function loadTexture(basePath, relPath) {\n    return scope.loadTexture(basePath, relPath);\n  };\n  function load( zipLoader, url, readyCallback, progressCallback, errorCallback ) {\n    try {\n      var text = zipLoader.zip.file(url).asText();\n      var xmlParser = new DOMParser();\n      var responseXML = xmlParser.parseFromString(text, \"application/xml\");\n      colladaLoader.parse(responseXML, readyCallback, url);\n    } catch (err) {\n      if (errorCallback) {\n        errorCallback('Error parsing kmz: ' + err);\n      }\n    }\n  }\n\n  colladaLoader.zippedLoad = load;\n\n  params.loader = colladaLoader;\n  ZIPLoader.call(this, params);\n};\n\nTHREE.KMZLoader.prototype = Object.create(ZIPLoader.prototype);\nTHREE.KMZLoader.prototype.constructor = THREE.KMZLoader;\n\nTHREE.ZippedObjLoader = function(params) {\n  params = _.defaults(params || {}, { regex: /^.*\\.obj$/ });\n\n  var scope = this;\n\n  var baseLoader = params.loader || new THREE.OBJLoader();\n  var mtlLoader = new THREE.MTLLoader(baseLoader.manager);\n  mtlLoader.load = function(url, onLoad, onProgress, onError) {\n    var text = scope.zip.file(url).asText();\n    onLoad( mtlLoader.parse(text) );\n  };\n  params.loadTexture = function loadTexture(url, mapping, onLoad, onProgress, onError) {\n    var texture = scope.loadTexture('', url);\n    if ( mapping !== undefined ) texture.mapping = mapping;\n    if (onLoad) {\n      onLoad(texture);\n    }\n    return texture;\n  };\n\n  baseLoader.getFileLoader = function() {\n    return {\n      load: function(url, onLoad, onProgress, onError) {\n        var text = scope.zip.file(url).asText();\n        onLoad(text);\n      },\n      setPath: function() {}\n    };\n  };\n\n  params.loader = baseLoader;\n  params.mtlLoader = mtlLoader;\n  ZIPLoader.call(this, params);\n  baseLoader.setOptions(this.options);\n  baseLoader.setMtlOptions(this.options);\n};\n\nTHREE.ZippedObjLoader.prototype = Object.create(ZIPLoader.prototype);\nTHREE.ZippedObjLoader.prototype.constructor = THREE.ZippedObjLoader;\n\nTHREE.ZippedObjMtlLoader = function(params) {\n  params = _.defaults(params || {}, { regex: /^.*\\.obj$/ });\n\n  var scope = this;\n\n  var baseLoader = params.loader || new THREE.OBJMTLLoader();\n  var mtlLoader = new THREE.MTLLoader(baseLoader.manager);\n  mtlLoader.load = function(url, onLoad, onProgress, onError) {\n    var text = scope.zip.file(url).asText();\n    onLoad( mtlLoader.parse(text) );\n  };\n  params.loadTexture = function loadTexture(url, mapping, onLoad, onProgress, onError) {\n    var texture = scope.loadTexture('', url);\n    if ( mapping !== undefined ) texture.mapping = mapping;\n    if (onLoad) {\n      onLoad(texture);\n    }\n    return texture;\n  };\n\n  baseLoader.getFileLoader = function() {\n    return {\n      load: function(url, onLoad, onProgress, onError) {\n        var text = scope.zip.file(url).asText();\n        onLoad(text);\n      },\n      setPath: function() {}\n    };\n  };\n  baseLoader.load = function(url, onLoad, onProgress, onError ) {\n\n    baseLoader.loadWithMtl(url, scope.options.mtl, scope.options, onLoad, onProgress, onError);\n  };\n\n  params.loader = baseLoader;\n  params.mtlLoader = mtlLoader;\n  ZIPLoader.call(this, params);\n};\n\nTHREE.ZippedObjMtlLoader.prototype = Object.create(ZIPLoader.prototype);\nTHREE.ZippedObjMtlLoader.prototype.constructor = THREE.ZippedObjMtlLoader;\n\n//# sourceURL=webpack://STK/./js/lib/loaders/ZippedLoaders.js?");

/***/ }),

/***/ "./js/lib/loaders/index.js":
/*!*********************************!*\
  !*** ./js/lib/loaders/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! loaders/MTLLoader */ \"./js/lib/loaders/MTLLoader.js\"),\n        __webpack_require__(/*! loaders/OBJLoader */ \"./js/lib/loaders/OBJLoader.js\"),\n        __webpack_require__(/*! loaders/OBJMTLLoader */ \"./js/lib/loaders/OBJMTLLoader.js\"),\n        __webpack_require__(/*! vendor/three/loaders/deprecated/LegacyJSONLoader */ \"./js/vendor/three/loaders/deprecated/LegacyJSONLoader.js\"),\n        __webpack_require__(/*! loaders/ColladaLoader */ \"./js/lib/loaders/ColladaLoader.js\"),\n        __webpack_require__(/*! loaders/PLYLoader */ \"./js/lib/loaders/PLYLoader.js\"),\n        __webpack_require__(/*! loaders/P5DLoader */ \"./js/lib/loaders/P5DLoader.js\"),\n        __webpack_require__(/*! loaders/UTF8Loader */ \"./js/lib/loaders/UTF8Loader.js\"),\n        __webpack_require__(/*! loaders/GLTFLoader */ \"./js/lib/loaders/GLTFLoader.js\"),\n        __webpack_require__(/*! loaders/ZippedLoaders */ \"./js/lib/loaders/ZippedLoaders.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/lib/loaders/index.js?");

/***/ }),

/***/ "./js/lib/materials/Materials.js":
/*!***************************************!*\
  !*** ./js/lib/materials/Materials.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar ImageUtil = __webpack_require__(/*! util/ImageUtil */ \"./js/lib/util/ImageUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Utilities for dealing with materials (operates only on materials/textures)\n * @module\n */\nvar Materials = {};\nMaterials.DefaultMaterialType = THREE.MeshPhysicalMaterial;\nMaterials.DefaultMaterialSide = THREE.DoubleSide;\nMaterials.FalseMaterialType = THREE.MeshPhongMaterial;\n\nMaterials.setDefaultMaterialType = function(defaultMatType, falseMatType) {\n  if (defaultMatType != null) {\n    if (typeof defaultMatType === 'string') {\n      defaultMatType = Materials.getMaterialType(defaultMatType);\n    }\n    Materials.DefaultMaterialType = defaultMatType;\n    THREE.Loader.DefaultMaterialType = new defaultMatType().type;\n  }\n  if (falseMatType != null) {\n    if (typeof falseMatType === 'string') {\n      falseMatType = Materials.getMaterialType(falseMatType);\n    }\n    Materials.FalseMaterialType = falseMatType;\n  }\n};\n\n/**\n * Helper to load image for a texture\n * @param texture {THREE.Texture}\n * @param opts.url {string} URL to load image from\n * @param [opts.crossOrigin]\n * @param [opts.onLoad]\n * @param [opts.onProgress]\n * @param [opts.onError]\n * @param [opts.manager] {THREE.LoadingManager}\n * @static\n */\nfunction loadTextureImage ( texture, opts ) {\n  var onLoad = opts.onLoad;\n  var onProgress = opts.onProgress;\n  var onError = opts.onError;\n\n  var manager =  (opts.manager !== undefined ) ? opts.manager : THREE.DefaultLoadingManager;\n  var loader = new THREE.ImageLoader( manager );\n  loader.setCrossOrigin( opts.crossOrigin );\n  //console.log('Load image', opts.url);\n  loader.load( opts.url, function (image, imageLoadCompleteCb) {\n    ImageUtil.ensurePowerOfTwo(image, texture, function(err, resizedImage) {\n      //console.log('Resized image to power of two', opts.url);\n      if (err) {\n        console.warn('Error resizing image to power of two', opts.url, err);\n      }\n      texture.image = resizedImage || image;\n      texture.needsUpdate = true;\n      if ( onLoad ) onLoad( texture );\n      if ( imageLoadCompleteCb ) { imageLoadCompleteCb(null, texture.image); }\n    });\n  }, onProgress, onError, true);\n}\nMaterials.loadTextureImage = loadTextureImage;\n\n/**\n * Helper to load texture\n * @param opts.url {string} URL to load image from\n * @param [opts.crossOrigin]\n * @param [opts.onLoad]\n * @param [opts.onProgress]\n * @param [opts.onError]\n * @param [opts.manager] {THREE.LoadingManager}\n * @param [opts.mapping]\n * @param [opts.isDataTexture]\n * @returns {THREE.Texture}\n */\nfunction loadTexture(opts) {\n  var mapping = opts.mapping;\n  var url = opts.url;\n  var manager = opts.manager || THREE.DefaultLoadingManager;\n\n  var texture;\n  var loader = manager.getHandler( url );\n\n  if ( loader !== null ) {\n    texture = loader.load( url, opts.onLoad );\n  } else {\n    texture = new THREE.Texture();\n    texture.name = url;\n    texture.sourceFile = url;\n\n    loadTextureImage(texture, opts);\n  }\n\n  if (opts.isDataTexture) {\n    texture.generateMipmaps = false;\n    texture.minFilter = THREE.NearestFilter;\n    texture.magFilter = THREE.NearestFilter;\n    //    texture.unpackAlignment = 1;\n  }\n  if ( mapping !== undefined ) {\n    texture.mapping = mapping;\n  }\n  return texture;\n}\nMaterials.loadTexture = loadTexture;\n\n/**\n * Apply coloring to texture pixels (without changing alpha)\n * @param texture {THREE.Texture} Texture to recolor\n * @param opts Options for how to recolor\n * @param opts.color\n * @returns THREE.Texture\n */\nMaterials.recolorTexture = function(texture, opts) {\n  // Apply recoloring function to texture\n  if (opts.color) {\n    // get texture image and recolor pixels the specified color (without changing alpha)\n    var color = Colors.toColor(opts.color);\n    var r = Math.floor(color.r*255);\n    var g = Math.floor(color.g*255);\n    var b = Math.floor(color.b*255);\n    var imageData = ImageUtil.recolorImageData(texture.image, function(data, i) {\n      data[i] = r;\n      data[i+1] = g;\n      data[i+2] = b;\n    });\n    var origTexture = texture;\n    texture = new THREE.DataTexture(new Uint8Array(imageData.data.buffer), imageData.width, imageData.height,\n      THREE.RGBAFormat, THREE.UnsignedByteType, texture.mapping, texture.wrapS, texture.wrapT);\n    texture.repeat = origTexture.repeat;\n    texture.offset = origTexture.offset;\n    texture.needsUpdate = true;\n  }\n  return texture;\n};\n\nMaterials.createMultiMaterial = function(materials) {\n  materials.isMultiMaterial = true;\n  materials.materials = materials;\n  materials.clone = function () {\n    return materials.slice();\n  };\n  return materials;\n};\n\nMaterials.getBasicMaterial = function (color, alpha, materialSide) {\n  if (color instanceof THREE.Material || color instanceof THREE.MultiMaterial) {\n    return color;\n  }\n  if (materialSide == null) {\n    materialSide = Materials.DefaultMaterialSide;\n  }\n  var mat = new THREE.MeshBasicMaterial({side: materialSide, color: color});\n  if (alpha != undefined) {\n    Materials.setMaterialOpacity(mat, alpha);\n  }\n  return mat;\n};\n\n\n/**\n * Transforms input into a material\n * @param mat {THREE.Material|THREE.MultiMaterial|color}\n * @returns {THREE.Material|THREE.MultiMaterial}\n */\nMaterials.toMaterial = function (mat) {\n  if (mat instanceof THREE.Material || mat instanceof THREE.MultiMaterial) {\n    return mat;\n  } else {\n    var color = mat || 'gray';\n    if (_.isArray(color)) {\n      var c = color;\n      color = new THREE.Color(c[0], c[1], c[2]);\n      return Materials.getStandardMaterial(color, c[3]);\n    } else {\n      return Materials.getStandardMaterial(Colors.toColor(color));\n    }\n  }\n};\n\nMaterials.updateMaterialParams = function(materialType, p) {\n  // Adjust for specular/shininess if material don't support them\n  if (materialType === THREE.MeshStandardMaterial || materialType === THREE.MeshPhysicalMaterial) {\n    var p2 = _.omit(p, ['specular', 'shininess']);\n    if (p.shininess != undefined) {\n      p2.roughness = 1 - THREE.Math.clamp(p.shininess / 200, 0, 1);\n    }\n    return p2;\n  } else {\n    return p;\n  }\n};\n\nMaterials.getMaterial = function (color, alpha, materialType, materialSide) {\n  if (color instanceof THREE.Material || color instanceof THREE.MultiMaterial) {\n    return color;\n  }\n  materialType = materialType || Materials.DefaultMaterialType;\n  if (materialSide == null) {\n    materialSide = Materials.DefaultMaterialSide;\n  }\n  var c = color;\n  var a = new THREE.Color();\n  //a.setRGB(0.02, 0.02, 0.05);\n  a.setRGB(c.r / 4, c.g / 4, c.b / 4);\n  var s = new THREE.Color();\n  s.setRGB(0.18, 0.18, 0.18);\n  var mat = new materialType(Materials.updateMaterialParams(materialType, {\n    color: c,\n    //ambient: a,\n    specular: s,\n    shininess: 64,\n    side: materialSide\n  }));\n  if (alpha != undefined) {\n    Materials.setMaterialOpacity(mat, alpha);\n  }\n  return mat;\n};\n\nMaterials.getStandardMaterial = function (color, alpha, materialSide) {\n  return Materials.getMaterial(color, alpha, Materials.DefaultMaterialType, materialSide);\n};\n\nMaterials.getSimpleFalseColorMaterial = function (id, color, palette) {\n  var c = color;\n  if (!c) {\n    c = Colors.createColor(id, palette || Constants.defaultPalette);\n  } else if (!(c instanceof THREE.Color)) {\n    c = Colors.toColor(c);\n  }\n\n  var mat = Materials.getMaterial(c, 1, Materials.FalseMaterialType);\n  mat.name = 'color' + id;\n  return mat;\n};\n\n\nMaterials.setMaterialOpacity = function (material, opacity) {\n  if (Array.isArray(material)) {\n    for (var i = 0; i < material.length; i++) {\n      Materials.setMaterialOpacity(material[i], opacity);\n    }\n  } else if (material instanceof THREE.MultiMaterial) {\n    for (var i = 0; i < material.materials.length; i++) {\n      Materials.setMaterialOpacity(material.materials[i], opacity);\n    }\n  } else {\n    material.opacity = opacity;\n    material.transparent = opacity < 1;\n  }\n};\n\nMaterials.createMaterial = function(params) {\n  // NOTE: Cannot have type set!!!\n  var p = _.omit(params, ['type']);\n  if (p.opacity < 1) {\n    p.transparent = true;\n  }\n  var colors = ['color', 'emissive', 'specular'];\n  colors.forEach(function (c) {\n    if (p.hasOwnProperty(c)) {\n      if (typeof p[c] === 'string') {\n        p[c] = new THREE.Color(parseInt(p[c], 16));\n      } else if (typeof p[c] instanceof THREE.Color) {\n      } else {\n        p[c] = new THREE.Color(p[c]);\n      }\n    }\n  });\n  var maps = ['map', 'bumpMap', 'normalMap', 'specularMap', 'envMap'];\n  maps.forEach(function (m) {\n    if (p.hasOwnProperty(m)) {\n      var textureParams = p[m];\n      var texture = Materials.loadTexture({ url: textureParams.src });\n      texture.name = textureParams.name;\n      texture.wrapS = (textureParams.wrapS !== undefined) ? textureParams.wrapS : THREE.RepeatWrapping;\n      texture.wrapT = (textureParams.wrapT !== undefined) ? textureParams.wrapT : THREE.RepeatWrapping;\n      p[m] = texture;\n    }\n  });\n\n  var materialType = Materials.getMaterialType(params.type);\n  return new materialType(p);\n};\n\nMaterials.getMaterialSide = function(sidedness, defaultSide) {\n  if (typeof(sidedness) === 'string') {\n    sidedness = sidedness.toLowerCase();\n    if (sidedness === \"front\") {\n      return THREE.FrontSide;\n    } else if (sidedness === \"back\") {\n      return THREE.BackSide;\n    } else if (sidedness === \"double\") {\n      return THREE.DoubleSide;\n    } else {\n      console.warn('Unknown sidedness: ' + sidedness);\n    }\n  } else if (sidedness == undefined) {\n    // console.log('Unspecified sidedness')\n  } else {\n    console.warn('Invalid sidedness type:' + typeof(sidedness));\n  }\n  return defaultSide;\n};\n\nMaterials.getMaterialType = function(mtype) {\n  switch (mtype) {\n    case 'basic':\n      return THREE.MeshBasicMaterial;\n    case 'normal':\n      return THREE.MeshNormalMaterial;\n    case 'depth':\n      return THREE.MeshDepthMaterial;\n    case 'face':\n      return THREE.MultiMaterial;\n    case 'lambert':\n      return THREE.MeshLambertMaterial;\n    case 'phong':\n      return THREE.MeshPhongMaterial;\n    case 'physical':\n      return THREE.MeshPhysicalMaterial;\n    case 'standard':\n      return THREE.MeshStandardMaterial;\n    case 'toon':\n      return THREE.MeshToonMaterial;\n    default:\n      console.log('Unknown material type: ' + mtype + ', default to ' + Materials.DefaultMaterialType.constructor.name);\n      return Materials.DefaultMaterialType;\n  }\n};\n\nMaterials.getMaterialParams = function (material) {\n  var includeFields = [\n    'id', 'name', 'side', 'opacity', 'shininess', 'reflexivity',\n    'color', 'emissive', 'specular', 'metalness', 'roughness',\n    'map', 'bumpMap', 'normalMap', 'specularMap', 'envMap'];\n  var params = _.pick(material, includeFields);\n  if (material instanceof THREE.MeshPhongMaterial) {\n    params['type'] = 'phong';\n  } else if (material instanceof THREE.MeshLambertMaterial) {\n    params['type'] = 'lambert';\n  } else if (material instanceof THREE.MeshBasicMaterial) {\n    params['type'] = 'basic';\n  } else if (material instanceof THREE.MeshNormalMaterial) {\n    params['type'] = 'normal';\n  } else if (material instanceof THREE.MeshDepthMaterial) {\n    params['type'] = 'depth';\n  } else if (material instanceof THREE.MultiMaterial) {\n    params['type'] = 'face';\n  } else if (material instanceof THREE.MeshPhysicalMaterial) {\n    params['type'] = 'physical';\n  } else if (material instanceof THREE.MeshToonMaterial) {\n    params['type'] = 'toon';\n  } else if (material instanceof THREE.MeshStandardMaterial) {\n    params['type'] = 'standard';\n  }\n  return params;\n};\n\nMaterials.getTextureParams = function (texture) {\n  var includeFields = [\n    'id', 'name', 'src', 'wrapS', 'wrapT'];\n  var params = _.pick(texture, includeFields);\n  if (params.src === undefined) {\n    params.src = texture.image.src;\n  }\n  return params;\n};\n\nMaterials.cloneMaterial = function(m) {\n  if (Array.isArray(m)) {\n    var copy = [];\n    for (var i = 0; i < m.length; i++) {\n      copy[i] = m[i].clone();\n    }\n    return copy;\n  } else {\n    return m.clone();\n  }\n};\n\nMaterials.toMaterialArray = function(material) {\n  if (material != null) {\n    if (material instanceof THREE.MultiMaterial) {\n      return material.materials;\n    } else if (Array.isArray(material)) {\n      return material;\n    } else {\n      return [material];\n    }\n  } else {\n    return [];\n  }\n};\n\n/**\n * Returns material of the intersected triangle\n * @param intersected {Intersect}\n */\nMaterials.getMaterialAtIntersected = function(intersected) {\n  var material = intersected.object.material;\n  if (material instanceof THREE.MultiMaterial) {\n    material = material.materials;\n  }\n  if (Array.isArray(material)) {\n    var iFaceMaterial = intersected.face.materialIndex;\n    return material[iFaceMaterial];\n  }\n  return material;\n};\n\nmodule.exports = Materials;\n\n\n/**\n * Material definition\n * @memberOf materials\n * @typedef MaterialDef\n * @type {object}\n * @property {string} type - Material type (`basic|phong|physical`)\n * @property {THREE.Color|string} [color] - Material color\n */\n\n//# sourceURL=webpack://STK/./js/lib/materials/Materials.js?");

/***/ }),

/***/ "./js/lib/math/MatrixUtil.js":
/*!***********************************!*\
  !*** ./js/lib/math/MatrixUtil.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nconst MatrixUtil = {};\n\nfunction axisPairToOrthoMatrix(_v1, _v2) {\n  // Let's make a copy so we don't change the incoming vectors\n  var v1 = new THREE.Vector3();\n  v1.copy(_v1);\n  v1.normalize();\n  var v2 = new THREE.Vector3();\n  v2.copy(_v2);\n  v2.normalize();\n  var v3 = new THREE.Vector3();\n  v3.crossVectors(v1, v2);\n\n  var m = new THREE.Matrix4();\n\n  m.set(\n    v1.x, v2.x, v3.x, 0,\n    v1.y, v2.y, v3.y, 0,\n    v1.z, v2.z, v3.z, 0,\n    0, 0, 0, 1\n  );\n\n  return m;\n}\nMatrixUtil.axisPairToOrthoMatrix = axisPairToOrthoMatrix;\n\n/**\n * Returns matrix to align from objectUp/objectFront to targetUp/targetFront\n * Assumptions: objectUp perpendicular to objectFront, targetUp perpendicular to targetFront.\n * @param objectUp Object's semantic up vector\n * @param objectFront Object's semantic front vector\n * @param targetUp Target up vector\n * @param targetFront Target front vector\n */\nMatrixUtil.getAlignmentMatrix = function (objectUp, objectFront, targetUp, targetFront) {\n  // Figure out what transform to apply to matrix\n  var objM = MatrixUtil.axisPairToOrthoMatrix(objectUp, objectFront);\n  var targetM = MatrixUtil.axisPairToOrthoMatrix(targetUp, targetFront);\n  var transform = new THREE.Matrix4();\n  var objMinv = new THREE.Matrix4();\n  objMinv.getInverse(objM);\n  transform.multiplyMatrices(targetM, objMinv);\n  return transform;\n};\n\n/**\n * Returns matrix to align from objectUp/objectFront to targetUp/targetFront\n * Assumptions: objectUp perpendicular to objectFront, targetUp perpendicular to targetFront.\n * @param objectUp Object's semantic up vector\n * @param objectFront Object's semantic front vector\n * @param targetUp Target up vector\n * @param targetFront Target front vector\n */\nMatrixUtil.getAlignmentQuaternion = function (objectUp, objectFront, targetUp, targetFront) {\n  var m = MatrixUtil.getAlignmentMatrix(objectUp, objectFront, targetUp, targetFront);\n  var position = new THREE.Vector3();\n  var scale = new THREE.Vector3();\n  var quaternion = new THREE.Quaternion();\n  m.decompose( position, quaternion, scale );\n  return quaternion;\n};\n\nfunction getRotationMatrixFromX(axis) {\n  return MatrixUtil.getAlignmentMatrixSingle(new THREE.Vector3(1,0,0), axis);\n}\nMatrixUtil.getRotationMatrixFromX = getRotationMatrixFromX;\n\nfunction getRotationMatrixFromY(axis) {\n  return MatrixUtil.getAlignmentMatrixSingle(new THREE.Vector3(0,1,0), axis);\n}\nMatrixUtil.getRotationMatrixFromY = getRotationMatrixFromY;\n\nfunction getRotationMatrixFromZ(axis) {\n  return MatrixUtil.getAlignmentMatrixSingle(new THREE.Vector3(0,0,1), axis);\n}\nMatrixUtil.getRotationMatrixFromZ = getRotationMatrixFromZ;\n\nfunction getOrthogonal(axis, rng = RNG.global) {\n  const w = axis.clone().normalize();\n  // Get random perpendicular to normal\n  const axes = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)];\n  for (let c of axes) {\n    if (Math.abs(c.dot(w)) == 0) {\n      return c;\n    }\n  }\n  const rand = new THREE.Vector3(rng.random(), rng.random(), rng.random()).normalize();\n  const randLengthInNormalDir = rand.dot(axis);\n  const randPartInNormalDir = w.multiplyScalar(randLengthInNormalDir);\n  const v = rand.clone();\n  v.sub(randPartInNormalDir);\n  v.normalize();\n  return v;\n}\nMatrixUtil.getOrthogonal = getOrthogonal;\n\nMatrixUtil.getAlignmentMatrixSingle = function (axis, target) {\n  const v1 = MatrixUtil.getOrthogonal(axis);\n  const v2 = MatrixUtil.getOrthogonal(target);\n  return MatrixUtil.getAlignmentMatrix(axis, v1, target, v2);\n};\n\n\nmodule.exports = MatrixUtil;\n\n//# sourceURL=webpack://STK/./js/lib/math/MatrixUtil.js?");

/***/ }),

/***/ "./js/lib/math/RNG.js":
/*!****************************!*\
  !*** ./js/lib/math/RNG.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var WELL = __webpack_require__(/*! well-rng */ \"../node_modules/well-rng/rng.js\");\n\nvar DEFAULT_SEED = [-73145273,-575333020,78223421,-75649942,97283626,1974487898,-1644093459,201800120,-2115906659,165918927,-351927079,-1995780997,-1821837288,-1884378861,502825323,1124314248,206222802,1973999199,-1212521702,619760979,-7423385,451025801,-1638878953,-535113523,-781706019,1903931134,-1075061703,-2020616308,1211246856,1483958096,2082487863,-1455167716];\n\n/**\n * Random number generator that can be seeded\n * @param params\n * @constructor\n * @memberOf math\n */\nfunction RNG(params) {\n  params = params || {};\n  var generator = params.generator || 'well-1024a';\n  if (generator === 'well-1024a') {\n    this.__rng = new WELL();\n  } else {\n    console.error('Unrecognized RNG type: ' + generator);\n  }\n  if (params.overrideMathRandom) {\n    Math.random = this.__rng.random.bind(this.__rng);\n  }\n}\n\nRNG.global = new RNG();\n\nRNG.prototype.seed = function (s) {\n  s = 0 | s;\n  var state = new Array(32);\n  for (var i = 0; i < 32; ++i) {\n    state[i] = 0 | (DEFAULT_SEED[i] + s);\n  }\n  this.__rng.set_state(state);\n};\n\nRNG.prototype.random = function () {\n  return this.__rng.random();\n};\n\nRNG.prototype.randInt = function (min, max) {\n  return this.__rng.randInt(min, max);\n};\n\nRNG.prototype.randBits = function (bits) {\n  return this.__rng.randBits(bits);\n};\n\n/**\n * Returns float point number in [min, max]\n * @param min {number}\n * @param max {number}\n * @returns {number}\n */\nRNG.prototype.uniform = function (min, max) {\n  return min + (this.random() * (max - min));\n};\n\n/**\n * Returns element of arr chosen uniformly at random\n * @param arr\n * @returns {*}\n */\nRNG.prototype.choice = function (arr) {\n  return arr[this.randInt(0, arr.length - 1)];\n};\n\n/**\n * Return k unique elements from array\n * @param array\n * @param k\n */\nRNG.prototype.sample = function (array, k) {\n  var arr = array.slice();\n  var j, tmp, ln = arr.length;\n  for (var i = ln - 1; i > (ln - k - 1); i--) {\n    j = this.randInt(0, i + 1);\n    tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n  return arr.slice(ln - k);\n};\n\n/**\n * Shuffles the array\n * @param array\n * @param inplace\n * @returns {*}\n */\nRNG.prototype.shuffle = function(array, inplace) {\n  const length = array == null ? 0 : array.length;\n  if (!length) {\n    return [];\n  }\n  var index = -1;\n  var lastIndex = length - 1;\n  var result = inplace? array : array.slice();\n  while (++index < length) {\n    const rand = index + Math.floor(this.random() * (lastIndex - index + 1));\n    const value = result[rand];\n    result[rand] = result[index];\n    result[index] = value;\n  }\n  return result;\n};\n\nmodule.exports = RNG;\n\n//# sourceURL=webpack://STK/./js/lib/math/RNG.js?");

/***/ }),

/***/ "./js/lib/model/Model.js":
/*!*******************************!*\
  !*** ./js/lib/model/Model.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! model/ModelInstance */ \"./js/lib/model/ModelInstance.js\"),__webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\"),__webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\"),__webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\"),__webpack_require__(/*! Constants */ \"./js/lib/Constants.js\"), __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (ModelInstance, Object3DUtil, GeometryUtil, AssetGroups, Constants, _) {\n\n      /**\n       * Metadata associated with each model.  The metadata is pretty much a freeform set of attributes and values.\n       * It must include the id,source of the model.  Other information are optional and typically populated after retrieving information from solr.\n       * @typedef {Object} ModelInfo\n       * @memberOf model\n       *\n       * @property fullId {string} Unique identifier for this model (concatenation of source and id)\n       * @property source {string} 3D model database from which this model is taken (\"wss\" or \"archive3d\")\n       * @property id {string} Unique id (for given source)\n       * @property [name] {string} Name of model\n       * @property [tags] {string[]} Tags associated with the model\n       * @property [unit] {number} Number specifying the physical unit (in meters) the model is specified in (defaults to Constants.defaultModelUnit)\n       * @property [up] {number[]|THREE.Vector3} Up vector for model ( defaults to the z-vector (0,0,1) )\n       * @property [front] {number[]|THREE.Vector3} Front vector for model ( defaults to the y-vector (0,1,0)? )\n       * @property [category] {string[]} Category of model\n       * @property [nfaces] {int} Number of faces\n       * @property [nvertices] {int} Number of vertices\n       * @property [nmaterials] {int} Number of materials\n       */\n\n      /**\n       * Create a new Model - a Model represents a 3D geometry with texture from which\n       *   we can instantiate new ModelInstance(s).  Each ModelInstance has the same\n       *   basic geometry as the original Model, but can be transformed (scaled, rotated, positioned)\n       *   in different ways.  The original Model is not used directly in a scene.\n       *   Only ModelInstance(s) are used in scenes.\n       *\n       * @param object3D {THREE.Object3D} Object3D that contains geometry/texture for the model\n       * @param info {Object} Additional metadata about the model\n       * @constructor\n       * @memberOf model\n       * @property object3D {THREE.Object3D}\n       * @property info {model.ModelInfo} The metadata associated with this model.\n       */\n      function Model(object3D, info) {\n        this.init(object3D, info);\n      }\n\n      Model.prototype.init = function (object3D, info) {\n        this.__origObject3D = object3D;              // Original input model\n        this.object3D = new THREE.Object3D();       // Physically scaled model\n        this.object3D.add(this.__origObject3D);\n        this.object3D.userData.type = 'Model';\n        this.object3D.userData = this.__origObject3D.userData;\n\n        if (!info) info = {};\n        this.info = info;\n\n        if (info.fullId) {\n          this.__origObject3D.name = info.fullId + '-orig';\n          this.object3D.name = info.fullId;\n          this.object3D.userData.modelId = info.fullId;\n        }\n\n        if (!this.info.source && this.info.options && this.info.options.source) {\n          this.info.source = this.info.options.source;\n        }\n\n        if (this.info.options && this.info.options.autoAlign) {\n          this.alignToWorld();\n        }\n        if (this.info.materials) {\n          this.applyMaterials();\n        } else if (this.info.options && this.info.options.defaultMaterial) {\n          Object3DUtil.setMaterial(this.object3D, this.info.options.defaultMaterial);\n        }\n\n        // Initialize object3D to physical scale\n        if (this.info.options && this.info.options.autoScale) {\n          this.initialBBDims = this.getBBoxDims();\n          console.log('Initial model ' + this.getFullID() +\n              ' bbdims: [' + this.initialBBDims.x + ',' + this.initialBBDims.y + ',' + this.initialBBDims.z + ']');\n\n          var scale = this.getVirtualUnit();\n          this.object3D.scale.set(scale, scale, scale);\n          this.object3D.updateMatrix();\n          Object3DUtil.clearCache(this.object3D);\n\n          this.physicalBBDims = this.getBBoxDims();\n          console.log('Rescaled model ' + this.getFullID() + ' with scale ' + scale +\n              ' bbdims: [' + this.physicalBBDims.x + ',' + this.physicalBBDims.y + ',' + this.physicalBBDims.z + ']');\n        }\n        if (this.info.options && this.info.options.autoCenter) {\n          var center = this.info.options.autoCenter;\n          if (typeof center === 'boolean') {\n              center = null;\n          } else {\n              center = Object3DUtil.toVector3(center);\n          }\n          Object3DUtil.placeObject3D(this.object3D, null, center);\n        }\n      };\n\n      Model.prototype.getAlignmentMatrix = function () {\n        var up = this.getUp();\n        var front = this.getFront();\n        var matrix =  Object3DUtil.getAlignmentMatrix(up, front, Constants.worldUp, Constants.worldFront);\n        if (this.info.alignments) {\n          //console.log('Got alignments', this.info.alignments);\n          if (this.info.alignments.data) {\n            var alns = this.info.alignments.data;\n            if (alns.length) {\n              var aln = alns[0].matrix;\n              // Premultiply (right multiply) matrix with aln\n              var transform = new THREE.Matrix4();\n              transform.multiplyMatrices(matrix, aln);\n              matrix = transform;\n            }\n          }\n        }\n        return matrix;\n      };\n\n      Model.prototype.applyMaterials = function () {\n        // Apply materials to this model\n        Object3DUtil.applyMaterialMappings(this.object3D, JSON.parse(this.info.materials));\n      };\n\n      Model.prototype.alignToWorld = function () {\n        var up = this.getUp();\n        var front = this.getFront();\n        //console.log('aligning model to world: up=' + JSON.stringify(up) + ', front=' + JSON.stringify(front));\n        Object3DUtil.alignToUpFrontAxes(this.object3D, up, front, Constants.worldUp, Constants.worldFront);\n        if (this.info.alignments) {\n          //console.log('Got alignments', this.info.alignments);\n          if (this.info.alignments.data) {\n            var alns = this.info.alignments.data;\n            if (alns.length) {\n              var aln = alns[0].matrix;\n              // Premultiply (right multiply) matrix with aln\n              var transform = new THREE.Matrix4();\n              transform.multiplyMatrices(this.object3D.matrix, aln);\n              Object3DUtil.setMatrix(this.object3D, transform);\n            }\n          }\n        }\n      };\n\n      Model.prototype.getUp = function () {\n        if (this.info.up && !(this.info.up instanceof THREE.Vector3)) {\n          this.info.up = Object3DUtil.toVector3(this.info.up);\n        }\n        return (this.info.up) ? this.info.up : AssetGroups.getDefaultUp(this.info);\n      };\n\n      Model.prototype.getFront = function () {\n        if (this.info.front && !(this.info.front instanceof THREE.Vector3)) {\n          this.info.front = Object3DUtil.toVector3(this.info.front);\n        }\n        return (this.info.front) ? this.info.front : AssetGroups.getDefaultFront(this.info);\n      };\n\n      Model.prototype.getDefaultUp = function () {\n        return AssetGroups.getDefaultUp(this.info);\n      };\n\n      Model.prototype.getDefaultFront = function () {\n        return AssetGroups.getDefaultFront(this.info);\n      };\n\n      Model.prototype.getVersion = function () {\n        return (this.info.version) ? this.info.version : 0;\n      };\n\n      Model.prototype.getFullID = function () {\n        return this.info.fullId;\n      };\n\n      Model.prototype.getAssetSource = function() {\n        return this.info.source;\n      };\n\n      Model.prototype.getBBox = function () {\n        return Object3DUtil.getBoundingBox(this.object3D);\n      };\n\n      Model.prototype.getBBoxDims = function () {\n        return Object3DUtil.getBoundingBoxDims(this.object3D, this.getBBox());\n      };\n\n      // Returns unit scale of this model\n      Model.prototype.getUnit = function () {\n        var unit = (this.info.unit) ? this.info.unit : AssetGroups.getDefaultUnit(this.info);\n        return unit;\n      };\n\n      // Returns unit in centimeters\n      Model.prototype.getVirtualUnit = function () {\n        // Get stored unit (in meters)\n        var unit = (this.info.unit) ? this.info.unit : AssetGroups.getDefaultUnit(this.info);\n        // Convert from stored physical unit to centimeters\n        unit = unit * Constants.metersToVirtualUnit;\n        return unit;\n      };\n\n      // Assumes this.object3D and correspondingly its BBox are already physically scaled\n      Model.prototype.getPhysicalDims = function () {\n        return this.physicalBBDims;\n      };\n\n      Model.prototype.newInstance = function (clone) {\n        return new ModelInstance(this,clone);\n      };\n\n      Model.prototype.deepClone = function() {\n        return new Model(Object3DUtil.deepClone(this.__origObject3D), this.info);\n      };\n\n      Model.prototype.isDoor = function () {\n        return this.hasCategory('door', true) || this.hasCategory('arch', true) || this.hasCategory('garage_door', true);\n      };\n\n      Model.prototype.isWindow = function () {\n        return this.hasCategory('window', true);\n      };\n\n      Model.prototype.isStairs = function () {\n        return this.hasCategory('stairs', true);\n      };\n\n      Model.prototype.isRoof = function () {\n        return this.hasCategory('roof', true);\n      };\n\n      Model.prototype.isPlant = function () {\n        return this.hasCategory('plant', true);\n      };\n\n      Model.prototype.isPerson = function () {\n        return this.hasCategory('person', true);\n      };\n\n      Model.prototype.isPartition = function () {\n        return this.hasCategory('partition', true);\n      };\n\n      Model.prototype.isStructure = function () {\n        return this.hasCategory('partition', true) || this.hasCategory('column', true) || this.hasCategory('roof', true);\n      };\n\n      Model.prototype.hasCategory = function (cat, ignoreCase) {\n        if (ignoreCase) {\n          var cats = this.getAllCategoryTags().map( function(x) { return x.toLowerCase(); });\n          return cats.indexOf(cat.toLowerCase()) >= 0;\n        } else {\n          var cats = this.getAllCategoryTags();\n          return cats.indexOf(cat) >= 0;\n        }\n      };\n\n      Model.prototype.hasCategoryIn = function (cats, ignoreCase) {\n        for (var i = 0; i < cats.length; i++) {\n          var cat = cats[i];\n          if (this.hasCategory(cat, ignoreCase)) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      Model.prototype.hasCategorySimilar = function (cat) {\n        // HACKY Similar category (exact match not required)\n        var cats = this.getCategories().map( function(x) { return x.toLowerCase(); });\n        var lower = cat.toLowerCase();\n        if (cats.indexOf(lower) >= 0) {\n          return true;\n        } else {\n          // Do better check\n          for (var i = 0; i < cats.length; i++) {\n            var c = cats[i];\n            var pieces = c.split(/[\\s,_.]+/);\n            //if (pieces[pieces.length-1] === lower || pieces[pieces.length-1] === (lower + 's')) {\n            if (pieces.indexOf(lower) >= 0 || pieces.indexOf(lower + 's') >= 0) {\n              return true;\n            }\n          }\n        }\n        return false;\n      };\n\n      Model.prototype.getMatchingCategory = function (validCategories) {\n        //var cats = this.getCategories();\n        var cats = this.getAllCategoryTags();\n        if (cats.length > 0) {\n          for (var i = 0; i < cats.length; i++) {\n            var cat = cats[i];\n            if (validCategories.has(cat)) {\n              return cat;\n            }\n          }\n          return null;\n        } else { return null; }\n      };\n\n      Model.prototype.getCategory = function (useFine) {\n        var cats = this.getCategories();\n        if (cats.length > 0) {\n          return useFine? cats[cats.length-1] : cats[0];\n        } else { return null; }\n      };\n\n      Model.prototype.getCategories = function () {\n        if (this.info && this.info.category) {\n          var categories = this.info.category;\n          if (!Array.isArray(categories)) {\n            categories = [categories];\n          }\n          var cats = categories.filter( function(x) { return !x.startsWith('_'); });\n          if (this.info.categoryOrdering === 'coarse-to-fine') {\n            cats = _.reverse(cats);\n          }\n          return cats;\n        } else {\n          return [];\n        }\n      };\n\n      Model.prototype.getInternalCategoryTags = function() {\n        // Return internal categories\n        return this.getAllCategoryTags().filter(function (x) {\n            return x.startsWith('_');\n        });\n      };\n\n      Model.prototype.getAllCategoryTags = function() {\n        if (this.info && this.info.category) {\n          var categories = this.info.category;\n          if (!Array.isArray(categories)) {\n            categories = [categories];\n          }\n          return categories;\n        } else {\n          return [];\n        }\n      };\n\n      Model.prototype.getDatasets = function () {\n        if (this.info && this.info.datasets) {\n          return this.info.datasets;\n        } else {\n          return [];\n        }\n      };\n\n      Model.prototype.isScan = function() {\n        return (this.info && Constants.assetSources.scan.indexOf(this.info.source) >= 0);\n      };\n\n      Model.prototype.getAudioFile = function(soundName) {\n        if (this.info && this.info.sounds) {\n          if (soundName) {\n            return this.info.sounds[soundName];\n          } else {\n            for (var s in this.info.sounds) {\n              if (this.info.sounds.hasOwnProperty(s)) {\n                return this.info.sounds[s];\n              }\n            }\n          }\n        }\n      };\n\n      Model.prototype.getAnnotatedContactPoint = function () {\n        if (this.info && this.info.contactPoint) {\n          return Object3DUtil.toVector3(this.info.contactPoint);\n        }\n      };\n\n      Model.prototype.isIndexed = function () {\n        return this.info && !this.info.isCustomAsset;\n      };\n\n      Model.prototype.getPartsConnectivity = function() {\n        if (this.partsConnectivity) {\n          return this.partsConnectivity;\n        }\n        if (this.object3D.userData.partsConnectivity) {\n          var PartsConnectivityGraph = __webpack_require__(/*! parts/PartConnectivityGraph */ \"./js/lib/parts/PartConnectivityGraph.js\");\n          this.partsConnectivity = PartsConnectivityGraph.fromJson(this.object3D.userData.partsConnectivity);\n          // connect object3D to connectivity graph (not needed since we will want to do this with the modelInstance)\n          //var nodes = Object3DUtil.findNodes(this.object3D,(node) => node.userData.pid != null);\n          //var idToObj = _.keyBy(nodes, (node) => node.userData.pid );\n          //this.partsConnectivity.withPartObject3Ds(idToObj);\n        }\n        return this.partsConnectivity;\n      };\n\n      // Exports\n      return Model;\n\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/lib/model/Model.js?");

/***/ }),

/***/ "./js/lib/model/ModelInfo.js":
/*!***********************************!*\
  !*** ./js/lib/model/ModelInfo.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar ModelInfo = {};\n\nModelInfo.getUp = function (info) {\n    if (info.up && !(info.up instanceof THREE.Vector3)) {\n        info.up = Object3DUtil.toVector3(info.up);\n    }\n    return (info.up) ? info.up : AssetGroups.getDefaultUp(info);\n};\n\nModelInfo.getFront = function (info) {\n    if (info.front && !(info.front instanceof THREE.Vector3)) {\n        info.front = Object3DUtil.toVector3(info.front);\n    }\n    return (info.front) ? info.front : AssetGroups.getDefaultFront(info);\n};\n\nModelInfo.getDefaultUp = function (info) {\n    return AssetGroups.getDefaultUp(info);\n};\n\nModelInfo.getDefaultFront = function (info) {\n    return AssetGroups.getDefaultFront(info);\n};\n\nModelInfo.getAlignmentMatrix = function(info1, info2) {\n  return  Object3DUtil.getAlignmentMatrix(\n      ModelInfo.getUp(info1), ModelInfo.getFront(info1),\n      ModelInfo.getUp(info2), ModelInfo.getFront(info2));\n};\n\nModelInfo.getUnit = function(info) {\n  return (info.unit) ? info.unit : AssetGroups.getDefaultUnit(info);\n};\n\nModelInfo.getRelativeTransform = function(info1, info2) {\n  var alignMat = ModelInfo.getAlignmentMatrix(info1, info2);\n  var s = ModelInfo.getUnit(info1) / ModelInfo.getUnit(info2);\n  return alignMat.scale(new THREE.Vector3(s, s, s));\n}\n\nModelInfo.getCenterTo = function(info) {\n  return Object3DUtil.toVector3(info.defaultCenter);\n};\n\nmodule.exports = ModelInfo;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/model/ModelInfo.js?");

/***/ }),

/***/ "./js/lib/model/ModelInstance.js":
/*!***************************************!*\
  !*** ./js/lib/model/ModelInstance.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! geo/BBox */ \"./js/lib/geo/BBox.js\"), __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\"),__webpack_require__(/*! Constants */ \"./js/lib/Constants.js\"), __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (BBox, Object3DUtil, Constants, _) {\n\n  /**\n   * ModelInstance represents an object (an instantiation of a 3D model)\n   * @param model {model.Model} Model from which to create a ModelInstance\n   * @param clone {boolean|THREE.Object3D} Whether to make a clone of the Model or not (NOTE: The cloning is only applies to the node hierarchy - the geometry is reused).\n   *   If a THREE.Object3D is specified, it is used as the cloned instance directly.\n   * @memberOf model\n   * @constructor\n   * @property object3D {THREE.Object3D} Object3D corresponding to the model instance.  This will be the top level node, under which will be `modelBaseObject3D` (optional), and `modelObject3D` (required)\n   * @property modelBaseObject3D {THREE.Object3D} Intermediate node used for editing operations.  Should not be accessed externally.  Automatically introduced when `setAttachmentPoint` is called.\n   * @property modelObject3D {THREE.Object3D} Object3D corresponding to the model.  Use this member (getObject3D('Model')) to get the transform in the original model space.\n   * @property model {model.Model} Model from which the model instance was created from (NOTE: typically the model is cloned and `this.model.object3D` and `this.object3D` will refer to different objects).\n   * @property scale {number}\n   * @property material {THREE.Material}\n   */\n  function ModelInstance(model, clone) {\n    this.model = model;\n    this.scale = 1;\n    this.material = null;\n\n    if (clone instanceof THREE.Object3D) {\n      if (clone.userData.type === 'Model') {\n        this.modelObject3D = clone;\n      } else if (clone.userData.type === 'ModelInstance') {\n        this.object3D = clone;\n        // Assume first child is the model...\n        this.modelObject3D = this.object3D.children[0];\n      } else {\n        console.error('Invalid object 3d as parameter');\n        console.log(clone);\n      }\n    }\n\n    if (!this.modelObject3D) {\n      // We weren't passed in a object3D to use for this modelInstance, lets create our own\n      // Cloning is only needed for multiple instances of same model\n      if (clone) {\n        this.modelObject3D = this.model.object3D.clone();\n      } else {\n        this.modelObject3D = this.model.object3D;\n      }\n    }\n\n    if (!this.object3D) {\n      this.object3D = new THREE.Object3D(); // Enclosing Object3D to handle instance transformation\n      if (model.info.fullId) {\n        this.object3D.name = model.info.fullId + '-inst';\n      }\n      this.object3D.add(this.modelObject3D);\n      this.object3D.userData.modelId = model.getFullID();\n      this.object3D.userData.type = 'ModelInstance';\n    }\n    this.object3D.metadata = {\n      modelInstance: this\n    };\n\n    this.object3D.userData.lightsOn = this.modelObject3D.userData.lightsOn;\n    this._updateLights();\n  }\n\n  ModelInstance.prototype.clone = function (clonedObject3D) {\n    if (clonedObject3D === undefined) {\n      Object3DUtil.revertMaterials(this.object3D);\n      this.object3D.updateMatrixWorld();\n      clonedObject3D = this.object3D.clone();\n    }\n\n    var newMinst = new ModelInstance(this.model, clonedObject3D);\n    newMinst.scale = this.scale;\n    if (this.material) {\n      newMinst.material = this.material.clone();\n    }\n    return newMinst;\n  };\n\n  ModelInstance.prototype.getObject3D = function (type) {\n    if (type === undefined || type === 'ModelInstance') {\n      return this.object3D;\n    } else if (type === 'Model') {\n      return this.modelObject3D;\n    } else {\n      console.error('Unknown object 3d type: ' + type);\n    }\n  };\n\n  ModelInstance.prototype.getArticulatedObjects = function() {\n    return Object3DUtil.findNodes(this.object3D, function(n) { return n.type === 'ArticulatedObject'; });\n  };\n\n  ModelInstance.prototype.getPartsConnectivity = function() {\n    if (this.partsConnectivity) {\n      return this.partsConnectivity;\n    }\n    var partsConnectivity = this.model.getPartsConnectivity();\n    if (partsConnectivity) {\n      var object3d = this.modelObject3D;\n      var nodes = Object3DUtil.findNodes(object3d,(node) => node.userData.pid != null);\n      var idToObj = _.keyBy(nodes, (node) => node.userData.pid );\n      partsConnectivity = partsConnectivity.withPartObject3Ds(idToObj, true);\n      this.partsConnectivity = partsConnectivity;\n    }\n    return this.partsConnectivity;\n  };\n\n  ModelInstance.prototype.toArticulatedObject = function(articulations) {\n    var partsConnectivity = this.getPartsConnectivity();\n    if (partsConnectivity) {\n      if (!Array.isArray(articulations)) {\n        articulations = [articulations];\n      }\n      var ArticulatedObject = __webpack_require__(/*! articulations/ArticulatedObject */ \"./js/lib/articulations/ArticulatedObject.js\");\n      return new ArticulatedObject(articulations, partsConnectivity);\n    }\n  }\n\n  ModelInstance.prototype.tumble = function () {\n    Object3DUtil.tumble(this.object3D);\n  };\n\n  ModelInstance.prototype.__switchModel = function(m) {\n    function replaceModelObject3D(obj3D, modelObject3D) {\n      var modelInstChildren = _.filter(obj3D.children, function(x) { return x.userData.type === 'ModelInstance'; });\n      Object3DUtil.removeAllChildren(obj3D);\n      obj3D.add(modelObject3D);\n      for (var i = 0; i < modelInstChildren.length; i++) {\n        obj3D.add(modelInstChildren[i]);\n      }\n    }\n    // console.log('switchModel', this, this.modelObject3D, m);\n    var oldModelObject3D = this.modelObject3D;\n    this.model = m;\n    this.modelObject3D = m.object3D.clone();\n    Object3DUtil.setMatrix(this.modelObject3D, oldModelObject3D.matrix);\n    // Move materials from old model to this one\n    var oldMeshes = Object3DUtil.getMeshList(oldModelObject3D);\n    var newMeshes = Object3DUtil.getMeshList(this.modelObject3D);\n    if (oldMeshes.length === newMeshes.length) {\n      for (var i = 0; i < newMeshes.length; i++) {\n        newMeshes[i].material = oldMeshes[i].material;\n      }\n    }\n    if (this.modelBaseObject3D) {\n      replaceModelObject3D(this.modelBaseObject3D, this.modelObject3D);\n    } else {\n      replaceModelObject3D(this.object3D, this.modelObject3D);\n    }\n    this.object3D.matrixWorldNeedsUpdate = true;\n    Object3DUtil.clearCache(this.object3D);\n\n    this._updateLights();\n\n    // Propagate castShadow and receiveShadow from this object down\n    Object3DUtil.setCastShadow(this.object3D, this.object3D.castShadow);\n    Object3DUtil.setReceiveShadow(this.object3D, this.object3D.receiveShadow);\n  };\n\n  ModelInstance.prototype.useFlippedModel = function(assetManager) {\n    var flipped = assetManager.getFlippedModel(this.model);\n    // Set the modelObject3D to be the flipped model\n    this.__switchModel(flipped);\n  };\n\n  ModelInstance.prototype.useModelVariant = function(assetManager, variantId, callback) {\n    var scope = this;\n    assetManager.getModelVariant(this.model, variantId, function(err, variant) {\n      if (err) {\n        console.error(err);\n      }\n      if (variant) {\n        // Set the modelObject3D to be the variant model\n        scope.__switchModel(variant);\n      }\n      if (callback) {\n        callback(err, variant);\n      }\n    });\n  };\n\n  ModelInstance.prototype.useNextModelVariant = function(assetManager) {\n    var modelInfo = this.model.info;\n    if (modelInfo.variantIds) {\n      var i = modelInfo.variantIds.indexOf(modelInfo.id);\n      if (i >= 0) {\n        var vi = (i+1) % modelInfo.variantIds.length;\n        this.useModelVariant(assetManager, modelInfo.variantIds[vi]);\n        return modelInfo.variantIds[vi];\n      }\n    }\n  };\n\n  ModelInstance.prototype.getLightState = function () {\n    return this.object3D.userData.lightsOn;\n  };\n\n  ModelInstance.prototype.setLightState = function (flag, assetManager) {\n    this.object3D.userData.lightsOn = flag;\n    var numLights = 0;\n    var lightSpecs = this.model.info.lightSpecs;\n    if (lightSpecs) {\n      var modelObject = this.getObject3D('Model');\n      numLights = lightSpecs.lights? lightSpecs.lights.length : 0;\n      if (assetManager && numLights && modelObject.userData.lightsOn == undefined) {\n        assetManager.__lightsLoader.createLights(this.model.info, modelObject);\n      }\n      numLights = Object3DUtil.setLights(this.object3D, flag);\n      Object3DUtil.setMaterialState(this.object3D, lightSpecs.materials, flag);\n    }\n    return numLights;\n  };\n\n  ModelInstance.prototype.queryCapabilities = function(assetManager) {\n    // Some capabilities to query\n    var object3D = this.object3D;\n    var modelInfo = this.model.info;\n    var scope = this;\n    // variants\n    Object3DUtil.getCapability(object3D,\n      'variants', function() {\n        var hasVariants = modelInfo.variantIds && modelInfo.variantIds.length > 0;\n        if (hasVariants) {\n          var openVariants = modelInfo.variantIds.filter(function(x) { return !x.endsWith('_0'); });\n          var closeVariants = modelInfo.variantIds.filter(function(x) { return x.endsWith('_0'); });\n          return {\n            getOperations: function() {\n              return ['toggle', 'open', 'close'];\n            },\n            openable: function() { return openVariants.length > 0; },\n            open: function(cb) {\n              if (openVariants.length > 0) {\n                scope.useModelVariant(assetManager, openVariants[0], cb);\n              }\n            },\n            closeable: function() { return closeVariants.length > 0; },\n            close: function(cb) {\n              if (closeVariants.length > 0) {\n                scope.useModelVariant(assetManager, closeVariants[0], cb);\n              }\n            },\n            toggle: function(cb) {\n              scope.useNextModelVariant(assetManager, cb);\n            }\n          };\n        }\n      });\n    // lights\n    Object3DUtil.getCapability(object3D,\n      'lights', function() {\n        var hasLights = modelInfo.lightSpecs && modelInfo.lightSpecs.lights && modelInfo.lightSpecs.lights.length > 0;\n        if (hasLights) {\n          var LightControls = __webpack_require__(/*! capabilities/LightControls */ \"./js/lib/capabilities/LightControls.js\");\n          return new LightControls({\n            object3D: object3D\n          });\n        }\n      });\n    // video\n    Object3DUtil.getCapability(object3D,\n      'video', function() {\n        return Object3DUtil.addVideoPlayer(object3D, { assetManager: assetManager });\n      });\n    // articulations\n    Object3DUtil.getCapability(object3D,\n        'articulation', function() {\n        return Object3DUtil.addArticulationPlayer(object3D, { assetManager: assetManager });\n    });\n    // Return capabilities\n    return Object3DUtil.getCapabilities(object3D);\n  };\n\n  ModelInstance.prototype._updateLights = function () {\n    this.setLightState(this.object3D.userData.lightsOn);\n    var lights = Object3DUtil.findLights(this.object3D);\n    for (var i = 0; i < lights.length; i++) {\n      var light = lights[i];\n      if (light instanceof THREE.SpotLight && light.target) {\n        light.parent.add(light.target);\n      }\n    }\n  };\n\n  /**\n   * Ensures that the model coordinate frame is normalized to be aligned with our world coordinate frame.\n   * Any scaling on the model instance is also absorbed into the `modelObject3D`.\n   * This means that the transform on `modelObject3D` is such that the `modelObject3D`\n   *  is oriented in the same way as our world coordinate frame (with same up and front), and positioning the `modelObject3D`\n   *  positions the axis-aligned bbox center of the `modelObject3D`.\n   * NOTE: This operation need to happen before any other nodes are introduced between the main `object3D` for this\n   *   model instance and the `modelObject3D` (e.g. it needs to happen before `setAttachmentPoint` is ever called)\n   * @returns {THREE.Matrix4} New localToWorld transform of this modelInstance's object3D.\n   */\n  ModelInstance.prototype.ensureNormalizedModelCoordinateFrame = function () {\n    // NOTE: Assumes that this.modelObject3D is a direct child of this.object3D and that\n    //       there are no other children for this.object3D\n    var modelInstanceMatrix = this.object3D.matrix.clone();\n    var modelObjectMatrix = this.modelObject3D.matrix.clone();\n\n    var matrix = new THREE.Matrix4();\n    matrix.multiplyMatrices(modelInstanceMatrix, modelObjectMatrix);\n\n    var alignment = this.model.getAlignmentMatrix();\n    Object3DUtil.normalize(this.modelObject3D, alignment, this.object3D.scale);\n\n    var newModelObjectMatrixInv = new THREE.Matrix4();\n    newModelObjectMatrixInv.getInverse(this.modelObject3D.matrix);\n    matrix.multiply(newModelObjectMatrixInv);\n\n    Object3DUtil.setMatrix(this.object3D, matrix);\n    //this.object3D.position.set(0,0,0);\n    //this.object3D.rotation.set(0,0,0);\n    //this.object3D.scale.set(1,1,1);\n    //this.object3D.updateMatrix();\n\n    //this.object3D.applyMatrix(matrix);\n    //this.object3D.updateMatrix();  // make sure matrixWorldNeedsUpdate is set\n\n    //Object3DUtil.clearCache(this.object3D);\n    return this.object3D.matrix;\n  };\n\n  /**\n   * Set attachment point.  To ensure that editing operations use a reasonable coordinate frame,\n   *  the `modelBaseObject3D` is introduced here so that operations on `this.object3D` can now assume that\n   *  the origin of `this.object3D` is at the attachment point (so movement, rotation, scaling will all be about that point)\n   * @param options\n   * @param [options.position] {THREE.Vector3} Position at which to place attachment point\n   * @param [options.coordFrame] {string} Coordinate frame is 'worldBB', 'parentBB', 'childBB', or 'child'\n   * @param [options.useModelContactPoint=false] {boolean} Whether to use annotated contact point\n   */\n  ModelInstance.prototype.setAttachmentPoint = function (options) {\n    // Wrapping so we have ModelInstance\n    // with ModelBase (transformed so aligned and centered at attachment point)\n    // with Model (transformed so aligned and centered at origin)\n    //this.object3D.updateMatrixWorld();\n    if (!this.modelBaseObject3D) {\n      this.modelBaseObject3D = new THREE.Object3D();\n      if (!this.modelBaseObject3D.userData) {\n        this.modelBaseObject3D.userData = {};\n      }\n      this.modelBaseObject3D.userData['attachmentPoint'] = new THREE.Vector3(0.5, 0.5, 0.5);\n      this.modelBaseObject3D.userData['type'] = 'ModelBase';\n      this.modelBaseObject3D.add(this.modelObject3D);\n      this.modelBaseObject3D.name = this.modelObject3D.name + '-base';\n      this.object3D.add(this.modelBaseObject3D);\n    }\n    var p = options.position;\n    var pCoordFrame = options.coordFrame;\n    if (options.useModelContactPoint) {\n      var contactPointInModelSpace = this.model.getAnnotatedContactPoint();\n      if (contactPointInModelSpace) {\n        console.log('contactPoint');\n        console.log(contactPointInModelSpace);\n        // Get the point in modelBaseObject3D\n        p = contactPointInModelSpace.clone().applyMatrix4(this.modelObject3D.matrix);\n        console.log(p);\n        pCoordFrame = 'child';\n      }\n    }\n    if (!this.modelBaseObject3D.userData['attachmentPoint'].equals(p)) {\n      Object3DUtil.setChildAttachmentPoint(this.object3D, this.modelBaseObject3D, p, pCoordFrame);\n    }\n  };\n\n  /**\n   * Returns attachment point in local normalized coordinate\n   * @returns {THREE.Vector3}\n   */\n  ModelInstance.prototype.getAttachmentPointLocal = function () {\n    if (this.modelBaseObject3D) {\n      return this.modelBaseObject3D.userData['attachmentPoint'];\n    }\n  };\n\n  /**\n   * Returns attachment point in world coordinate\n   * @returns {THREE.Vector3}\n   */\n  ModelInstance.prototype.getAttachmentPointWorld = function () {\n    if (this.modelBaseObject3D) {\n      var v = new THREE.Vector3();\n      this.object3D.updateMatrixWorld();\n      v.setFromMatrixPosition(this.object3D.matrixWorld);\n      return v;\n    }\n  };\n\n  /**\n   * @typedef {Object} AttachmentPoint\n   * @memberOf model\n   * @property type {string} Type of attachment `bbface` or `annotated`\n   * @property frame {string} Coordinate frame `child`\n   * @property bbfaceIndex {int} If attachment is `bbface`, which face.\n   * @property local {{pos: THREE.Vector3, out: THREE.Vector3}}\n   * @property world {{pos: THREE.Vector3, out: THREE.Vector3}}\n   * @property index: attachment index (id)\n   */\n\n  /**\n   * Returns candidate attachment points (6 canonical points at the centers of the bounding box, and any annotated attachments)\n   * @returns {model.AttachmentPoint[]}\n   */\n  ModelInstance.prototype.getCandidateAttachmentPoints = function() {\n    // Returns as candidate attachment points the 6 canonical bbox sides\n    // along with any annotated contact points\n    this.object3D.updateMatrixWorld();\n    var modelBB = Object3DUtil.computeBoundingBoxLocal(this.modelObject3D.parent);\n    var modelBBDims = modelBB.dimensions();\n    var mw = this.modelObject3D.parent.matrixWorld;\n    var modelBBDimsWorld = new THREE.Vector3();\n    var modelBBWorldCenter = new THREE.Vector3(0,0,0).applyMatrix4(mw);\n    modelBBDimsWorld.fromArray([new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)].map(\n      function (x) {\n        return x.multiply(modelBBDims).applyMatrix4(mw).sub(modelBBWorldCenter).length();\n      }));\n    var modelBBFaceDimsWorld = BBox.getFaceDims(modelBBDimsWorld);\n    var normalMatrixWorld = new THREE.Matrix3();\n    normalMatrixWorld.getNormalMatrix(mw);\n\n    //console.log('got modelBBDimsWorld', modelBBDimsWorld);\n    var attachmentPoints = [];\n    for (var i = 0; i < 6; i++) {\n      var fc = Object3DUtil.FaceCenters01[i];\n      var outNorm = Object3DUtil.OutNormals[i];\n      var p = modelBB.getWorldPosition(fc);\n      var wp = p.clone().applyMatrix4(this.modelObject3D.parent.matrixWorld);\n      var woutNorm = outNorm.clone().applyMatrix3(normalMatrixWorld).normalize();\n      var s = Math.abs(modelBBDimsWorld.dot(outNorm));\n      attachmentPoints.push({\n        type: 'bbface',\n        frame: 'child',\n        bbfaceIndex: i,\n        local: { pos: p, out: outNorm },\n        world: { pos: wp, out: woutNorm, size: s, faceDims: modelBBFaceDimsWorld[i] },\n        index: attachmentPoints.length\n      });\n    }\n    var contactPointInModelSpace = this.model.getAnnotatedContactPoint();\n    if (contactPointInModelSpace) {\n      // Get the point in modelBaseObject3D\n      var p = contactPointInModelSpace.clone().applyMatrix4(this.modelObject3D.matrix);\n      var wp = p.clone().applyMatrix4(this.modelObject3D.parent.matrixWorld);\n      var outNorm = Object3DUtil.OutNormals[Constants.BBoxFaceCenters.BOTTOM];\n      var woutNorm = outNorm.clone().applyMatrix3(normalMatrixWorld).normalize();\n      var s = Math.abs(modelBBDimsWorld.dot(outNorm));\n      attachmentPoints.push({\n        type: 'annotated',\n        local: { pos: p, out: outNorm },\n        world: { pos: wp, out: woutNorm, size: s },\n        index: attachmentPoints.length\n      });\n    }\n    return attachmentPoints;\n  };\n\n  ModelInstance.prototype.setMaterial = function (material) {\n    this.material = material;\n    Object3DUtil.setMaterial(this.object3D, material);\n  };\n\n  ModelInstance.prototype.alignAndScale = function (targetUp, targetFront, sceneUnit) {\n    // Assumes that the model has not been aligned/scaled\n    // Aligns and scales the model instance based on the model unit and front/up\n    var model = this.model;\n    var up = model.getUp();\n    var front = model.getFront();\n    Object3DUtil.alignToUpFrontAxes(this.object3D, up, front, targetUp, targetFront);\n    if (sceneUnit) {\n      var targetScale = model.getVirtualUnit() / sceneUnit;\n      this.setScale(targetScale);\n    }\n  };\n\n  ModelInstance.prototype.alignAndScaleObject3D = function(object3D, targetUp, targetFront) {\n    var model = this.model;\n    var up = model.getUp();\n    var front = model.getFront();\n    Object3DUtil.alignToUpFrontAxes(object3D, up, front, targetUp, targetFront);\n    Object3DUtil.rescaleObject3D(object3D, model.getVirtualUnit());\n  };\n\n  // TODO: Fix interface to these calls (detect vector vs numbers)\n\n  ModelInstance.prototype.translate = function (delta) {\n    this.object3D.position.add(delta);\n    this.object3D.updateMatrix();\n    Object3DUtil.clearCache(this.object3D);\n  };\n\n  ModelInstance.prototype.setTranslation = function (x, y, z) {\n    if (x instanceof THREE.Vector3) {\n      this.object3D.position.copy(x);\n    } else {\n      this.object3D.position.set(x, y, z);\n    }\n    this.object3D.updateMatrix();\n    Object3DUtil.clearCache(this.object3D);\n  };\n\n  ModelInstance.prototype.scaleBy = function (scale, maintainAttachmentAt) {\n    //console.time('scaleBy');\n    if (maintainAttachmentAt != undefined) {\n      var oldPosition = Object3DUtil.getBBoxFaceCenter(this.object3D,maintainAttachmentAt);\n      this.setScale(this.scale * scale);\n      Object3DUtil.placeObject3DByBBFaceCenter(this.object3D,oldPosition,maintainAttachmentAt);\n    } else {\n      this.setScale(this.scale * scale);\n    }\n    //console.timeEnd('scaleBy');\n  };\n\n  ModelInstance.prototype.setScale = function (scale) {\n    // Debug logging\n    //console.log(\"Scaling model instance \" + this.object3D.id + \", model \" + this.model.getFullID() + \" to \" + scale);\n    //var bbdims = this.getBBoxDims();\n    // console.log(\"Before bbdims: [\" + bbdims.x + \",\" + bbdims.y + \",\" + bbdims.z + \"]\");\n    // Actual scaling\n    if (this.object3D.parent && this.scale) {\n      // Has parent, just do relative scaling\n      var sf = scale / this.scale;\n      var s = this.object3D.scale;\n      this.object3D.scale.set(s.x * sf, s.y * sf, s.z * sf);\n    } else {\n      // No parent, just set our scale\n      this.object3D.scale.set(scale, scale, scale);\n    }\n    this.scale = scale;\n    this.object3D.updateMatrix();\n    Object3DUtil.clearCache(this.object3D);\n\n    // Debug logging\n    //bbdims = this.getBBoxDims();\n    // console.log(\"After bbdims: [\" + bbdims.x + \",\" + bbdims.y + \",\" + bbdims.z + \"]\");\n  };\n\n  ModelInstance.prototype.setScaleToDefault = function () {\n    this.setScale(Constants.metersToVirtualUnit * Constants.defaultModelUnit / this.model.getVirtualUnit());\n  };\n\n  ModelInstance.prototype.convertScaleToNewUnit = function (unit) {\n    this.setScale(unit / this.model.getVirtualUnit());\n  };\n\n  ModelInstance.prototype.getScale = function () {\n    return this.scale;\n  };\n\n  // Returns the unit that this model instance wants to be in\n  ModelInstance.prototype.getVirtualUnit = function () {\n    return this.scale * this.model.getVirtualUnit();\n  };\n\n  ModelInstance.prototype.getPhysicalSize = function (sizeBy) {\n    var dims = this.getPhysicalDims();\n    return Object3DUtil.convertBbDimsToSize(dims, sizeBy);\n  };\n\n  ModelInstance.prototype.setToPhysicalSize = function (sizeBy, targetSize) {\n    var dims = this.model.getPhysicalDims();\n    var modelSize = Object3DUtil.convertBbDimsToSize(dims, sizeBy);\n    if (modelSize) {\n      var scale = targetSize / modelSize;\n      this.setScale(scale);\n    } else {\n      console.error('Unable to get model size using sizeBy ' + this.sizeBy);\n    }\n  };\n\n  ModelInstance.prototype.setScaleVector = function (sx, sy, sz) {\n    if (sx instanceof THREE.Vector3) {\n      this.object3D.scale.copy(sx);\n    } else {\n      this.object3D.scale.set(sx, sy, sz);\n    }\n    this.object3D.updateMatrix();\n    Object3DUtil.clearCache(this.object3D);\n  };\n\n  ModelInstance.prototype.rotate = function (delta, order, bbBoxPoint) {\n    Object3DUtil.rotateObject3DEuler(this.object3D, delta, order, bbBoxPoint);\n  };\n\n  ModelInstance.prototype.rotateAboutAxis = function (axis, delta, bbBoxPoint) {\n    Object3DUtil.rotateObject3DAboutAxis(this.object3D, axis, delta, bbBoxPoint);\n  };\n\n  ModelInstance.prototype.rotateAboutAxisSimple = function (axis, delta, isWorld) {\n    Object3DUtil.rotateObject3DAboutAxisSimple(this.object3D, axis, delta, isWorld);\n  };\n\n  ModelInstance.prototype.rotateWrtBBFace = function (axis, delta, bbface) {\n    Object3DUtil.rotateObject3DWrtBBFace(this.object3D, axis, delta, bbface);\n    //Object3DUtil.rotateObject3D(this.object3D, delta, order);\n  };\n\n  ModelInstance.prototype.setRotation = function (x, y, z) {\n    //console.log(this.object3D.position, this.object3D.rotation);\n    var r = this.object3D.rotation;\n    this.rotate(new THREE.Vector3(-r.x,-r.y,-r.z), 'ZYX');\n    this.rotate(new THREE.Vector3(x,y,z));\n    // Just setting the rotation doesn't quite work (object moved)\n    //this.object3D.rotation.set(x, y, z);\n    //this.object3D.updateMatrix();\n  };\n\n  ModelInstance.prototype.setQuaternion = function (x, y, z, w) {\n    if (x instanceof THREE.Quaternion) {\n      this.object3D.quaternion.copy(x);\n    } else {\n      this.object3D.quaternion.set(x, y, z, w);\n    }\n    this.object3D.updateMatrix();\n    Object3DUtil.clearCache(this.object3D);\n  };\n\n  ModelInstance.prototype.clearRotation = function (undoModelRotation) {\n      this.setRotation(0,0,0);\n      if (undoModelRotation) {\n        var modelRotation = this.model.object3D.rotation;\n        this.rotate(new THREE.Vector3(-modelRotation.x,-modelRotation.y,-modelRotation.z), 'ZYX');\n      }\n    };\n\n  // transform is THREE.Matrix4\n  ModelInstance.prototype.applyTransform = function (transform) {\n    this.object3D.applyMatrix(transform);\n    this.object3D.updateMatrix();  // make sure matrixWorldNeedsUpdate is set\n    this.scale = this.object3D.scale.x;\n    Object3DUtil.clearCache(this.object3D);\n  };\n\n  /**\n   * Returns the world axis-aligned bounding box of this model instance\n   */\n  ModelInstance.prototype.getBBox = function () {\n    return Object3DUtil.getBoundingBox(this.object3D);\n  };\n\n  ModelInstance.prototype.getBBoxDims = function () {\n    var bbox = this.getBBox();\n    return bbox.dimensions();\n  };\n\n  ModelInstance.prototype.getPhysicalDims = function () {\n    var unscaledPhysicalDims = this.model.getPhysicalDims();\n    var physicalDims = new THREE.Vector3();\n    physicalDims.copy(unscaledPhysicalDims);\n    physicalDims.multiply(this.object3D.scale);\n    return physicalDims;\n  };\n\n  ModelInstance.prototype.getUpFrontAxes = function (targetUp, targetFront, snapTo) {\n    var r = new THREE.Quaternion();\n    if (this.modelBaseObject3D) {\n      r.multiplyQuaternions(this.object3D.quaternion, this.modelBaseObject3D.quaternion);\n      r.multiplyQuaternions(r, this.modelObject3D.quaternion);\n    } else {\n      r.multiplyQuaternions(this.object3D.quaternion, this.modelObject3D.quaternion);\n    }\n    return Object3DUtil.getObjUpFrontAxes(r, targetUp, targetFront, snapTo);\n  };\n\n  ModelInstance.prototype.alignObbUpFront = function(obb, targetUp, targetFront) {\n    Object3DUtil.alignObjectObbUpFront(this.object3D, obb, targetUp, targetFront);\n  };\n\n  ModelInstance.prototype.getPartMeshes = function() {\n    return Object3DUtil.getMeshList(this.object3D);\n  };\n\n  ModelInstance.prototype.getUILogInfo = function (detailed) {\n    var logInfo = detailed ? {\n      modelIndex: this.index,\n      modelId: this.model.getFullID(),\n      category: this.model.getCategory()\n    } : {\n      modelIndex: this.index\n    };\n    return logInfo;\n  };\n\n  ModelInstance.getUILogInfo = function (obj, detailed) {\n    if (obj instanceof THREE.Object3D) {\n      var selectedInstance = Object3DUtil.getModelInstance(obj);\n      return selectedInstance.getUILogInfo(detailed);\n    } else if (obj instanceof ModelInstance) {\n      return obj.getUILogInfo(detailed);\n    }\n  };\n\n  // Exports\n  return ModelInstance;\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/lib/model/ModelInstance.js?");

/***/ }),

/***/ "./js/lib/parts/Part.js":
/*!******************************!*\
  !*** ./js/lib/parts/Part.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const OBB = __webpack_require__(/*! geo/OBB */ \"./js/lib/geo/OBB.js\");\n\nclass Part {\n  /**\n   * Defines a part\n   * @param pid {int} Part id\n   * @param name {string} Part name\n   * @param label {string} Part label\n   * @param obb {geo.OBB} Part obb\n   * @param object3D {THREE.Object3D} Part geometry\n   */\n  constructor(pid, label, name, obb, object3D) {\n    this.pid = pid;\n    this.label = label;\n    this.name = name;\n    this.obb = obb;\n    this.object3D = object3D;\n\n    this.parent = null;\n    this.children = [];\n  }\n\n  get text() {\n    return this.label;\n  }\n\n  set text(v) {\n    this.label = v;\n  }\n\n  clone() {\n    // Fine, as long as we never intend to modify the underlying part geometry...\n    // (We can modify transforms, though)\n    let clonedObject3D = null;\n    if (this.object3D) {\n      const oldChildren = this.object3D.children;\n      const basicChildren = this.object3D.children.filter(c => c.userData.pid == null);\n      this.object3D.children = basicChildren;\n      clonedObject3D = this.object3D.clone();\n      this.object3D.children = oldChildren;\n    }\n    return new Part(this.pid, this.label, this.name,\n      this.obb? this.obb.clone() : null,\n      clonedObject3D);\n  }\n\n  toJson() {\n    return {\n      pid: this.pid,\n      label: this.label,\n      name: this.name,\n      obb: this.obb? this.obb.toJSON() : undefined,\n      // skip object3D\n      // Some extra information that we added for merged parts\n      baseIds: this.baseIds && this.baseIds.length? this.baseIds : undefined,\n      parentId: this.parentIds && this.parentIds.length? this.parentIds : undefined,\n      childIds: this.childIds && this.childIds.length? this.childIds : undefined,\n      sourceParts: this.sourceParts? this.sourceParts.map( p => p.toJson() ) : undefined\n    }\n  }\n\n  fromJson(json) {\n    // NOTE: this does not populate the object3D field\n    this.pid = json.pid;\n    this.label = json.label;\n    this.name = json.name;\n    if (json.obb) {\n      this.obb = new OBB();\n      this.obb.fromJSON(json.obb);\n    } else {\n      this.obb = null;\n    }\n    this.object3D = null;\n\n    this.parent = json.parent;\n    this.children = json.children || [];\n  }\n\n  static fromJson(json) {\n    let part = new Part();\n    part.fromJson(json);\n    return part;\n  }\n}\n\nmodule.exports = Part;\n\n//# sourceURL=webpack://STK/./js/lib/parts/Part.js?");

/***/ }),

/***/ "./js/lib/parts/PartConnectivityGraph.js":
/*!***********************************************!*\
  !*** ./js/lib/parts/PartConnectivityGraph.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Part = __webpack_require__(/*! parts/Part */ \"./js/lib/parts/Part.js\");\nconst _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nclass PartConnectivityGraph {\n    /**\n     * Defines a connectivity graph between parts\n     * @param connections {int[][]}\n     * @param parts {Part[]}\n     */\n    constructor(connections, parts, metadata) {\n        this.connections = connections? connections.map(c => new Set(c)) : [];\n        this.parts = parts;\n        this.metadata = metadata;\n    }\n\n    isConnected(pid1, pid2) {\n        return this.getConnectedPartIds(pid1).has(pid2);\n    }\n\n    remove(pid1, pid2, bidir=false) {\n        if (this.connections[pid1] && this.connections[pid1].has(pid2)) {\n            console.log(`Removing ${pid1} and ${pid2}`);\n            this.connections[pid1].delete(pid2);\n        }\n        if (bidir && this.connections[pid2] && this.connections[pid2].has(pid1)) {\n            console.log(`Removing ${pid2} and ${pid1}`);\n            this.connections[pid2].delete(pid1);\n        }\n    }\n\n    add(pid1, pid2, bidir=false) {\n        this.connections[pid1] = this.connections[pid1] || new Set();\n        this.connections[pid1].add(pid2);\n        if (bidir) {\n            this.connections[pid2] = this.connections[pid2] || new Set();\n            this.connections[pid2].add(pid1);\n        }\n    }\n\n    discardPartHierarchy() {\n        this.parts.forEach( p => {\n            p.object3D.children = p.object3D.children.filter(c => c.userData.pid == null);\n            p.object3D.parent = null;\n            delete p.baseIds;\n            delete p.childIds;\n            delete p.parentId;\n            delete p.object3D.userData.isStatic;\n            delete p.object3D.userData.isArticulated;\n            delete p.object3D.userData.articulatablePartId;\n            delete p.object3D.userData.isArticulatedNode;\n        });\n    }\n\n    getConnectedPartIds(pid) {\n        if (this.connections[pid]) {\n            return [...this.connections[pid]];\n        } else return [];\n    }\n\n    getConnectedParts(part) {\n        return this.getConnectedPartIds(part.pid).map(pid => this.parts[pid]);\n    }\n\n    /**\n     * Get part ids that are connected by traversing connectivity graph\n     * Note that the partIds are included in the returned set of parts\n     * @param partIds\n     * @param [stopFn] {function(id): boolean} Whether to stop when the node is reached\n     * @param [includeFn] {function(id): boolean} If specified, for a node that we decide not to traverse further,\n     *                                          whether to include it in the connected set\n     * @returns {Set<int>}\n     */\n    getConnectedPartIdsDeep(partIds, stopFn, includeFn) {\n        if (!Array.isArray(partIds)) {\n            partIds = [partIds];\n        }\n        const todo = partIds.slice();\n        const connected = new Set();\n        while (todo.length > 0) {\n            let pid = todo.pop();\n            connected.add(pid);\n            let connectedIds = this.getConnectedPartIds(pid);\n            for (let cid of connectedIds) {\n                if (!stopFn || !stopFn(cid)) {\n                    if (!connected.has(cid)) {\n                        todo.push(cid);\n                    }\n                } else if (includeFn) {\n                    if (includeFn(cid)) {\n                        connected.add(cid);\n                    }\n                }\n            }\n        }\n        return connected;\n    }\n\n    cutExtraConnections(articulations) {\n        // Extract hierarchy from articulations\n        for (let articulation of articulations) {\n            // based on base/articulation extra connections\n            let pid = articulation.pid;\n            let basePartIds = articulation.base;\n            let connectedBasePartIds = this.getConnectedPartIdsDeep(basePartIds, cid => pid === cid);\n            let connectedChildPartIds = this.getConnectedPartIdsDeep(pid, cid => connectedBasePartIds.has(cid));\n            for (let cid of connectedChildPartIds) {\n                for (let bid of connectedBasePartIds) {\n                    if (basePartIds.indexOf(bid) < 0) {\n                        this.remove(cid, bid, true);\n                    }\n                }\n            }\n        }\n    }\n\n    clone(cloneParts = false) {\n        const parts = cloneParts? _.map(this.parts, (p) => p? p.clone() : null) : this.parts;\n        return new PartConnectivityGraph(this.connectivityAsArray(), parts, this.metadata);\n    }\n\n    connectivityAsArray() {\n        return this.connections.map(p => [...p]);\n    }\n\n    withPartObject3Ds(idToObjs, clone) {\n        const graph = clone? this.clone(true) : this;\n        _.each(idToObjs, (obj, pid) => {\n            if (typeof pid === 'string') {\n                pid = parseInt(pid);\n            }\n            if (graph.parts[pid]) {\n                graph.parts[pid].object3D = obj;\n            } else {\n                console.log('unknown part', pid);\n            }\n        });\n        return graph;\n    }\n\n    fromPartHierarchy(partHierarchy) {\n        const nodes = partHierarchy.getNodes();\n        this.parts = nodes;\n        this.connections = [];\n        nodes.forEach(n => {\n            if (n.parent) {\n                this.add(n.pid, n.parent.pid, true);\n            }\n            if (n.children) {\n                for (let c of n.children) {\n                    this.add(n.pid, c.pid, true);\n                }\n            }\n        });\n        this.metadata = {};\n        if (this.metadata.modelId == null) {\n            this.metadata.modelId = partHierarchy.root.object3D.userData.modelId;\n        }\n    }\n\n    static fromPartHierarchy(partHierarchy) {\n        let cg = new PartConnectivityGraph();\n        cg.fromPartHierarchy(partHierarchy);\n        return cg;\n    }\n\n    fromJson(json) {\n        this.parts = json.parts.map(p => p? Part.fromJson(p) : null );\n        this.connections = json.connectivityGraph.map(c => new Set(c));\n        this.metadata = json.metadata || {};\n        if (this.metadata.partsAnnId == null) {\n            this.metadata.partsAnnId = json.annId;\n        }\n        if (this.metadata.modelId == null) {\n            this.metadata.modelId = json.modelId || json.id;\n        }\n\n    }\n\n    toJson() {\n        const json = {\n            version: 'part-connectivity@0.0.1',\n            modelId: this.metadata? this.metadata.modelId : undefined,\n            metadata: _.omit(this.metadata, ['modelId'])\n        };\n        json.parts = this.parts.map(p => p? p.toJson() : null);\n        const allSourceParts = [];\n        for (let part of json.parts) {\n            if (part && part.sourceParts) {\n                for (let p of part.sourceParts) {\n                    allSourceParts[p.pid] = p;\n                }\n                part.sourcePartIds = part.sourceParts.map(p => p.pid);\n                delete part.sourceParts;\n            }\n        }\n        if (allSourceParts.length > 0) {\n            json.sourceParts = allSourceParts;\n        }\n        json.connectivityGraph = this.connectivityAsArray();\n        return json;\n    }\n\n    static fromJson(json) {\n        let cg = new PartConnectivityGraph();\n        cg.fromJson(json);\n        return cg;\n    }\n\n    static load(filename, callback) {\n        _.getJSON(filename, (err, json) => {\n            if (err) {\n                callback(err, null);\n            } else {\n                callback(null, PartConnectivityGraph.fromJson(json));\n            }\n        });\n    }\n\n}\n\n\nmodule.exports = PartConnectivityGraph;\n\n//# sourceURL=webpack://STK/./js/lib/parts/PartConnectivityGraph.js?");

/***/ }),

/***/ "./js/lib/parts/PartHierarchy.js":
/*!***************************************!*\
  !*** ./js/lib/parts/PartHierarchy.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Tree = __webpack_require__(/*! ds/Tree */ \"./js/lib/ds/Tree.js\");\nconst Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\n\nclass PartHierarchy extends Tree {\n  constructor(root) {\n    super(root);\n  }\n\n  createObjectGroup(node, objs) {\n    const g = new THREE.Group();\n    g.name = (node.id >= 0)? node.id + \"_\" + node.name : node.name;\n    for (var j = 0; j < objs.length; j++) {\n      if (objs[j]) {\n        g.add(objs[j]);\n      } else {\n        console.warn(\"Missing object for \" + node.id + \" child \" + j);\n      }\n    }\n    if (node.transform) {\n      Object3DUtil.setMatrix(g, node.transform);\n    }\n    _.merge(g.userData, _.omit(node, [\"children\", \"object3D\", \"obb\", \"parent\"]));\n    g.userData.partId = node.id;\n    return g;\n  };\n\n  attachChildObject3Ds() {\n    this.traverse(null,\n      node => {\n        if (node.children) {\n          if (node.object3D) {\n            const objs = _.filter(_.map(node.children, 'object3D'));\n            _.each(objs, c => node.object3D.add(c));\n          } else {\n            const objs = _.filter(_.map(node.children, 'object3D'));\n            node.object3D = this.createObjectGroup(node, objs);\n          }\n        }\n      }\n    );\n  }\n\n  clone() {\n    let converted = this.convert(p => {\n      return p.clone();\n    });\n    converted.attachChildObject3Ds();\n    return converted;\n  }\n}\n\nmodule.exports = PartHierarchy;\n\n//# sourceURL=webpack://STK/./js/lib/parts/PartHierarchy.js?");

/***/ }),

/***/ "./js/lib/scene/HouseJsonLoader.js":
/*!*****************************************!*\
  !*** ./js/lib/scene/HouseJsonLoader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Scene Loader for house json files\n */\n\n\n\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar ArchCreator = __webpack_require__(/*! geo/ArchCreator */ \"./js/lib/geo/ArchCreator.js\");\nvar AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar ModelInfo = __webpack_require__(/*! model/ModelInfo */ \"./js/lib/model/ModelInfo.js\");\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar SceneLoader = __webpack_require__(/*! scene/SceneLoader */ \"./js/lib/scene/SceneLoader.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nvar d3queue = __webpack_require__(/*! d3-queue */ \"../node_modules/d3-queue/build/d3-queue.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction getHasCategoryInFilter(targetCategories) {\n  return function(modelInfo) {\n    var match = false;\n    if (modelInfo && modelInfo.category) {\n      var categories = modelInfo.category;\n      for (var i = 0; i < categories.length; i++) {\n        if (targetCategories.indexOf(categories[i]) >= 0) {\n          match = true;\n          break;\n        }\n      }\n    }\n    return match;\n  };\n}\n\nHouseJsonLoader.ArchCategories = ['door', 'arch', 'garage_door', 'window', 'stairs', 'column', 'partition', 'roof'];\nHouseJsonLoader.PortalCategories = ['door', 'arch', 'garage_door', 'window'];\n\n// Loader for HOUSE JSON format scenes\nfunction HouseJsonLoader(params) {\n  SceneLoader.call(this, params);\n  this.defaultSceneSource = (params.defaultSceneSource != undefined)? params.defaultSceneSource : 'scenes';\n  this.defaultModelSource = (params.defaultModelSource != undefined)? params.defaultModelSource : '3dw';\n  this.archSource = (params.archSource != undefined)? params.archSource : 'arch';\n  this.attachWallsToRooms = params.attachWallsToRooms;\n  this.archOnly = params.archOnly;  // Only load architecture elements (no objects)\n  this.useVariants = params.useVariants;\n  this.keepInvalid = params.keepInvalid; // Retain invalid objects\n  this.keepParse = params.keepParse; // Retain intermediate parse\n  this.keepMaterialInfo = params.keepMaterialInfo;\n  this.useArchModelId = params.useArchModelId; // Use model id for room and ground instead of json id\n  this.ignoreOriginalArchHoles = params.ignoreOriginalArchHoles; // Whether to ignore precomputed architectural holes\n  this.useDefaultMaterials = params.useDefaultMaterials; // Whether to use default materials\n  this.adjustReplacementTransforms = params.adjustReplacementTransforms; // Whether to adjust replacement transforms based on up/front\n\n  this.skipElements = params.skipElements;  // Set to ['Object'] to only load architecture elements (no Object)\n                                            // Set to ['Object', 'Box'] to skip Object and Box\n  this.loadModelFilter = params.loadModelFilter; // Only load models matching filter (default: null to load all)\n  this.replaceModels = params.replaceModels; // Replace models\n  this.verbose = params.verbose;  // verbose logging\n  // TODO: Consolidate with ModelInfoFilter\n  if (params.emptyRoom) {\n    this.loadModelFilter = getHasCategoryInFilter(HouseJsonLoader.PortalCategories);\n    this.skipElements = ['Box'];\n  } else if (params.archOnly) {\n    this.loadModelFilter = getHasCategoryInFilter(HouseJsonLoader.ArchCategories);\n  } else if (params.loadModelFilter === 'ignorePortals') {\n    var fn = getHasCategoryInFilter(HouseJsonLoader.PortalCategories);\n    this.loadModelFilter = function(x) { return !fn(x); };\n  } else if (params.loadModelFilter && params.loadModelFilter.categories) {\n    this.loadModelFilter = getHasCategoryInFilter(params.loadModelFilter.categories);\n  } else if (params.loadModelFilter && params.loadModelFilter.ignoreCategories) {\n    var fn = getHasCategoryInFilter(params.loadModelFilter.ignoreCategories);\n    this.loadModelFilter = function(x) { return !fn(x); };\n  }\n\n  this.__scenesAssetGroup =  this.defaultSceneSource? AssetGroups.getAssetGroup(this.defaultSceneSource) : null;\n  this.__modelsAssetGroup =  AssetGroups.getAssetGroup(this.defaultModelSource);\n\n  if (params.createArch) {\n    // Create architecture\n    var archCreatorOptions = this.__getDefaultArchConfig();\n    if (params.archOptions) {\n      archCreatorOptions = _.defaultsDeep(Object.create(null), params.archOptions, archCreatorOptions);\n    }\n    this.archCreator = new ArchCreator(archCreatorOptions);\n  }\n}\n\nHouseJsonLoader.prototype = Object.create(SceneLoader.prototype);\nHouseJsonLoader.prototype.constructor = HouseJsonLoader;\n\nHouseJsonLoader.textureRepeat = new THREE.Vector2(1, 1);\n\nHouseJsonLoader.prototype.__getDefaultArchConfig = function() {\n  return ArchCreator.DEFAULTS;\n};\n\nHouseJsonLoader.prototype.__createArch = function(archData, json, context) {\n  var scope = this;\n  var archIds;\n  //console.log('useArchModelId', scope.useArchModelId);\n  if (scope.useArchModelId) {\n    var archMappings = {};\n    var archRegex = /[a-zA-Z]+_(\\d+)[a-zA-Z]+_(\\d+)/;\n    var rooms = _.flatten(_.map(json.levels, function (level) {\n        return _.filter(level.nodes, function (x) {\n          return x.type === 'Room' || x.type === 'Ground';\n        });\n      }\n    ));\n    _.each(rooms, function (arch) {\n      var archId = arch.id;\n      if (arch.modelId) {\n        // Get archId from modelId\n        var match = arch.modelId.match(archRegex);\n        if (match) {\n          archId = match[1] + '_' + match[2];\n        }\n      }\n      archMappings[arch.id] = archId;\n    });\n    context.archMappings = archMappings;\n    //console.log('create archMappings', rooms, archMappings);\n    archIds = _.values(archMappings);\n  }\n\n  context.arch = this.archCreator.createArch(archData, {\n    filterElements: ArchCreator.getFilter({\n      includeCeiling: scope.includeCeiling,\n      includeFloor: scope.includeFloor,\n      includeWalls: scope.includeWalls,\n      room: scope.room,\n      level: scope.level,\n      archIds: archIds\n    }),\n    getMaterials: function (w) {\n      return scope.__getMaterials(w);\n    },\n    groupWalls: false\n  });\n};\n\n// Extra functions for making new holes\nHouseJsonLoader.prototype.__associateArchWithNewHoles = function(arch, objects) {\n  // console.log('objects', objects);\n  function isHoleFilter(x) {\n    return x.object3D && (x.json.type === 'Object' && (x.modelInstance.model.isDoor() || x.modelInstance.model.isWindow()));\n  }\n\n  // helper to get hole BBox and flip y-z\n  var left = this.archCreator.left;\n  function getBBox(hole) {\n    var bbox = Object3DUtil.computeBoundingBox(hole.object3D).clone();\n    // Shrink bbox along length, expand along perpendicular\n    var widthDir = left.clone().applyQuaternion(hole.object3D.getWorldQuaternion());\n    var x = Math.abs(widthDir.x);\n    var z = Math.abs(widthDir.z);\n    var bboxDelta = new THREE.Vector3(-0.05*x + 0.05*z, -0.02, -0.05*z + 0.05*x);\n    //console.log('bbox hole: ' + bbox.toString(), hole);\n    //console.log('adjusting bbox hole', widthDir, bboxDelta);\n    bbox = bbox.expandBy(bboxDelta);  // TODO(MS): Hack! - slightly contract hole bboxen to avoid over-merging and over-cutting\n    var miny = bbox.min.y;\n    var maxy = bbox.max.y;\n    bbox.min.y = bbox.min.z;\n    bbox.max.y = bbox.max.z;\n    bbox.min.z = miny;\n    bbox.max.z = maxy;\n    return bbox;\n  }\n\n  // TODO: Check this logic!!!\n  var holes = objects.filter(isHoleFilter);\n  var walls = arch.elements.filter(function(element) { return element.type === 'Wall'; });\n  _.each(walls, function(wall) { wall.holes = []; });\n  this.archCreator.associateWallsWithHoles(walls, holes, getBBox, function(wall) {\n    return [ new THREE.Vector2(wall.points[0][0], wall.points[0][2]), new THREE.Vector2(wall.points[1][0], wall.points[1][2]) ];\n  }, 0.25);\n  //console.log('walls',walls);\n};\n\n// Extra functions for making new holes\nHouseJsonLoader.prototype.__attachRoomArchWithNewHoles = function (archData, objects, json, context) {\n  this.__associateArchWithNewHoles(archData, objects);\n  this.__createArch(archData, json, context);\n  var holeToWalls = context.arch.holeToWalls;\n  for (var i = 0; i < objects.length; i++) {\n    var r = objects[i];\n    if (r.json.type === 'Room') {\n      var room = this.__parseRoomCached(r.json, context);\n      while (room.object3D.children.length) {\n        r.object3D.add(room.object3D.children[0]);\n      }\n    } else if (r.json.type === 'Object' && r.object3D && holeToWalls[r.id]) {\n      r.object3D.userData.wallIds = holeToWalls[r.id];\n    }\n  }\n};\n\n// Parses json of house json\nHouseJsonLoader.prototype.parse = function (json, callback, url, loadOpts) {\n  //console.log(json);\n  var scene = new THREE.Scene();\n  for (var i = 0; i < json.levels.length; i++) {\n    json.levels[i].type = 'Level';\n  }\n  var sceneResult = new SceneState(scene, { up: json.up, front: json.front, unit: json.scaleToMeters, textureRepeat: HouseJsonLoader.textureRepeat });\n  //console.log('got loadOpts', loadOpts);\n  var context = {\n    scene: sceneResult,\n    sceneHash: json.id\n  };\n  if (json.camera) {\n    this.__parseCamera(json.camera, sceneResult);\n  }\n\n  var origArchData = null;\n  if (this.archCreator) {\n    if (json.arch) {\n      origArchData = json.arch;\n    } else if (loadOpts.arch && loadOpts.arch.data) {\n      origArchData = loadOpts.arch.data;\n    }\n    if (origArchData) {\n      context.hasArch = true;\n      if (this.ignoreOriginalArchHoles) {\n        // Skip room for now so that we can create rooms with custom cut out holes\n        this.__createDummyRoom = true;\n        this.keepParse = true;\n      } else {\n        this.__createArch(origArchData, json, context);\n      }\n    } else {\n      this.keepParse = true;\n      console.warn('No architecture data found for ' + json.id);\n    }\n  }\n\n  var scope = this;\n  this.__parseItemDeferred(json, json.levels, context, ['Level'], function(err, parsed, results) {\n    // Load or create room\n    if (context.hasArch && scope.ignoreOriginalArchHoles) {\n      // Hack to have delayed creation of new architecture, now that we loaded the windows/doors\n      scope.__createDummyRoom = false;\n      // TODO: handle ground\n      var archData = _.cloneDeep(origArchData);\n      var objects = _.flatMap(results, function(x) { return x.children; });\n      scope.__attachRoomArchWithNewHoles(archData, objects, json, context);\n    } else if (scope.__hasEmbeddedArchElements) {\n      scope.__hasEmbeddedArchElements = false;\n      var roomJsons = _.flatMap(results, function(x) { return x.json.nodes.filter(function(y) { return y.type === 'Room'; } ); });\n      var allElements = _.flatMap(roomJsons, function(x) { return x.elements || []; });\n      var archData = { elements: allElements };\n      var objects = _.flatMap(results, function(x) { return x.children; });\n      scope.__attachRoomArchWithNewHoles(archData, objects, json, context);\n    }\n\n    __addChildren(scene, results);\n\n    _.each(results, function(level, levelIndex) {\n      if (level.object3D) {\n        level.object3D.traverse(function (child) {\n          if (child.userData.id != undefined) {\n            child.userData.level = levelIndex;\n          }\n        });\n      }\n    });\n\n    // Finalize our scene\n    if (scope.keepParse) {\n      parsed.loader = 'HouseJsonLoader';\n      sceneResult.parsedData = parsed;\n    }\n    scope.__onSceneCompleted(null, sceneResult);\n    // our callback expect the sceneResult and then error\n    callback(sceneResult, err);\n  });\n};\n\nHouseJsonLoader.prototype.__parseCamera = function(cameraJson, sceneResult) {\n  var cameras;\n  if (_.isArray(cameraJson)) {\n    cameras = _.keyBy(cameraJson, 'name');\n  } else {\n    cameras = cameraJson;\n  }\n  _.each(cameras, function(v, k) {\n    v.name = k;\n    if (!v.type) {\n      v.type = k;\n    }\n    if (v.type === 'orthographic') {\n      if (!v.position) {\n        // Convert from world into local\n        v.position = new THREE.Vector3((v.left + v.right)/2, v.near, (v.top + v.bottom)/2);\n        v.target = new THREE.Vector3((v.left + v.right)/2, v.far, (v.top + v.bottom)/2);\n        var w = (v.right - v.left)/2;\n        var h = (v.top - v.bottom)/2;\n        v.left = -w; v.right = w;\n        v.top = h; v.bottom = -h;\n        delete v['near'];\n        delete v['far'];\n      }\n    }\n    if (v.position) {\n      v.position = Object3DUtil.toVector3(v.position);\n    }\n    if (v.target) {\n      v.target = Object3DUtil.toVector3(v.target);\n    }\n    if (v.direction) {\n      v.direction = Object3DUtil.toVector3(v.direction);\n    }\n  });\n  sceneResult.cameras = cameras;\n};\n\nHouseJsonLoader.prototype.__parseItemDeferred = function (json, items, context, allowed, callback) {\n  // List of asynchronous jobs we want to do\n  var deferred = d3queue.queue();\n  var parsed = { json: json, parent: context.parent, sceneHash: context.sceneHash,\n    floor: context.floor, id: context.id, index: context.index };\n  for (var i = 0; i < items.length; i++) {\n    var child = items[i];\n    var processChild = !context.keepItems || context.keepItems.indexOf(i) >= 0;  // Check if we want to process this\n    if (!this.keepInvalid) {\n      processChild = processChild && (child.valid == null || child.valid);\n    }\n    if (this.skipElements && this.skipElements.indexOf(child.type) >= 0) {\n      processChild = false;\n    }\n    if (!processChild) {\n      deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n    } else if (allowed && allowed.indexOf(child.type) < 0) {\n      console.warn('Disallowed type ' + child.type + ' when processing ' + parsed.id, child);\n      deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n    } else {\n      var func = this.__lookupParseFn(child.type);\n      var childCtx = _.defaults({}, context);\n      childCtx.parent = parsed;\n      childCtx.index = i;\n      childCtx.id = (parsed.id != undefined)? parsed.id + '_' + i : i;\n      delete childCtx.keepItems;\n\n      if (func) {\n        deferred.defer(func.bind(this, child, childCtx));\n      } else {\n        console.warn('Unknown type ' + child.type + ' when processing ' + parsed.id, child);\n        deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n      }\n    }\n  }\n\n  // the first argument is the error and the next argument the results\n  // our callback expect the sceneResult and then error\n  var scope = this;\n  deferred.awaitAll(function (err, results) {\n    if (err) {\n      console.error('Error processing', context);\n      console.error(err);\n    }\n    if (results && results.length) {\n      //console.log(results);\n      for (var i = 0; i < results.length; i++) {\n        var result = results[i];\n        if (result && result.object3D) {\n//          result.object3D.userData.id = result.id;\n          result.object3D.userData.id = result.json.id;\n          if (scope.keepMaterialInfo) {\n            if (result.json.materials) {\n              result.object3D.userData.materials = result.json.materials;\n            }\n          }\n        }\n      }\n    }\n    if (scope.keepParse) {\n      parsed.children = results;\n    }\n    // console.log('Processed ' + item.type);\n    callback(err, parsed, results);\n  });\n};\n\n HouseJsonLoader.prototype.__parseItemSimple = function (item, context, callback) {\n   //console.log(item.type);\n   //console.log(item);\n   var parsed = { json: item, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n   if (callback) {\n     callback(null, parsed);\n   } else {\n     return parsed;\n   }\n };\n\nHouseJsonLoader.prototype.__parseLevel = function (json, context, callback) {\n  context.floor = context.index;\n  var scope = this;\n  var loadFloor = this.floor == undefined || (this.floor === context.floor);\n  // Only load specified floor if only one floor requested\n  if (loadFloor) {\n    if (this.room != undefined) {\n      var room = json && json.nodes? json.nodes[this.room] : null;\n      var isRoom = room && room.type === 'Room';\n      var itemIndices = room.nodeIndices;\n      if (itemIndices != null) {\n        context['keepItems'] = [this.room].concat(itemIndices);\n      }\n      var itemStr = 'Scene ' + context.sceneHash + ', floor ' + context.floor + ', item ' + this.room;\n      if (!isRoom) {\n        var msg2 = (context['keepItems'])? ' but has other items ' + itemIndices.join(',') : ' loading single object';\n        console.warn(itemStr + ' is not a room,' + msg2);\n      }\n      if (!context['keepItems']) {\n        if (isRoom) {\n          console.warn(itemStr + ' is a room without any objects.');\n        }\n        context['keepItems'] = [this.room];\n      }\n    }\n    this.__parseItemDeferred(json, json.nodes, context, ['Room', 'Object', 'Ground', 'Box'], function (err, parsed, results) {\n      // add children into group and callback\n      var group = new THREE.Group();\n      group.name = 'Level#' + context.floor;\n      group.userData.type = 'Level';\n      __addChildren(group, results);\n      parsed.object3D = group;\n\n      // Process roomObjectMapping (map of room index to object indices)\n      var rooms = _.filter(results, function(x) { return x.json.type === 'Room'; });\n      for (var i = 0; i < rooms.length; i++) {\n        var room = rooms[i];\n        if (room && room.object3D && room.json.nodeIndices) {\n          var m = room.json.nodeIndices;\n          room.objectIndices = m;\n          room.partitions = m.map(function(idx) {\n            if (results[idx]) {\n              var mInst = results[idx].modelInstance;\n              if (mInst && mInst.model.isPartition()) {\n                return results[idx];\n              }\n            } else {\n              console.warn('Invalid node index for room', idx, room.json.id);\n            }\n          }).filter(function(x) { return x; });\n          for (var j = 0; j < m.length; j++) {\n            var ci = m[j];\n            var item = results[ci];\n            if (item && item.object3D) {\n              if (item.json.type === 'Room') {\n                console.warn('Skipping attaching Room ' + item.object3D.userData.id + ' to Room ' + room.object3D.userData.id);\n              } else {\n                if (!item.object3D.userData.roomIds) {\n                  item.object3D.userData.roomIds = [];\n                }\n                item.object3D.userData.roomIds.push(room.object3D.userData.id);\n                Object3DUtil.attachToParent(item.object3D, room.object3D, group);\n              }\n            }\n          }\n        }\n      }\n      if (context.arch) {\n        var holeToWalls = context.arch.holeToWalls;\n        for (var i = 0; i < results.length; i++) {\n          var r = results[i];\n          if (r.object3D && holeToWalls[r.id]) {\n            r.object3D.userData.wallIds = holeToWalls[r.id];\n          }\n        }\n      }\n      callback(err, parsed);\n    });\n  } else {\n    console.log('Skipping floor ' + context.floor + ', only loading floor ' + this.floor);\n    this.__parseItemSimple(json, context, callback);\n  }\n};\n\nHouseJsonLoader.prototype.__parseGround = function (json, context, callback) {\n  // console.log('parse ground');\n  var scope = this;\n  var parts = ['f'].map(function(suffix) {\n    return {\n      id: json.id,\n      type: 'Arch',\n      modelId: json.modelId + suffix,\n      archType: 'Ground'\n    };\n  });\n  // Load modelId with ground\n  this.__parseItemDeferred(json, parts, context, null, function (err, parsed, results) {\n    var group = new THREE.Group();\n    group.name = 'Ground' + json.id;\n    group.userData.type = 'Ground';\n    __addChildren(group, results);\n    scope.__applyTransform(group, json);\n    parsed.object3D = group;\n    callback(err, parsed);\n  });\n};\n\nfunction __getWallHeight(elements, defaults) {\n  var walls = _.filter(elements, function(x) { return x.type === 'Wall'; });\n  var defaultWallHeight = _.get(defaults, \"Wall.height\");\n  return _.max(_.map(walls, function(w) {\n    return w.height || defaultWallHeight;\n  }));\n}\n\nHouseJsonLoader.prototype.__parseRoom = function (json, context, callback) {\n  if (this.__createDummyRoom || (!context.arch && json.elements)) {\n    if (!context.arch && json.elements) {\n      var scope = this;\n      this.__hasEmbeddedArchElements = true;\n      _.each(json.elements, function(x) {\n        x.roomId = json.id;\n      });\n      var addFloor = this.includeFloor && !_.some(json.elements, function(e) { return e.type === 'Floor'; });\n      var addCeiling = this.includeCeiling && !_.some(json.elements, function(e) { return e.type === 'Ceiling'; });\n      if (addFloor || addCeiling) {\n        var s = scope.archCreator.getWallPoints(json.elements, true);\n        var wallPoints = s.wallPoints;\n        json.elements = _.flatten(s.groupedWalls); // reordered walls\n        if (addFloor) {\n          // Let's create a floor\n          json.elements.push({\n            'id': json.id + \"f\",\n            \"type\": \"Floor\",\n            \"roomId\": json.id,\n            \"points\": wallPoints\n          });\n        }\n        if (addCeiling) {\n          // Let's create a ceiling\n          var up = Object3DUtil.toVector3(scope.archCreator.up).clone();\n          var wallHeight = __getWallHeight(json.elements, scope.archCreator.defaults);\n          var ceilingOffset = _.get(scope.archCreator.defaults, \"Ceiling.offset\") || 0;\n          // Let's create a floor\n          json.elements.push({\n            'id': json.id + \"c\",\n            \"type\": \"Ceiling\",\n            \"roomId\": json.id,\n            \"offset\": up.multiplyScalar(wallHeight + ceilingOffset).toArray(),\n            \"points\": wallPoints\n          });\n        }\n      }\n    }\n    // console.log('dummy room creation');\n    this.__parseItemSimple(json, context, function (err, parsed) {\n      var group = new THREE.Group();\n      group.name = 'Room#' + json.id;\n      group.userData.id = json.id;\n      group.userData.type = 'Room';\n\n      if (json.roomTypes) {\n        group.userData.roomType = json.roomTypes;  // Room types as array\n      }\n      parsed.object3D = group;\n      callback(err, parsed);\n    });\n  } else if (context.arch) {\n    // console.log('parse room cached');\n    this.__parseRoomCached(json, context, callback);\n  } else {\n    // console.log('parse room load');\n    this.__parseRoomLoad(json, context, callback);\n  }\n};\n\nHouseJsonLoader.prototype.__parseRoomCached = function (json, context, callback) {\n  //console.log('parseRoomCached', json, context);\n  var parsed = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  var archId = json.id;\n  if (context.archMappings) {\n    var m = context.archMappings[json.id];\n    if (m != null) {\n      archId = m;\n    }\n  }\n  parsed.object3D = context.arch.rooms[archId];\n  if (parsed.object3D) {\n    var ro = parsed.object3D;\n    if (json.roomTypes) {\n      ro.userData.roomType = json.roomTypes;  // Room types as array\n    }\n    for (var i = 0; i < ro.children.length; i++) {\n      // HACK!!!!\n      context.scene.extraObjects.push(ro.children[i]);\n    }\n  }\n\n  if (callback) {\n    callback(null, parsed);\n  } else {\n    return parsed;\n  }\n};\n\nHouseJsonLoader.prototype.__parseRoomLoad = function (json, context, callback) {\n  var parts = ['f','c','w'];\n  if (!this.includeFloor || json.hideFloor) {\n    _.pull(parts, 'f');\n  }\n  if (!this.includeCeiling || json.hideCeiling) {\n    _.pull(parts, 'c');\n  }\n  if (!this.includeWalls || json.hideWalls) {\n    _.pull(parts, 'w');\n  }\n  //console.log(parts);\n  parts = parts.map(function(suffix) {\n    var archType;\n    if (suffix === 'f') {\n      archType = 'Floor';\n    } else if (suffix === 'w') {\n      archType = 'Wall';\n    } else if (suffix === 'c') {\n      archType = 'Ceiling';\n    }\n    return {\n      id: json.id + suffix,\n      type: 'Arch',\n      modelId: json.modelId + suffix,\n      archType: archType\n    };\n  });\n  // Load modelId + parts (do not load c/f/w if hideCeiling/hideFloor/hideWall)\n  this.__parseItemDeferred(json, parts, context, null, function (err, parsed, results) {\n    var group = new THREE.Group();\n    group.name = 'Room#' + json.id;\n    group.userData.id = json.id;\n    group.userData.type = 'Room';\n\n    parsed.items = results;\n    __addChildren(group, results);\n\n    if (json.roomTypes) {\n      group.userData.roomType = json.roomTypes;  // Room types as array\n    }\n    parsed.object3D = group;\n    callback(err, parsed);\n  });\n};\n\nHouseJsonLoader.prototype.__parseObject = function (json, context, callback) {\n  this.__parseItemLoad(json, context, callback);\n};\n\nHouseJsonLoader.prototype.__parseArch = function (json, context, callback) {\n  if (context.arch) {\n    this.__parseArchCached(json, context, callback);\n  } else {\n    this.__parseArchLoad(json, context, callback);\n  }\n};\n\nHouseJsonLoader.prototype.__parseBox = function (json, context, callback) {\n  // Procedurally generated content\n  var scope = this;\n  var parsed = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n\n  // See 93cdd63ea3523de8fb5d56ac5dc1b7e4\n  var dims = json.dimensions;\n  var box = new THREE.BoxGeometry(dims[0], dims[1], dims[2], 1, 1, 1);\n  for (var i = 0; i < box.faceVertexUvs.length; i++) {\n    var uvs = box.faceVertexUvs[i];\n    for (var j = 0; j < uvs.length; j++) {\n      var uv1, uv2;\n      if (j >= 0 && j <= 3) {\n        // sY, sZ   // left right\n        uv1 = dims[2];\n        uv2 = dims[1];\n        if (j % 2 === 0) {\n          uvs[j][0].set(0, uv2);\n          uvs[j][2].set(uv1, uv2);\n        } else {\n          uvs[j][1].set(uv1, 0);\n          uvs[j][2].set(uv1, uv2);\n        }\n      } else if (j >= 4 && j <= 7) {\n        // sX, sY   // top bottom\n        uv1 = dims[0];\n        uv2 = dims[2];\n        if (j % 2 === 0) {\n          uvs[j][0].set(0, uv2);\n          uvs[j][2].set(uv1, uv2);\n        } else {\n          uvs[j][1].set(uv1, 0);\n          uvs[j][2].set(uv1, uv2);\n        }\n      } else {\n        // sX, sZ   // front back\n        uv1 = dims[0];\n        uv2 = dims[1];\n        if (j % 2 === 0) {\n          uvs[j][0].set(0, uv2);\n          uvs[j][2].set(uv1, uv2);\n        } else {\n          uvs[j][1].set(uv1, 0);\n          uvs[j][2].set(uv1, uv2);\n        }\n      }\n    }\n  }\n  var materials = [];\n  // TODO: Check ordering of materials [2,3,0,1,4,5]?\n  var materialIndexMapping = [2,3,0,1,4,5]; // from json.materials to our materials\n  for (var i = 0; i < json.materials.length; i++) {\n    var mat = json.materials[i];\n    var m = scope.__getMaterial(mat.diffuse, mat.texture + '.jpg', { side: THREE.DoubleSide });\n    //console.log('material: ' + i + ' ' + mat.texture + '.jpg');\n    materials[materialIndexMapping[i]] = m;\n  }\n  var object3D = new THREE.Mesh(box, new THREE.MultiMaterial(materials));\n  scope.__applyTransform(object3D, json);\n  //scope.__applyMaterials(object3D, json);\n\n  parsed.object3D = object3D;\n  object3D.name = 'Box';\n  // HACK!!!!\n  context.scene.extraObjects.push(object3D);\n\n  if (callback) {\n    callback(null, parsed);\n  } else {\n    return parsed;\n  }\n};\n\nHouseJsonLoader.prototype.__parseItemLoad = function (json, context, callback) {\n  //console.log('processing object!!!');\n  //console.log(json);\n\n  var object = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  var modelId = json.modelId;\n  var initialModelId = null;\n  object.modelId = modelId;\n  // Handle aframe\n  if (this.useVariants && json.state > 0) {\n    modelId += '_' + (json.state-1);\n  }\n  if (this.replaceModels) {\n    var replacementModelId = _.isFunction(this.replaceModels)? this.replaceModels(modelId) : this.replaceModels[modelId];\n    if (replacementModelId && modelId !== replacementModelId) {\n      if (this.verbose) {\n        console.log('Replace model ' + modelId + ' with ' + replacementModelId);\n      }\n      initialModelId = modelId;\n      modelId = replacementModelId;\n    }\n  }\n  var scope = this;\n  function __loadModel(initialTransform, centerTo) {\n    scope.assetManager.getModelInstance(scope.defaultModelSource, modelId,\n      function (modelInstance) {\n        // Okay\n        object.modelInstance = modelInstance;\n        object.object3D = modelInstance.getObject3D();\n        if (json.state != null) {\n          object.object3D.userData.state = json.state;\n        }\n\n        if (initialTransform) {\n          var modelObject3D = modelInstance.modelObject3D;\n          modelObject3D.matrix.premultiply(initialTransform);\n          modelObject3D.matrix.decompose(modelObject3D.position, modelObject3D.quaternion, modelObject3D.scale);\n        }\n        if (centerTo) {\n          Object3DUtil.placeObject3D(modelInstance.modelObject3D, null, centerTo);\n        }\n        scope.__applyTransform(object.object3D, json);\n        // Apply materials after transform (apply transform may change underlying model...)\n        scope.__applyMaterials(object.object3D, json);\n        // Ensure modelInstance has double sided materials as flips will reveal back faces\n        Object3DUtil.setDoubleSided(object.modelInstance.object3D);\n        callback(null, object);\n      },\n      function (error) {\n        // Error loading model\n        console.warn('Error loading model ' + modelId);\n        console.warn(error);\n        object.error = error;\n        callback(null, object);\n      },\n      { defaultFormat: scope.defaultModelFormat }\n    );\n  }\n\n  var lookupModelInfoIds = [];\n  if (this.loadModelFilter) {\n    lookupModelInfoIds.push(modelId);\n  } else if (initialModelId != null && this.adjustReplacementTransforms) {\n    lookupModelInfoIds.push(modelId);\n    lookupModelInfoIds.push(initialModelId);\n  }\n  // console.log('lookupModelInfoIds', lookupModelInfoIds);\n  if (lookupModelInfoIds.length) {\n    async.mapLimit(lookupModelInfoIds, Constants.MAX_ASYNC_REQS, function(item, cb) {\n      scope.assetManager.lookupModelInfo(scope.defaultModelSource, item, function(modelInfo) {\n        cb(null, modelInfo);\n      });\n    }, function(err, results) {\n      var modelInfos = {};\n      if (results) {\n        for (var i = 0; i < lookupModelInfoIds.length; i++) {\n          modelInfos[lookupModelInfoIds[i]] = results[i];\n        }\n      }\n      //console.log('modelInfos', modelInfos, modelId, initialModelId);\n      var modelInfo = modelInfos[modelId];\n      var initialTransform;\n      var centerTo;\n      if (initialModelId != null) {\n        var initialModelInfo = modelInfos[initialModelId];\n        if (initialModelInfo && modelInfo) {\n          initialTransform = ModelInfo.getRelativeTransform(modelInfo, initialModelInfo);\n          centerTo = ModelInfo.getCenterTo(initialModelInfo);\n        }\n      }\n      if (!scope.loadModelFilter || scope.loadModelFilter(modelInfo)) {\n        __loadModel(initialTransform, centerTo);\n      } else {\n        callback(null, object);\n      }\n    });\n  } else {\n    __loadModel();\n  }\n};\n\nHouseJsonLoader.prototype.__parseArchLoad = function (json, context, callback) {\n  //console.log('processing object!!!');\n  //console.log(json);\n\n  var object = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  var modelId = json.modelId;\n  object.modelId = modelId;\n  var scope = this;\n  this.assetManager.getModelInstanceFromModelInfo({\n      source: this.archSource,\n      fullId: this.archSource + '.' + context.sceneHash + '_' + modelId,\n      id: context.sceneHash + '_' + modelId,\n      format: 'obj',\n      texturePath: this.__scenesAssetGroup['texturesPath'],\n      file: this.__scenesAssetGroup['roomFilesPath'] + context.sceneHash + '/' + modelId + '.obj',\n      mtl: this.__scenesAssetGroup['roomFilesPath'] + context.sceneHash + '/' + modelId + '.mtl',\n      options: { useBuffers: true, preserveMeshes: false },\n      skipCache: true // Don't cache this\n    },\n    function (modelInstance) {\n      // Okay\n      object.modelInstance = modelInstance;\n      object.object3D = modelInstance.getObject3D();\n      object.object3D.userData.archType = json.archType;\n\n      scope.__applyTransform(object.object3D, json);\n      //scope.__applyMaterials(object.object3D, json);\n      // Ensure modelInstance has double sided materials as flips will reveal back faces\n      //Object3DUtil.setDoubleSided(object.modelInstance.object3D);\n      callback(null, object);\n    },\n    function (error) {\n      // Error loading model\n      console.warn('Error loading model ' + modelId);\n      console.warn(error);\n      object.error = error;\n      callback(null, object);\n    }\n  );\n};\n\nHouseJsonLoader.prototype.__parseArchCached = function (json, context, callback) {\n  var parsed = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  var element = context.arch.elementsById[json.id];\n  if (_.isArray(element)) {\n    var group = new THREE.Group();\n    group.name = json.archType + '#' + json.id;\n    group.userData.id = json.id;\n    group.userData.type = json.archType;\n    for (var i = 0; i < element.length; i++) {\n      var e = element[i];\n      group.add((e instanceof THREE.Object3D)? e : e.object3D);\n    }\n    parsed.object3D = group;\n  } else if (element) {\n    parsed.object3D = (element instanceof THREE.Object3D)? element : element.object3D;\n  } else {\n    console.warn('Cannot find arch element', json.id);\n  }\n  if (parsed.object3D) {\n    // HACK!!!!\n    context.scene.extraObjects.push(parsed.object3D);\n  }\n  callback(null, parsed);\n};\n\nHouseJsonLoader.prototype.__getMaterial = function (color, texture, options) {\n  if (texture) {\n    options = options || { wrap: THREE.RepeatWrapping, repeat: HouseJsonLoader.textureRepeat };\n    var out = this.assetManager.getTexturedMaterial(this.defaultModelSource, texture, options);\n    out.color = new THREE.Color(color || '#ffffff');\n    return out;\n  } else {\n    return Object3DUtil.getMaterial(color);\n  }\n};\n\nHouseJsonLoader.prototype.__getMaterials = function(w) {\n  var scope = this;\n  var materials = (!this.useDefaultMaterials && w.materials)? w.materials : _.get(this.archCreator.defaults, w.type + '.materials');\n  // console.log(\"materials\", materials);\n  return _.map(materials, function (m) {\n    return scope.__getMaterial(m.diffuse, m.texture);\n  });\n};\n\nHouseJsonLoader.prototype.__getTextureLoader = function() {\n  return null;\n};\n\nHouseJsonLoader.prototype.__applyMaterials = function (object3D, json) {\n  var scope = this;\n  if (json.materials && json.materials.length > 0) {\n    for (var i = 0; i < json.materials.length; i++) {\n      json.materials[i].color = json.materials[i].diffuse;  // Hack to handle diffuse\n    }\n    // Assume that the object3D is a single mesh with a multimaterial\n    // Get the multimaterial and make sure that it matches the number of materials specified and set it\n    var meshes = Object3DUtil.getMeshList(object3D);\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var name = mesh.material.name; // name not cloned for some reason\n      var index = mesh.material.index; // Our own custom index\n      mesh.material = mesh.material.clone();\n      mesh.material.name = name;\n      mesh.material.index = index;\n      var textureLoader = this.__getTextureLoader();\n      if (textureLoader && textureLoader.updateMaterials) {\n        textureLoader.loadTexture = function (path, onLoad, onProgress, onError) {\n          //console.log('Using texture ' + path + ' on model ' + json.id);\n          var texturePath = scope.assetManager.getTexturePath(scope.defaultModelSource, path);\n          //console.log('loadTexture ' + scope.defaultModelSource + ' ' + path + ' ' + texturePath);\n          return Object3DUtil.loadTexture(texturePath, undefined, onLoad, onError);\n        };\n        textureLoader.updateMaterials(mesh, json);\n      } else {\n        //console.warn(\"No texture loader.\");\n      }\n    }\n  }\n};\n\nHouseJsonLoader.prototype.__applyTransform = function (object3D, json, premultiplyTransform) {\n  if (json.transform) {\n    var transform = new THREE.Matrix4();\n    transform.fromArray(json.transform);\n    if (json.isMirrored == null) {\n      var det = transform.determinant();\n      json.isMirrored = det < 0;\n    }\n    if (premultiplyTransform) {\n      transform.premultiply(premultiplyTransform);\n    }\n    Object3DUtil.setMatrix(object3D, transform);\n  }\n\n  Object3DUtil.clearCache(object3D);\n};\n\n// Populate SceneState members for sceneResult (called at end with callback)\nHouseJsonLoader.prototype.__onSceneCompleted = function (callback, sceneResult) {\n  var scene = sceneResult.scene;\n  sceneResult.modelInstances = Object3DUtil.findModelInstances(scene);\n  for (var i = 0; i < sceneResult.modelInstances.length; i++) {\n    var modelInst = sceneResult.modelInstances[i];\n    this.setObjectFlags(sceneResult, modelInst);\n    modelInst.object3D.name = '' + i;\n    if (this.useNormalizedCoordinateFrame) {\n      modelInst.ensureNormalizedModelCoordinateFrame().clone();\n    }\n  }\n  this.Publish('sceneLoaded', sceneResult);\n  if (callback) {\n    callback(sceneResult);\n  }\n};\n\nHouseJsonLoader.prototype.__lookupParseFn = function (type) {\n  return this['__parse' + type];\n};\n\n// Utility function\nfunction __addChildren(parent, results) {\n  if (results) {\n    //console.log('Adding children');\n    //console.log(results);\n    for (var i = 0; i < results.length; i++) {\n      var result = results[i];\n      if (result.object3D) {\n        parent.add(result.object3D);\n      } else {\n        //console.warn('Skipping child ' + i);\n      }\n    }\n  } else {\n    console.warn('No results!!!!');\n  }\n}\n\n// Exports\nmodule.exports = HouseJsonLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/HouseJsonLoader.js?");

/***/ }),

/***/ "./js/lib/scene/Planner5dLoader.js":
/*!*****************************************!*\
  !*** ./js/lib/scene/Planner5dLoader.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Scene Loader for Planner5d Scene files\n */\n\n\n\nvar ArchCreator = __webpack_require__(/*! geo/ArchCreator */ \"./js/lib/geo/ArchCreator.js\");\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar SceneLoader = __webpack_require__(/*! scene/SceneLoader */ \"./js/lib/scene/SceneLoader.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar P5DTextureLoader = __webpack_require__(/*! loaders/P5DTextureLoader */ \"./js/lib/loaders/P5DTextureLoader.js\");\nvar BoundingBoxHelper = __webpack_require__(/*! geo/BoundingBoxHelper */ \"./js/lib/geo/BoundingBoxHelper.js\");\nvar d3queue = __webpack_require__(/*! d3-queue */ \"../node_modules/d3-queue/build/d3-queue.js\");\n//var async = require('async');\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction getHasCategoryInFilter(targetCategories) {\n  return function(modelInfo) {\n    var match = false;\n    if (modelInfo && modelInfo.category) {\n      var categories = modelInfo.category;\n      for (var i = 0; i < categories.length; i++) {\n        if (targetCategories.indexOf(categories[i]) >= 0) {\n          match = true;\n          break;\n        }\n      }\n    }\n    return match;\n  };\n}\n\n// Loader for Planner 5D JSON format scenes\nfunction Planner5dLoader(params) {\n  SceneLoader.call(this, params);\n  this.defaultSource = 'p5d';\n  this.includeCeiling = params.includeCeiling;\n  this.attachWallsToRooms = params.attachWallsToRooms;\n  this.skipElements = params.skipElements;  // Set to ['Ns'] to only load architecture elements (no Ns)\n                                            // Set to ['Ns', 'Pr'] to skip Ns and Pr\n  this.loadModelFilter = params.loadModelFilter; // Only load models matching filter (default: null to load all)\n  this.useVariants = params.useVariants;\n  this.keepInvalid = params.keepInvalid; // Retain invalid objects\n  this.keepHidden = params.keepHidden; // Keep hidden floors and ceilings and objects\n  this.keepParse = params.keepParse; // Retain intermediate parse\n  this.replaceModels = params.replaceModels; // Replace models\n  this.verbose = params.verbose;  // verbose logging\n  if (params.emptyRoom) {\n    this.loadModelFilter = getHasCategoryInFilter(Planner5dLoader.PortalCategories);\n    this.skipElements = ['Pr'];\n  } else if (params.archOnly) {\n    this.loadModelFilter = getHasCategoryInFilter(Planner5dLoader.ArchCategories);\n  } else if (params.loadModelFilter && params.loadModelFilter.categories) {\n    this.loadModelFilter = getHasCategoryInFilter(params.loadModelFilter.categories);\n  }\n\n  this.archCreator = new ArchCreator({\n    up: Planner5dLoader.SCENE_UP,\n    front: Planner5dLoader.SCENE_FRONT,\n    unit: 0.01,\n    defaults: {\n      'Wall': {\n        depth: Planner5dLoader.__wallDepth,\n        extraHeight: Planner5dLoader.__wallExtraHeight\n      },\n      'Ceiling': {\n        depth: Planner5dLoader.__ceilingDepth\n      },\n      'Floor': {\n        depth: Planner5dLoader.__floorDepth\n      },\n      'Ground': {\n        depth: Planner5dLoader.__groundDepth\n      }\n    }\n  });\n}\nPlanner5dLoader.prototype = Object.create(SceneLoader.prototype);\nPlanner5dLoader.prototype.constructor = Planner5dLoader;\n\n// Architecture categories\nPlanner5dLoader.ArchCategories = ['door', 'arch', 'garage_door', 'window', 'stairs', 'column', 'partition', 'roof'];\nPlanner5dLoader.PortalCategories = ['door', 'arch', 'garage_door', 'window'];\n\n// Default P5D scene orientation\nPlanner5dLoader.SCENE_UP = new THREE.Vector3(0,1,0);\nPlanner5dLoader.SCENE_FRONT = new THREE.Vector3(0,0,1);\nPlanner5dLoader.SCENE_LEFT = new THREE.Vector3(1,0,0);\n\nPlanner5dLoader.__objVertOffset = 5;  // should be equal to ceilingDepth to ensure objects are on floor\nPlanner5dLoader.__groundDepth = 8;\nPlanner5dLoader.__groundVertOffset = 4;\nPlanner5dLoader.__floorDepth = 5;\nPlanner5dLoader.__floorVertOffset = 5;\nPlanner5dLoader.__ceilingDepth = 5;  // ceilingDepth - ceilingVertOffset must be less than floorDepth\nPlanner5dLoader.__ceilingVertOffset = 4;  // put ceiling top below floor of above level\nPlanner5dLoader.__wallDepth = 10;\nPlanner5dLoader.__wallExtraHeight = 3.5;\nPlanner5dLoader.__defaultWallHeight = 270;\nPlanner5dLoader.__lowCeilingThreshold = 120;\nPlanner5dLoader.textureRepeat = new THREE.Vector2(1/100, 1/100);\n\nPlanner5dLoader.__materialDefaults = {\n  'Room': {\n    texture: 'laminate_1_2',\n    fcolor: '#ffffff',\n    rtexture: 'linen_1_4',\n    rcolor: '#ffffff',\n    wtexture: 'wallp_1_1',\n    wcolor: '#ffffff',\n    otexture: 'bricks_1',\n    wocolor: '#ffffff'\n  },\n  'Ground': {\n    texture: 'ground_1',\n    color: '#ffffff'\n  }\n  // Here for reference (not used right now)\n  // 'Ns': {\n  //   color: '#48230d'\n  // },\n  // 'Pr': {\n  //   texture: 'wood_1',\n  //   tcolor: '#FFFFFF'\n  // }\n};\n\n// rtypes from p5d scene interface (dropdown)\nPlanner5dLoader.__roomTypes = _.fromPairs(_.zip(\n  [0, 1, 2, 9, 20, 3, 4, 5, 22, 6, 11, 10, 12, 13, 7, 21, 8, 17, 23, 14, 15, 16, 18, 24],\n  ['Living_Room', 'Kitchen', 'Bedroom', 'Child_Room',\n    'Dining_Room', 'Bathroom', 'Toilet', 'Hall', 'Hallway',\n    'Office', 'Guest_Room', 'Wardrobe', 'Room', 'Lobby',\n    'Storage', 'Boiler_room', 'Balcony', 'Loggia', 'Terrace',\n    'Entryway', 'Passenger_elevator', 'Freight_elevator', 'Aeration', 'Garage']\n  ));\nPlanner5dLoader.__roomTypesByName = _.invert(Planner5dLoader.__roomTypes);\nPlanner5dLoader.__roomTypesWithoutCeilings = ['Balcony'].map(\n  function(x) { return Planner5dLoader.__roomTypesByName[x]; });\n\n// Parses json of P5D scene\nPlanner5dLoader.prototype.parse = function (json, callbackFinished, url) {\n  //console.log(json);\n  var sceneResult = new SceneState(null, { textureRepeat: Planner5dLoader.textureRepeat });\n  var itemsData = json.items[0].data;\n  if (itemsData.className === 'Project') {\n    var hash = json.items[0].hash;\n    var context = {\n      scene: sceneResult,\n      sceneHash: hash,\n      version: itemsData.version\n    };\n    // Weird hack for scene with bad floors\n    if (hash === 'c93b9938c5d57553d265e3ab1d774cc9') {\n      console.warn('Removing invalid levels 1 and 2 from scene ' + hash);\n      itemsData.items = itemsData.items.slice(0,1);\n    }\n    this.__parseProject(itemsData, context, callbackFinished);\n  } else {\n    callbackFinished(sceneResult, 'Unsupported className: ' + itemsData.className);\n  }\n};\n\n\nPlanner5dLoader.prototype.__parseProject = function (json, context, callback) {\n  //console.log(json);\n  // Process each floor\n  var sceneResult = context.scene;\n  sceneResult.scene = new THREE.Scene();\n  sceneResult.archDefaults = _.clone(this.archCreator.defaults);\n  this.__parseItemDeferred(json, context, ['Floor'], function (err, parsed, results) {\n    // Put our floors at right height!\n    if (results) {\n      var z = 0;\n      for (var i = 0; i < results.length; i++) {\n        if (results[i].object3D) {\n          __setPositionY(results[i].object3D, z);\n        }\n        var h = results[i].maxRoomHeight || results[i].json.h;\n        if (h) {\n          z += h;\n        }\n      }\n    }\n    __addChildren(sceneResult.scene, results);\n\n    _.each(results, function(level, levelIndex) {\n      if (level.object3D) {\n        level.object3D.traverse(function (child) {\n          if (child.userData.id != undefined) {\n            child.userData.level = levelIndex;\n          }\n        });\n      }\n    });\n\n    if (this.keepParse) {\n      sceneResult.parsedData = parsed;\n    }\n    // Finalize our scene\n    this.__onSceneCompleted(null, sceneResult);\n    // our callback expect the sceneResult and then error\n    callback(sceneResult, err);\n  }.bind(this));\n};\n\nPlanner5dLoader.prototype.__cleanColorStrings = function(item, itemId, colorNames) {\n  var itemMaterialDefaults = Planner5dLoader.__materialDefaults[item.className];\n  for (var i = 0; i < colorNames.length; i++) {\n    var name = colorNames[i];\n    if (item.hasOwnProperty(name)) {\n      if (typeof item[name] !== 'string') continue;\n      var newColor = undefined;\n      if (item[name] === \"''\") {\n        item[name] = undefined;\n      } else if (item[name] === '1') {\n        newColor = '#ffffff';\n      } else if (item[name][0] === '#') {\n        if (item[name].length === 6) {\n          // Weird - not enough letters!!!!\n          newColor = '#0' + item[name].substring(1);\n        } else if (item[name].length === 5) {\n          // Weird - not enough letters!!!!\n          newColor = '#00' + item[name].substring(1);\n        } else if (item[name].length === 8) {\n          // Weird - so many digits!!!!\n          // Let's drop one!\n          newColor = item[name].substring(0, 7);\n        }\n      }\n      if (newColor != undefined) {\n        if (this.verbose) {\n          console.warn('Remap color ' + name + ' ' + item[name] + ' to ' + newColor + ' for item ' + itemId);\n        }\n        item[name] = newColor;\n      }\n    } else {\n      if (itemMaterialDefaults && itemMaterialDefaults.hasOwnProperty(name)) {\n        item[name] = itemMaterialDefaults[name];\n        //console.warn('Using default color ' + name + ' ' + item[name] + ' for item ' + item.className + ' ' + itemId);\n      }\n    }\n  }\n  if (item.materials) {\n    for (var i = 0; i < item.materials.length; i++) {\n      this.__cleanColorStrings(item.materials[i], itemId + '_' + i, colorNames);\n    }\n  }\n};\n\nPlanner5dLoader.prototype.__cleanTextureStrings = function(item, itemId, textureNames) {\n  var digits = /^\\d+$/;\n  var itemMaterialDefaults = Planner5dLoader.__materialDefaults[item.className];\n  for (var i = 0; i < textureNames.length; i++) {\n    var name = textureNames[i];\n    if (item.hasOwnProperty(name) && item[name]) {\n      if (typeof item[name] !== 'string') continue;\n      if (item[name] === \"digut\" || item[name] === 'color_4' || item[name] === 'color_5' || item[name] === 'jpg') {\n        if (this.verbose) {\n          console.warn('Ignoring texture ' + name + ' ' + item[name] + ' for item ' + itemId);\n        }\n        item[name] = undefined;\n      } else if (item[name].match(digits)) {\n        //console.warn('Remap texture ' + item[name] + ' to ' + 's/' + item[name]);\n        item[name] = 's/' + item[name];\n      }\n    } else {\n      if (itemMaterialDefaults && itemMaterialDefaults.hasOwnProperty(name)) {\n        item[name] = itemMaterialDefaults[name];\n        if (this.verbose) {\n          console.warn('Using default texture ' + name + ' ' + item[name] + ' for item ' + item.className + ' ' + itemId);\n        }\n      }\n    }\n    //console.log(name + '=' + item[name])\n  }\n  if (item.materials) {\n    for (var i = 0; i < item.materials.length; i++) {\n      this.__cleanTextureStrings(item.materials[i], itemId + '_' + i, textureNames);\n    }\n  }\n};\n\n\nPlanner5dLoader.prototype.__identifyInvalid = function(item, itemId) {\n  // Marks more items as invalid!!!\n  // Mainly things with gigantic positions and scales\n  if ((item.valid == null || item.valid) && !item.hidden) {\n    var type = item.className;\n    if (type === 'Ns' || type === 'Door' || type === 'Window' || type === 'Pr') {\n      if (Math.abs(item.x) >= 10000 || Math.abs(item.y) >= 10000 || Math.abs(item.z) >= 10000) {\n        if (this.verbose) {\n          console.warn('Marking as invalid ' + type + ' ' + itemId + ' due to position ' + JSON.stringify([item.x, item.y, item.z]));\n        }\n        item.valid = 0;\n      }\n      if (Math.abs(item.sX) >= 10000 || Math.abs(item.sY) >= 10000 || Math.abs(item.sZ) >= 10000) {\n        if (this.verbose) {\n          console.warn('Marking as invalid ' + type + ' ' + itemId + ' due to scale ' + JSON.stringify([item.sX, item.sY, item.sZ]));\n        }\n        item.valid = 0;\n      }\n    } else if (type === 'Ground') {\n      if (item.items) {\n        for (var i = 0; i < item.items.length; i++) {\n          var w = item.items[i];\n          if (w.items) {\n            for (var j = 0; j < w.items.length; j++) {\n              var p = w.items[j];\n              if (p.className === 'Point' && (Math.abs(p.x) >= 10000 || Math.abs(p.y) >= 10000)) {\n                if (this.verbose) {\n                  console.warn('Marking as invalid ' + type + ' ' + itemId + ' due to position ' + JSON.stringify([p.x, p.y]));\n                }\n                item.valid = 0;\n                break;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n};\n\nPlanner5dLoader.prototype.__parseItemDeferred = function (item, context, allowed, callback, preprocess) {\n  //console.log('processing ' + item.className);\n  //console.log(item);\n\n  // List of asynchronous jobs we want to do\n  var deferred = d3queue.queue();\n  var parsed = { json: item, parent: context.parent, sceneHash: context.sceneHash, version: context.version,\n    floor: context.floor, id: context.id, index: context.index };\n  // Preprocessing of parsed\n  if (preprocess) {\n    preprocess(parsed);\n  }\n  if (item.items) {\n    // HACK! HACK! HACK! Clean color string....\n    for (var i = 0; i < item.items.length; i++) {\n      var itemId = context.id  + '_' + i;\n      this.__cleanColorStrings(item.items[i], itemId, ['color','tcolor','fcolor','rcolor','wcolor','wocolor']);\n      this.__cleanTextureStrings(item.items[i], itemId, ['texture','rtexture','wtexture','otexture']);\n      this.__identifyInvalid(item.items[i], itemId);\n    }\n\n    for (var i = 0; i < item.items.length; i++) {\n      var child = item.items[i];\n      var processChild = !context.keepItems || context.keepItems.indexOf(i) >= 0;  // Check if we want to process this\n      if (!this.keepHidden) {\n        processChild = processChild && (child.className === 'Wall' || !child.hidden);\n      }\n      if (!this.keepInvalid) {\n        processChild = processChild && (child.valid == null || child.valid);\n      }\n      if (this.skipElements && this.skipElements.indexOf(child.className) >= 0) {\n        processChild = false;\n      }\n      if (!processChild) {\n        deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n      } else if (allowed && allowed.indexOf(child.className) < 0) {\n        console.warn('Disallowed className ' + child.className + ' when processing ' + item.className);\n        console.log(child);\n        deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n      } else {\n        var func = this.__lookupParseFn(child.className);\n        var childCtx = _.defaults({}, context);\n        childCtx.parent = parsed;\n        childCtx.index = i;\n        childCtx.id = (parsed.id != undefined)? parsed.id + '_' + i : i;\n        delete childCtx.keepItems;\n\n        if (func) {\n          deferred.defer(func.bind(this, child, childCtx));\n        } else {\n          console.warn('Unknown className ' + child.className + ' when processing ' + item.className);\n          console.log(child);\n          deferred.defer(this.__parseItemSimple.bind(this, child, { parent: parsed }));\n        }\n      }\n    }\n  }\n\n  // the first argument is the error and the next argument the results\n  // our callback expect the sceneResult and then error\n  var scope = this;\n  deferred.awaitAll(function (err, results) {\n    if (err) {\n      console.error('Error processing ' + item.className);\n      console.error(err);\n    }\n    if (results && results.length) {\n      //console.log(results);\n      for (var i = 0; i < results.length; i++) {\n        var result = results[i];\n        if (result && result.object3D) {\n          result.object3D.userData.id = result.id;\n        }\n      }\n    }\n    if (scope.keepParse) {\n      parsed.children = results;\n    }\n    // console.log('Processed ' + item.className);ex\n    callback(err, parsed, results);\n  });\n};\n\nPlanner5dLoader.prototype.__parseItemSimple = function (item, context, callback) {\n   //console.log(item.className);\n   //console.log(item);\n   var parsed = { json: item, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n   if (callback) {\n     callback(null, parsed);\n   } else {\n     return parsed;\n   }\n };\n\nPlanner5dLoader.prototype.__lookupParseFn = function (className) {\n  return this['__parse' + className];\n};\n\nPlanner5dLoader.prototype.__parseFloor = function (json, context, callback) {\n  context.floor = context.index;\n  var scope = this;\n  var loadFloor = this.floor == undefined || (this.floor === context.floor);\n  // Only load specified floor if only one floor requested\n  function isHoleFilter(x) {\n    return x.object3D && (x.json.className === 'Window' || x.json.className === 'Door' ||\n      (x.json.className === 'Ns' && (x.modelInstance.model.isDoor() || x.modelInstance.model.isWindow())));\n  }\n  if (loadFloor) {\n    if (this.room != undefined) {\n      var isRoom = json.items && json.items[this.room] && json.items[this.room].className === 'Room';\n      var itemIndices = json.roomObjectMapping[this.room];\n      if (itemIndices != null) {\n        if (typeof itemIndices === 'number') {\n          itemIndices = [itemIndices];\n        }\n        if (Array.isArray(itemIndices)) {\n          itemIndices = itemIndices.map(function (x) {\n            return x - 1;\n          });\n          context['keepItems'] = [this.room].concat(itemIndices);\n        }\n      }\n      var itemStr = 'Scene ' + context.sceneHash + ', floor ' + context.floor + ', item ' + this.room;\n      if (!isRoom) {\n        var msg2 = (context['keepItems'])? ' but has other items ' + itemIndices.join(',') : ' loading single object';\n        console.warn(itemStr + ' is not a room,' + msg2);\n      }\n      if (!context['keepItems']) {\n        if (isRoom) {\n          console.warn(itemStr + ' is a room without any objects.');\n        }\n        context['keepItems'] = [this.room];\n      }\n    }\n    this.__parseItemDeferred(json, context, ['Room', 'Ns', 'Pr', 'Ground', 'Window', 'Door'], function (err, parsed, results) {\n      // accumulate walls and holes (doors, windows) to create wall geometry with holes\n      var allWalls = [];\n      var holes = [];\n      var maxRoomHeight = 0;\n      results.forEach(function (x) {\n        if (x.object3D && (x.json.valid != null && !x.json.valid)) {\n          x.object3D.userData.isInvalid = true;\n        }\n        if (x.json.className === 'Room') {\n          if (x.height > maxRoomHeight) {\n            maxRoomHeight = x.height;\n          }\n        }\n        if (x.json.className === 'Room' && x.object3D) {\n          allWalls.push.apply(allWalls, x.walls);\n          holes.push.apply(holes,\n            x.items.filter(isHoleFilter)\n          );\n        }\n      });\n      holes.push.apply(holes, results.filter(isHoleFilter));\n      parsed.maxRoomHeight = maxRoomHeight;\n      var wallObject3Ds = scope.__createWallsWithHoles(allWalls, holes);\n      var roomHoleMappings = {};\n      var holeRoomMappings = {};\n      if (wallObject3Ds) {\n        for (var i = 0; i < wallObject3Ds.length; i++) {\n          context.scene.extraObjects.push(wallObject3Ds[i]);  // HACK!!!!\n        }\n        // doors and windows may not have been associated with rooms\n        // Build up correct association of doors and windows with rooms\n        for (var i = 0; i < holes.length; i++) {\n          var hole = holes[i];\n          if (hole && hole.object3D) {\n            holeRoomMappings[hole.id] = holeRoomMappings[hole.id] || [];\n            var wallIds = hole.object3D.userData.wallIds;\n            if (wallIds) {\n              // Associate hole with correct rooms\n              for (var j = 0; j < wallIds.length; j++) {\n                var wallId = wallIds[j];\n                var wallRoomId = wallId.substring(0, wallId.lastIndexOf('_'));\n                roomHoleMappings[wallRoomId] = roomHoleMappings[wallRoomId] || [];\n                roomHoleMappings[wallRoomId].push(hole.id);\n                holeRoomMappings[hole.id].push(wallRoomId);\n              }\n            }\n          }\n        }\n      }\n\n\n      // add children into group and callback\n      var group = new THREE.Group();\n      group.name = 'Level#' + context.floor;\n      group.userData.type = 'Level';\n      __addChildren(group, results);\n      __addChildren(group, allWalls);\n      if (scope.attachWallsToRooms) {\n        var walls = allWalls;\n        for (var iWall = 0; iWall < walls.length; iWall++) {\n          var wall = walls[iWall];\n          if (wall.object3D && wall.parent && wall.parent.object3D) {\n            Object3DUtil.attachToParent(wall.object3D, wall.parent.object3D);\n          }\n        }\n      }\n      parsed.object3D = group;\n\n      // Process roomObjectMapping (map of room index to object indices)\n      if (json.roomObjectMapping) {\n        for (var i = 0; i < json.roomObjectMapping.length; i++) {\n          var m = json.roomObjectMapping[i];\n          var room = results[i];\n          if (m && room && room.object3D) {\n            // console.log(\"Room \" + i);\n            if (!Array.isArray(m)) {\n              // Check if m is a single number\n              if (typeof m === 'number') {\n                m = [m];\n              } else {\n                console.warn('Invalid roomObjectMapping for floor ' + context.floor + ', room ' + i);\n              }\n            }\n            m = m.map(function(x) { return x-1; });\n            // Filter out holes\n            m = m.filter(function(idx) {\n              var node = results[idx];\n              return !holeRoomMappings[node.id];\n            });\n            // Incorporate corrected hole ids for room\n            if (roomHoleMappings[room.id]) {\n              _.each(roomHoleMappings[room.id], function(holeId) {\n                var holeIndex = _.findIndex(results, function(r) { return r.id === holeId; });\n                if (_.indexOf(m, holeIndex) < 0) {\n                  m.push(holeIndex);\n                }\n              });\n            }\n            m.sort(function(a,b) { return a-b; });\n\n            room.objectIndices = m;\n            room.partitions = m.map(function(idx) {\n              var mInst = results[idx].modelInstance;\n              if (mInst && mInst.model.isPartition()) {\n                return results[idx];\n              }\n            }).filter(function(x) { return x; });\n            for (var j = 0; j < m.length; j++) {\n              var ci = m[j];\n              if (ci !== i) {\n                var item = results[ci];\n                if (item && item.object3D) {\n                  if (!item.object3D.userData.roomIds) {\n                    item.object3D.userData.roomIds = [];\n                  }\n                  item.object3D.userData.roomIds.push(room.object3D.userData.id);\n                  if (item.json.className === 'Ns' && item.json.id === '121') {\n                    // Special fixing to adjust rotation of object by 90 degrees\n                    __checkAndApplySpecialRotationFix121(item, room);\n                  }\n                  Object3DUtil.attachToParent(item.object3D, room.object3D, group);\n                }\n              }\n            }\n          }\n        }\n        // Special fixing for model Id 121 that do not belong to a room\n         _.each(results, function(item) {\n          if (item && item.object3D && item.json.className === 'Ns' && item.json.id === '121') {\n            var roomIds = item.object3D.userData.roomIds || [];\n            if (roomIds.length === 0) {\n              __checkAndApplySpecialRotationFix121(item, {sceneHash: context.sceneHash});\n            }\n          }\n        });\n      }\n\n      callback(err, parsed);\n    });\n  } else {\n    console.log('Skipping floor ' + context.floor + ', only loading floor ' + this.floor);\n    this.__parseItemSimple(json, context, callback);\n  }\n};\n\nPlanner5dLoader.prototype.__parseGround = function (json, context, callback) {\n  var scope = this;\n  this.__parseItemDeferred(json, context, ['Wall'], function (err, parsed, results) {\n    var walls = results.filter(function (x) { return x.json.className === 'Wall'; });\n    var group = new THREE.Group();\n    group.name = 'Ground#' + parsed.id;\n    group.userData.type = 'Ground';\n    if (walls.length > 0) {\n      // Use wall points to make ground\n      var wallPoints = __getGroundVertices(walls);\n      if (wallPoints.length >= 4) {\n        var material = scope.__getMaterial(json.color, json.texture);\n        var groupedWallPoints = __groupPoints2DForShapes(wallPoints,4);\n        var ground = scope.archCreator.makeGround(groupedWallPoints, Planner5dLoader.__groundDepth, material);\n        group.add(ground);\n        ground.name = 'Ground#' + parsed.id;\n        ground.userData.type = 'Ground';\n        group.userData.material = { color: json.color, texture: json.texture };\n        group.userData.groupedPoints = groupedWallPoints;\n        group.userData.planeHeight = 0;\n        group.userData.depth = Planner5dLoader.__groundDepth;\n        group.userData.isSupportObject = true;\n        group.userData.isPickable = true;\n        group.userData.isEditable = false;\n        group.userData.isSelectable = false;\n        // HACK!!!!\n        context.scene.extraObjects.push(group);\n      } else {\n        group.isDegenerate = true;\n        if (scope.verbose) {\n          console.warn('Not enough wall points for ground');\n          //console.log(wallPoints);\n        }\n      }\n    } else {\n      group.isDegenerate = true;\n      if (scope.verbose) {\n        console.warn('Cannot get points to make ground');\n      }\n    }\n    scope.__applyTransform(group, json);\n    group.userData.offset = new THREE.Vector2(group.position.x, group.position.z);\n    group.userData.planeHeight += group.position.y;\n    parsed.object3D = group;\n    callback(err, parsed);\n  });\n};\n\n\nPlanner5dLoader.prototype.__parseRoom = function (json, context, callback) {\n  var scope = this;\n  // HACK!!!\n  if (context.sceneHash === '6c4a68064e72a9d76e39f9c46371e1f6' && context.id === '0_3') {\n    var walls = json.items;\n    walls[1].items[1].y = 559;\n    walls[2].items[0].y = 559;\n    walls[2].items[1].y = 559;\n    walls[3].items[0].y = 559;\n  } else if (context.sceneHash === '07dcc783a318e50156a252af4e922c43' && context.id === '0_16') {\n    json.h = 270;\n  } else if (context.sceneHash === '76b25e1954ef9704faaf98b6443d367f' && context.id === '0_6') {\n    json.items[0].h = 270;\n  } else if (context.sceneHash === '23790b17761f655c7fdc38f7bdadaf95' && context.id === '0_6') {\n    json.items[2].h = 270;\n  } else if ((context.sceneHash === '9a158dd1cba1b39a9e1d636e4ce23baa' || context.sceneHash === '585ab7b06d0c62fa859469a35711cd16') && context.id === '0_3') {\n    json.items[2].h = 270;\n  }\n  this.__parseItemDeferred(json, context, ['Wall', 'Window', 'Door'], function (err, parsed, results) {\n    var group = new THREE.Group();\n    group.name = 'Room#' + parsed.id;\n    group.userData.type = 'Room';\n\n    // Create a room with ground and walls (with windows/doors) carved out\n    // Assumes walls are in order\n    var walls = results.filter(function (x) { return x.json.className === 'Wall'; });\n    walls.forEach(function (w) {\n      w.points2DFinal = w.json.items.map(function (p) {\n        return new THREE.Vector2(p.x + json.x, p.y + json.y);\n      });\n      w.materials = [\n        { name: 'inside', texture: w.json.wtexture || parsed.json.wtexture, color: parsed.json.wcolor},\n        { name: 'outside', texture: w.json.otexture || parsed.json.otexture, color: parsed.json.wocolor}\n      ];\n    });\n\n    parsed.height = json.h;\n    if (parsed.height > 5000 && context.parent.json.h) {\n      if (scope.verbose) {\n        console.warn('Capping room ' + parsed.id + ' height to ' + context.parent.json.h + ' from ' + parsed.height);\n      }\n      parsed.height = context.parent.json.h;\n      walls.forEach(function (w) {\n        if (w.height > parsed.height) { w.height = parsed.height; }\n      });\n    } else {\n      walls.forEach(function (w) {\n        if (w.height > 5000 && parsed.height) {\n          if (scope.verbose) {\n            console.warn('Capping wall ' + w.id + ' height to ' + parsed.height + ' from ' + w.height);\n          }\n          w.height = parsed.height;\n        }\n        if (parsed.height && w.height === Planner5dLoader.__defaultWallHeight && parsed.height > w.height) {\n          if (scope.verbose) {\n            console.warn('Increasing wall ' + w.id + ' height to ' + parsed.height + ' from ' + w.height);\n          }\n          w.height = parsed.height;\n        }\n      });\n    }\n\n    if (walls.length > 0) {\n      var visibleWalls = walls.filter(function(x) { return !x.json.hidden;});\n      parsed.nVisibleWalls = visibleWalls.length;\n      var maxWallHeight = visibleWalls.length > 0? Math.max.apply(null, visibleWalls.map(function(x) { return x.height; })) : 0;\n      if (json.h === 0 && maxWallHeight > 0 && visibleWalls.length >= 4) {\n        //console.warn('Setting height to ' + maxWallHeight + ' for room ' + parsed.id + ' due to height=' + json.h + ', nVisibleWalls=' + visibleWalls.length);\n        parsed.height = maxWallHeight;\n      }\n      // console.log('maxWallHeight: ' + maxWallHeight);\n      // Use wall points to make ground\n      var wallPoints = __getGroundVertices(walls);\n      if (wallPoints.length >= 4) {\n        var groupedWallPoints = __groupPoints2DForShapes(wallPoints,4);\n        if (scope.keepHidden || !json.fhidden) {\n          var material = scope.__getMaterial(json.fcolor || json.color, json.texture);\n          var ground = scope.archCreator.makeGround(groupedWallPoints, Planner5dLoader.__floorDepth, material, Planner5dLoader.__floorVertOffset);\n          ground.name = 'Floor#' + parsed.id;\n          ground.userData.id = parsed.id + 'f';\n          ground.userData.type = 'Floor';\n          ground.userData.roomId = parsed.id;\n          ground.userData.material = { color: json.fcolor || json.color, texture: json.texture };\n          ground.userData.groupedPoints = groupedWallPoints;\n          ground.userData.offset = new THREE.Vector2(json.x, json.y);\n          ground.userData.planeHeight = Planner5dLoader.__floorVertOffset;\n          ground.userData.depth = Planner5dLoader.__floorDepth;\n          Object3DUtil.setVisible(ground, !json.fhidden);\n          group.add(ground);\n          // HACK!!!!\n          context.scene.extraObjects.push(ground);\n          parsed.hasFloor = true;\n        }\n\n        if (scope.includeCeiling && (scope.keepHidden || !json.rhidden)) {\n          //console.log('check ceiling', json, parsed);\n          // NOTE: Check against original json.h to determine whether to include ceiling or not\n          if (json.h <= 0 && parsed.height <= 0) {\n            // Probably no ceiling (too low)\n            if (scope.verbose) {\n              console.warn('Ignoring ceiling for room ' + parsed.id + ' due to height=' + json.h + ', nVisibleWalls=' + visibleWalls.length);\n            }\n          } else if (Planner5dLoader.__roomTypesWithoutCeilings.indexOf(json.rtype) >= 0 &&\n            json.h <= Planner5dLoader.__lowCeilingThreshold && parsed.height <= Planner5dLoader.__lowCeilingThreshold) {\n              // Probably no ceiling (too low)\n              if (scope.verbose) {\n                console.warn('Ignoring ceiling for room ' + parsed.id + ', rtype=' + json.rtype +\n                  ' due to height=' + json.h + ', nVisibleWalls=' + visibleWalls.length);\n              }\n          } else if (visibleWalls.length === 0 && json.h > 1000) {\n            // Probably no ceiling (too high and no walls)\n            if (scope.verbose) {\n              console.warn('Ignoring ceiling for room ' + parsed.id + ' due to lack of visible walls and height=' + json.h + ', nVisibleWalls=' + visibleWalls.length);\n            }\n          } else if (maxWallHeight && (parsed.height - maxWallHeight) > 1000) {\n            // Probably no ceiling (room height way above wall heights - compare with the parsed.height now)\n            if (scope.verbose) {\n              console.warn('Ignoring ceiling for room ' + parsed.id + ' due to difference between room height=' + parsed.height + ' and wall height=' + maxWallHeight);\n            }\n          } else {\n            // Also make ceiling\n            if (maxWallHeight > parsed.height) {\n              if (scope.verbose) {\n                console.warn('Setting height to ' + maxWallHeight + ' for room ' + parsed.id + ' due to height=' + json.h);\n              }\n              parsed.height = maxWallHeight;\n            }\n            var material = scope.__getMaterial(json.rcolor, json.rtexture);\n            // NOTE: Use our trimmed height\n            var ceiling = scope.archCreator.makeCeiling(groupedWallPoints, Planner5dLoader.__ceilingDepth, material, parsed.height + Planner5dLoader.__ceilingVertOffset);\n            ceiling.name = 'Ceiling#' + parsed.id;\n            ceiling.userData.id = parsed.id + 'c';\n            ceiling.userData.type = 'Ceiling';\n            ceiling.userData.roomId = parsed.id;\n            ceiling.userData.material = { color: json.rcolor, texture: json.rtexture };\n            ceiling.userData.groupedPoints = groupedWallPoints;\n            ceiling.userData.offset = new THREE.Vector2(json.x, json.y);\n            ceiling.userData.planeHeight = parsed.height + Planner5dLoader.__ceilingVertOffset;\n            ceiling.userData.depth = Planner5dLoader.__ceilingDepth;\n            Object3DUtil.setVisible(ceiling, !json.rhidden);\n            group.add(ceiling);\n            // HACK!!!!\n            context.scene.extraObjects.push(ceiling);\n            parsed.hasCeiling = true;\n          }\n        }\n      } else {\n        group.isDegenerate = true;\n        if (scope.verbose) {\n          console.warn('Not enough wall points for room');\n        }\n        //console.log(wallPoints);\n      }\n    }\n\n    parsed.items = results;\n    __addChildren(group, results);\n\n    // Assume sX, sY, sZ is for scale and x,y,z is for translation\n    group.position.set(json.x, 0, json.y);\n    //group.scale.set(json.sX, json.sY, json.sZ);\n    group.updateMatrix();\n    Object3DUtil.clearCache(group);\n\n    if (json.rtype != undefined) {\n      var roomType = Planner5dLoader.__roomTypes[json.rtype];\n      if (roomType) {\n        group.userData.origRoomType = roomType;\n      } else {\n        console.log('Unknown rtype: ' + json.rtype);\n      }\n    }\n    if (json.rtypeStr) {\n      group.userData.roomType = json.rtypeStr;\n    }\n    parsed.object3D = group;\n    parsed.walls = walls;\n    callback(err, parsed);\n  }.bind(this));\n};\n\nPlanner5dLoader.prototype.__parseWall = function (json, context, callback) {\n  this.__parseItemDeferred(json, context, ['Point'], function (err, parsed, results) {\n    parsed.depth = json.w || Planner5dLoader.__wallDepth;\n    parsed.height = (json.h > 0)? json.h : (context.parent.json.h > 0)? context.parent.json.h : Planner5dLoader.__defaultWallHeight;\n    parsed.points2D = results;\n    callback(err, parsed);\n  });\n};\n\nPlanner5dLoader.prototype.__parseWindow = function (json, context, callback) {\n  this.__parseItemLoad(json, context, callback);\n};\n\nPlanner5dLoader.prototype.__parseDoor = function (json, context, callback) {\n  this.__parseItemLoad(json, context, callback);\n};\n\nPlanner5dLoader.prototype.__parsePoint = function (json, context, callback) {\n  callback(null, new THREE.Vector2(json.x, json.y));\n};\n\nPlanner5dLoader.prototype.__parseNs = function (json, context, callback) {\n  this.__parseItemLoad(json, context, callback);\n};\n\nPlanner5dLoader.prototype.__parsePr = function (json, context, callback) {\n  // Procedurally generated content\n  var scope = this;\n  var parsed = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  if (json.t === 'box') {\n    // See https://dovahkiin.stanford.edu/fuzzybox/suncg/projects_room/93cdd63ea3523de8fb5d56ac5dc1b7e4/project.json\n    var box = new THREE.BoxGeometry(json.sX, json.sZ, json.sY, 1, 1, 1);\n    var tm = json.tm || 100;\n    for (var i = 0; i < box.faceVertexUvs.length; i++) {\n      var uvs = box.faceVertexUvs[i];\n      for (var j = 0; j < uvs.length; j++) {\n        var uv1, uv2;\n        if (j >= 0 && j <= 3) {\n          // sY, sZ   // left right\n          uv1 = json.sY / tm;\n          uv2 = json.sZ / tm;\n          if (j % 2 === 0) {\n            uvs[j][0].set(0, uv2);\n            uvs[j][2].set(uv1, uv2);\n          } else {\n            uvs[j][1].set(uv1, 0);\n            uvs[j][2].set(uv1, uv2);\n          }\n        } else if (j >= 4 && j <= 7) {\n          // sX, sY   // top bottom\n          uv1 = json.sX / tm;\n          uv2 = json.sY / tm;\n          if (j % 2 === 0) {\n            uvs[j][0].set(0, uv2);\n            uvs[j][2].set(uv1, uv2);\n          } else {\n            uvs[j][1].set(uv1, 0);\n            uvs[j][2].set(uv1, uv2);\n          }\n        } else {\n          // sX, sZ   // front back\n          uv1 = json.sX / tm;\n          uv2 = json.sZ / tm;\n          if (j % 2 === 0) {\n            uvs[j][0].set(0, uv2);\n            uvs[j][2].set(uv1, uv2);\n          } else {\n            uvs[j][1].set(uv1, 0);\n            uvs[j][2].set(uv1, uv2);\n          }\n        }\n      }\n    }\n    var materials = [];\n    // TODO: Check ordering of materials [2,3,0,1,4,5]?\n    var materialIndexMapping = [2,3,0,1,4,5]; // from json.materials to our materials\n    for (var i = 0; i < json.materials.length; i++) {\n      var mat = json.materials[i];\n      var m = scope.__getMaterial(mat.tcolor, mat.texture, { side: THREE.DoubleSide });\n      //console.log('material: ' + i + ' ' + mat.texture + '.jpg');\n      materials[materialIndexMapping[i]] = m;\n    }\n    var object3D = new THREE.Mesh(box, new THREE.MultiMaterial(materials));\n    object3D.position.set(json.x, Planner5dLoader.__objVertOffset + json.z + json.sZ / 2, json.y);\n    if (json.aX != undefined && json.aY != undefined && json.aZ != undefined) {\n      // Only for Pr class?\n      var r = new THREE.Vector3(json.aX / 180 * Math.PI, -json.aY / 180 * Math.PI, json.aZ / 180 * Math.PI);\n      object3D.rotation.set(r.x, r.y, r.z);\n    }\n    object3D.updateMatrix();\n\n    Object3DUtil.setVisible(object3D, !json.hidden);\n    parsed.object3D = object3D;\n    object3D.name = 'Box#' + parsed.id;\n    object3D.userData.type = 'Box';\n    // HACK!!!!\n    context.scene.extraObjects.push(object3D);\n  } else {\n    console.warn(\"Unsupported Pr type \" + json.t + \" for floor \" + context.floor + ', item ' + context.id, json);\n  }\n  if (callback) {\n    callback(null, parsed);\n  } else {\n    return parsed;\n  }\n};\n\nPlanner5dLoader.prototype.__parseItemLoad = function (json, context, callback) {\n  //console.log('processing object!!!');\n  //console.log(json, context);\n\n  var object = { json: json, parent: context.parent, floor: context.floor, id: context.id, index: context.index };\n  if (context.sceneHash === '48b4a30936c531455f6db120352f333b' && context.id === '0_17') {\n    // Weird hack for object 326 (glass door) on shelf\n    object.json.hidden = true;\n    object.json.a = 180;\n    object.json.sY = 57;\n    object.json.sZ = 61;\n    object.json.y += 53;\n  // } else if (context.sceneHash === '4c6c1294ba74e9b0efe3093d6a61c9f6' && context.id === '0_224') {\n  //   // Weird tub with door (impossible to get to)\n  //   object.json.hidden = true;\n  // } else if (context.sceneHash === '15e2e10d986c290ac52b9b8f81ea2d23' && context.id === '0_34') {\n  //   // Weird tub with door (impossible to get to)\n  //   object.json.hidden = true;\n  } else if (context.sceneHash === '2366401c83962cde8cf1cbbd938d92e2' && context.id === '0_61') {\n    // Jacuzzi blocking door way, move it to be under the window\n    object.json.y -= 120;\n  } else if (context.sceneHash === '769879deb713649f92a05174591c5f5c' && context.id === '0_1') {\n    // Weird door slightly out of house\n    object.json.x += 30;\n  } else if (context.sceneHash === '5a5ada1137160fa97f6b2228052125d0' && context.id === '0_63') {\n    // Weird door very high up\n    object.json.z = 2;\n    object.json.sZ = 94;\n  } else if (context.sceneHash === '92c1306c1ccc287336ed2117851c4319' &&\n    (context.id === '0_130' || context.id === '0_131' || context.id === '0_132' || context.id === '0_133')) {\n    object.json.x += 230;\n  } else if (context.sceneHash === '44ffeacb35bf75921f96fca86c157d08' && context.id === '0_28') {\n    // hide blind associated with door\n    object.json.hidden = true;\n  } else if (context.sceneHash === 'e5ecdd0c75c88f5a7fdcee6a0df7cf59' && context.id === '0_14') {\n    // hide blind associated with door\n    object.json.hidden = true;\n  } else if (context.sceneHash === '4c6c1294ba74e9b0efe3093d6a61c9f6' &&\n    (context.id === '0_212' || context.id === '0_213')) {\n    // hide blind associated with door\n    object.json.hidden = true;\n  } else if (context.sceneHash === '956bb20e072d8524253dbf1f25e3d99e' && context.id === '0_22') {\n    // shrink curtain so door is visible\n    object.json.sX = 90;\n  } else if (context.sceneHash === '86edddf60dc278a0b96b9d60117e5f1d' && context.id === '0_30') {\n    // shrink cabinet so height is reasonable\n    object.json.sZ = 115;\n  } else if (context.sceneHash === '11535fb0648bb4634360fca94e95af23' && context.id === '0_88') {\n    object.json.x = 6247;\n    object.json.y = 5554;\n  } else if (context.sceneHash === '1d1cdc34ff5e7ca0c04e26bd495a28d2' && context.id === '0_40') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === 'dbc90bb8c7b0c3b731e4a59b1651de40' && context.id === '0_278') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === '256b04497f1fded640fd0ea0aaa6ebe2' && context.id === '0_26') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === 'f230ef1ac8123c4695cf35586c2963a1' && context.id === '0_14') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === 'ea0d2badc73778024a7242853bbf52ba' && context.id === '0_18') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === '409a1c14fb2ebdf105b107e0da0474e9' && context.id === '0_130') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === '1ec6d875d9bea8ae729eac3bde63a1fd' && context.id === '0_17') {\n    object.json.sZ = 100;\n  } else if (context.sceneHash === 'ace255d51edbbeace8048c5db76ce8c6' && context.id === '0_59') {\n    object.json.sZ = 100;\n    object.json.z = 0;\n  } else if (context.sceneHash === 'ace255d51edbbeace8048c5db76ce8c6' && context.id === '0_64') {\n    object.json.z += 14;\n  } else if (context.sceneHash === 'e7b638cc05b8b0a82a287b3e8f5c15ab' && context.id === '0_115') {\n    object.json.sZ = 100;\n    object.json.z = 0;\n  } else if (context.sceneHash === 'e7b638cc05b8b0a82a287b3e8f5c15ab' && context.id === '0_116') {\n    object.json.z += 14;\n  } else if (context.sceneHash === 'ee9bc2ec9aa564a2c839d210f3d2064b' && context.id === '0_184') {\n    object.json.sZ = 100;\n    object.json.z = 0;\n  } else if (context.sceneHash === '2defc24b6de4ade78c8cd3190fbe3e51' && (context.id === '0_94' || context.id === '0_95' || context.id === '0_84')) {\n    if (context.id === '0_94') {\n      object.json.sZ = 100;\n    }\n    object.json.z = 0;\n  } else if (context.sceneHash === '49a5b4b8563ff811a46a249869de8fee' && context.id === '0_54') {\n    object.json.z = 0;\n  } else if (context.sceneHash === '5a258a0857d9e29dbbe0c9e3f7b848bf' && context.id === '0_11') {\n    object.json.hidden = true;\n    object.json.valid = 0;\n    if (!this.keepInvalid) {\n      callback(null, object);\n      return;\n    }\n  } else if (__hide121Scenes.indexOf(context.sceneHash) >= 0 && json.id === '121') {\n    // not too sure about these\n    object.json.hidden = true;\n    object.json.valid = 0;\n    if (!this.keepInvalid) {\n      callback(null, object);\n      return;\n    }\n  }\n  //console.log('Got ', object);\n  var modelId = json.id.replace(/\\\\*\\/+/, '__');\n  modelId = modelId.replace(/stores__[0-9]\\//, 's__');\n  object.modelId = modelId;\n  // Handle aframe\n  if (this.useVariants && json.aframe > 0) {\n    modelId += '_' + (json.aframe-1);\n  }\n  if (this.replaceModels) {\n    var replacementModelId = _.isFunction(this.replaceModels)? this.replaceModels(modelId) : this.replaceModels[modelId];\n    if (replacementModelId) {\n      if (this.verbose) {\n        console.log('Replace model ' + modelId + ' with ' + replacementModelId);\n      }\n      modelId = replacementModelId;\n    }\n  }\n\n  var scope = this;\n  function __loadModel() {\n    // console.log('loading model ' + modelId);\n    scope.assetManager.getModelInstance(scope.defaultSource, modelId,\n      function (modelInstance) {\n        // Okay\n        object.modelInstance = modelInstance;\n        object.object3D = modelInstance.getObject3D();\n        // align to scene up and front (TODO: get up/front context)\n        var model = object.modelInstance.model;\n        var up = model.getDefaultUp();\n        var front = model.getDefaultFront();\n        Object3DUtil.alignToUpFrontAxes(object.modelInstance.getObject3D('Model'), up, front,\n          Planner5dLoader.SCENE_UP, Planner5dLoader.SCENE_FRONT);\n\n        scope.__applyTransform(object.object3D, json, context);\n        // Apply materials after transform (apply transform may change underlying model...)\n        scope.__applyMaterials(object.object3D, json);\n        // Ensure modelInstance has double sided materials as flips will reveal back faces\n        Object3DUtil.setDoubleSided(object.modelInstance.object3D);\n        Object3DUtil.setVisible(object.object3D, !object.json.hidden);\n        callback(null, object);\n      },\n      function (error) {\n        // Error loading model\n        console.warn('Error loading model ' + modelId);\n        console.warn(error);\n        object.error = error;\n        callback(null, object);\n      },\n      { defaultFormat: scope.defaultModelFormat }\n    );\n  }\n\n  if (this.loadModelFilter) {\n    // Check category of the model\n    var scope = this;\n    this.assetManager.lookupModelInfo(scope.defaultSource, modelId, function(modelInfo) {\n      if (scope.loadModelFilter(modelInfo)) {\n        __loadModel();\n      } else {\n        callback(null, object);\n      }\n    });\n  } else {\n    __loadModel();\n  }\n};\n\nPlanner5dLoader.prototype.__getMaterial = function (color, texture, options) {\n  if (texture) {\n    options = options || { wrap: THREE.RepeatWrapping, repeat: Planner5dLoader.textureRepeat };\n    var out = this.assetManager.getTexturedMaterial(this.defaultSource, texture, options);\n    out.color = new THREE.Color(color || '#ffffff');\n    return out;\n  } else {\n    return Object3DUtil.getMaterial(color);\n  }\n};\n\nPlanner5dLoader.prototype.__applyMaterials = function (object3D, json) {\n  var scope = this;\n  if (json.materials && json.materials.length > 0) {\n    // Assume that the object3D is a single mesh with a multimaterial\n    // Get the multimaterial and make sure that it matches the number of materials specified and set it\n    var meshes = Object3DUtil.getMeshList(object3D);\n    for (var i = 0; i < meshes.length; i++) {\n      var mesh = meshes[i];\n      var name = mesh.material.name; // name not cloned for some reason\n      var index = mesh.material.index; // Our own custom index\n      mesh.material = mesh.material.clone();\n      mesh.material.name = name;\n      mesh.material.index = index;\n      var p5dLoader = new P5DTextureLoader();\n      p5dLoader.loadTexture = function (path, onLoad, onProgress, onError) {\n        //console.log('Using texture ' + path + ' on model ' + json.id);\n        var texturePath = scope.assetManager.getTexturePath(scope.defaultSource, path);\n        //console.log('loadTexture ' + scope.defaultSource + ' ' + path + ' ' + texturePath);\n        return Object3DUtil.loadTexture(texturePath, undefined, onLoad, onError);\n      };\n      p5dLoader.updateMaterials(mesh, json);\n    }\n  }\n};\n\n// Special scenes that our logic don't quite handle but still need fixing\n var __hide121Scenes = [\n    // Unsure which orientation it should be, perhaps best to hide it\n   '1e0c93ab57c44c293df9e6e99ba20d34', // used in very weird ways\n   '64964b65efaa7aaa541df529f5805c6d', // what is this doing there?\n   '55afa9f89bf4c7c85f05f26cac057a9e', // Neither position is any good\n   //'b8d5a6a11cb88a9ae95a2bf79f509727'  // What are they doing with the cabinet? Texturing the bathroom?\n ];\n // In general the auto detect rotation logic is working fairly well, here we explicit list scenes that need fixing (rotation)\n// and the ones that don't.  We list scenes for one of the following reasoning:\n// 1) there are lots of occurrences of 121 so it's good to be explicit so that the rotation is consistent\n//    typically for >= 4 occurrences\n// 2) weird use of model 121 to form walls or beams (there is typically lots of occurrences of 121 as well\n//    it is difficult for our logic to detect correct orientation in those cases\n// 3) we don't identify the model need to be rotated (typically this happens when the model appears in the middle of the\n//    room - we currently only check against the walls and the bounding box)\n// 4) room bounding box is inaccurate (room is cutoff), or room walls are not access aligned, or not rectangular\n// 5) for some reason the algorithm failed to detect correct orientation when manually checking.  The algorithm\n//    has been improved over time so it's possible it can correctly detect the correct orientation now.\n var __needFix121Scenes = [\n   '00674ddf2644455cb0f3d28dc84c1ffe', '00aefdae025360aacbfdf4b3f5bc4e9f', '00d8ab760e601c7e24bba79d3aee760c',\n   '016f6d20a99cac200a94ebed48105ab5', '017721df60943af0aa37f37fbd5a7af7',\n   '01b1f23268db0f2801f4685a7e1563b9',\n   '023b7b05fc91674a0b0c01d72287fdb2', '027617f9ad622f32a0e72ff13d4ba371',\n   '0373fde623565d56daef3d3a30368780', '03920de70952fb3e3abb414c9cf0e6c9',\n   '04af2ebf0ccafaeb41209d460cad20b4',\n   '04c345fbc51dfbbb927c950b3077f51e', '04e275a6e07cf446556422e55016f9d0',\n   '058a778388d0ec120a2359bd85817138',\n   '06045318dff093bcf9c99119fe431c45', '064370ae05a4d5a9573fced09dbae7d3', '0c537a2f19b50c8e596947d50d8a2f64',\n   '083002a16a2df813053645a23f78efb5', '08cfc1fc04564dc313c4a62e0b45cfb7',\n   '0a4c950d90288e20d194903f11f38818', '0a86f9338f7a56338d35d3a89c46faa4',\n   '0b99612f2ff6ec49c278de3c8abaa8ca',\n   '0c33bc4155cf7bfb61ae0af0be9dd265',\n   '0c61e9d558e868eb914a713e351d44bf', '0c88a0932fd1b91b72831de1550df84f',\n   '0da9d139194376e8005375552670fc05',\n   '0d9bcec641334c42cbb536388aa1f163', '0dbdd882342ec14b626dcd0b8dad5a46',\n   '0ec73409c7bea64a8107dbc76abd1c91',  // Weird use of model 121\n   '0fc4ccca4b8a40990bfb18919d3d5154',\n   '0feaa73646c6cee21b653d7d66a1aff3',\n   '1065f7730035474a82fc77d5053c510d',\n   '10bec6b202e8ff231e8060334a96ceb4',\n   '114c8af20d1e8aba3a28e337fa99c3d7',\n   //'11535fb0648bb4634360fca94e95af23',\n   '11d6b3d1739bd3be4885d40933f96fd3',\n   '1209de35970df9c397f29b1e48f15814', '124cd7d4aa6ce2f5b1a52b7bb367a7ab', '125aec2ac0d1af44d72f9bde56e5dfa9',\n   '13304f20f6327c21aa285069efb03ca1', '134d785f6e456fbdeec0c748c6e71361',\n   '1417c7b21905d7e438e8d79e01087355', '148a2cf9094ee4d3b56613c392462bfc',\n   '16a0f8931c51995fdda374c932daf28d',\n   '16ea1777bf6871560b3929f13ca8f789',  // Weird use of model 121\n   '173c36eec78e89ca2459f2b7831cef45',\n   '18aae119deb7a550890a03a96690588f', '18d769855c1b9fdf3e73e061c81d7763',\n   '1948ad0c9782febf4ca10dd4c9fe4f63', '1957adff2bfcbf6d984b2746dee98095', '195a7871a31bfe9114642c676e5a28eb',\n   '19f0dae1c358874a208a774923d73b1a', '19fbebc86fd245ba974307db806ee0e2',\n   '1b8b3986ce11498aa6f6d637acde58c1', '1b96481a5d7fcf648889427f9ab1943b',\n   '1c8e1fd06c5e8def6a2b40385208a33d',\n   '1f1ea1dbabdb0f2cbc08df3f319f1e9a', '1f1f3bb3306999f747f99af3915101de', '1f23fda185661f5cd1cbced38a6c8eb6',\n   '20846d4d1dc2068345ec9cda11510c08',\n   '209ed4d996935c07888fa1fb5ea02bbc', '214a5df2afc0e145622f2fda40ff209d',\n   '220409f288f5769d89e54ef2cede06b2', '22a1aecccb92bcd684fddec55c435906',\n   '238eb442e77ffc9dfb8760fc20df13d5',\n   '23aa5125945ab2455e730097276f8c52',\n   '23c8678f4da3a1b79cef8bde1b495398',  // Weird use of model 121\n   '24384211e54554f02ae7d9688092849a',  // Weird use of model 121\n   '25138c4077d00396990e974b0ee600ed',\n   '25c2fa68455573983e29aa54694fabd1',  // Weird use of model 121\n   '2768dcf5490ab2a2ad21097b82b5bbd3', '279a014167a76764eb694234cdf38d5b',\n   '293411a2550052be73515d832cdd35e7',\n   '294f12c08568af1350637d39be57fe2c', '298e1a7d3095dd903e211faa5050242d', '29d4078712959357c84dc263c55efbcc',\n   '2bb5440039dd55d2625fe48ec2c0a0ca', '2bb8f86076e5600af74674742d53a59d',\n   '2ca881bdf540ecff6a5d8216bb73df98', '2caf12d8f7a02106e90318007223a0aa',\n   '2e3b7f10ab400b75aae899dbc424021d', '2e4c6db7a53489596a0ec024be30ba6c', '2e940d2c0310a38d41d1b6c7994897a4',\n   '2ff270bcfa428db1045685a4aabeed54',\n   '30310e5bff4f2f7164e9d73dabd5a3db', '304c7a919453368f5e9cf8537c1a0c43',\n   '30815efdcc811655211925e83ebcb6b6', '31cb6f84a45fb414f1556019d97663a6', '31d00068aa940a954c446ceef399c16d',\n   '323dab270972f6ce03e43b90b8b74cc8', '328ef011ec366086acf1f32ff734a295', '32e89b3348bd619f5b627f679a634aeb',\n   '332e4bdb5fac68ffb909d110472e33a9', '3374876be5b611e2fdf274e6746185e6',\n   '33ab2874a197c04027ae7eb02f2235a9', '33d9f0631ea82c2e408080a7e1de3aa2',\n   '34269510cf873b41ee76610412f8df1c',\n   '3485ad80d37f6e99ac2f97285caeb963', '351d9a24a1b7673e44b00b86c4ec6c83', '35a4fce3f38280139f2d2e6756d3fce8',\n   '374c54a54d09fbeae224e64aa8fcedf8',\n   '393a749e3167c2bd1fef6d24e704215c', '39749d7345a45932e0480a2e204335f0',\n   '39c3a6ec306215e8a0cba048b5c35e06', // weird use of model 121\n   '39e65d57aefff32fbeb08da11cc65d42',\n   '3a57abf385e417104eec02dc537ac71d', '3b031b7b47a29f548ea67add533e3ea6', '3b9be5ea4e740e825fa10227da7be64f',\n   '3c52ca39109e84aef70281a0b18de870', '3c8691690243675e97f5452cf49763cb',\n   '3dad9cad9c484ff0cd01b68e6f48cd8d',\n   '3eab4c930cec0e4ac792172cf50c6c12',\n   '3fe0a0466df393799c0df89052a0405e', '3ffe330b543cdf9cffc9c452a2eb7cad',\n   '401b5ee6d4f62ceb66e72fd21e65278a', '40a88b3e8b2727bc73ae7a36dbd07b83',\n   '411c41b45c84dba4b093ddad31df5052', '4139a4d617fa800d0278c90470e64f3a', '41e86e902f88268fc6b6e64bc4ef6ae5',\n   '4239b6d223f6e4d12366bcc8b7615183',\n   '433726268cefc057611f19b01e99c78c', '43a589e07fae095b4e2f628d40c43410',\n   '442a562a6ff520983af3a6f65d492105', // weird use of model 121 as roof\n   '452da95765c9f439a4c58238b8698c32', '4594a51d90edcd4f5c2de01013390143',\n   '46b219f6eeff5c145a8c38a0a33fe663', '46cec962be92c57163db2ea821af0a5f',\n   '4751222070d9e5485559bf55b3be7181', '47f42a00ba560deefe8e6ff6a6f315e3',\n   '499b7ccd94de2cfc75ba4ed3f8e71a19', // neither way is great but most of the 121 instances need rotation\n   '4aa150ac6cdf9997ba393dfee78d71e8', '4abf6528b21e1c504d2a87102a5d097a',\n   '4c015e704c98a5dec3248cbe161808c1', '4c0a3e9bc23aea4dfb8cc664229e39f5',\n   '4c3259c18aaf67614e45f3927be540ea',\n   '4d4c22a1e64ad549167af8ba9bb0d5ab', '4d5432ebb73ea09ba69467f2646a95f7', '4dbd54c89758920bcdb21555ba6ac353',\n   '4e7710e5e9a16df1c5b2c22b4e782ff3', '4f938f90302f3a4a3497c85d38e68349',\n   '50c57a009114c019057c251332e0d967', '51b7f6e83355106d96ac448050436368', '521517330cc778317e5d9cfd0e3ffe16',\n   '54496cffcf60eb0bdd7653d9e1ba4e36', '54acc1820d223238e8f522c6f1eaea81',\n   '562123db56891b7f71bbed13ca981ef4', '5661af0fc5566eb87041e577c0f25bec', '56ecfe99039cb0926ef21a240815ccdc',\n   '5703b1dd53b1c0e8d788e72eb25252c6', '5760074ec765357062d983841b512704', '57be44d9ef1441b43136ab6f5a2b505f',\n   '58fa1835cf37c9e0af5fe5d9655b515b',\n   '59783dbef684a23aa6d60f1250d643c9',\n   '5a292e07ef6b709b34b4bfb9559fb4c1', '5adbc0359f583cc7f8ccd7ff059e395b',\n   '5b9e86d9759904e8034badb9a6f4819b',\n   '5c02c415aa2a24bd1f51364ffb5886f6',\n   '5dc95b188d7068ccd557264490fb0a32', '5dd3ebd233cb5f7d458e0e931d777d08', '5de6b36b068295a5fbb77bb53ceac558',\n   '5e5208cf2b04cf26fbeec101e1e6c8e5',\n   '5f6a59f4a3d05260101da38d8256b111', '5fd2bdb8d2ee7ff6321e81debf5c464c', '5ffa8a15f5642e8ac66a569c7bfb28ac',\n   '60e1d36d39ca45b1e1cb35ad20f34c1c', '60fdaad1216ff640b9ea23faa594eea5',\n   '612c4a7a76444e623fd045f71f357ea5', 'b16bb9eb32ed8b599416378a5ff939c7',\n   '6416ac8a0c08454247e736dd3d89ec74', '64752e5d843f04e2b1f27e332ed5d559', '6484b72e5183213990680269b02ed76b',\n   '65fc9060f1eb04ccde73d8663b4a60e5', '67b8ec7372bf108924acb0e8dedb2216',\n   '67ccadd6eafdb6bb9ca90f0bf6471272', // weird use of model 121\n   '68c65255f1b8fe4d0fb92e3a2ee99c33', '68efab58d53a275797c0b221975e5b3a',\n   '6ac7b35115fb16485f0a59e48979d5c6',\n   '6b67c73c3cc36363fbe6b98b8f4611ff',\n   '6ce82e355808a654d6b959a0e2a846ad', '6c8fa2eef2df5786e825326b36c720fb', '6c7ceeead806bc919ed039eda6b732e3',\n   '6de3b17eb6631f504833755028249803',\n   '6e071aede53585062e20144db7028fba', '6e9967e1b89c07ba28563993ab573857', '6ee7c1857e8929be0ba730a95d6808c4',\n   '6f3fc6cb74b3b77c3fec751c582521e9',\n   '6fbe66608a7b82236c100454bf43e77a',\n   '702773db312960a2d6aaa006665f425a',\n   '70eeec190a5db3a1b3fd69694268349a', // weird use of model 121\n   '70f5eef05faf468b38e7f91651af860b',\n   '71202c6a48fd6a649bc014861f5dae22',\n   '721c789fb9185b1f125f69b19e808d06', '727cfdfe40cb15548129794a08d4d2f8',\n   '73709a5d711c3e50bd29d19148037609', '73f99219a65c9d9fa22fb13a04585113',\n   '74349e19c2489c6da43a459ee972edab',\n   '7534f8d63f4b4cf7ae4eea104cd5ca42', '754a7296fe17955839aed12d0b771c51', '75b2977c39f4febde192c5bc85df31eb',\n   '7606a7433b620d9efd2abbb3e22ecd16', '7692ea792aa112e6d06da316d62365f0', '76fad8e2f2921ca3882414e31a3aed3e',\n   '770e06193d40508e2e8d00862165af22', '77b18359cdc8255aba9de2b3b04fbb57', '77ce6289da451bac3c3977eaa515431a',\n   '78352af9606d6418bd3c188fb8cd8835', '7933af14f7bf32130d4f8bc863473cfd',\n   '7a979977bdfcd8b392758ee6068c3121',\n   '7b0f7bb35f0923094c6f03b39fed5b5a', '7bed589233a2a4a88bf6300dae02942a', '7bede716e2377aaddab758e23ddb8c30',\n   '7f1f2cbb9299e47925b683911623b52e', '7f4b8b6864393bd34023dd45b31a0e0b',\n   '807255ea61deda06d73c6cdce4e942bd', '80a25452813967fb15de8835b0898a5e',\n   '8240ba289fb6c33e9175b8a655ffb7dc', '82669aa830b0aa3d84c24df29ebead62', '82e83f5d22a018b744aa8ea6aeca8950',\n   '838d93c4ff4dacbc3944d93e44116e6a',\n   '840721cb8bd642253e62c7c122c8e430', '847038273f348c044b56ced22be4e3c5', '84866adac7606363e6e8e039a7620eb9',\n   '84b841d45f09d2ab0736d6273e93f759', '84b1fee6d4136cdcd810c48250ae3b84',\n   '8596c65d15bc3e63846332b39ffef865', '85d76a03ee1ea9ba77d0f04e433faac9',\n   '8704e568e61b17d7a9e0f5c8582a0609', // Weird use of model 121\n   '888630697bf36e716a5fc412b2c9f82b',\n   '88ea881dd7b23b580a1cecd9d4d287cb', // Weird use of model 121\n   '8947ef1591ca434c82a97a4937a3717f',\n   '8aa3af7023f02f5cdb5486af2b209423',\n   '8c5b03d4601415bd816eb952db709661', // Weird use of model 121\n   '8d407283f07ef68b3535249a6d8b15c9',\n   '8f0c805bab92511d5370eae8a4169990',\n   '8f3993706d2896dda2380b55f4bdb541', '8f957dda2e302243f37e91696977e5f2',\n   '90db864d37391702f6fbe2b497700d12', '914c25a75542f4d313461b34dff11d95',\n   '919053e78ce7a4c9c5ee359b4db3c286',\n   '933622f0a21c755c0697c0668846f49b', '937712cf2715a952f4462a5d3daf5eeb',\n   '94726e0d13032d24b1d685be79d94f18',\n   '957bdfdcf2433c620e064da63adbc1cb', '95b5bc417b6fddf2c889c8c1f9bb5156', '95e440c4b78e1c6e1b6b3bc86fb28554',\n   '9663f289bf816b22bf75e6f0265a1950', // Weird use of model 121\n   '96ecf52dcc801049f6fded972f071ef9',\n   '984656a8b89d4bb14b70144b30efe420', // Weird use of model 121\n   '9ac2558512d7e6df4f08139e838b6cef',\n   '9bcade5b4c24d2319b950de39e718d48',\n   '9ccff52c3cde6d058a64f58ce8841def', '9cdb4764864c60fe2ee65306bafb3ca1',\n   '9d1304f68df334368c499e0a21d23d24', '9dab22ee4b4f6622d2f3d56ed1e6bf4d',\n   '9e12894c05b9402cf89f7912f1cbd57e', '9eb9569933faa32fa12d522a92ab31e0',\n   'a05d29f4ec13ab648419cbda0c31c7ab', // Weird use of model 121\n   'a1dd5b0f7f9a6a9dff40cfa2dd2a2291',\n   'a26ab0c3035e697396825edc9e61a064',\n   'a32472d114e28ebdba9c7dbd0238a34c', 'a41c2986802fd48e769b86de1f1f1b8d', 'a4b58507348b137c5ebc1af568116958',\n   'a5187e7542c31cf294b3ef1bbb923ad4', // Weird use of model 121\n   'a6a42648d526fe028a21d6f31b5f98e7', 'a64f780e53edc838ac7f15cfd0f8e54d',\n   'a79b7479fdcb9657d8321fd0fc04ea1e', 'a7f12a825f05e3af2ed712500d538827',\n   'a813dc6400207fcd717271678e57b507', 'a86221e68c789d16c795b80203e0634c',\n   'a98c957f8328514b00de2926677d3467',\n   'ab22c19028bd0fab8f902b64118e9348', 'aba523d1d02ed8e8e910e4e0d9eb40fb', 'abc9379e8ed1c30ad22da54c52689560',\n   'ac2cf3c38d49c61959d95a41ea8c972e',\n   'ad2f4bb92d199b45b6b9775011af7199', 'ad5efd10994a8d013a0b1405d13d767c', 'ad86c346561eba12f03c3806ee154c75',\n   'afe2576f91289845e2daf2b4bd0cf036', 'afe2b5c23ba83daad0109889b0a4a3c6', 'aff5604576a804ae3533ccb315a606ac',\n   'b0702417a36db238f6b27188e66a7c90', 'b0cd9c01d9077569097916d5ddecedec', 'b0ee1e33934c63456d63155cb5596f8b',\n   'b12614d3469c16e0276d1cd31da93c33', 'b1efb94dfdb6cdae7e7b6649e72c1abe',\n   'b33b72d3b3997be205b0b8ae734db5fc',\n   'b49fcc3adaf6d3e0117f5962f48868d2', 'b4e34f21adc95855d3281bcadac3db88',\n   'b5669b09665c5f5b4983dc7a09cdb04d', // weird use of model 121\n   'b59033883c8915fe4a41eb156aec5641', 'b5b949481bc41a24e1f552939bd3912a',\n   'b63dee9d2f78c694d3dd8d2f14e49d00',\n   'b713f34d4babd22ae98ca2da1f06a459', 'b76426107081553755ef15366b78685f', 'b7833410fd3d572c84a49da6df99076f',\n   'b7eb129a5fa1c5e2f2969395cffad818',\n   'b8634d4a608581c377fd78f93ce43e90', 'b877763966f9754ce22864b83004b135',\n   'b95d13b6868f37c66564db71eee8c6c8', 'b9cb0fd5a70869ecee1852bff2eff49c',\n   'baa4bc50506741abb82695e693737a1b',\n   'bbd093fe2f5d6da490a4fdf1852d70a2',\n   'bce9445ee5b2649eafba371561fe3cb8',\n   'be52c6dd0e77ec69858733b50b78db99', 'be58e07c48443b6aab5ae9261cca3125',\n   'be5d81d736d8081a225b5b032e1c0c73', // weird use of model 121\n   'be80a888864a52036c334eac0e11b791',\n   'bf9e25c6111512702d0aae638df72665', 'bfcdad636e378bd117652a894b3661b9',\n   'c1d981b45628b8904f4493d0c2c70148',\n   'c1f1ff40a36696508c3c7be508286587',\n   'c208febf84837d5be2b2d8e32d1d4248', 'c2318809f21e721ac306b46a70dfd8af', 'c2d3f4c8d6e6f8eca4039f071d0cf129',\n   'c3457e338bd31ce8e7fdea37a4253208', 'c346014f8eae8aba3bd3dd6e99655b7b',\n   'c38029cb2d75eeb289822c69bd7945d7', 'c3f2e40788b41e5a3816339a72e0ffdb',\n   'c4cb9ba262dd66c02e6559bb452afea0',\n   'c58bf94e4027628849d90fefe6f6f2de', 'c59029b024a338cf49f1b3feba6312d9',\n   'c6df03f0b9a3d5a63700f0e83f3b2d31',\n   'c7ac6c8f52943cae3dfbaa3589656460', 'c8a2cbd08122e915ba4dfad995357fad',\n   'ca2409c957268a072a2e410eece264f7',\n   'cb179109b8bd9a810f4539921481625f', 'cb1eb1c3049d7e8010178c3780e9876b',\n   'ccf9dc1d9e3ae28c66239c3c7f040a32', // weird use of model 121\n   'cd2956261e852d5569cb0c2ef19b6ac7', 'cd35d02fc0c8b3f28279cd9801cf952c', 'cd39ffec5ffe63d133d8e22a49f26766',\n   'cd614f1a61b5610c5e78ebc3e577558a',\n   'ce4364d9bee23c97693db080702534dc', 'cec79610010f7f5a930dc8f0a2733acd',\n   'cf637894191cd17087c926dcc94d513a', 'cf68e2219bfe40600d48fd55d55873c7',\n   'cfd8e14a9fbc74426c6bf678a080ae80', 'cff9572f467812ec90034811cd757f8f',\n   'ca463448edd5d00a4522c1e9d1780fc6',\n   'd1551a5685fd91866454464d87752277',\n   'd2e49b307fcff27d4883ff9a34e75866', 'd3d287dad202f217e6f34c533647eef5',\n   'd4940c0a8aa49487c956d3e092645ca1',\n   'd51654437f32ff31696d98b62c10fe7c',\n   'd686fe59991adf9cc096e72068c7fe45', 'd6ca058083e7719acad6830c899cf91f', 'd713d04dd8df7d9dc62674c3bb91b319',\n   'd80f5b43536eb9e73084cffe9d2de189', 'd8c107a551f890d892e4ee1c40d7c934',\n   'd97f02f0b7366cff12755580a3502240',\n   'dad2c9cc49eeac895f6f6996f1a59a48', 'dad8c35114713365bd3df94b332b3c03',\n   'db539a8f6135ad2dfda85802301b4abc', 'db5d50909c5dfdd48a964576927490e1',\n   'de3e09f3ebf32cc72b09ee3af023aa1f',  // weird use of model 121\n   'de6304e64da1aa95faed0aff5adcd766',\n   'df1f92b2a4b6e723d66f9eb9f9eff5cc', 'df77091c95b4bff91e7db8faf5d8c3a1', 'dfac8af07fd8600b50d4d700fe4d1cac',\n   'e1a1e240bf5c61a1478b2690460bcfc2',\n   'e2245986cdf1658535967282aa75a9d9', 'e2487c68ab1d6a2a45da172dfc946c9c',\n   'e26d3c43e2d35204d21b5bcc59102632', 'e27598c8aab78df63c795b54f7f8a2c7',\n   'e3075b27015ca92c1c05f48a1c737393', 'e309ed98a2385b348ef5675415ccd1eb',\n   'e57f61973e1654189a35bec40d224a37', 'e6e03c13ec7ebe85817781b0cbfbda73', 'e6fc3538d2051bb98b5a335e62495e49',\n   'e75427054f3167f39ca705dfffd1542c', 'e7642be2a241fffdc8c3b8e466c8f869',\n   'e8f1f5454976ce150a6f6705e9406bbd',\n   'eb01708f2377022d94408767575f4400', // weird use of model 121\n   'eb3caa7f19ea5ad19074b72c15bd9cc6', 'eb3e580f4271978e578acdafd09b8dcb',\n   'eb53da35b157c3ac69811282210b395e', 'eb634a7c3c76c8525f4b381eaaefdbcf', 'eb907dd75a5074ca03a81ecdf2eab8b9',\n   'ebb5e3ccf04176205ac4bc7a291aa63c', 'ebda834d11d8f725c977f98d6b69b2a6',\n   'ebeaa284cd92935748c3c497e7fe1de8', // weird use of model 121\n   'ec71456c490c595200fb504f2bda3011', 'ecc42183d8681e6b4d748eddfb4e8a2e',\n   'ecda7c267f81a8c40e4d079e5cc2a991',\n   'ed6040eacc0c2f7b8df77699d4fc5eb7', 'ed69c3dc2c410e151cfcf23747242841',\n   'edb5357d253d2473a2fb0ee4c59f1f0b',\n   'edd67177b3b57d5d9b2c2cec438923cb', 'ee494ae2f33357a0c6346ff54df745d9',\n   'e9e90aedbebc85887e858531c5154301',  // 0_94 intersects bed when rotated, sticks out of wall when not\n   'ed10b93888e99ffa98f87b0265bef674', 'ed8bd51817fb13127067eda4d0642e3a',\n   'efe0286a0449f8668e5467845bb2be9d',\n   'f0b41033d3107726378bbd947d83bbb0', 'f0c474c3bc79961b6b6bfda640f74344', 'f0fb32d860e9b30eb7a3939593207016',\n   'f14b348069538870b8c914c06aa04545',\n   'f204f5573793470916420118373dbff6',\n   'f25bf5bbb06c3982814af7b104031446', // weird use of model 121\n   'f2ae4863f6cdb534242a6800de55be3c',\n   'f574b0f380cd5126971586433e4a4555',\n   'f5ebc259f3f9e64373566de0b5c0d775',\n   'f60aa0ab39b9af735ce93fd2679ebc9b', 'f62e1e798f1182af90f1c4a9dbe4220d', 'f67dabb3850ebb2837b916659ceb4196',\n   'f6c71289c85a6d8facab62c68dc13dff',\n   'f7e41f74c5ba8cd2c3c5230b61e0f6a5',\n   'f8ea39ba6964bbe7a49c3c7ea00cf6df',\n   'faee5b6aa497ecbcb29cb42be8ed678b',\n   'fb1743f8413cc1d1227ed31436b12e38', 'fbebb8459048fdd2a082ef3083e6b0de',\n   'fc74b17055e97a049a746b57900c1e45', 'fce86242bea25cd0db3159d791757ffe',\n   'fc28c33accfd6be69ddf4beedd441e52', // weird use of model 121\n   'fd209a39ed19ff855173039999dccc14',\n   'fd42686f592f19858b6e5db55bcd7ebd', 'fdf2632f7e689dd867dd9d6961e88a40'\n ];\n var __needFix121ScenesSet = new Set(__needFix121Scenes);\n var __noFix121Instances = {\n   '84b841d45f09d2ab0736d6273e93f759': ['0_56'],  // very weird, intersects bed\n   '521517330cc778317e5d9cfd0e3ffe16': ['0_195', '0_229']\n };\n // Special scenes that don't need fixing\n var __noFix121Scenes = [\n   '003cf0cdb02443370b659820667ead7e',\n   '021516ef8fe38881c92819bde4f72127', '02178ee1df2aeb46bb45eafb980d32ec', '0298084d7e99ab9e61bd026c7aed2eac',\n   '03023b072c49fe4afe3264abd5b2e460', '03958b7f2876410f31db007f36942f93',\n   '04555dc06c542cc6bc0a7880152a5346',\n   '082e6f7abd8c86fd326b178f3acfd330', '09c1f9d74ec3c899dcf40e3c89123c1b',\n   '0a86348c95f4548e15446232bd187460', '0ac297c80cba3266c3999204e27d67ae', '0acee9723705fede4747e73bd11e48a5',\n   '0c774fc3d3ee919e5dffe8128519cecd', '0c9a666391cc08db7d6ca1a926183a76', '0fdf3e7e84c692454b1ce0474b9977b4',\n   '12e0307a0e76c4535af58abfa849e8bc',\n   '196b3cf5104fb0be86101be7cfb22ba9', '19d36ca6739e6dac1b8076d837c1bf4e', '19bf51d2c88c83b925c81e80372c7a48',\n   '1a1f24a849f4349a0502c5fdad191d5c', '1a573bfc2474e3d95ebb22e81a2d972d', '1ac159ed37044fc0f21fb67315b1661d',\n   '1b294f35d347cc2d6d28322156c2b2c7',\n   '1d673afd917495557d80a1358503c21f',\n   '1f5afe92ddbf8cf3c4737dad5aaf38ec',\n   '204d720d3620fdb33dfe4defcd0bdd57',\n   '228fcab3900e1dcfe8cc1bf8dd3563b5',\n   '25e8b574eeb4bc124ccfe1e653f0e9ef',\n   '2813d8a03134bb1b00b2b7eeda37a5f5', '286700d34ee1785eb5b9a60f3702a3f3',\n   '2a2b317dedf4eec14b9f82f701b095a5', '2a9e746d7b83be2e96a1f5b8ef031fea',\n   '30bff55da4fabee694210d71b796a94a', '31c6874b842b518db6fe3f5fce17faad',\n   '335473e795eef6372a6a6d8bcd6869a3', '33c939e69f88c645669f3bb71490ccff',\n   '346d1dc48bbcf3f98b05c67a4eb038e1', '3626669733ddc1c8dc89dfa9484730ca', '385425ae4f16c986129d5384ae3aae72',\n   '3a266e840800c0e339c0c94825bcd9f1', '3ba503dc63d019f5ac6276b37befb517',\n   '3c475edd5174c7133e02abfd414a3145', // very weird use of model 121\n   '3f2a67ae9e11251d9733f6e9d3c1dbe8', '3f8a4f098aa8e1eb3538e106b25c60c8',\n   '40d88ec62304c1874a4ae15a7b4cacbf',\n   '4205cf0a31bb432adba34c3731c03e0c', '427dc962b8707a14fe3dda01ca126c07',\n   '4330dda4b5fbc26aab34423ae0791008', '4474b5d5bc7263cf59a02d1e31c2ac53', '447fbcc1fcb2fadb12be9f6557b91ece',\n   '4579e5cfd4bdd61db7d2588bd0f1179e', '459a250630d10365afe6627b7ec850fa',\n   '462d4ec4b57e352c71db24b67f993aea', '4654d15eb0bcaac7ddce264a23a5565a', '467b52bfbc5507b288bd194623a645f9',\n   '47b2a4820ef1929482be5d0761e5262f',\n   '489e6920466e37eb50379d01a99d7d48', '48f0eef8f8013b9ffdb96637f7d77ad1',\n   '4a78f8872c50bbcf80698d74955f989a', '4bb8f06100466897f4dd8d98e96b878c', '4db5f702f880cf7b7d7a70b39414ba7e',\n   '4c9f04ec06b9f2b498900c3fb52d26b8',\n   '4ef4ae26c618812269e8759654818d68',\n   '50374c6fcea0d2703d5e05eeed62afc4', '506ec3a20c4b9bbdee7a50b50d391888',\n   '5383c3762692dd46e46b89a5cc51f3ae', '55afa9f89bf4c7c85f05f26cac057a9e', '5885d0846fc14a04a74711a7740e79e1',\n   '5927fa836eee54275e7cc2706f21f47e',\n   '597287cafb0146e09fd6d544cd449733', // very weird use of of model 121\n   '5a6feaad74e5ac9a859ac73e0cb43dcf',\n   '5e13fcd628319812e7d31f5535bc4610',\n   '5e3993ea4884dcd37fa2d9983e5e1013', '5e76dcfeb897ff1df2f60c51dfb54b07', '5e788a9f1df3a0bda1f79af7e657f913',\n   '600c4144145ea82a4589386d6fa3f157', '60b7354894cddb735aa19fda3bf9687a', '60fd65ff7c8357be3150ab679eaf659d',\n   '6169fa5df035020eb1e5771a56f80028',\n   '65ef6513af1c8ef8ce998e544ea770f3', '65f8888407f76696859d43137af4009e',\n   '669f289c2afa72aa19075c0349e26ca1',\n   '677aa59891c4ba7e2a8ccc8b457d0a3f',\n   '6809b8dce18213362aa2c9aa749068b4',\n   '6a04585a31d525dfa9d1d5890c7383d9', '6cba2b129184f0b41739666597acc8a5',\n   '6d80768d2270e26f16d2e2c46b21ac8b', '6e4e2eb4eb2c234a0f920d1235b21519',\n   '6ec2ea6e767ebd2abf5610e456ad3aa0', // very weird use of model 121\n   '71f70d0ac238e4d5869abdc89c5eef52', '71f50bcc39d1419415b0d0c8336f19b7',\n   '7330350937ab8e4662e624b41c6d48be',\n   '740fd64ef76fa8c0bd8136672fe82a94', '74482970b07691aa19cea0f55256a9e1',\n   '75da00bec6aaf877b3cd185c53c89447',\n   '773929b11750f0e480091237ea57523f', // very weird use of model 121\n   '79e887cffdbec23e867d50ff06e4e93e',\n   '7a5a947fb61f8980887150c1c7ff5797', '7abc0171e77a63205fbef125cafedd26',\n   '7bbf52bf0d194dcbb80d902329762781', '7bf491c30cd3b6917c682417a622839e',\n   '7dcf46550b5599b2ca483108979d9a2e', '7df773cb73b3fe99270469a818aa89b2',\n   '7ec9dc8b29856cef635cafcb31d9f426', // very weird use of model 121\n   '7fac9e6f2b1124aa0cb4426a23acaec3',\n   '8116c9ca6362b7e7633b0b7b71a2ee78', '82d1383d0001c93f3400ec272970fefe',\n   '8562bcce6c8879c6b9a333348ce3b644', // very weird use of model 121\n   '866e0dc2f6a4a4e5976419b10709f2a5', // very weird use of model 121\n   '86800152e734e1822c979ba51739654d', '86e635480947a3050334dd34421df415',\n   '875e363bfd2748c5997c0ee125fea9bc', '89c7153ae04dfe3e6b7fab8605423a67',\n   '8aa3e6e05e0827f808dc66972ae86405', '8a0c4b45ee0b7b4849a651fba7185544', '8added77185e310abbc75d2b77a38d9e',\n   '8b53498fba2136bbf42bb8c3ffb7a305', '8d441acf569c51569c033cd2b490d3c7', '8e2067bf01ca975afc4eb79ced0afda3',\n   '8f98697b92424792192a66f07ff508fc',\n   '8fa5d72c5ec8650610ed4f5c6a4b755c', '8fbcff4a2b39d4b6f0bc2f4f9ccf3cf9',\n   '90896caeb3f7726de6970d5dc87fe7a5',\n   '918483606fdf0d63c7cbe8e99e9a687f', '943aeb3f830c433b6bba299fd83d3e40', '9467f1ba79aab08a8716373aad0510eb',\n   '97655cf69d545ad2ac74bfc3442d96e6',\n   '9878c4dd7901422d7111396301b28059', '98c68072791a5b5f9023c55b205b0559',\n   '9a3af64393733cf63122cd12c6282a9b', '9b8f2e71b8c5693f6a72c89dfde9f93f', '9cadd8474ea0e1259e05759fe04b33c3',\n   '9ea5505a9854a654e32b67cb90170eb5', '9eb26b2687b33bf253f99ad1e9da42dd',\n   '9fd1aab65510b2febed749aaa81e5d38',\n   'a0d61429702616c17753d54ad10c01c6', // very weird use of model 121\n   'a154352fd6e01f033b82a1ed4f392ec4',\n   'a205f66b8365cedf7f37c222209b2ac6', // weird use of model 121\n   'a27fde7f73e28d74cca71c16291a7301',\n   'a3c039b029acd2292bc86a1f2f91e605', 'a3c26785061acca806cb691abbf27c61', 'a443bab5f1bc4b8131f1992fa2027cf7',\n   'a645680e80ebb57ec2e1ba882d863681',\n   'a7a20e5950a19ac04ec3e25db9bb58b2', 'a82f220609ad751cad812e02eb5a25e4', 'a8bbd138ef1c8de4816e720d6c2f38f6',\n   'ab72c70e3a43c2a24a33fe02daf8654f', 'acabc1fe6e2b9da3c58c8e29228a30a8',\n   'ad04ae524e1f3ee279b6814f2396e844', 'ad25b606d046b64c3049630707397b98',\n   'ae939b3907865bb079ca02de61494778', 'ae130b9dc96409d93f2210b889811b6f', 'aef0ca865326a808bc515a259bfd58a4',\n   'b13bbfdc5b711071d51c27a81abf2f6f',\n   'b26e7e9d7ac371cb5ca016fa236e6772', 'b3bdc8b6bbfc8acbb7fc7497b5d221f1',\n   'b438e614e659412c574abeb5a3f78bd0', // very weird use of model 121\n   'b4a2f5bdb900ec77a70b2262d0a97830',\n   'b54bc5147554904bc933fc8b82326020', 'b566960398a3ee6795541f844fb6e7df', 'b7b529c5288cb7c44a2b2c3b6c26fd78',\n   'b8d5a6a11cb88a9ae95a2bf79f509727',  // used for texturing bathroom (weird)\n   'b9d90d6ad4213afb692e8c3f095ec888', // very weird use of model 121\n   'bac2719d8d4dcb14e6e0fa9046a6c776', 'bacb122f086b01788a704b4cdfa17162', 'baee2ddf9e6972d470577e57cb1aeeae',\n   'be70d9dfdc32dd032333394aac9fa9c3', // very weird use of model 121\n   'c01e10f210f03e6d8b41ab73cf7f2e7d', // weird use of model 121\n   'c0de2230333849b111a898b735cbad9e',\n   'c2ab4e7a7cdbdc43b4a0088283e969fa', 'c89c13b61bc6a7f925f6b4afe5bd55b5',\n   'ca42e92160f0005cac4ef986ab77f129', 'ca9fac914d06d12d7df2b092c31a849d', 'cad24637ea9bc0d1f8b97cbebbd5c51a',\n   'cbfb3a0e0c501f9802055196a99a9e9f',\n   'cbfd70c3f7bf22d2e57a385594ce1df5',  // very weird use of model 121\n   'cdc1a47c12e842475f03bbf67871ac28',  // strange use of model 121\n   'ce5ffd07d609278d8ed6c54966f2f7d5',\n   'cbb8c324e780fb34f148f53c959f98e9',  // very weird use of model 121\n   'cfd28fa76892563100d930305fe5330e',\n   'd1ebfab60e2d7c0369de0bb7ed2a1f1a',\n   'd36a9ad16bd1549c73670088779bc1d8', 'd45650c6178db21e123daa69df83e3bc', 'd63e15fc97934977ae7190d9e8ccc5fb',\n   'd71e52877de176a46a3cb5773cc14e20', 'd7505c08c663ace19470b3b2be262db1', 'd7e510fdad6536dae734201e76b53a6c',\n   'd9e86f581d027c6349e294cc9acee0b7',\n   'db4b4239aac105af842787229e5e0d97',\n   'dcdbe584ef2c5c70de82b61e7e1ec134', // weird use of model 121\n   'dced0c428f31df627265134474ec96bd',\n   'ddd75e81348e00b7007e5d20b9811e47', // weird use of model 121\n   'df216583b801cf860d34274698a7b6c3',\n   'e2b2d9dfbac2af9678ca4a839b029f85', 'e34acf454c02ba527152cceaba213e22', 'e3fa451ff61e61058a21b9abe5f7f8ae',\n   'e7bfc2b3ba81b7a47bcd01edf6607a4e',\n   'ebe7354f84734c2ae322f134c1473c7e', 'ebf82f4f81cc02e7b9a0dc6316509531',\n   'ec75019b9d5e26168e1ce274ef629ce2', 'ed32862ddc282e8106d7e02794c38365', 'ee9bc2ec9aa564a2c839d210f3d2064b',\n   'f08f7111f65c33e507470f07fbbd6345', 'f1480946f6287258d360e467234f92be',\n   'f3b3d3237fab55fff362d15b7c5bf1a6', 'f3d55a197419216c88e9882dab0cf77a',\n   'f412a656524ded1f2d22f28ebf6f58e5', // very weird use of model 121\n   'f5e091908245826aae758a1146024e80', 'f749db1c418d91c3cfbf8de655768569', 'f7d96f0a8a1789693ed9049ed436f8c9',\n   'f895ce0351e999285e7c077e8adef2fd', 'f8f33fbe48744bf93ba7b75aa31362fc',\n   'fa6ad517aaada115a1d9109a6795c16f', 'faee5b6aa497ecbcb29cb42be8ed678b',\n   'fb840ca17fe162b4e5092eba880d8042',\n   'fcddc4ff179425e584ea0c6599d2cb9c',\n   'fd53b8f2877f8c85a5be72b0568d3293',\n   'fdb70b5ef50e97138900b0ccf53dd781', 'fde809277a6189600f25d236112600c9',\n   'ffdbbc9b82d081f79f62616f8ba3f422'\n ];\nvar __noFix121ScenesSet = new Set(__noFix121Scenes);\n\nfunction __checkAndApplySpecialRotationFix121(item, room) {\n  var noFixInstances = __noFix121Instances[room.sceneHash];\n  if (item.object3D\n      && (!noFixInstances || noFixInstances.indexOf(item.id) < 0)\n      && item.object3D.userData.localAxis && !__noFix121ScenesSet.has(room.sceneHash)) {\n    //var partitions = room.partitions;\n    var needSpecialFixing = __needFix121ScenesSet.has(room.sceneHash);\n    var reason = needSpecialFixing? \"special\" : \"outside room\";\n\n    var itemBBox = Object3DUtil.getBoundingBox(item.object3D);\n    var roomBBox;\n    var needFixing = needSpecialFixing;\n    if (!needFixing && room.object3D) {\n      roomBBox = Object3DUtil.getBoundingBox(room.object3D);\n      needFixing = !roomBBox.contains(itemBBox);\n    }\n    var intersectingWalls = null;\n    var uw1 = 0;\n    if (!needFixing && room.walls) {\n      // Check against intersection with walls\n      intersectingWalls = room.walls.filter(function(w) {\n        var wbbox = w.object3D? Object3DUtil.getBoundingBox(w.object3D) : null;\n        if (wbbox) {\n          var u = wbbox.union(itemBBox);\n          uw1 += u.volume();\n          var swbbox = wbbox.expandBy(-Planner5dLoader.__wallDepth);\n          return swbbox.intersects(itemBBox);\n        }\n      });\n      if (intersectingWalls.length > 0) {\n        needFixing = true;\n        reason = \"wall intersection\";\n      }\n    }\n    if (needFixing) {\n      // Extra Rotating needed\n      var initialItemBBox = itemBBox;\n      console.warn('Rotating ' + item.id + ' extra +90 to avoid wall collision: ' + reason);\n      var localAxis = item.object3D.userData.localAxis;\n      item.object3D.children[0].rotateOnAxis(localAxis, THREE.Math.degToRad(90));\n      item.object3D.children[0].updateMatrix();\n      Object3DUtil.clearCache(item.object3D);\n      itemBBox = Object3DUtil.getBoundingBox(item.object3D);\n      var originalBetter = false;\n      if (needSpecialFixing) {\n        originalBetter = false;\n      } else if (intersectingWalls) {\n        var uw2 = 0;\n        var intersectingWalls2 = room.walls.filter(function(w) {\n          var wbbox = w.object3D? Object3DUtil.getBoundingBox(w.object3D) : null;\n          if (wbbox) {\n            var u = wbbox.union(itemBBox);\n            uw2 += u.volume();\n            var swbbox = wbbox.expandBy(-Planner5dLoader.__wallDepth);\n            return swbbox.intersects(itemBBox);\n          }\n        });\n        //console.log('checking if original is better', intersectingWalls, intersectingWalls2, uw1, uw2);\n        if (intersectingWalls.length < intersectingWalls2.length) {\n          // ORIGINAL BETTER - REVERT\n          originalBetter = true;\n        } else if (intersectingWalls.length === intersectingWalls2.length) {\n          originalBetter = uw1 < uw2;\n        }\n      } else if (roomBBox && !roomBBox.contains(itemBBox)) {\n        var u1 = roomBBox.union(initialItemBBox);\n        var u2 = roomBBox.union(itemBBox);\n        originalBetter = (u1.volume() < u2.volume());\n      }\n      if (originalBetter) {\n        // ORIGINAL BETTER - REVERT\n        console.warn('Rotating ' + item.id + ' back (original was better)');\n        item.object3D.children[0].rotateOnAxis(localAxis, THREE.Math.degToRad(-90)); // Rotate back\n        item.object3D.children[0].updateMatrix();\n        Object3DUtil.clearCache(item.object3D);\n      }\n    }\n    delete item.object3D.userData.localAxis;  // Not needed anymore\n  }\n}\n\nPlanner5dLoader.prototype.__applyTransform = function (object3D, json, context) {\n  // assumes object3D is pre-rotated\n  // rotation (around z, in degrees)\n  var vOffset = 0; // vertical offset (p5d has different vertical offset depending on className)\n  if (json.className === 'Ns') {\n    var mi = Object3DUtil.getModelInstance(object3D);\n    vOffset = mi.model.hasCategory('chandelier') || mi.model.hasCategory('ceiling_fan') ? Planner5dLoader.__ceilingVertOffset - Planner5dLoader.__ceilingDepth : Planner5dLoader.__objVertOffset;\n    //vOffset = Planner5dLoader.__objVertOffset;\n  } else if (json.className === 'Door') {\n    vOffset = 2;\n  } else if (json.className === 'Ground') {\n    if (json.texture && json.texture.split('_')[0] === 'ground') {\n      vOffset = 3;\n    } else {\n      vOffset = 4;\n    }\n  }\n\n  if (json.className === 'Ns' || json.className === 'Window') {\n    if (json.otf == null) {\n      var mi = Object3DUtil.getModelInstance(object3D);\n      if (mi.model.info && mi.model.info.otf > 0) {\n        vOffset += mi.model.info.otf;\n      }\n    }\n  }\n\n  if (json.a != undefined) {\n    var localAxis = object3D.worldToLocal(Planner5dLoader.SCENE_UP);\n    //console.log(localAxis);\n    // Don't do extra -90 if version is undefined\n    var specialScenes = ['f6c16e962095501545858c47f506aa2a']; // Special scenes with version undefined\n    var needExtra90 = ((json.className === 'Door' || json.className === 'Window') &&\n      (context.version != undefined || specialScenes.indexOf(context.sceneHash) >= 0));\n    var angle =  needExtra90? -json.a - 90 : -json.a;\n    object3D.rotateOnAxis(localAxis, THREE.Math.degToRad(angle));\n    if (json.id === '121') {\n      // May need special fixing\n      object3D.userData.localAxis = localAxis;\n    }\n  }\n  // sX, sY, sZ is for scale (percentage)\n  if (json.className !== 'Ground' && json.sX != undefined && json.sY != undefined) {\n    //object3D.scale.set(json.sX / 100, json.sY / 100, json.sZ / 100);\n    object3D.scale.set(json.sX, json.sZ || 1.0, json.sY);\n  }\n  // NOTE: P5D format X-Y axes seem to have opposite interpretation\n  var needToFlipNormals = false;\n  if (json.fY) {  // Flip across z axis\n    object3D.scale.x = -object3D.scale.x;\n    needToFlipNormals = !needToFlipNormals;\n  }\n  if (json.fX) {  // Flip across x axis\n    object3D.scale.z = -object3D.scale.z;\n    needToFlipNormals = !needToFlipNormals;\n  }\n\n  // AXC: Not needed as of r89 (maybe even a bit before)\n  // if (needToFlipNormals) {\n  //   // console.log('Flip normals!!!', object3D);\n  //   var mi = Object3DUtil.getModelInstance(object3D);\n  //   if (mi) {\n  //     mi.useFlippedModel(this.assetManager);\n  //   } else {\n  //     Object3DUtil.flipForMirroring(object3D);\n  //   }\n  // }\n\n  // x,y,z is for translation\n  if (json.x != undefined && json.y != undefined) {\n    object3D.position.set(json.x, vOffset + (json.z || 0.0), json.y);\n  } else {\n    object3D.position.set(0, vOffset, 0);\n  }\n  object3D.updateMatrix();\n  Object3DUtil.clearCache(object3D);\n};\n\n// Populate SceneState members for sceneResult (called at end with callback)\nPlanner5dLoader.prototype.__onSceneCompleted = function (callback, sceneResult) {\n  var scene = sceneResult.scene;\n  sceneResult.modelInstances = Object3DUtil.findModelInstances(scene);\n  for (var i = 0; i < sceneResult.modelInstances.length; i++) {\n    var modelInst = sceneResult.modelInstances[i];\n    this.setObjectFlags(sceneResult, modelInst);\n    modelInst.object3D.name = '' + i;\n    if (this.useNormalizedCoordinateFrame) {\n      modelInst.ensureNormalizedModelCoordinateFrame().clone();\n    }\n  }\n  this.Publish('sceneLoaded', sceneResult);\n  if (callback) {\n    callback(sceneResult);\n  }\n};\n\n// Utility function\nfunction __addChildren(parent, results) {\n  if (results) {\n    //console.log('Adding children');\n    //console.log(results);\n    for (var i = 0; i < results.length; i++) {\n      var result = results[i];\n      if (result.object3D) {\n        parent.add(result.object3D);\n      } else {\n        //console.warn('Skipping child ' + i);\n      }\n    }\n  } else {\n    console.warn('No results!!!!');\n  }\n}\n\nfunction __groupPoints2DForShapes(points, minPoints) {\n  minPoints = minPoints || 0;\n  // Find repeating points and group them\n  var pointIndices = {};\n  var groups = [];\n  var pts = points.slice();\n  var i = 0;\n  while (i < pts.length) {\n    var p = pts[i];\n    var ps = p.x + ',' + p.y;\n    if (pointIndices[ps] != undefined) {\n      var group = pts.splice(pointIndices[ps], i + 1 - pointIndices[ps], p);\n      if (group.length >= minPoints) {\n        groups.push(group);\n      } else {\n        console.warn('Discarding group', group);\n      }\n      pointIndices = {}; // Start new group\n      i = 0;\n    } else {\n      pointIndices[ps] = i;\n      i++;\n    }\n  }\n  if (pts.length >= minPoints) {\n    groups.push(pts);\n  } else if (pts.length > 1) {\n    console.warn('Discarding group', pts);\n  }\n  //console.log(groups);\n  return groups;\n}\n\nfunction __removeInnerWallPointsSimple(wallPoints) {\n  var finalWallPoints = [];\n  // Look at sequence p1,p2,p3, skip p2,p3 if p1 == p3\n  var i = 0;\n  while (i < wallPoints.length) {\n    var pt = wallPoints[i];\n    var next = i+1;\n    if (i + 2 < wallPoints.length) {\n      var pt2 = wallPoints[i+2];\n      if (pt2.equals(pt)) {\n        // Skip\n        next = i+3;\n      }\n    }\n    finalWallPoints.push(pt);\n    i = next;\n  }\n  return finalWallPoints;\n}\n\nfunction __removeInnerWallPointsColinear(wallPoints) {\n  var finalWallPoints = wallPoints.slice();\n  // Look at sequence p1,p2,p3, skip p2 if p1,p2,p3 all lie on the same line\n  var i = 0;\n  while (i + 2 < finalWallPoints.length) {\n    var colinear = Object3DUtil.isColinearVec2(finalWallPoints[i], finalWallPoints[i + 1], finalWallPoints[i + 2]);\n    if (colinear) {\n      //console.log('Ignoring point ', finalWallPoints[i+1]);\n      finalWallPoints.splice(i + 1, 1);\n    } else {\n      i = i + 1;\n    }\n  }\n  return finalWallPoints;\n}\n\nfunction __removeInnerWallPointsAll(wallPoints) {\n  var finalWallPoints = wallPoints;\n  var done = false;\n  while (!done) {\n    var t = __removeInnerWallPointsSimple(finalWallPoints);\n    if (t.length === finalWallPoints.length) {\n      done = true;\n    } else {\n      finalWallPoints = t;\n    }\n  }\n  done = false;\n  while (!done) {\n    var t = __removeInnerWallPointsColinear(finalWallPoints);\n    if (t.length === finalWallPoints.length) {\n      done = true;\n    } else {\n      finalWallPoints = t;\n    }\n  }\n  return finalWallPoints;\n}\n\nfunction __getGroundVertices(walls) {\n  var wallPoints = [];\n  var lastPt = null;\n  for (var i = 0; i < walls.length; i++) {\n    var pts = walls[i].points2D;\n    if (pts.length > 0) {\n      if (lastPt === null || !lastPt.equals(pts[0])) {\n        // Append all wallpoints\n        wallPoints.push.apply(wallPoints, pts);\n      } else {\n        wallPoints.push.apply(wallPoints, pts.slice(1));\n      }\n      lastPt = wallPoints[wallPoints.length - 1];\n    }\n  }\n  //console.log('before', wallPoints);\n  var finalWallPoints = __removeInnerWallPointsAll(wallPoints);\n  //console.log('after', finalWallPoints);\n  return finalWallPoints;\n}\n\nfunction __setPositionY(object3D, y) {\n  object3D.position.y = y;\n  object3D.updateMatrix();\n  Object3DUtil.clearCache(object3D);\n}\n\nPlanner5dLoader.prototype.__createWallsWithHoles = function(walls, holes) {\n  //console.log('createWallsWithHoles');\n\n  // helper to get hole BBox and flip y-z\n  function getBBox(hole) {\n    var bbox = Object3DUtil.computeBoundingBox(hole.object3D).clone();\n    // Shrink bbox along length, expand along perpendicular\n    var widthDir = Planner5dLoader.SCENE_LEFT.clone().applyQuaternion(hole.object3D.getWorldQuaternion());\n    var x = Math.abs(widthDir.x);\n    var z = Math.abs(widthDir.z);\n    var bboxDelta = new THREE.Vector3(-5*x + 5*z, -2, -5*z + 5*x);\n    //console.log('bbox hole: ' + bbox.toString(), hole);\n    //console.log('adjusting bbox hole', widthDir, bboxDelta);\n    bbox = bbox.expandBy(bboxDelta);  // TODO(MS): Hack! - slightly contract hole bboxen to avoid over-merging and over-cutting\n    var miny = bbox.min.y;\n    var maxy = bbox.max.y;\n    bbox.min.y = bbox.min.z;\n    bbox.max.y = bbox.max.z;\n    bbox.min.z = miny;\n    bbox.max.z = maxy;\n    return bbox;\n  }\n\n  this.archCreator.associateWallsWithHoles(walls, holes, getBBox, function(wall) {\n    return wall.points2DFinal;\n  }, 25);\n\n  // for each wall\n  //   project hole's bounding box corners onto wall's coordinate frame\n  //   create 2D hole points and 2D wall outline points\n  //   use points to generate extruded geometry with holes\n  if (!this.keepHidden) {\n    walls = walls.filter(function(w) { return !w.json.hidden; });\n  }\n\n  var scope = this;\n  return this.archCreator.createWalls(walls,\n    function(wall) {\n      return _.map(wall.points2DFinal, function(p) {\n        return [p.x, 0, p.y];\n      });\n    },\n    function(wall) {\n      // inside, outside materials;\n      return _.map(wall.materials, function(m) {\n        return scope.__getMaterial(m.color, m.texture);\n      });\n    });\n}\n\n// Exports\nmodule.exports = Planner5dLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/Planner5dLoader.js?");

/***/ }),

/***/ "./js/lib/scene/SUNCGLoader.js":
/*!*************************************!*\
  !*** ./js/lib/scene/SUNCGLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var HouseJsonLoader = __webpack_require__(/*! scene/HouseJsonLoader */ \"./js/lib/scene/HouseJsonLoader.js\");\nvar P5DTextureLoader = __webpack_require__(/*! loaders/P5DTextureLoader */ \"./js/lib/loaders/P5DTextureLoader.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n// Loader for SUNCG JSON format scenes\nfunction SUNCGLoader(params) {\n  params = _.defaults(params, { defaultModelSource: 'p5d', defaultSceneSource: 'p5dScene', archSource: 'suncg-arch' });\n  HouseJsonLoader.call(this, params);\n}\n\nSUNCGLoader.prototype = Object.create(HouseJsonLoader.prototype);\nSUNCGLoader.prototype.constructor = HouseJsonLoader;\n\nSUNCGLoader.prototype.__getDefaultArchConfig = function() {\n  return {\n      up: new THREE.Vector3(0,1,0),\n      front: new THREE.Vector3(0,0,1),\n      unit: 1,\n      defaults: {\n      'Wall': {\n        depth: 0.1,\n          height: 2.7,\n          extraHeight: 0.035,\n          materials: [\n          {\n            \"name\": \"inside\",                          // Name of material (\"inside\" for inside wall)\n            \"texture\": \"wallp_1_1\",                    // Texture\n            \"diffuse\": \"#ffffff\"                       // Diffuse color in hex\n          },\n          {\n            \"name\": \"outside\",                         // Name of material (\"outside\" for outside wall)\n  //              \"texture\": \"bricks_1\",                     // Texture\n            \"texture\": \"wallp_1_1\",                    // Texture\n            \"diffuse\": \"#ffffff\"                       // Diffuse color in hex\n          }\n        ]\n      },\n      'Ceiling': {\n        depth: 0.05,\n          offset: 0.04,    // Bit offset above wall extraHeight\n          materials: [\n          {\n            \"name\": \"surface\",\n            \"texture\": \"linen_1_4\",\n            \"diffuse\": \"#ffffff\"\n          }\n        ]\n      },\n      'Floor': {\n        depth: 0.05,\n          materials: [\n          {\n            \"name\": \"surface\",\n            \"texture\": \"laminate_1_2\",\n            \"diffuse\": \"#ffffff\"\n\n          }\n        ]\n      },\n      'Ground': {\n        depth: 0.08,\n          materials: [\n          {\n            \"name\": \"surface\",\n            \"texture\": \"ground_1\",\n            \"diffuse\": \"#ffffff\"\n          }\n        ]\n      }\n    }\n  };\n};\n\nSUNCGLoader.prototype.__getTextureLoader = function() {\n  return new P5DTextureLoader();\n};\n\n\nmodule.exports = SUNCGLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/SUNCGLoader.js?");

/***/ }),

/***/ "./js/lib/scene/SceneLoader.js":
/*!*************************************!*\
  !*** ./js/lib/scene/SceneLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar PubSub = __webpack_require__(/*! PubSub */ \"./js/lib/PubSub.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction SceneLoader(params) {\n  PubSub.call(this);\n  this.defaultModelFormat = params.defaultModelFormat;\n  this.assetManager = params.assetManager;\n  this.useSupportHierarchy = true;\n  this.useNormalizedCoordinateFrame = true;\n  this.freezeObjects = params.freezeObjects;  // Option to make placed objects not movable\n  this.floor = params.floor;  // Floor to load (ignored by most loaders)\n  if (typeof this.floor === 'string') {\n    this.floor = parseInt(this.floor);\n  }\n  this.room = params.room;  // Room to load (ignored by most loaders)\n  if (typeof this.room === 'string') {\n    this.room = parseInt(this.room);\n  }\n  this.defaultSource = undefined;\n\n  this.includeCeiling = (params.includeCeiling != undefined)? params.includeCeiling : true;\n  this.includeWalls = (params.includeWalls != undefined)? params.includeWalls : true;\n  this.includeFloor = (params.includeFloor != undefined)? params.includeFloor : true;\n}\n\nSceneLoader.prototype = Object.create(PubSub.prototype);\nSceneLoader.prototype.constructor = SceneLoader;\n\nSceneLoader.prototype.setCrossOrigin = function (value) {\n  this.crossOrigin = value;\n};\n\nSceneLoader.prototype.load = function (url, onLoad, onProgress, onError, loadInfo) {\n  var scope = this;\n  var loader = new THREE.FileLoader(scope.manager);\n  //loader.setCrossOrigin(this.crossOrigin);\n  return loader.load(url, function (text) {\n    scope.parse(JSON.parse(text), onLoad, url, loadInfo);\n  }, onProgress, onError);\n};\n\nSceneLoader.prototype.setObjectFlags = function(sceneState, modelInst) {\n  sceneState.setObjectFlags(modelInst);\n  if (this.freezeObjects && modelInst) {\n    modelInst.object3D.userData.isSelectable = true;\n    modelInst.object3D.userData.isEditable = false;\n  }\n};\n\n// SceneResult comes at end since we do binding of callback\nSceneLoader.prototype.__onSceneCompleted = function (callback, sceneResult) {\n  // Convert to scene and make appropriate transforms\n  var scene = sceneResult.scene || new THREE.Scene();\n  var roots = [];\n  var transforms = [];\n  for (var i = 0; i < sceneResult.modelInstancesMeta.length; i++) {\n    var metadata = sceneResult.modelInstancesMeta[i];\n    if (metadata) {\n      delete metadata.childIndices;  // We'll compute our own\n    }\n  }\n  for (var i = 0; i < sceneResult.modelInstances.length; i++) {\n    var metadata = sceneResult.modelInstancesMeta[i];\n    var modelInst = sceneResult.modelInstances[i];\n    if (metadata.userData) {\n      _.merge(modelInst.object3D.userData, metadata.userData);\n    }\n    this.setObjectFlags(sceneResult, modelInst);\n    if (modelInst) {\n      if (metadata.transform)  {\n        var te = metadata.transform.data || metadata.transform;\n        var transform = new THREE.Matrix4();\n        transform.set(te[0], te[4], te[8], te[12],\n          te[1], te[5], te[9], te[13],\n          te[2], te[6], te[10], te[14],\n          te[3], te[7], te[11], te[15]\n        );\n        transforms.push(transform);\n        modelInst.applyTransform(transform);\n      } else {\n        // No transform - try to apply the stuff we know about\n        if (metadata.scale) {\n          if (typeof metadata.scale === 'number') {\n            modelInst.setScale(metadata.scale);\n          } else if (metadata.scale instanceof THREE.Vector3) {\n            modelInst.setScaleVector(metadata.scale);\n          }\n        }\n        if (metadata.quaternion) {\n          modelInst.setQuaternion(metadata.quaternion);\n        }\n        if (metadata.position) {\n          modelInst.setTranslation(metadata.position);\n        }\n        transforms.push(modelInst.object3D.matrix);\n      }\n      // TODO: is this recursive linking okay?\n      // Don't use userData since that is suppose to be well behaved and we are not\n      // Probably not good if we want to export this scene\n      modelInst.object3D.metadata = {\n        modelInstance: modelInst,\n        metadata: metadata\n      };\n      modelInst.object3D.name = '' + i;\n      if (this.useNormalizedCoordinateFrame) {\n        transforms[i] = modelInst.ensureNormalizedModelCoordinateFrame().clone();\n      }\n\n      scene.add(modelInst.object3D);\n\n      if (metadata.parentIndex >= 0) {\n        var parent = sceneResult.modelInstancesMeta[metadata.parentIndex];\n        if (parent.childIndices) {\n          parent.childIndices.push(i);\n        } else {\n          parent.childIndices = [i];\n        }\n      } else {\n        roots.push(i);\n      }\n    } else {\n      transforms.push(null);\n    }\n  }\n  if (this.useSupportHierarchy) {\n    // Try to put model as child of parent\n    var todo = roots.slice(0);\n    while (todo.length > 0) {\n      var i = todo.shift();\n      var metadata = sceneResult.modelInstancesMeta[i];\n      var modelInst = sceneResult.modelInstances[i];\n      if (modelInst) {\n        if (metadata.childIndices) {\n          var minv = new THREE.Matrix4();\n          minv.getInverse(transforms[i]);\n          for (var j = 0; j < metadata.childIndices.length; j++) {\n            var ci = metadata.childIndices[j];\n            var child = sceneResult.modelInstances[ci];\n            if (child) {\n              modelInst.object3D.add(child.object3D);\n              // Fix child transform to be relative to parent\n              // cwm = pwm * cm\n              // cm = pwm^(-1)*cwm\n              child.applyTransform(minv);\n              // Add child to todo queue\n              todo.push(ci);\n            }\n          }\n        }\n      }\n    }\n  }\n  sceneResult.scene = scene;\n  this.Publish('sceneLoaded', sceneResult);\n  callback(sceneResult);\n};\n\nSceneLoader.prototype.__onModelInstanceLoaded = function (sceneResult, modelIndex, allModelsLoadedCallback, modelInstance) {\n  allModelsLoadedCallback = allModelsLoadedCallback || this.__onSceneCompleted.bind(this);\n  sceneResult.modelInstances[modelIndex] = modelInstance;\n  sceneResult.modelInstancesLoaded += 1;\n  this.Publish('modelLoaded', modelIndex, sceneResult);\n  if (sceneResult.modelInstancesLoaded + sceneResult.modelInstancesErrors === sceneResult.modelInstancesMeta.length) {\n    allModelsLoadedCallback(sceneResult);\n  }\n};\n\nSceneLoader.prototype.__onModelInstanceLoadError = function (sceneResult, modelIndex, allModelsLoadedCallback, error) {\n  console.error('Cannot load: ' + error);\n  allModelsLoadedCallback = allModelsLoadedCallback || this.__onSceneCompleted.bind(this);\n  sceneResult.modelInstancesErrors += 1;\n  this.Publish('modelLoadedError', modelIndex, sceneResult);\n  if (sceneResult.modelInstancesLoaded + sceneResult.modelInstancesErrors === sceneResult.modelInstancesMeta.length) {\n    allModelsLoadedCallback(sceneResult);\n  }\n};\n\nSceneLoader.prototype.__loadModel = function (sceneResult, modelIndex, modelId, callback) {\n  var modelFormat = this.defaultModelFormat;\n  if (sceneResult.modelInstancesMeta && sceneResult.modelInstancesMeta[modelIndex]) {\n    if (sceneResult.modelInstancesMeta[modelIndex].format != null) {\n      modelFormat = sceneResult.modelInstancesMeta[modelIndex].format;\n    }\n  }\n  this.assetManager.getModelInstance(this.defaultSource, modelId,\n    this.__onModelInstanceLoaded.bind(this, sceneResult, modelIndex,\n      this.__onSceneCompleted.bind(this, callback)),\n    this.__onModelInstanceLoadError.bind(this, sceneResult, modelIndex,\n      this.__onSceneCompleted.bind(this, callback)),\n    { defaultFormat: modelFormat }\n  );\n};\n\nSceneLoader.prototype.parse = function (json, callbackFinished, url) {\n  if (json.format === 'objects' && json.objects) {\n    var sceneResult = new SceneState(null, null);\n    var objects = json.objects.map(function(record) {\n      record.position = Object3DUtil.toVector3(record.position);\n      record.scale = Object3DUtil.toVector3(record.scale);\n      record.quaternion = Object3DUtil.toQuaternion(record.quaternion);\n      return record;\n    });\n    if (json.scan) {\n      objects.unshift(json.scan);\n    }\n    sceneResult.modelInstancesMeta = objects;\n    console.log('objects', objects);\n    for (var i = 0; i < objects.length; i++) {\n      this.__loadModel(sceneResult, i, objects[i].fullId, callbackFinished);\n    }\n  } else {\n    throw 'Please implement parse method!!!';\n  }\n};\n\n// Exports\nmodule.exports = SceneLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/SceneLoader.js?");

/***/ }),

/***/ "./js/lib/scene/SceneState.js":
/*!************************************!*\
  !*** ./js/lib/scene/SceneState.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! Constants */ \"./js/lib/Constants.js\"),__webpack_require__(/*! model/ModelInstance */ \"./js/lib/model/ModelInstance.js\"),__webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\"),__webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\"),__webpack_require__(/*! geo/RaycasterUtil */ \"./js/lib/geo/RaycasterUtil.js\"),__webpack_require__(/*! geo/Attachments */ \"./js/lib/geo/Attachments.js\"),\n    __webpack_require__(/*! scene/SceneUtil */ \"./js/lib/scene/SceneUtil.js\"), __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\"), __webpack_require__(/*! ds/Index */ \"./js/lib/ds/Index.js\"), __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\"), __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function (Constants, ModelInstance, Object3DUtil, GeometryUtil, RaycasterUtil, Attachments, SceneUtil, AssetGroups, Index, async, _) {\n\n    /**\n     * Create a new SceneState.\n     *   A SceneState consists of a scene (a set of objects and transforms on the objects)\n     *     and a set of selected objects\n     *\n     *   Metadata associated with the scene includes:\n     *   <ul>\n     *     <li>source - scene database from which this scene is taken (\"wssScenes\")</li>\n     *     <li>id - Unique id (for given source)</li>\n     *   </ul>\n     *\n     *   Populated after retrieving information from solr:\n     *   <ul>\n     *     <li>name - Name of scene</li>\n     *     <li>tags - Tags associated with the scene</li>\n     *     <li>unit - Number specifying the physical unit (in meters) the scene is specified in\n     *            (defaults to Constants.defaultModelUnit)</li>\n     *     <li>up - Up vector for scene ( defaults to the z-vector (0,0,1) )</li>\n     *     <li>front - Front vector for scene ( defaults to the y-vector (0,1,0)? )</li>\n     *     <li>category - Category of scene</li>\n     *   </ul>\n     *\n     * @param scene - Three.Scene that contains the Three.js scene graph for the scene\n     * @param info - Additional metadata about the scene\n     * @constructor SceneState\n     * @memberOf scene\n     * @public\n     */\n    function SceneState(scene, info) {\n      this.init(scene, info);\n    }\n\n    SceneState.getArchType = function(sceneinfo) {\n      return sceneinfo.emptyRoom? 'empty' : (sceneinfo.archOnly? 'arch' : 'furnished');\n    };\n\n    SceneState.prototype.init = function (scene, info) {\n      this.info = info;\n      this.lights = [];\n      this.extraObjects = [];   // Extra objects that are not models but do something in the scene\n      this.selectedObjects = [];\n      this.modelInstancesMeta = [];\n      this.modelInstances = [];\n      this.modelInstancesErrors = 0;\n      this.modelInstancesLoaded = 0;\n      this.currentCamera = null;\n      this.currentCameraControls = null;\n      this.manipulator = null;\n      this.rootModelInstance = null;\n      this.sceneType = '';\n\n      // Basic Three.Scene that contains just the models\n      if (scene) {\n        this.scene = scene;\n      } else {\n        this.scene = new THREE.Scene();\n      }\n      // Full Three.Scene with lighting and cameras\n      this.finalizeScene();\n    };\n\n    SceneState.prototype.addDefaultLights = function (sceneBBox, cameraPos, intensity) {\n      var lights = this.lights;\n      var fullScene = this.fullScene;\n      if (lights.length > 0) {\n        return;\n      }\n      var light = new THREE.HemisphereLight(0xffffff, 0x202020, intensity);\n      fullScene.add(light);\n      lights.push(light);\n      return lights;\n    };\n\n    SceneState.prototype.addLights = function (lights) {\n      for (var i = 0; i < lights.length; i++) {\n        var light = lights[i];\n        if (light.parent !== this.fullScene) {\n          this.fullScene.add(light);\n          this.lights.push(light);\n        }\n      }\n    };\n\n    SceneState.prototype.getNumberOfModelInstances = function () {\n      return this.modelInstances.length;\n    };\n\n    SceneState.prototype.isEmpty = function () {\n      return this.getNumberOfModelInstances() === 0 && this.extraObjects.length === 0;\n    };\n\n    SceneState.prototype.identifyAttachments = function () {\n      console.time('identifyAttachments');\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var m = this.modelInstances[i];\n        if (!m) { continue; }\n        this.setAttachmentPointToParent(m);\n      }\n      console.timeEnd('identifyAttachments');\n    };\n\n    SceneState.prototype.setAttachmentPointToParent = function(modelInst) {\n      var m = modelInst;\n      if (m.object3D) {\n        m.setAttachmentPoint({ position: new THREE.Vector3(0.5, 0.5, 0.5), coordFrame: 'childBB' });\n      }\n      if (m.object3D.parent) {\n        m.attachment = Attachments.identifyAttachment([m.object3D.parent], { modelInstance: m, attachments: m.getCandidateAttachmentPoints() }, { sameModelCost: 1.0 });\n        if (m.attachment) {\n          //var ball = Object3DUtil.makeBall(m.attachment.childAttachment.world.pos, 0.05*Constants.metersToVirtualUnit);\n          //this.fullScene.add(ball);\n          var p = m.attachment.childAttachment.local.pos;\n          var u = m.object3D.userData;\n          m.setAttachmentPoint({ position: p, coordFrame: 'child' });\n          u['attachmentPoint'] = p;\n          u['attachmentIndex'] = m.attachment.index;\n          u['childWorldBBFaceIndex'] = m.attachment.childWorldBBFaceIndex;\n        }\n      }\n      return m.attachment;\n    };\n\n    SceneState.prototype.__filterSupportObjects = function (modelInst, candidateSupportObjects, opts) {\n      candidateSupportObjects = candidateSupportObjects || this.fullScene.supportObjects;\n      var filteredCandidateSupportObjects = candidateSupportObjects;\n      if (modelInst.object3D.userData.wallIds) {\n        filteredCandidateSupportObjects = _.filter(candidateSupportObjects, function(cobj) {\n          return modelInst.object3D.userData.wallIds.indexOf(cobj.userData.id) >= 0;\n        });\n        //console.log('wallIds', modelInst.object3D.userData.wallIds, filteredCandidateSupportObjects);\n      } else if (opts && opts.keepSameLevel && this.getLevels() > 1) {\n        var id = modelInst.object3D.userData.id;\n        var pi = id.indexOf('_');\n        if (pi > 0) {\n          var level = id.substring(0, pi);\n          var prefix = level + '_';\n          filteredCandidateSupportObjects = _.filter(candidateSupportObjects, function(cobj) {\n            return modelInst.object3D.userData.id.startsWith(prefix);\n          });\n        }\n      }\n      return filteredCandidateSupportObjects;\n    };\n\n    SceneState.prototype.identifyAttachment = function (modelInst, candidateSupportObjects, opts) {\n      var filteredCandidateSupportObjects = this.__filterSupportObjects(modelInst, candidateSupportObjects, opts);\n      return this.__identifyAttachment(modelInst, filteredCandidateSupportObjects, opts);\n    };\n\n    SceneState.prototype.__identifyAttachment = function (modelInst, candidateSupportObjects, opts) {\n      opts = opts || {};\n      var supportObjectsForMe = candidateSupportObjects.filter(function(x) {\n        return !Object3DUtil.isDescendantOf(x, modelInst.object3D);\n      });\n      if (supportObjectsForMe.length > 0) {\n        var attachment = Attachments.identifyAttachment(supportObjectsForMe,\n          { modelInstance: modelInst, attachments: modelInst.getCandidateAttachmentPoints() },\n          _.merge({ sameModelCost: 1.0 }, opts));\n        if (attachment) {\n          //var ball = Object3DUtil.makeBall(attachment.childAttachment.world.pos, 0.05*Constants.metersToVirtualUnit);\n          //this.fullScene.add(ball);\n          attachment.parentInst = Object3DUtil.getModelInstance(attachment.parent, true);\n          return attachment;\n        }\n      }\n    };\n\n    SceneState.prototype.identifyCandidateAttachments = function (modelInst, candidateSupportObjects, opts) {\n      var filteredCandidateSupportObjects = this.__filterSupportObjects(modelInst, candidateSupportObjects, opts);\n      return this.__identifyCandidateAttachments(modelInst, filteredCandidateSupportObjects, opts);\n    };\n\n    SceneState.prototype.__identifyCandidateAttachments = function (modelInst, candidateSupportObjects, opts) {\n      opts = opts || {};\n      var supportObjectsForMe = candidateSupportObjects.filter(function(x) {\n        var notDescOfSelf = !Object3DUtil.isDescendantOf(x, modelInst.object3D);\n        var sameLevel = (modelInst.object3D.userData.level != undefined)?\n          x.userData.level == undefined || modelInst.object3D.userData.level === x.userData.level : true;\n        return notDescOfSelf && sameLevel;\n      });\n      if (supportObjectsForMe.length > 0) {\n        var attachments = Attachments.identifyAttachments(supportObjectsForMe,\n          { modelInstance: modelInst, attachments: modelInst.getCandidateAttachmentPoints() },\n          _.merge({ sameModelCost: 1.0 }, opts));\n        if (attachments && attachments.best) {\n          return attachments;\n        }\n      }\n    };\n\n    // Do something with doors closed (revert door state afterwards)\n    SceneState.prototype.__doWithDoorsClosed = function(assetManager, act, callback) {\n      // Make sure close variants of doors are used\n      if (assetManager) {\n        var doors = this.findModelInstances(function(mi) {\n          return mi.model.isDoor() ;\n        });\n        //console.log('got doors', doors);\n        var doorsWithClosedVariants = _.filter(doors, function(mi) {\n          var capabilities = mi.queryCapabilities(assetManager);\n          //console.log('capabilities', mi);\n          var variants = capabilities.variants;\n          return variants && variants.closeable();\n        });\n        var initialDoorIds = [];\n        for (var i = 0; i < doorsWithClosedVariants.length; i++) {\n          initialDoorIds[i] = doorsWithClosedVariants[i].model.info.id;\n        }\n\n        async.each(doorsWithClosedVariants, function(door, cb) {\n            var capabilities = door.queryCapabilities(assetManager);\n            var variants = capabilities.variants;\n            variants.close(cb);\n          },\n          function(err){\n            var result = act();\n            // restore old variants\n            async.eachOf(doorsWithClosedVariants, function(door, i, cb) {\n              door.useModelVariant(assetManager, initialDoorIds[i], cb);\n            }, function(err) {\n              callback(null, result);\n            });\n          }\n        );\n      } else {\n        var result = act();\n        callback(null, result);\n      }\n    };\n\n    // Do something with ceiling (restore ceiling visibility afterwards)\n    SceneState.prototype.__doWithCeiling = function(act) {\n      // Make ceilings visible\n      var ceilings = Object3DUtil.findNodes(this.scene, function (node) {\n        return node.userData.type === 'Ceiling';\n      });\n      var ceilingsVisibility = [];\n      for (var i = 0; i < ceilings.length; i++) {\n        ceilingsVisibility[i] = ceilings[i].visible;\n        Object3DUtil.setVisible(ceilings[i], true);\n      }\n\n      var result = act();\n\n      // Restore ceiling visibility\n      for (var i = 0; i < ceilings.length; i++) {\n        Object3DUtil.setVisible(ceilings[i], ceilingsVisibility[i]);\n      }\n\n      return result;\n    };\n\n    /**\n     * Identifies the support hierarchy.  Makes sure doors are closed and ceiling is in place\n     * before computing attachments\n     * Note, this function is asynchronous.\n     * @param opts\n     * @param [opts.groupBySupport] {boolean}\n     * If true, a group is made for all objects with the same support node.\n     * A dummy node is used to group the children node and support node.\n     * @param [opts.attachToParent] {boolean}\n     * If true, children are attached directly to the support parent.\n     * If `opts.groupBySupport` is also set to `true`, this is only applied for parents that are model instances\n     * @param [opts.checkOpposites] {boolean}\n     * @param [opts.assetManager] {assets.AssetManager} Used to retrieve model variants such as closed doors\n     * @param [opts.aggregatedSceneStatistics] Precomputed aggregated scene statistics of likely relations.\n     * @param callback {function(error, Attachment[])}\n     */\n    SceneState.prototype.identifySupportHierarchy = function(opts, callback) {\n      console.time('identifySupportHierarchyAll');\n      var scope = this;\n      this.__doWithDoorsClosed(opts.assetManager, function() {\n        return scope.__doWithCeiling(function() {\n          return scope.__identifySupportHierarchy(opts);\n        });\n      }, function(err, res) {\n        console.timeEnd('identifySupportHierarchyAll');\n        callback(err, res);\n      });\n    };\n\n    SceneState.prototype.__identifySupportHierarchy = function(opts) {\n      console.time('identifySupportHierarchy');\n      var allCandidateSupportObjects = this.fullScene.supportObjects;\n      var attachments = [];\n      var candidates = [];\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var m = this.modelInstances[i];\n        if (!m) {\n          continue;\n        }\n        var candidateAttachments = this.identifyCandidateAttachments(m, allCandidateSupportObjects,\n          {\n            aggregatedSceneStatistics: opts.aggregatedSceneStatistics, includeCandidates: true,\n            keepSameLevel: true, disallowSameModelHorizontalAttachment: true, checkOpposites: opts.checkOpposites\n          });\n        if (candidateAttachments) {\n          attachments[i] = candidateAttachments.best;\n          candidates[i] = candidateAttachments.candidates;\n        }\n      }\n      var grouped = groupNodesByAttachmentChain(this.modelInstances, attachments);\n      breakAttachmentCycles(this.modelInstances, attachments, candidates, grouped.groups);\n      //console.log('attachments', attachments);\n      if (opts) {\n        this.__groupNodesByAttachment(attachments, grouped.indexToGroup, opts);\n      }\n      console.timeEnd('identifySupportHierarchy');\n      return attachments;\n    };\n\n    // Helper function for identifySupportHierarchy (groups nodes into attachment chains)\n    // @returns {groups: AttachmentChain[], indexToGroup:\n    function groupNodesByAttachmentChain(modelInstances, attachments) {\n      // Go through attachments and identify groups of modelInstances\n      var groups = [];\n      var indexToGroup = {};\n      for (var i = 0; i < modelInstances.length; i++) {\n        if (indexToGroup[i]) {\n          continue;\n        } // We have visited this index before\n        var m = modelInstances[i];\n        var attachment = attachments[i];\n        if (!attachment) {\n          continue;\n        } // No attachment, continue\n        // Follow parent until root or cycle\n        var p = attachment.parentInst;\n        var indices = [];\n        var nodes = [];\n        nodes.push(m);\n        indices.push(m.index);\n        var group = null;\n        while (p && indices.indexOf(p.index) < 0) {\n          group = indexToGroup[p.index];\n          if (group) {\n            // Merge with this group;\n            p = null;\n            break;\n          }\n          indices.push(p.index);\n          nodes.push(p);\n          if (attachments[p.index]) {\n            p = attachments[p.index].parentInst;\n          } else {\n            p = null;\n          }\n        }\n        if (group) {\n          group.nodes = group.nodes.concat(nodes);\n        } else {\n          group = {\n            nodes: nodes,\n            isCycle: !!p\n          };\n          if (p) {\n            group.cycleNode = p;\n          }\n          groups.push(group);\n        }\n        for (var j = 0; j < nodes.length; j++) {\n          var index = nodes[j].index;\n          indexToGroup[index] = group;\n        }\n      }\n      return { groups: groups, indexToGroup: indexToGroup };\n    }\n\n    function breakAttachmentCycles(modelInstances, attachments, candidates, groups) {\n\n      // Go through cycles and break cycles by marking one as parent of another\n      // If one object contains another, it should be support of other...\n      var cycles = groups.filter(function(x) { return x.isCycle; });\n      //console.log('groups', groups);\n      //console.log('cycles', cycles);\n\n      function getNodeSize(object3D, index) {\n        //return Object3DUtil.getBoundingBox(object3D).volume();\n        var faceDims = _.get(attachments[index], 'childAttachment.world.faceDims');\n        //console.log('got faceDims', faceDims, index);\n        return faceDims? faceDims.x * faceDims.y : 0;\n      }\n\n      function hasAncestor(attachment, indices, checkSelf) {\n        var visitedNodes = new Set();\n        if (checkSelf && attachment) {\n          if (indices.indexOf(attachment.child.index) >= 0) { return true; }\n        }\n        while (attachment && !visitedNodes.has(attachment)) {\n          visitedNodes.add(attachment);\n          var parentIndex = attachment.parent.index;\n          if (indices.indexOf(parentIndex) >= 0) { return true; }\n          attachment = attachments[parentIndex];\n        }\n        return false;\n      }\n\n      for (var i = 0; i < cycles.length; i++) {\n        var cycle = cycles[i];\n        if (!cycle.isCycle) continue;  // Skip if no longer a cycle\n        var cycleNode = cycle.cycleNode;\n        // Find the largest object in cycle and break the link between it and it's so called parent\n        var largest = cycleNode;\n        var largestSize = getNodeSize(cycleNode.object3D, largest.index);\n        var p = attachments[largest.index].parentInst;\n        while (p && p.index !== cycleNode.index) {\n          var pSize = getNodeSize(p.object3D, p.index);\n          if (pSize > largestSize) {\n            largest = p;\n            largestSize = pSize;\n          }\n          if (attachments[p.index]) {\n            p = attachments[p.index].parentInst;\n          } else {\n            largest = p;\n            largestSize = pSize;\n            console.log('no cycle, selecting', largest.object3D.userData.id);\n            break;\n          }\n        }\n        console.log('Breaking cycle: ', _.map(cycle.nodes, function(x) { return x.object3D.userData.id; }), largest.object3D.userData.id);\n        if (Constants.isBrowser) {\n          console.log('Breaking cycle: ', cycle, largest);\n        }\n        cycle.removedAttachment = attachments[largest.index];\n        cycle.wasCycle = cycle.isCycle;\n        cycle.isCycle = false;\n        attachments[largest.index] = null;\n        // See if there is better attachment for this node that doesn't create a cycle, if so add it\n        var cs = candidates[largest.index];\n        if (cs && cs.length) {\n          var descIndices = _.map(_.filter(modelInstances, function(m) {\n            return hasAncestor(attachments[m.index], [largest.index], true);\n          }), function(m) {\n            return m.index;\n          });\n          for (var j = 0; j < cs.length; j++) {\n            var c = cs[j];\n            var inGroup = _.some(cycle.nodes, function(x) { return x.index === c.parent.index; });\n            //console.log('inGroup', j, inGroup, c);\n            if (!inGroup) {\n              // do we need to check that no other cycles is created?\n              if (!hasAncestor(c, descIndices, true)) {\n                attachments[largest.index] = c;\n                console.log('Attaching former cyclic node ' + largest.object3D.userData.id + ' to ' + c.parent.userData.id);\n                //console.log('cycles', _.map(cycles, function(cyc) { return _.map(cyc.nodes, function(n) { return n.object3D.userData.id; })}));\n                break;\n              }\n            }\n          }\n        }\n      }\n      return cycles;\n    }\n\n    SceneState.prototype.groupNodesByAttachment = function(attachments, opts) {\n      var attachmentsForModelsInstances = [];\n      for (var i = 0; i < attachments.length; i++) {\n        var attachment = attachments[i];\n        if (attachment.childInst) {\n          var index = attachment.childInst.index;\n          if (attachmentsForModelsInstances[index]) {\n            console.warn('Object ' + attachment.child.userData.id + ' already has attachment');\n          } else {\n            attachmentsForModelsInstances[index] = attachment;\n          }\n        } else {\n          console.warn('Object ' + attachment.child.userData.id + ' is not a model instance');\n        }\n      }\n      var grouped = groupNodesByAttachmentChain(this.modelInstances, attachmentsForModelsInstances);\n      breakAttachmentCycles(this.modelInstances, attachmentsForModelsInstances, grouped.indexToGroup, grouped.groups);\n      this.__groupNodesByAttachment(attachmentsForModelsInstances, grouped.indexToGroup, opts);\n    };\n\n    SceneState.prototype.__groupNodesByAttachment = function(attachments, indexToGroup, opts) {\n      if (opts.groupBySupport) {\n        var parentToChildren = {};\n        for (var i = 0; i < this.modelInstances.length; i++) {\n          var m = this.modelInstances[i];\n          var attachment = attachments[i];\n          if (!attachment) { continue; }\n          if (indexToGroup) {\n            var group = indexToGroup[i];\n            if (group.isCycle) { continue; } // skip\n          }\n\n          var parentId = attachment.parent.uuid; // userData.id;\n          if (!parentToChildren.hasOwnProperty(parentId)) {\n            parentToChildren[parentId] = { parent: attachment.parent, parentInst: attachment.parentInst, children: [m] };\n          } else {\n            parentToChildren[parentId].children.push(m);\n          }\n        }\n        //console.log('parentToChildren', parentToChildren);\n        for (var parentId in parentToChildren) {\n          if (parentToChildren.hasOwnProperty(parentId)) {\n            var g = parentToChildren[parentId];\n            if (g.parentInst && opts.attachToParent) {\n              for (var i = 0; i < g.children.length; i++) {\n                Object3DUtil.attachToParent(g.children[i].object3D, g.parentInst.object3D, this.scene);\n              }\n            } else {\n              var region = new THREE.Group();\n              region.name = 'Region-' + g.parent.userData.id;\n              region.userData.type = 'SupportGroup';\n              region.userData.sceneHierarchyGroup = true;\n              this.addExtraObject(region);\n              var grandParent = g.parent.parent;\n              Object3DUtil.attachToParent(g.parent, region, this.scene);\n              Object3DUtil.attachToParent(region, grandParent, this.scene);\n\n              var region2 = new THREE.Group();\n              region2.name = 'Region-' + g.parent.userData.id + '-children';\n              region2.userData.type = 'SupportGroupChildren';\n              region2.userData.sceneHierarchyGroup = true;\n              this.addExtraObject(region2);\n              Object3DUtil.attachToParent(region2, region, this.scene);\n              for (var i = 0; i < g.children.length; i++) {\n                if (g.children[i].object3D.parent.userData.type === 'SupportGroup') {\n                  Object3DUtil.attachToParent(g.children[i].object3D.parent, region2, this.scene);\n                } else {\n                  Object3DUtil.attachToParent(g.children[i].object3D, region2, this.scene);\n                }\n              }\n            }\n          }\n        }\n      } else if (opts.attachToParent) {\n        for (var i = 0; i < this.modelInstances.length; i++) {\n          var m = this.modelInstances[i];\n          var attachment = attachments[i];\n          if (!attachment) { continue; }\n          if (indexToGroup) {\n            var group = indexToGroup[i];\n            if (group.isCycle) { continue; } // skip\n          }\n          var parentInst = attachment.parentInst;\n          if (parentInst) {\n            if (parentInst.object3D) {\n              //console.log('attachToParent', m.object3D, parentInst.object3D);\n              Object3DUtil.attachToParent(m.object3D, parentInst.object3D, this.scene);\n            } else {\n              console.warn('No object3D for parent instance', parentInst);\n            }\n          }\n        }\n      }\n    };\n\n    SceneState.prototype.__initHouseData = function() {\n      var regionsData = _.get(this.info, 'regions.data');\n      if (regionsData && this.info.regions.assetType === 'house') {\n        var house = regionsData;\n        house.name = this.info.fullId;\n        // TODO: update house.label\n        // house.label = ???\n        if (!house.object3D) {\n          house.createGeometry({ includeParts: { 'RegionShape': true, 'Surface': true,  'BBox': false, 'Object': false} });\n        }\n        Object3DUtil.setMatrix(house.object3D, this.scene.matrixWorld);\n        house.object3D.updateMatrixWorld();\n        this.house = house;\n      }\n    };\n\n    SceneState.prototype.finalizeScene = function () {\n      // Wrap scene since we will use the resulting scene and add camera and lights and stuff\n      //    which we want to be in a consistent world space\n      var wrappedScene = new THREE.Scene();\n      wrappedScene.name = \"fullScene\";\n      wrappedScene.add(this.scene);\n      this.extraObjectNode = new THREE.Group();\n      this.extraObjectNode.name = \"extraObjects\";\n      this.extraObjectNode.applyMatrix(this.scene.matrix);\n      this.debugNode = new THREE.Group();\n      this.debugNode.name = 'debugNode';\n      wrappedScene.add(this.extraObjectNode);\n      wrappedScene.add(this.debugNode);\n\n      if (this.info && this.info.rootObjectIndex != undefined) {\n        var modelInstance = this.modelInstances[this.info.rootObjectIndex];\n        if (modelInstance) {\n          //console.log('Got rootModelInstance', modelInstance);\n          //this.rootModelInstance = modelInstance;\n          this.info.up = modelInstance.model.getUp();\n          this.info.front = modelInstance.model.getFront();\n          this.info.unit = modelInstance.model.getUnit();\n        }\n      }\n\n      // Align and scale\n      this.alignToWorld();\n      // Rescale scene so we have proper mapping between virtual and physical units\n      var scale = this.getVirtualUnit();\n      Object3DUtil.rescaleObject3D(this.scene, scale);\n      this.fullScene = wrappedScene;\n      this.fullScene.updateMatrixWorld();\n      // Initialize any house information\n      this.__initHouseData();\n      // Initialize roomIndex\n      if (this.house) {\n        this.__roomIndex = new Index();\n        this.__roomIndex.add('unknown');\n        for (var i = 0; i < this.house.regions.length; i++) {\n          var region = this.house.regions[i];\n          this.__roomIndex.indexOf(region.object3D.userData.id, true, { room: region.object3D });\n        }\n      } else {\n        this.__roomIndex = this.computeRoomIndex();\n      }\n      // Make sure selectables and such are set\n      this.populateSelectables();\n      if (this.info && this.info.precomputeAttachments) {\n        this.identifyAttachments();\n      }\n      if (!this.sceneType && this.info) {\n        this.sceneType = (this.info.source === 'wssScenes')?\n          this.getWssRoomCategory() : this.getCategory();\n      }\n    };\n\n    SceneState.prototype.resetCoordFrame = function(up, front, unit) {\n      // NOTE: only use for empty scenes!\n      if (!this.info) {\n        this.info = {};\n      }\n      this.info.up = up;\n      this.info.front = front;\n      this.info.unit = unit;\n      this.alignToWorld();\n      var scale = this.getVirtualUnit();\n      Object3DUtil.rescaleObject3D(this.scene, scale);\n    };\n\n    SceneState.prototype.alignToWorld = function () {\n      var up = this.getUp();\n      var front = this.getFront();\n      //console.log('aligning scene to world: up=' + JSON.stringify(up) + ', front=' + JSON.stringify(front));\n      Object3DUtil.alignToUpFrontAxes(this.scene, up, front, Constants.worldUp, Constants.worldFront);\n      // Invalidate cached bbox\n      if (this.info) this.info.bbox = null;\n    };\n\n    SceneState.prototype.getUp = function () {\n      var defaultUp = AssetGroups.getDefaultUp(this.info, Constants.defaultSceneUp);\n      return this._getMetadataVector3('up', defaultUp);\n    };\n\n    SceneState.prototype.getFront = function () {\n      var defaultFront = AssetGroups.getDefaultFront(this.info, Constants.defaultSceneFront);\n      return this._getMetadataVector3('front', defaultFront);\n    };\n\n    SceneState.prototype.getUnit = function () {\n      var defaultUnit = AssetGroups.getDefaultUnit(this.info, Constants.defaultSceneUnit);\n      // Get stored unit (in meters)\n      var metadata = this._getMetadata();\n      if (metadata && metadata.unit) {\n        return metadata.unit;\n      } else {\n        return defaultUnit;\n      }\n    };\n\n    SceneState.prototype.getVirtualUnit = function () {\n      var unit = this.getUnit();\n      // Convert from stored physical unit to centimeters\n      unit = unit * Constants.metersToVirtualUnit;\n      return unit;\n    };\n\n    SceneState.prototype._getMetadataVector3 = function (field, defaultValue) {\n      var v = defaultValue;\n      var metadata = this._getMetadata();\n      if (metadata && metadata[field]) {\n        if (!(metadata[field] instanceof THREE.Vector3)) {\n          metadata[field] = Object3DUtil.toVector3(metadata[field]);\n        }\n        if (metadata[field]) {\n          v = metadata[field];\n        }\n      }\n      return v;\n    };\n\n    SceneState.prototype._getMetadata = function () {\n      if (this.info && this.info.metadata) {\n        return this.info.metadata;\n      } else if (this.json && this.json.scene) {\n        return this.json.scene;\n      } else if (this.info) {\n        return this.info;\n      }\n    };\n\n    SceneState.prototype.hasCategory = function (cat) {\n      return this.info && this.info.category && this.info.category.indexOf(cat) >= 0;\n    };\n\n    SceneState.prototype.getCategory = function () {\n      if (this.info && this.info.category && this.info.category.length > 0) {\n        return this.info.category[0];\n      } else { return null; }\n    };\n\n    SceneState.prototype.getWssRoomCategory = function() {\n      var roomTypes = [\"LivingRoom\", \"Bathroom\", \"LaundryRoom\", \"Bedroom\", \"Kitchen\", \"Study\", \"Laboratory\" ];\n      var categoryToRoomType = {\n        \"EntertainmentCenterWithSofa\": \"LivingRoom\",\n        \"EntertainmentCenter\": \"LivingRoom\",\n        \"CoffeeTable\": \"LivingRoom\",\n        \"LivingRoomTable\": \"LivingRoom\",\n        \"Bed\": \"Bedroom\",\n        \"NightStand\": \"Bedroom\",\n        \"Dresser\": \"Bedroom\",\n        \"Desk\": \"Study\",\n        \"KitchenCounter\": \"Kitchen\",\n        \"DiningTable\": \"Kitchen\",\n        \"Bookshelf\": \"Room\"\n      };\n      if (this.info && this.info.category && this.info.category.length > 0) {\n        for (var i = 0; i < this.info.category.length; i++) {\n          var cat = this.info.category[i];\n          var roomType = categoryToRoomType[cat];\n          if (roomType) return roomType;\n          if (roomTypes.indexOf(cat) >= 0) return cat;\n        }\n      }\n      return null;\n    };\n\n    SceneState.prototype.findNodeById = function(id) {\n      return this.findNode(function(x) { return x.userData.id === id; });\n    };\n\n    SceneState.prototype.findNode = function(filter, visibleOnly) {\n      var nodes = Object3DUtil.findNodes(this.scene, filter, visibleOnly);\n      if (nodes.length > 0) { return nodes[0]; }\n    };\n\n    SceneState.prototype.findNodes = function(filter, visibleOnly) {\n      return Object3DUtil.findNodes(this.scene, filter, visibleOnly);\n    };\n\n    SceneState.prototype.getFullID = function () {\n      if (this.info) {\n        return this.info.fullId;\n      }\n    };\n\n    SceneState.prototype.getSceneName = function() {\n      return this.scene.name;\n    };\n\n    SceneState.prototype.getBBox = function () {\n      if (!this.info.bbox) {\n        this.info.bbox = Object3DUtil.getBoundingBox(this.scene);\n      }\n      return this.info.bbox;\n    };\n\n    SceneState.prototype.getBBoxDims = function () {\n      return Object3DUtil.getBoundingBoxDims(this.scene, this.getBBox());\n    };\n\n    SceneState.prototype.findModelInstances = function (match) {\n      if (!match) {\n        return this.modelInstances;\n      }\n      if (_.isString(match)) {\n        var modelId = match;\n        match = function (mi) { return mi.model.getFullID() === modelId; };\n      }\n      // Find model instances in scene matching filter\n      return _.filter(this.modelInstances, match);\n    };\n\n    SceneState.prototype.createModelIdToInstanceMap = function () {\n      // Find model instances in scene matching modelId\n      var map = {};\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        if (modelInstance && modelInstance.model) {\n          var modelId = modelInstance.model.getFullID();\n          var list = map[modelId];\n          if (!list) {\n            list = [];\n            map[modelId] = list;\n          }\n          modelInstance.modelInstanceId = modelId + '#' + list.length;\n          list.push(modelInstance);\n        }\n      }\n      return map;\n    };\n\n    SceneState.prototype.assignObjectIndices = function () {\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        if (modelInstance) {\n          modelInstance.index = i;\n          modelInstance.object3D.index = i;\n          modelInstance.object3D.userData['objectIndex'] = i;\n        }\n      }\n    };\n\n    /**\n     * Removes all objects from this scene\n     */\n    SceneState.prototype.removeAll = function () {\n      // Explicitly remove objects since some objects are attached to the extraObjects (not the scene)\n      var indices = _.range(0, this.modelInstances.length);\n      this.removeObjects(indices);\n      // Clear everything\n      this.selectedObjects = [];\n      this.modelInstancesMeta = [];\n      this.modelInstances = [];\n      this.modelInstancesErrors = 0;\n      this.modelInstancesLoaded = 0;\n      this.rootModelInstance = null;\n\n      // Remove extra objects\n      Object3DUtil.removeAllChildren(this.extraObjectNode);\n      this.extraObjects = [];\n      // Make sure everything is removed from scene\n      Object3DUtil.removeAllChildren(this.scene);\n      this.compactify();\n    };\n\n    /**\n     * Remove selected objects from this scene\n     * @returns {model.ModelInstance[]} List of model instances that were removed\n     */\n    SceneState.prototype.removeSelected = function () {\n      var selectedIndices = this.getSelectedModelIndices();\n      var removed = this.removeObjects(selectedIndices, true);\n      this.selectedObjects = [];\n      return removed;\n    };\n\n    /**\n     * Removes objects from the scene.  Selected objects are automatically updated to not include removed objects\n     * unless `skipSelectedUpdated` is true.\n     * @param indices {int[]} Indices of model instances to remove\n     * @param skipSelectedUpdate {boolean} Whether to skip updating of selected objecs.\n     * @returns {model.ModelInstance[]} List of removed model instances\n     */\n    SceneState.prototype.removeObjects = function (indices, skipSelectedUpdate) {\n      var removedIndicesSet = {};\n      for (var i = 0; i < indices.length; i++) {\n        var index = indices[i];\n        var modelInstance = this.modelInstances[index];\n        // Keep track of children that were also removed...\n        removedIndicesSet[index] = 1;\n        if (modelInstance) {\n          if (modelInstance.object3D.parent) {\n            modelInstance.object3D.parent.remove(modelInstance.object3D);\n          }\n          /*jshint -W083 */\n          Object3DUtil.traverseModelInstances(modelInstance, function (m) {\n            removedIndicesSet[m.index] = 1;\n          });\n        }\n      }\n      var removed = [];\n      for (var index in removedIndicesSet) {\n        if (removedIndicesSet.hasOwnProperty(index)) {\n          var modelInstance = this.modelInstances[index];\n          this.modelInstances[index] = null;\n          removed.push(modelInstance);\n        }\n      }\n      if (!skipSelectedUpdate) {\n        var newSelected = [];\n        for (var i = 0; i < this.selectedObjects; i++) {\n          var s = this.selectedObjects[i];\n          if (removed.indexOf(s) < 0) {\n            newSelected.push(s);\n          }\n        }\n        this.selectedObjects = newSelected;\n      }\n      this.compactify();\n      return removed;\n    };\n\n    /**\n     * Add a modelInstance to the SceneState\n     * @param modelInstance {model.ModelInstance} Model instance to add\n     * @param [keepWorldTransform=false] {boolean} Whether to keep world transform of the object when adding the object to the scene or not\n     */\n    SceneState.prototype.addObject = function (modelInstance, keepWorldTransform) {\n      this.modelInstances.push(modelInstance);\n      if (keepWorldTransform) {\n        Object3DUtil.attachToParent(modelInstance.object3D, this.scene);\n      } else {\n        this.scene.add(modelInstance.object3D);\n      }\n      Object3DUtil.clearCache(this.scene);\n\n      this.setObjectFlags(modelInstance);\n      this._addObject3DToFullScene(modelInstance.object3D);\n    };\n\n    SceneState.prototype.pasteObject = function (rootObject, modelInstances) {\n      Object3DUtil.attachToParent(rootObject, this.scene);\n      for (var i = 0; i < modelInstances.length; i++) {\n        var modelInstance = modelInstances[i];\n        this.modelInstances.push(modelInstance);\n\n        //this.setObjectFlags(modelInstance);\n        this._addObject3DToFullScene(modelInstance.object3D);\n      }\n      this.assignObjectIndices();\n      //Object3DUtil.clearCache(this.scene);\n    };\n\n    SceneState.prototype.setObjectFlags = function (modelInstance) {\n      if (modelInstance) {\n        if (modelInstance.model.isScan()) {  // Don't allow selection for reconstructed scenes\n          // Make semi transparent\n          //Object3DUtil.setTransparency(modelInstance.object3D, 0.5);\n          // Set depthWrite to false so the other objects always appear on top\n          //Object3DUtil.setDepthWrite(modelInstance.object3D, false);\n          // Make the object not pickable, selectable, and not a support object\n          modelInstance.object3D.userData.isPickable = modelInstance.object3D.userData.isPickable ||false;\n          modelInstance.object3D.userData.isSelectable = modelInstance.object3D.userData.isSelectable || false;\n          modelInstance.object3D.userData.isEditable = modelInstance.object3D.userData.isSelectable;\n          modelInstance.object3D.userData.isSupportObject = modelInstance.object3D.userData.isSupportObject || false;\n          // Set the current scene type to be the category of the vf model\n          this.rootModelInstance = modelInstance;\n          this.sceneType = modelInstance.model.getCategory();\n        } else {\n          modelInstance.object3D.userData.isPickable = true;\n          // TODO: check if object3D.userData.isRoot (to be set when loading) is true and make not selectable if isRoot\n          modelInstance.object3D.userData.isSelectable = !modelInstance.model.hasCategory('Room') && !modelInstance.model.hasCategory('Courtyard');\n          modelInstance.object3D.userData.isEditable = modelInstance.object3D.userData.isSelectable;\n          modelInstance.object3D.userData.isSupportObject = true;\n        }\n      }\n    };\n\n    SceneState.prototype.clearGhostScene = function () {\n      if (this.ghostScene) {\n        this.fullScene.remove(this.ghostScene);\n      }\n      this.ghostScene = undefined;\n    };\n\n    SceneState.prototype.showGhostScene = function (flag) {\n      if (this.ghostScene) {\n        Object3DUtil.setVisible(this.scene, !flag);\n        Object3DUtil.setVisible(this.ghostScene, flag);\n      }\n    };\n\n    SceneState.prototype.hideObjectSegmentation = function (opts) {\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        // Remove segments\n        if (modelInstance.segments) {\n          modelInstance.object3D.remove(modelInstance.segments);\n        }\n      }\n    };\n\n    SceneState.prototype.showObjectSegmentation = function (opts) {\n      function applyMaterial(object3D) {\n        var segmentName = opts.segmentName;\n        var getMaterialFn = function(object3D, material, meshIndex) {\n          if (segmentName === 'materials') {\n            return opts.getMaterial(object3D, { material: material, partIndex: material.id });\n          } else if (segmentName === 'meshes' || segmentName === 'surfaces') {\n            return opts.getMaterial(object3D, { material: material, partIndex: meshIndex });\n          } else {\n            return opts.getMaterial(object3D, { material: material, partIndex: 0 });\n          }\n        };\n        var getMeshMaterial = function(mesh) {\n          if (Array.isArray(mesh.material)) {\n            var materials = mesh.material.map(function (m) {\n              return getMaterialFn(object3D, m, mesh.index);\n            });\n            return new THREE.MultiMaterial(materials);\n          } else if (mesh.material instanceof THREE.MultiMaterial) {\n            var materials = mesh.material.materials.map(function(m) {\n              return getMaterialFn(object3D, m, mesh.index);\n            });\n            return new THREE.MultiMaterial(materials);\n          } else {\n            return getMaterialFn(object3D, mesh.material, mesh.index);\n          }\n        };\n        opts.applyMaterial(object3D, getMeshMaterial);\n      }\n\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        var segmentationData = modelInstance.model.segmentations? modelInstance.model.segmentations[opts.segmentType] : null;\n        if (segmentationData && segmentationData.data) {\n          // Remove segments\n          if (modelInstance.segments) {\n            modelInstance.object3D.remove(modelInstance.segments);\n          }\n          modelInstance.segments = segmentationData.getSegments(\n            {segmentName: opts.segmentName, useOriginalMaterial: opts.useOriginalMaterial,\n              getMaterial: opts.getMaterial, object3D: modelInstance.object3D}\n          );\n          opts.applyMaterial(modelInstance.object3D, Object3DUtil.InvisibleMat);\n          Object3DUtil.attachToParent(modelInstance.segments, modelInstance.object3D, this.scene);\n        } else {\n          applyMaterial(modelInstance.object3D);\n        }\n      }\n\n      for (var i = 0; i < this.extraObjects.length; i++) {\n        var object3D = this.extraObjects[i];\n        applyMaterial(object3D);\n      }\n    };\n\n    SceneState.prototype.createGhostSceneWithSegmentation = function (opts) {\n      // Clone the current scene\n      this.clearGhostScene();\n      this.ghostScene = new THREE.Object3D();\n      this.fullScene.add(this.ghostScene);\n\n      var segmentName = opts.segmentName;\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        modelInstance.segments = modelInstance.model.segmentation.getSegments(\n          {segmentName: opts.segmentName, getMaterial: opts.getMaterial, object3D: modelInstance.object3D}\n        );\n        Object3DUtil.attachToParent(modelInstance.segments, this.ghostScene, this.fullScene);\n      }\n      for (var i = 0; i < this.extraObjects.length; i++) {\n        var object3D = this.extraObjects[i];\n        var segmented = object3D.clone();\n        segmented.name = object3D.name + '-segmented';\n        _.merge(segmented.userData, object3D.userData, { segmentType: opts.segmentType, segmentName: opts.segmentName });\n        Object3DUtil.traverseMeshes(segmented, false, function(mesh) {\n          if (segmentName === 'materials') {\n            Object3DUtil.applyMaterial(segmented, opts.getMaterial(object3D, mesh.index));\n          } else if (segmentName === 'meshes' || segmentName === 'surfaces') {\n            Object3DUtil.applyMaterial(segmented, opts.getMaterial(object3D, mesh.index));\n          } else {\n            Object3DUtil.applyMaterial(segmented, opts.getMaterial(object3D, 0));\n          }\n        });\n        object3D.updateMatrixWorld();\n        Object3DUtil.setMatrix(segmented, object3D.matrixWorld);\n        Object3DUtil.attachToParent(segmented, this.ghostScene, this.fullScene);\n      }\n      Object3DUtil.setVisible(this.scene, false);\n      Object3DUtil.setVisible(this.ghostScene, true);\n    };\n\n    SceneState.prototype.createGhostSceneWithParts = function (objectParts) {\n      // Clone the current scene\n      console.log('Got ' + objectParts.length + ' parts');\n      //console.log(objectParts);\n      this.clearGhostScene();\n      this.ghostScene = new THREE.Object3D();\n      var clone = this.scene.clone();\n      //Object3DUtil.copyModelInstancesOfChildren(this.scene, clone);\n      this.ghostScene.add(clone);\n      this.fullScene.add(this.ghostScene);\n      Object3DUtil.setMaterial(this.ghostScene, Object3DUtil.ClearMat);\n      // go over the scene and highlight the object parts\n      var indexedObjects = Object3DUtil.getIndexedObject3Ds(this.ghostScene);\n      // console.log(indexedObjects);\n      for (var iPart = 0; iPart < objectParts.length; iPart++) {\n        var objPart = objectParts[iPart];\n        var index = objPart['objectIndex'];\n        var obj = indexedObjects[index];\n        if (obj && objPart.segment && objPart.segment.length) {\n          var color;\n          if (objPart.attribute) {\n            for (var i = 0; i < objPart.attribute.length; i++) {\n              var attr = objPart.attribute[i];\n              if (attr.name === 'color') {\n                color = Object3DUtil.getColor(attr.value);\n                break;\n              }\n            }\n          }\n          var mat = Object3DUtil.getSimpleFalseColorMaterial(iPart, color);\n          var segments = Object3DUtil.remeshObject(obj, objPart.segment);\n          Object3DUtil.setMaterial(segments, mat);\n          this.ghostScene.add(segments);\n        }\n      }\n      Object3DUtil.setVisible(this.scene, false);\n      Object3DUtil.setVisible(this.ghostScene, true);\n    };\n\n    SceneState.prototype.compactify = function () {\n      // Re-order models so our array of model instances doesn't have any gaps\n      var newModelInstances = [];\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        if (modelInstance) {\n          newModelInstances.push(modelInstance);\n        }\n      }\n      this.modelInstances = newModelInstances;\n      this.assignObjectIndices();\n      this.populateSelectables();\n    };\n\n    // Private helper function to addObject3D\n    SceneState.prototype._addObject3DToFullScene = function (obj) {\n      if (obj.userData.isPickable !== false) {\n        this.fullScene.pickables.push(obj);\n      }\n      if (obj.userData.isSelectable !== false) {\n        this.fullScene.selectables.push(obj);\n      }\n      if (obj.userData.isEditable !== false) {\n        this.fullScene.editables.push(obj);\n      }\n      if (obj.userData.isSupportObject !== false) {\n        this.fullScene.supportObjects.push(obj);\n      }\n      this.__onObjectAdded(obj);\n    };\n\n    SceneState.prototype._removeObject3DFromFullScene = function (obj) {\n      if (obj.userData.isPickable !== false) {\n        _.pull(this.fullScene.pickables, obj);\n      }\n      if (obj.userData.isSelectable !== false) {\n        _.pull(this.fullScene.selectables, obj);\n      }\n      if (obj.userData.isEditable !== false) {\n        _.pull(this.fullScene.editables, obj);\n      }\n      if (obj.userData.isSupportObject !== false) {\n        _.pull(this.fullScene.supportObjects, obj);\n      }\n      this.__onObjectRemoved(obj);\n    };\n\n    SceneState.prototype.addExtraObject = function (obj, keepParent) {\n      // Extra objects\n      if (!keepParent) {\n        var matInv = new THREE.Matrix4();\n        matInv.getInverse(this.extraObjectNode.matrix);\n        obj.applyMatrix(matInv);\n        this.extraObjectNode.add(obj);\n      }\n      this.extraObjects.push(obj);\n      this._addObject3DToFullScene(obj);\n    };\n\n    SceneState.prototype.removeExtraObject = function (obj) {\n      if (obj.parent) {\n        obj.parent.remove(obj);\n      }\n      _.pull(this.extraObjects, obj);\n      this._removeObject3DFromFullScene(obj);\n    };\n\n    SceneState.prototype.populateSelectables = function () {\n      var objects = this.modelInstances.map(function (m) { return m.object3D; });\n      this.fullScene.pickables = objects.filter(\n        function (o) { return o && o.userData.isPickable !== false; }\n      );\n\n      this.fullScene.selectables = objects.filter(\n        function (o) { return o && o.userData.isSelectable !== false; }\n      );\n\n      this.fullScene.editables = objects.filter(\n        function (o) { return o && o.userData.isEditable !== false; }\n      );\n\n      this.fullScene.supportObjects = objects.filter(\n        function (o) { return o && o.userData.isSupportObject !== false; }\n      );\n\n      this.extraObjects.forEach(this._addObject3DToFullScene.bind(this));\n    };\n\n    SceneState.prototype.setCurrentCamera = function (camera) {\n      this.currentCamera = camera;\n    };\n\n    SceneState.prototype.setCurrentCameraControls = function (cameraControls, setCameraTo) {\n      this.currentCameraControls = cameraControls;\n      return this.applyCameraState(setCameraTo);\n    };\n\n    SceneState.prototype.applyCameraState = function (setCameraTo) {\n      if (setCameraTo) {\n        var currentCam = this.getCameraJson(this.json, setCameraTo);\n        if (currentCam && this.currentCameraControls) {\n          var sceneToWorld = this.getSceneToWorldMatrix();\n          // Convert to world orientation\n          var scale = this.getVirtualUnit();\n          currentCam = this.transformCameraState(currentCam, sceneToWorld, scale);\n          this.currentCameraControls.restoreCameraState(currentCam);\n          return true;\n        }\n      }\n    };\n\n    SceneState.prototype.convertCameraConfig = function (cameraConfig) {\n      var sceneToWorld = this.getSceneToWorldMatrix();\n      // Convert to world orientation\n      var scale = this.getVirtualUnit();\n      console.log('scale', scale);\n      cameraConfig = this.transformCameraState(cameraConfig, sceneToWorld, scale);\n      return cameraConfig;\n    };\n\n    SceneState.prototype.updateState = function (json) {\n      // Set selected models\n      this.json = json;\n      if (json.selected) {\n        this.selectedObjects = json.selected.map(function (selection) {\n          var i = selection.objectIndex;\n          console.log('is selected: ' + i);\n          this.modelInstances[i].object3D.userData.isSelected = true;\n          return this.modelInstances[i].object3D;\n        }.bind(this));\n      }\n      // Set current camera\n      this.applyCameraState('current');\n    };\n\n    SceneState.prototype.getCameraJson = function (json, name) {\n      if (json && json.scene && json.scene.camera) {\n        var cameras = json.scene.camera;\n        for (var ci = 0; ci < cameras.length; ci++) {\n          var cf = cameras[ci];\n          if (cf.name === name) {\n            return cf;\n          }\n        }\n      }\n    };\n\n    SceneState.prototype.getCoordinateFrameJson = function (json, name) {\n      if (json && json.scene && json.scene.coordinateFrame) {\n        var coordinateFrames = json.scene.coordinateFrame;\n        for (var ci = 0; ci < coordinateFrames.length; ci++) {\n          var cf = coordinateFrames[ci];\n          if (cf.frameType === name) {\n            return cf;\n          }\n        }\n      }\n    };\n\n    SceneState.prototype.setObjectWorldMatrix = function (modelIndex, parentIndex, worldMatrix) {\n      var modelInstance = this.modelInstances[modelIndex];\n      var object3D = modelInstance.object3D;\n      var parent = (parentIndex >= 0) ? this.modelInstances[parentIndex].object3D : this.scene;\n      Object3DUtil.detachFromParent(object3D, this.fullScene);\n      object3D.position.set(0,0,0);\n      object3D.rotation.set(0,0,0);\n      object3D.scale.set(1,1,1);\n      object3D.updateMatrix();\n      object3D.applyMatrix(worldMatrix);\n      object3D.matrixWorldNeedsUpdate = true;\n      Object3DUtil.attachToParent(object3D, parent);\n    };\n\n    SceneState.prototype.getSelectedModelIndices = function () {\n      // Assign indices\n      this.assignObjectIndices();\n      var sceneSelections = this.selectedObjects.map(function (x) {\n        var modelInstance = Object3DUtil.getModelInstance(x);\n        return modelInstance? modelInstance.index : -1;\n      }).filter(function(x) { return x >= 0;});\n      return sceneSelections;\n    };\n\n    SceneState.prototype.getWorldToSceneMatrix = function () {\n      return Object3DUtil.getAlignmentMatrix(Constants.worldUp, Constants.worldFront, this.getUp(), this.getFront());\n    };\n\n    SceneState.prototype.getSceneToWorldMatrix = function () {\n      return Object3DUtil.getAlignmentMatrix(this.getUp(), this.getFront(), Constants.worldUp, Constants.worldFront);\n    };\n\n    SceneState.prototype.transformCameraState = function (camState, matrix, scale) {\n      //TODO(MS): Account for direction vs position vector transformation\n      // Takes camera state using matrix\n      var fields = ['up', 'position', 'target', 'direction'];\n      var transformedCamState = {};\n      for (var i = 0; i < fields.length; i++) {\n        var field = fields[i];\n        var fieldValue = camState[field];\n        if (fieldValue) {\n          transformedCamState[field] = new THREE.Vector3();\n          if (fieldValue instanceof Array) {\n            transformedCamState[field].set(fieldValue[0], fieldValue[1], fieldValue[2]);\n          } else {\n            transformedCamState[field].copy(fieldValue);\n          }\n          transformedCamState[field].applyMatrix4(matrix);\n          if (field === 'position' || field === 'target') {\n            // also apply scale\n            transformedCamState[field].multiplyScalar(scale);\n          }\n        }\n      }\n      var scaleFields = ['left','right','bottom','top','near','far'];\n      for (var i = 0; i < scaleFields.length; i++) {\n        var field = scaleFields[i];\n        var fieldValue = camState[field];\n        if (fieldValue) {\n          transformedCamState[field] = fieldValue*scale;\n        }\n      }\n      for (var prop in camState) {\n        if (camState.hasOwnProperty(prop) && !transformedCamState[prop]) {\n          transformedCamState[prop] = camState[prop];\n        }\n      }\n      return transformedCamState;\n    };\n\n    SceneState.prototype.__getMatchingRegions = function(object3D, rtype, level) {\n      var rooms = [];\n      object3D.traverse(function (node) {\n        if (node instanceof THREE.Group && node.userData.type === rtype) {\n          // check that this room belongs to the specified level (do type compatible check)\n          if (level == undefined || node.userData.level == level) {\n            rooms.push(node);\n          }\n        }\n      });\n      return rooms;\n    };\n\n    SceneState.prototype.getGrounds = function (level, filter) {\n      if (level != null && _.isNumber(level)) {\n        var levels = this.getLevels();\n        level = levels[level];\n      }\n      // Try to get cached grounds\n      var grounds = level? level.__grounds : this.__grounds;\n      if (!grounds) {\n        if (level instanceof THREE.Object3D) {\n          grounds = this.__getMatchingRegions(level, 'Ground');\n        } else {\n          grounds = this.__getMatchingRegions(this.scene, 'Ground', level);\n        }\n        if (level) {\n          level.__grounds = grounds;\n        } else {\n          this.__grounds = grounds;\n        }\n      }\n      if (filter) {\n        grounds = _.filter(grounds, filter);\n      }\n      return grounds;\n    };\n\n    SceneState.prototype.getRooms = function (level) {\n      if (level instanceof THREE.Object3D) {\n        return this.__getMatchingRegions(level, 'Room');\n      } else {\n        return this.__getMatchingRegions(this.scene, 'Room', level);\n      }\n    };\n\n    SceneState.prototype.getHouseRegions = function(level) {\n      var rooms = [];\n      if (level instanceof THREE.Object3D) {\n        rooms = this.__getMatchingRegions(level, 'Region');\n      } else if (this.house && this.house.object3D) {\n        rooms = this.__getMatchingRegions(this.house.object3D, 'Region', level);\n      }\n      return rooms;\n    };\n\n    SceneState.prototype.getRoomsOrHouseRegions = function (level, filter) {\n      if (level != null && _.isNumber(level)) {\n        var levels = this.getLevels();\n        level = levels[level];\n      }\n      // Try to get cached roomsOrHouseRegions\n      var rooms = level? level.__roomsOrHouseRegions : this.__roomsOrHouseRegions;\n      if (!rooms) {\n        rooms = this.getRooms(level);\n        if (rooms.length === 0) {\n          rooms = this.getHouseRegions(level);\n        }\n        if (level) {\n          level.__roomsOrHouseRegions = rooms;\n        } else {\n          this.__roomsOrHouseRegions = rooms;\n        }\n      }\n      if (filter) {\n        rooms = _.filter(rooms, filter);\n      }\n      return rooms;\n    };\n\n    SceneState.prototype.getRoomInfo = function (room) {\n      if (!room) {\n        return { id: '', roomType: '' };\n      }\n      var roomType = room.userData.roomType || room.userData.regionType || [];\n      if (_.isArray(roomType)) {\n        if (roomType.length) {\n          roomType = roomType[0];  // Hackishly pick first roomType only\n        } else if (roomType.length === 0 && room.userData.origRoomType) {  // Use origRoomType if roomType empty\n          roomType = room.userData.origRoomType;\n        } else {\n          roomType = '';\n        }\n      }\n      return { id: room.userData.id, roomType: roomType };\n    };\n\n    SceneState.prototype.__getLevels = function (object3D) {\n      var levels = [];\n      object3D.traverse(function (node) {\n        if (node instanceof THREE.Group && node.userData.type === 'Level' && node.children.length > 0) {\n          levels.push(node);\n        }\n      });\n      levels.sort(function (x) { return x.userData.id; });\n      return levels;\n    };\n\n    SceneState.prototype.getLevels = function() {\n      var levels = this.__getLevels(this.scene);\n      if (!levels.length && this.house && this.house.object3D) {\n        levels = this.__getLevels(this.house.object3D);\n      }\n      if (!levels.length) {\n        levels = [this.scene]; // No real levels, return whole scene as one level\n      }\n      return levels;\n    };\n\n    SceneState.prototype.getLevelByIndex = function(index) {\n      var levels = this.getLevels();\n      return levels[index];\n    };\n\n    SceneState.prototype.getSelectedObjects = function() {\n      return this.selectedObjects;\n    };\n\n    SceneState.prototype.getSceneJson = function () {\n      if (this.json && this.json.scene) {\n        return this.json.scene;\n      }\n    };\n\n    SceneState.prototype.getSceneTemplate = function () {\n      if (this.json && this.json.scene && this.json.scene.template) {\n        return this.json.scene.template;\n      }\n    };\n\n    SceneState.prototype.toJsonString = function () {\n      var json = this.toJson();\n      return JSON.stringify(json);\n    };\n\n    SceneState.prototype.toJson = function (includeUserData) {\n      // Assign indices\n      this.assignObjectIndices();\n      // Populate a scene state\n      var sceneObjects = [];\n      var sceneTransformMatrixInverse = new THREE.Matrix4();\n      sceneTransformMatrixInverse.getInverse(this.scene.matrixWorld);\n      var assetSources = [];\n      for (var i = 0; i < this.modelInstances.length; i++) {\n        var modelInstance = this.modelInstances[i];\n        var modelObject = modelInstance.getObject3D('Model');\n        modelObject.updateMatrixWorld();\n        var transformMatrix = new THREE.Matrix4();\n        transformMatrix.multiplyMatrices(sceneTransformMatrixInverse, modelObject.matrixWorld);\n        var transform = Object3DUtil.matrix4ToProto(transformMatrix);\n        var parentIndex = (modelInstance.object3D.parent) ? modelInstance.object3D.parent.index : -1;\n        if (parentIndex === undefined || parentIndex === null) {\n          parentIndex = -1;\n        }\n        var sceneObject = {\n          modelId: modelInstance.model.getFullID(),\n          index: modelInstance.object3D.index,\n          parentIndex: parentIndex,\n          transform: transform\n          //          objectDescIndex: -1\n        };\n        var modelSource = modelInstance.model.getAssetSource();\n        if (modelSource != null && assetSources.indexOf(modelSource) < 0) {\n          assetSources.push(modelSource);\n        }\n        if (includeUserData) {\n          sceneObject.userData = modelInstance.object3D.userData;\n        }\n        sceneObjects.push(sceneObject);\n      }\n\n      var scene = {\n        up: this.getUp(),\n        front: this.getFront(),\n        unit: this.getUnit(),\n        assetSource: assetSources,\n        object: sceneObjects\n      };\n\n      // TODO: Save extraObjects\n      var includeExtraObjects = true;\n      if (includeExtraObjects && this.extraObjects.length > 0) {\n        // Get objects (but exclude modelInstances and references to other objects)\n      }\n      // NOTE: this field added July 13, 2015-- sceneStates prior to this do not contain this\n      // NOTE: This is not handled by the text2scene backend\n      // if (this.wrappedThreeObjects.length) {\n      //   scene['wrappedThreeObjects'] = this.wrappedThreeObjects.map(function (x) {\n      //     return x.toJson();\n      //   });\n      // }\n\n      var sceneId = this.getFullID();\n      if (sceneId) {\n        scene.sceneId = sceneId;\n      }\n      if (this.currentCameraControls) {\n        // Set viewer coordinate frame\n        var currentCameraState = this.currentCameraControls.getCurrentCameraState();\n        // Convert to scene orientation\n        var worldToScene = this.getWorldToSceneMatrix();\n        var scale = 1.0 / this.getVirtualUnit();\n        currentCameraState = this.transformCameraState(currentCameraState, worldToScene, scale);\n        currentCameraState['name'] = 'current';\n        // Let the Babysherlock set the viewer coordinate frame from the current camera state\n        // Also set the scene cameras\n        scene['camera'] = [currentCameraState];\n      }\n\n      var selectedIndices = this.getSelectedModelIndices();\n      var sceneSelections = selectedIndices.map(function (index) {\n        var selection = {\n          objectIndex: index\n        };\n        return selection;\n      });\n\n      var ss = {\n        format: 'sceneState',\n        scene: scene,\n        selected: sceneSelections\n      };\n      return ss;\n    };\n\n    SceneState.prototype.changeTexture = function(materialIndex, mi, texture) {\n      // Updates material with new texture\n      this.changeMaterial(materialIndex, mi, { map: texture });\n    };\n\n    SceneState.prototype.changeMaterial = function(materialIndex, mi, materialChanges) {\n      // Updates material with new material\n      var metadata = materialIndex.metadata(mi);\n      if (metadata && metadata.materials) {\n        for (var i = 0; i < metadata.materials.length; i++) {\n          var m = metadata.materials[i].m;\n          if (m) {\n            _.merge(m, materialChanges);\n          }\n        }\n      }\n    };\n\n    SceneState.prototype.getObject3Ds = function() {\n      var modelInstances = Object3DUtil.findModelInstances(this.scene);\n      var object3Ds = _.map(modelInstances, function (mInst) {\n        return mInst.object3D;\n      });\n      return object3Ds.concat(this.extraObjects);\n    };\n\n    SceneState.prototype.getModelObject3Ds = function() {\n      var modelInstances = Object3DUtil.findModelInstances(this.scene);\n      var object3Ds = _.map(modelInstances, function (mInst) {\n        return mInst.object3D;\n      });\n      return object3Ds;\n    };\n\n    SceneState.prototype.getWalls = function() {\n      return _.filter(this.extraObjects, function(x) { return x.userData.type === 'Wall'; });\n    };\n\n    SceneState.prototype.populateMeshUserData = function(fieldName, objectIndex) {\n      var object3Ds = this.getObject3Ds();\n      for (var i = 0; i < object3Ds.length; i++) {\n        var object3D = object3Ds[i];\n        var index = objectIndex.indexOf(object3D.userData.id);\n        Object3DUtil.traverseMeshes(object3D, true, function(x) {\n          x.userData[fieldName] = index;\n        });\n      }\n    };\n\n    SceneState.prototype.computeObjectIndex = function() {\n      var objectIndex = new Index();\n      objectIndex.add('unknown');\n      var object3Ds = this.getObject3Ds();\n      var sorted = _.sortBy(object3Ds, function(object3D) {\n        var id = object3D.userData.id;\n        var parts = id.split('_');\n        parts[0] = parseInt(parts[0]);\n        parts[1] = parts.length >= 2? parseInt(parts[1]) : -1;\n        parts[2] = parts.length >= 3? parseInt(parts[2]) : -1;\n        return parts;\n      });\n      for (var i = 0; i < sorted.length; i++) {\n        var object3D = sorted[i];\n        var modelInstance = Object3DUtil.getModelInstance(object3D);\n        var objectCategory = modelInstance? modelInstance.model.getCategory() : (object3D.userData.type || object3D.name);\n        var metadata = {\n          modelId: modelInstance? modelInstance.model.getFullID() : undefined,\n          category: objectCategory\n        };\n        objectIndex.indexOf(object3D.userData.id, true, metadata);\n      }\n      return objectIndex;\n    };\n\n    SceneState.prototype.getObjectIndex = function() {\n      if (!this.__objectIndex) {\n        this.__objectIndex = this.computeObjectIndex();\n      }\n      return this.__objectIndex;\n    };\n\n    SceneState.prototype.computeRoomIndex = function() {\n      var roomIndex = new Index();\n      roomIndex.add('unknown');\n      var rooms = this.getRooms();\n      var sorted = _.sortBy(rooms, function(room) {\n        var id = room.userData.id;\n        var parts = id.split('_');\n        parts[0] = parseInt(parts[0]);\n        parts[1] = parts.length >= 2? parseInt(parts[1]) : -1;\n        return parts;\n      });\n      for (var i = 0; i < sorted.length; i++) {\n        var room = sorted[i];\n        room.userData.index = roomIndex.indexOf(room.userData.id, true, { room: room }) - 1; // Have stored index be 0 based\n      }\n      return roomIndex;\n    };\n\n    SceneState.prototype.getRoomIndex = function() {\n      if (!this.__roomIndex) {\n        this.__roomIndex = this.computeRoomIndex();\n      }\n      return this.__roomIndex;\n    };\n\n    SceneState.prototype.getRoomById = function(roomId) {\n      var roomIndex = this.getRoomIndex().indexOf(roomId);\n      if (roomIndex >= 0) {\n        return this.getRoomByIndex1(roomIndex);\n      } else {\n        return null;\n      }\n    };\n\n    SceneState.prototype.getRoomByIndex1 = function(roomIndex) {\n      if (_.isFinite(roomIndex) && roomIndex > 0) {\n        // input roomIndex is one based\n        if (this.house) {\n          var region = this.house.regions[roomIndex-1];  // regions start at index 0\n          return region? region.object3D : null;\n        } else {\n          var metadata = this.getRoomIndex().metadata(roomIndex); // 0 is unknown - real rooms start at 1\n          return metadata? metadata.room : null;\n        }\n      }\n    };\n\n    SceneState.prototype.setVisible = function(flag, filter, recursive) {\n      var matching = Object3DUtil.findNodes(this.scene, filter);\n      for (var i = 0; i < matching.length; i++) {\n        Object3DUtil.setVisible(matching[i], flag, recursive);\n      }\n    };\n\n    /**\n     * Returns a list of model ids in use in this scene\n     */\n    SceneState.prototype.getModelIds = function(filter) {\n      var mInsts = filter? _.filter(this.modelInstances, filter) : this.modelInstances;\n      var modelIds = _.map(mInsts, function(x) { return x.model.getFullID(); });\n      modelIds = _.uniq(modelIds);\n      return modelIds;\n    };\n\n    SceneState.prototype.getModelIdCounts = function(filter) {\n      var mInsts = filter? _.filter(this.modelInstances, filter) : this.modelInstances;\n      var modelIdCounts = _.countBy(mInsts, function(x) { return x.model.getFullID(); });\n      return modelIdCounts;\n    };\n\n\n    /** When scene state is updated we may also need to dynamically update auxiliary information kept with the scene */\n    SceneState.prototype.__onObjectAdded = function(object3D) {\n      // Update BVH\n      if (this.bvh) {\n        // TODO: update bvh more efficiently\n        this.bvh = null;\n      }\n      if (this.octree) {\n        // TODO: update octree more efficiently\n        this.octree = null;\n      }\n    };\n\n    SceneState.prototype.__onObjectRemoved = function(object3D) {\n      // Update BVH\n      if (this.bvh) {\n        // TODO: update bvh more efficiently\n        this.bvh = null;\n      }\n      if (this.octree) {\n        // TODO: update octree more efficiently\n        this.octree = null;\n      }\n    };\n\n    SceneState.prototype.__onObjectChanged = function(object3D) {\n      // Update BVH\n      if (this.bvh) {\n        // TODO: update bvh more efficiently\n        this.bvh = null;\n      }\n      if (this.octree) {\n        // TODO: update octree more efficiently\n        this.octree = null;\n      }\n    };\n\n\n    SceneState.prototype.__getIntersectedRoomAt = function (rooms, position, distThreshold) {\n      function selectRoom(candidates) {\n        candidates = RaycasterUtil.getClosestPerObject(candidates, distThreshold);\n        // Select smallest room\n        return _.minBy(candidates, function(c) {\n          return SceneUtil.getRoomFloorArea(c.object);\n        });\n      }\n      var room;\n      //console.log('rooms', rooms.map( function(r) { return Object3DUtil.getBoundingBox(r); }));\n      var downwards = RaycasterUtil.getIntersected(rooms, { position: position, direction: Constants.worldDown, intersectBackFaces: true});\n      if (downwards && downwards.length) {\n        room = selectRoom(downwards);\n      }\n      var upwards = RaycasterUtil.getIntersected(rooms, { position: position, direction: Constants.worldUp, intersectBackFaces: true});\n      if (upwards && upwards.length) {\n        var c = selectRoom(upwards);\n        if (room && c) {\n          if (c.distance < room.distance) {\n            room = c;\n          }\n        } else if (c) {\n          room = c;\n        }\n      }\n      return room;\n    };\n\n    SceneState.prototype.getIntersectedRoomAt = function(position, level, distThreshold) {\n      if (distThreshold == undefined) {\n        distThreshold = 0.05*Constants.metersToVirtualUnit;\n      }\n      var rooms = this.getRoomsOrHouseRegions(level);\n      return this.__getIntersectedRoomAt(rooms, position, distThreshold);\n    };\n\n    SceneState.prototype.getIntersectedGroundAt = function(position, level, distThreshold) {\n      if (distThreshold == undefined) {\n        distThreshold = 0.05*Constants.metersToVirtualUnit;\n      }\n      var rooms = this.getGrounds(level);\n      return this.__getIntersectedRoomAt(rooms, position, distThreshold);\n    };\n\n    SceneState.prototype.computeFloorHeight = function (room, defaultFloorHeight) {\n      if (room instanceof THREE.Object3D) {\n        var floors = Object3DUtil.findNodes(room, function(node) {\n          return node.userData.type === 'Floor' || node.userData.type === 'Ground';\n        });\n        if (floors.length > 0) {\n          if (floors.length === 1) {\n            return Object3DUtil.getBoundingBox(floors[0]).max.y;\n          } else {\n            var weightedHeights = _.map(floors, function(floor) {\n              return {\n                weight: SceneUtil.getRoomFloorArea(floor),\n                height: Object3DUtil.getBoundingBox(floor).max.y\n              };\n            });\n            var totalWeight = _.sum(_.map(weightedHeights, function(x) { return x.weight; }));\n            var weightedSum = _.sum(_.map(weightedHeights, function(x) { return x.weight*x.height; }));\n            console.log('floor height ' + weightedSum/totalWeight);\n            return weightedSum/totalWeight;\n          }\n        }\n        return (defaultFloorHeight != undefined)? defaultFloorHeight : Object3DUtil.getBoundingBox(room).min.y;\n      }\n    };\n\n    SceneState.prototype.getFloorHeight = function (room, defaultFloorHeight) {\n      if (room instanceof THREE.Object3D) {\n        if (room.userData.floorHeight == undefined) {\n          room.userData.floorHeight = this.computeFloorHeight(room, defaultFloorHeight);\n        }\n        return room.userData.floorHeight;\n      }\n      if (!room) {\n        if (this.info.floorHeight != undefined) {\n          return this.info.floorHeight;\n        } else if (this.info.baseModelInfo) {\n          return this.info.baseModelInfo.floorHeight;\n        } else {\n          return defaultFloorHeight;\n        }\n      }\n    };\n    // Exports\n    return SceneState;\n\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/SceneState.js?");

/***/ }),

/***/ "./js/lib/scene/SceneStateLoader.js":
/*!******************************************!*\
  !*** ./js/lib/scene/SceneStateLoader.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Scene Loader for SceneState json files\n */\n\n\n\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar SceneLoader = __webpack_require__(/*! scene/SceneLoader */ \"./js/lib/scene/SceneLoader.js\");\nvar ArchCreator = __webpack_require__(/*! geo/ArchCreator */ \"./js/lib/geo/ArchCreator.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction SceneStateLoader(params) {\n  SceneLoader.call(this, params);\n  this.defaultSource = 'wss';\n\n  var archCreatorOptions = ArchCreator.DEFAULTS;\n  if (params.archOptions) {\n    archCreatorOptions = _.defaultsDeep(Object.create(null), params.archOptions, archCreatorOptions);\n  }\n  this.archCreator = new ArchCreator(archCreatorOptions);\n}\n\nSceneStateLoader.prototype = Object.create(SceneLoader.prototype);\nSceneStateLoader.prototype.constructor = SceneStateLoader;\n\nSceneStateLoader.prototype.load = function (url, onLoad, onProgress, onError) {\n  var scope = this;\n  var loader = new THREE.FileLoader(scope.manager);\n  //loader.setCrossOrigin(this.crossOrigin);\n  return loader.load(url, function (text) {\n    var json = JSON.parse(text);\n    var sceneState = (json.hasOwnProperty('scene')) ? json : { scene: json };\n    scope.parse(sceneState, onLoad, url);\n  }, onProgress, onError);\n};\n\nSceneStateLoader.prototype.parse = function (json, callback, url) {\n  // The json stores an array of models in the field scene.object\n  // Each model has the following information\n  //   index: instance id\n  //   modelId: full model id (for looking up model information)\n  //   parentIndex: instance id of the parent model (i.e. model that this one is attached to)\n  //   transform: 16 value array indicating global transform\n\n  json = _.cloneDeep(json);  // Make a copy, we sometimes mutate\n  var scene = json.scene || json;\n  if (scene.scene) {\n    json = scene;  // Set json to be here so we can locates stuff later...\n    scene = scene.scene;   // Sometimes double nesting!!! Ack!!! (happens with SceneStudio scene and ui_log)\n  }\n\n  var sceneResult;\n  if (scene.arch) {\n    var scope = this;\n    var arch = this.archCreator.createArch(scene.arch, {\n      filterElements: ArchCreator.getFilter({\n        includeCeiling: scope.includeCeiling,\n        includeFloor: scope.includeFloor,\n        includeWalls: scope.includeWalls,\n        room: scope.room,\n        level: scope.level,\n        archIds: scope.archIds\n      }),\n      groupRoomsToLevels: true\n    });\n    sceneResult = this.archCreator.toSceneState(json, arch, false);\n  } else {\n    sceneResult = new SceneState(null, null);\n  }\n\n  var models = scene.object;\n  sceneResult.modelInstancesMeta = models;\n  sceneResult.json = json;\n\n  // TODO: Get rid of this weird wrappedThreeObjects\n  if (scene.wrappedThreeObjects) {\n    var wrappedThreeObjects = scene.wrappedThreeObjects;\n\n    for (var i = 0; i < wrappedThreeObjects.length; i++) {\n      var objectLoader = new THREE.ObjectLoader();\n      var loadedObj3D = objectLoader.parse(wrappedThreeObjects[i].object3D);\n      sceneResult.addExtraObject(loadedObj3D);\n    }\n  }\n\n  var wrappedCallback = function(sr) {\n    sr.updateState(json);\n    callback(sr);\n  };\n\n  if (models.length <= 0) {\n    wrappedCallback(sceneResult);\n  } else {\n    // Get all models at flat list for now!\n    for (var i = 0; i < models.length; i++) {\n      var m = models[i];\n      this.__loadModel(sceneResult, i, m.modelId, wrappedCallback);\n    }\n  }\n};\n\n// Exports\nmodule.exports = SceneStateLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/SceneStateLoader.js?");

/***/ }),

/***/ "./js/lib/scene/SceneUtil.js":
/*!***********************************!*\
  !*** ./js/lib/scene/SceneUtil.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nvar AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar BVH = __webpack_require__(/*! geo/BVH */ \"./js/lib/geo/BVH.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar GeometryUtil = __webpack_require__(/*! geo/GeometryUtil */ \"./js/lib/geo/GeometryUtil.js\");\nvar ImageUtil = __webpack_require__(/*! util/ImageUtil */ \"./js/lib/util/ImageUtil.js\");\nvar Index = __webpack_require__(/*! ds/Index */ \"./js/lib/ds/Index.js\");\nvar MeshHelpers = __webpack_require__(/*! geo/MeshHelpers */ \"./js/lib/geo/MeshHelpers.js\");\nvar MeshSampling = __webpack_require__(/*! geo/MeshSampling */ \"./js/lib/geo/MeshSampling.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar VPTreeFactory = __webpack_require__(/*! ds/VPTree */ \"./js/lib/ds/VPTree.js\");\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\nvar SceneStatistics = __webpack_require__(/*! ssg/SceneStatistics */ \"./js/lib/ssg/SceneStatistics.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Utility functions for working with scenes\n * @module SceneUtil\n */\nvar SceneUtil = {};\n\nfunction getMaterial(idx, color, palette) {\n  return Object3DUtil.getSimpleFalseColorMaterial(idx, color, palette);\n}\n\nfunction getIndexMaterial(idx, color, palette) {\n  // Encode index somewhere\n  var mat = new THREE.MeshBasicMaterial({\n    name: \"index-\" + idx,\n    color: color || new THREE.Color(idx)\n  });\n  return mat;\n}\n\nfunction colorObj(obj, material, opts) {\n  opts = opts || {};\n  var setMaterialMode = (Object3DUtil.getModelInstance(obj) != null)? Object3DUtil.MaterialsAllNonRecursive : Object3DUtil.MaterialsAll;\n  Object3DUtil.setMaterial(obj, material, setMaterialMode, true, function(node, m) {\n    if (!opts.isTemporary) {\n      node.__colorMaterial = m;\n    }\n    return true;\n  });\n}\n\nSceneUtil.revertMaterial = function(obj, fullRevert) {\n  var nonrecursive = (Object3DUtil.getModelInstance(obj) != null);\n  Object3DUtil.revertMaterials(obj, nonrecursive, fullRevert);\n};\n\nSceneUtil.recolorObject = function(object3D) {\n  var setMaterialMode = (Object3DUtil.getModelInstance(object3D) != null) ? Object3DUtil.MaterialsAllNonRecursive : Object3DUtil.MaterialsAll;\n  Object3DUtil.setMaterial(object3D, function(node) {\n    return node.__colorMaterial;\n  }, setMaterialMode, true);\n};\n\nSceneUtil.revertMaterials = function(sceneState) {\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    SceneUtil.revertMaterial(modelInstance.object3D);\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    SceneUtil.revertMaterial(object);\n  }\n};\n\n// TODO: deprecate category\nSceneUtil.ColorByOptions = [\n 'objectId', 'objectMaterialId', 'objectPartId', 'objectPartLabel', 'partId',\n 'modelId', 'category', 'objectType', 'roomId', 'roomType',\n 'materialId', 'material', 'texture', 'meshId',\n 'depth', 'normal', 'wireframe', 'color'];\n\n/**\n * Recolors a scene\n * @function colorScene\n * @static\n * @param sceneState {scene.SceneState}\n * @param colorBy {string} How to recolor a scene.\n * <ul>\n *   <li>modelId: recolors by model id - objects with the same model id will be the same color</li>\n *   <li>materialId: recolors by material id - parts with different materials will be different colors</li>\n *   <li>material: recolors by material - parts with same materials will be the same color</li>\n *   <li>texture: recolors by texture - parts with textured materials will be different colors</li>\n *   <li>objectType (or category): recolors by objectType - objects with the same object type/category will be the same color</li>\n *   <li>roomId: recolors by room id - different rooms will have different colors</li>\n *   <li>roomType: recolors by room type - rooms with the same room type will have the same color</li>\n *   <li>objectId: recolors by object id - each object instance will have a different color</li>\n *   <li>objectMaterialId: recolors by object, then materialId - each object part with different material will have a different color</li>\n *   <li>objectPartId: recolors by object, then partId - each annotated object part will have a different color</li>\n *   <li>objectPartLabel: recolors by part label - object parts with the same label will have the same color</li>\n * </ul>\n * @param opts Additional options\n * @param [opts.callback]\n * @param [opts.encodeIndex]\n * @param [opts.objectIndex]\n * @param [opts.loadIndex] {string} Filename to load the encoding index from (must also specify `opts.fs`)\n * @param [opts.writeIndex] {string} Filename to save the encoded index to (must also specify `opts.fs`)\n * @param [opts.fs] Filesystem API to use (must be specified if writeIndex or loadIndex is specified)\n * @param [opts.getMaterialFn] {function(int, THREE.Color, palette): THREE.Material}\n * @param [opts.palette] {Palette}\n * @param [opts.getId]\n * @param [opts.getObjectId]\n * @param [opts.randomize]\n * @param [opts.rng]\n */\nSceneUtil.colorScene = function(sceneState, colorBy, opts) {\n  opts = opts || {};\n  var loadIndex = opts.loadIndex;\n  if (loadIndex) {\n    loadIndex = _.pickBy(loadIndex, function(v,k) { return v; });\n  }\n  if (loadIndex && _.size(loadIndex) > 0) {\n    // Need to load these indices before calling color scene\n    async.eachOfSeries(loadIndex, function(item, key, cb) {\n      Index.import({ fs: opts.fs, filename: item, callback: function(err, index) {\n        if (index) {\n          opts[key] = index;\n        }\n        cb(err, index);\n      }});\n    }, function(err, res) {\n      SceneUtil.__colorScene(sceneState, colorBy, opts);\n    });\n  } else {\n    return SceneUtil.__colorScene(sceneState, colorBy, opts);\n  }\n};\n\nSceneUtil.__colorScene = function (sceneState, colorBy, opts) {\n  if (opts.encodeIndex) {\n    // Make sure that we use basic material\n    opts = _.clone(opts);\n    opts.getMaterialFn = getIndexMaterial;\n    if (colorBy === 'objectId' || colorBy === 'objectPartId') {\n      // Make sure we have a consistent ordering over entire scene for objectId\n      opts.getId = opts.getId || function(x) { return x.userData.id; };\n      opts.getObjectId = opts.getId;\n      if (!opts.objectIndex) {\n        opts.objectIndex = sceneState.getObjectIndex();\n      }\n    }\n  }\n  if (opts.writeIndex) {\n    opts = _.clone(opts);\n    var origCallback = opts.callback;\n    opts.callback = function(err, res) {\n      async.series([\n        function (cb) {\n          if (res && res.objectIndex) {\n            res.objectIndex.export({ fs: opts.fs, filename: opts.writeIndex + '.objectIndex.csv', callback: cb });\n          } else {\n            cb();\n          }\n        },\n        function (cb) {\n          if (res && res.index) {\n            res.index.export({ fs: opts.fs, filename: opts.writeIndex + '.' + colorBy + '.csv', callback: cb });\n          } else {\n            cb();\n          }\n        }\n      ], function(err2, res2) {\n        if (origCallback) {\n          origCallback(err, res);\n        }\n      });\n    };\n  }\n  if (colorBy === 'modelId') {\n    return SceneUtil.__colorSceneByModelId(sceneState, opts);\n  } else if (colorBy === 'materialId') {\n    return SceneUtil.__colorSceneByMaterial(sceneState, opts);\n  } else if (colorBy === 'material') {\n    return SceneUtil.__colorSceneByMaterial(sceneState, _.merge(Object.create(null), opts, { materialIndex: SceneUtil.getMaterialIndex(sceneState) }));\n  } else if (colorBy === 'texture') {\n    return SceneUtil.__colorSceneByMaterial(sceneState, _.merge(Object.create(null), opts,\n      { materialIndex: SceneUtil.getTextureIndex(sceneState), getMaterialIndexId: function(metadata, id) { return metadata.texture == undefined? 'unknown' : id; } }));\n  } else if (colorBy === 'category' || colorBy === 'objectType') {\n    return SceneUtil.__colorSceneByObjectType(sceneState, opts);\n  } else if (colorBy === 'roomId') {\n    return SceneUtil.__colorSceneByRoomId(sceneState, opts);\n  } else if (colorBy === 'roomType') {\n    return SceneUtil.__colorSceneByRoomType(sceneState, opts);\n  } else if (colorBy === 'objectId') {\n    return SceneUtil.__colorSceneByObjectId(sceneState, opts);\n  } else if (colorBy === 'objectMaterialId') {\n    return SceneUtil.__colorSceneByObjectPart(sceneState, _.merge(Object.create(null),\n      { segmentType: 'surfaces', segmentName: 'materials' }, opts, { useLabel: false }));\n  } else if (colorBy === 'meshId') {\n    return SceneUtil.__colorSceneByMeshId(sceneState, opts);\n  } else if (colorBy === 'partId') {\n    return SceneUtil.__colorSceneByPartId(sceneState, opts);\n  } else if (colorBy === 'objectPartId') {\n    return SceneUtil.__colorSceneByObjectPart(sceneState, _.merge(Object.create(null),\n      { segmentType: 'parts', segmentName: 'parts', recolorAlphaTexture: true }, opts, { useLabel: false }));\n  } else if (colorBy === 'objectPartLabel') {\n    return SceneUtil.__colorSceneByObjectPart(sceneState, _.merge(Object.create(null),\n      { segmentType: 'parts', segmentName: 'parts', recolorAlphaTexture: true }, opts, { useLabel: true }));\n  } else if (colorBy === 'index') {\n    return SceneUtil.__colorSceneByIndex(sceneState, opts);\n  } else if (colorBy) {\n    var material = SceneUtil.__getColorByMaterial(colorBy, opts);\n    if (material) {\n      return SceneUtil.__colorSceneUsingMaterial(sceneState, _.merge(Object.create(null), opts, { material: material }));\n    } else {\n      console.warn('Unsupported colorBy=' + colorBy);\n      if (opts.callback) {\n        opts.callback('Unsupported colorBy=' + colorBy, null);\n      }\n    }\n  }\n};\n\nSceneUtil.__getColorByMaterial = function(colorBy, opts) {\n  if (colorBy === 'depth') {\n    return new THREE.MeshDepthMaterial({depthPacking: opts.depthPacking || THREE.RGBADepthPacking});\n  } else if (colorBy === 'normal') {\n    return new THREE.MeshNormalMaterial();\n  } else if (colorBy === 'wireframe') {\n    return new THREE.MeshBasicMaterial({color: new THREE.Color(0), wireframe: true, side: THREE.DoubleSide});\n  } else if (colorBy === 'color') {\n    return Object3DUtil.getStandardMaterial(opts.color, opts.alpha);\n  }\n};\n\n\nSceneUtil.__colorSceneUsingMaterial = function (sceneState, opts) {\n  opts = opts || {};\n  var material = opts.material;\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    colorObj(modelInstance.object3D, material, opts);\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    colorObj(object, material, opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, {});\n  }\n};\n\nSceneUtil.__colorSceneByMaterial = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var materialIndex = opts.materialIndex;\n  var categoryIndex = opts.index || materialIndex || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  var rng = opts.rng || RNG.global;\n\n  var materialIdMap = materialIndex? materialIndex.materialIdMap || SceneUtil.__getMaterialIdMap(materialIndex, opts) : null;\n\n  var getMeshMaterial = opts.getMeshMaterialFn || function(mesh) {\n    if (Array.isArray(mesh.materials)) {\n      var materials = mesh.material.map(function (m, i) {\n        var category = materialIdMap ? materialIdMap[m.id] : m.id;\n        var colorIdx = (category != undefined) ? categoryIndex.indexOf(category, true) : unknownIdx;\n        return getMaterialFn(colorIdx, null, palette);\n      });\n      return new THREE.MultiMaterial(materials);\n    } else if (mesh.material instanceof THREE.MultiMaterial) {\n      var materials = mesh.material.materials.map(function(m, i) {\n        var category = materialIdMap? materialIdMap[m.id] : m.id;\n        var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n        return getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette);\n      });\n      return new THREE.MultiMaterial(materials);\n    } else {\n      var category = mesh.material.id; // TODO: build index of materials\n      var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n      return getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette);\n    }\n  };\n  var modelInstances = sceneState.modelInstances;\n  if (opts.randomize) {\n    modelInstances = rng.shuffle(modelInstances);\n  }\n  for (var i = 0; i < modelInstances.length; i++) {\n    var modelInstance = modelInstances[i];\n    colorObj(modelInstance.object3D, getMeshMaterial, opts);\n  }\n  var extraObjects = sceneState.extraObjects;\n  if (opts.randomize) {\n    extraObjects = rng.shuffle(extraObjects);\n  }\n  for (var i = 0; i < extraObjects.length; i++) {\n    var object = extraObjects[i];\n    colorObj(object, getMeshMaterial, opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\nSceneUtil.__remapSceneModelMaterials = function (sceneState, opts) {\n  opts = opts || {};\n  var remapMaterialsKey = opts.remapMaterialsKey;\n  var getMeshMaterialForModel = function (modelInfo, mesh) {\n    var originalMaterials = null;\n    var materialsMap = modelInfo[remapMaterialsKey].data.materials;\n    if (mesh.material instanceof THREE.MultiMaterial) {\n      originalMaterials = mesh.material.materials;\n    } else if (Array.isArray(mesh.material)) {\n      originalMaterials = mesh.material;\n    }\n    if (originalMaterials) {\n      var newMaterials = originalMaterials.map(function(m) {\n        return materialsMap[m.name];\n      });\n      return new THREE.MultiMaterial(newMaterials);\n    } else {\n      return materialsMap[mesh.material.name];\n    }\n  };\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var modelInfo = modelInstance.model.info;\n    if (modelInfo[remapMaterialsKey].data != null) {\n      var getMeshMaterial = function (m) { return getMeshMaterialForModel(modelInfo, m); };\n      colorObj(modelInstance.object3D, getMeshMaterial, opts);\n    } else {\n      console.error('Cannot find remapMaterial ' + remapMaterialsKey + ' for model ' + modelInfo.fullId);\n      colorObj(modelInstance.object3D, Object3DUtil.BlackMat, opts);\n    }\n  }\n};\n\nSceneUtil.__colorSceneByIndex = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var getIndex = opts.getIndex;\n  var index = opts.index;\n\n  var object3Ds = sceneState.modelInstances.map(function(x) { return x.object3D; });\n  object3Ds = object3Ds.concat(sceneState.extraObjects);\n  for (var i = 0; i < object3Ds.length; i++) {\n    var object = object3Ds[i];\n    var idx = getIndex(object);\n    colorObj(object, getMaterialFn(idx, null, palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: index });\n  }\n  return index;\n};\n\nSceneUtil.__colorSceneByModelId = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var categoryIndex = opts.index || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var category = modelInstance.model.getFullID();\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n    colorObj(modelInstance.object3D, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    colorObj(object, getMaterialFn(unknownIdx, categoryIndex.metadata(unknownIdx, 'color'), palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\nSceneUtil.__colorSceneByObjectId = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var categoryIndex = opts.index || opts.objectIndex || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var category = opts.getId? opts.getId(modelInstance.object3D) : modelInstance.object3D.id;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true, { modelId: modelInstance.model.getFullID(), category: modelInstance.model.info.category }) : unknownIdx;\n    colorObj(modelInstance.object3D, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    var category = opts.getId? opts.getId(object) : object.id;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true, { category: object.userData.type }) : unknownIdx;\n    colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\nSceneUtil.__colorSceneByMeshId = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var categoryIndex = opts.index || new Index();\n  var addToIndex = !(opts.restrictToIndex && opts.index);\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  var meshes = Object3DUtil.getMeshList(sceneState.scene, true);\n  for (var i = 0; i < meshes.length; i++) {\n    var mesh = meshes[i];\n    var category = opts.getId? opts.getId(mesh) : mesh.id;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, addToIndex) : unknownIdx;\n    if (colorIdx == undefined) {\n      colorIdx = unknownIdx;\n    }\n    colorObj(mesh, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\nSceneUtil.__colorSceneByPartId = function (sceneState, opts) {\n  opts = opts || {};\n  opts = _.defaults({ getId: function(mesh) {\n    var m = Object3DUtil.findFirstAncestor(mesh, function(x) { return x.userData.partId != null; }, true);\n    if (m) {\n      return m.ancestor.userData.partId;\n    }\n  }}, opts || {});\n  return this.__colorSceneByMeshId(sceneState, opts);\n};\n\nSceneUtil.__colorSceneByObjectPart = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var categoryIndex = opts.index || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  var objectIndex = null;\n  if (opts.encodeIndex) {\n    objectIndex = opts.objectIndex || new Index();\n  }\n  // Need to make sure segmentation for objects are loaded\n  //console.log('opts is', opts);\n  SceneUtil.ensureObjectSegmentation(sceneState, { segmentType: opts.segmentType || 'surfaces',\n    callback: function(err, res) {\n      sceneState.showObjectSegmentation({\n        segmentType: opts.segmentType || 'surfaces',\n        segmentName: opts.segmentName || 'materials',\n        useOriginalMaterial: opts.recolorAlphaTexture,   // Set true to recolor textures with alpha\n        getMaterial: function(object3D, segInfo) {\n          var objectId = opts.getObjectId? opts.getObjectId(object3D) : object3D.id;\n          var category = 'unknown';\n          var modelInstance = Object3DUtil.getModelInstance(object3D);\n          var objectCategory = modelInstance? modelInstance.model.getCategory() : (object3D.userData.type || object3D.name);\n          var label = segInfo.label;\n          var partIndex = segInfo.partIndex || 0;\n          var material = segInfo.material;\n          var objectPartMetadata =  {\n              modelId: modelInstance? modelInstance.model.getFullID() : undefined,\n              category: objectCategory,\n              partLabel: label\n          };\n          if (opts.useLabel) {\n            category = (label && label !== objectCategory)? (objectCategory + '-' + label) : objectCategory;\n          }  else {\n            category = objectId + '-' + partIndex;\n          }\n          var color = null;\n          if (opts.encodeIndex && !opts.useLabel) {\n            // Encode objectIndex and partIndex directly in color\n            // objectIndex lower order 2 bytes (GB), partIndex first byte (R)\n            var objectIdx = objectIndex.indexOf(objectId, true, _.omit(objectPartMetadata, ['partLabel']));\n            objectPartMetadata['objectIndex'] = objectIdx;\n            objectPartMetadata['partIndex'] = partIndex;\n            var c = (partIndex << 16) ^ objectIdx;\n            color = new THREE.Color(c);\n          }\n          var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true, objectPartMetadata) : unknownIdx;\n          var mat = getMaterialFn(colorIdx, color, palette);\n          if (opts.recolorAlphaTexture && material && material.map && material.map.image && material.alphaTest > 0) {\n            // Hmm, there may be interesting stuff there....\n            // TODO: optimize this....\n            var Materials = __webpack_require__(/*! materials/Materials */ \"./js/lib/materials/Materials.js\");\n            //console.log('recolor', material.alphaTest, material, mat);\n            mat.map = Materials.recolorTexture(material.map, { color: mat.color });\n            mat.alphaTest = material.alphaTest;\n          }\n          return mat;\n        },\n        applyMaterial: function(object3D, material) {\n          colorObj(object3D, material, opts);\n        }\n      });\n      if (opts.callback) {\n        var res = { index: categoryIndex };\n        if (objectIndex) {\n          res['objectIndex'] = objectIndex;\n        }\n        opts.callback(null, res);\n      }\n    }\n  });\n  return categoryIndex;\n};\n\nSceneUtil.__colorSceneByObjectType = function (sceneState, opts) {\n  opts = opts || {};\n  var getCategory = opts.getCategory;\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.concatPalettes('all-roomtypes',[\n    Colors.createPalette('other-roomtypes', ['#A9A9A9', '#708090']),\n    Colors.palettes.d3_category18p\n  ]);\n  var categoryIndex = opts.index || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  if (opts.restrictToIndex && opts.index) {\n    var validCategories = new Set(opts.index.objects());\n    if (getCategory) {\n      var getBaseCategory = getCategory;\n      getCategory = function(mi) {\n        var c = getBaseCategory(mi);\n        if (!validCategories.has(c)) {\n          c = undefined;\n        }\n        return c;\n      };\n    } else {\n      getCategory = function(mi) {\n        return mi.model.getMatchingCategory(validCategories);\n      };\n    }\n  } else {\n    categoryIndex.indexOf('Wall', true);\n  }\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var category = getCategory? getCategory(modelInstance) : modelInstance.model.getCategory();\n    if (category == undefined && modelInstance.object3D.userData.archType) {\n      category = modelInstance.object3D.userData.archType;\n    }\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n    colorObj(modelInstance.object3D, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    var category = object.userData.type || object.name;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n    colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\nSceneUtil.__colorSceneByRoomId = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.concatPalettes('roomids',[\n      Colors.createPalette('wall-outside', ['#A9A9A9', '#708090', '#c4cfc4']),\n      Colors.palettes.d3_category18p\n    ]);\n  var rooms = sceneState.getRooms();\n  var categoryIndex = opts.index || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  categoryIndex.indexOf('Wall', true);\n  categoryIndex.indexOf('Outside', true);\n\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var objRooms = modelInstance.object3D.userData.roomIds;\n    var inRoom = objRooms && objRooms.length > 0;\n    if (!inRoom) {\n      var colorIdx = categoryIndex.indexOf('Outside', true);\n      colorObj(modelInstance.object3D, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    var objRooms = object.userData.roomIds;\n    var inRoom = objRooms && objRooms.length > 0;\n    if (!inRoom) {\n      var colorIdx = categoryIndex.indexOf('Outside', true);\n      colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n\n  for (var i = 0; i < rooms.length; i++) {\n    var room = rooms[i];\n    var category = room.userData.id;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n    colorObj(room, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n\n  // Keep walls a nice lovely gray\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    if (object.userData.type === 'Wall') {\n      var colorIdx = categoryIndex.indexOf('Wall', true);\n      colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\n\nSceneUtil.__colorSceneByRoomType = function (sceneState, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.concatPalettes('all-roomtypes',[\n    Colors.createPalette('other-roomtypes', ['#A9A9A9', '#708090', '#c4cfc4']),\n    Colors.palettes.d3_category18p\n  ]);\n    //Colors.palettes.d3_category19p;\n  var rooms = sceneState.getRooms();\n  var categoryIndex = opts.index || new Index();\n  var unknownIdx = categoryIndex.indexOf('unknown', true);\n  categoryIndex.indexOf('Wall', true);\n  categoryIndex.indexOf('Outside', true);\n  var roomTypes = [\n    // List of original rooms types\n    'Living_Room', 'Kitchen', 'Bedroom', 'Child_Room',\n    'Dining_Room', 'Bathroom', 'Toilet', 'Hall', 'Hallway',\n    'Office', 'Guest_Room', 'Wardrobe', 'Room', 'Lobby',\n    'Storage', 'Boiler_room', 'Balcony', 'Loggia', 'Terrace',\n    'Entryway', 'Passenger_elevator', 'Freight_elevator', 'Aeration', 'Garage',\n    // Additional room types\n    'Gym'];\n  for (var i = 0; i < roomTypes.length; i++) {\n    categoryIndex.indexOf(roomTypes[i], true);\n  }\n\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var objRooms = modelInstance.object3D.userData.roomIds;\n    var inRoom = objRooms && objRooms.length > 0;\n    if (!inRoom) {\n      var colorIdx = categoryIndex.indexOf('Outside', true);\n      colorObj(modelInstance.object3D, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    var objRooms = object.userData.roomIds;\n    var inRoom = objRooms && objRooms.length > 0;\n    if (!inRoom) {\n      var colorIdx = categoryIndex.indexOf('Outside', true);\n      colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n\n  for (var i = 0; i < rooms.length; i++) {\n    var room = rooms[i];\n    var category = (room.userData.roomType && room.userData.roomType.length > 0)?\n      room.userData.roomType[0] : null;\n    var colorIdx = (category != undefined)? categoryIndex.indexOf(category, true) : unknownIdx;\n    colorObj(room, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n\n  // Keep walls a nice lovely gray\n  for (var i = 0; i < sceneState.extraObjects.length; i++) {\n    var object = sceneState.extraObjects[i];\n    if (object.userData.type === 'Wall') {\n      var colorIdx = categoryIndex.indexOf('Wall', true);\n      colorObj(object, getMaterialFn(colorIdx, categoryIndex.metadata(colorIdx, 'color'), palette), opts);\n    }\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: categoryIndex });\n  }\n  return categoryIndex;\n};\n\n/**\n * Recolor scene with compatible materials (based on aggregated scene statistics)\n * @function recolorWithCompatibleMaterials\n * @static\n * @param sceneState {scene.SceneState}\n * @param opts {Object} Options for helping to recolor the scene\n * @param opts.aggregatedSceneStatistics {ssg.SceneStatistics} statistics to use to figure out what materials are compatible\n * @param opts.assetManager {assets.AssetManager} AssetManager that we will use to load new textures and materials\n * @param [opts.textureOnly=false] {boolean} Whether only texture is remapped (color is kept as before)\n * @param [opts.texturedObjects] {string[]} List of object categories that we want to ensure has a textured material\n * @param [opts.texturedSet] {string} What set of textures to use (useful for when we want to split into train/test sets)\n * @param [opts.rng] {math.RNG} Random number generator to use when we need to randomize\n * @param [opts.debug=false] {boolean} Whether to enable debugging of this function\n */\nSceneUtil.recolorWithCompatibleMaterials = function(sceneState, opts) {\n  var ss = opts.aggregatedSceneStatistics;\n  var assetManager = opts.assetManager;\n  // Option to only remap texture (keep color)\n  var remapTextureOnly = opts.textureOnly;\n  // What object types should always have a texture\n  var texturedObjects = opts.texturedObjects;\n  var materialCounts = remapTextureOnly? ss.getTextureCounts() : ss.getMaterialCounts();\n  var materialCountIndex = remapTextureOnly? ss.getTextureIndex() : ss.getMaterialIndex();\n  var texturedMaterialCounts = ss.getTexturedMaterialCounts(opts.textureSet);\n  var textureRepeat = opts.textureRepeat || sceneState.info.textureRepeat || new THREE.Vector2(1/100, 1/100);   // TODO: This is different for other walls\n  // console.log('texturedMaterialCounts', texturedMaterialCounts);\n  // console.log('materialCounts', materialCounts);\n  var materialRemap = {};\n\n  var materialIndex = SceneUtil.getMaterialIndex(sceneState,\n    { includeMaterial: true,\n      includeMaterialId: true,\n      computeMaterialIdMap: true\n    });\n  var sampleOpts = {\n    rng: opts.rng,\n    filter: function(i) { return materialCountIndex.get(i); }\n  };\n\n  function getRemappedMaterial(material, cacheType, sampleType, sampleTexturedMaterialsOnly) {\n    var mId = materialIndex.materialIdMap[material.id];\n    var mat = materialIndex.metadata(materialIndex.indexOf(mId));\n    if (!mat) {\n      console.log('no metadata for material', Constants.isBrowser? material : material.id);\n      return material;\n    }\n    var key = remapTextureOnly? ss.getTextureKey(mat) : ss.getMaterialKey(mat);\n    if (!key || !mat.color || material.name === 'video') {\n      return material;\n    }\n    var ckey = cacheType + '-' + key;\n    if (materialRemap[ckey]) {\n      return materialRemap[ckey];\n    } else {\n      if (Constants.isBrowser) {\n        console.log('remap ' + ckey);\n      }\n      var sampled;\n      if (!remapTextureOnly && sampleTexturedMaterialsOnly) {\n        sampled = texturedMaterialCounts.sample([sampleType], sampleOpts);\n        //console.log('sampled textured ' + sampleType, sampled);\n        if (!sampled || !sampled[0]) {\n          sampled = materialCounts.sample([sampleType], sampleOpts);\n          //console.log('resampled', sampled);\n        } else if (opts.debug) {\n          if (ss.hasTexture(sampled[0])) {\n            console.log('No texture for sampled ' + sampled[0]);\n            // console.log('textured', texturedMaterialCounts.get([sampleType]));\n            // console.log('unfiltered', materialCounts.get([sampleType]));\n            // console.log('Index is ' + texturedMaterialCounts.indices[1].indexOf(sampled[0]));\n          }\n        }\n      } else {\n        sampled = materialCounts.sample([sampleType], sampleOpts);\n      }\n      if (Constants.isBrowser) {\n        console.log('sampled ' + cacheType + ', ' + sampleType, sampled);\n      }\n      var m = material.clone();\n      if (material.index != undefined) {\n        m.index = material.index;\n      }\n      var textureOptions = (sampleType.startsWith('p5d') || sampleType.startsWith('Box'))? null :\n        { wrap: THREE.RepeatWrapping, repeat: textureRepeat };\n      if (sampled && sampled[0]) {\n        if (remapTextureOnly) {\n          var textureName = sampled[0];\n          var texture = assetManager.getTexture(assetManager.getTexturePath('p5d', textureName), textureOptions);\n          _.merge(m, {name: 'p5d.' + textureName, map: texture});\n        } else {\n          var matParts = sampled[0].split('-');\n          var color = new THREE.Color(matParts[0]);\n          // TODO: Take into account opacity as well, for now ignore\n          var opacity = parseFloat(matParts[1]);\n          var textureName = matParts[2];\n          var texture = textureName?\n            assetManager.getTexture(assetManager.getTexturePath('p5d', textureName), textureOptions) : null;\n          _.merge(m, {name: 'p5d.' + sampled[0], map: texture, color: color});\n\n        }\n      }\n      materialRemap[ckey] = m;\n      //console.log('remapped', ckey, m);\n      return m;\n    }\n  }\n\n  SceneUtil.colorScene(sceneState, 'materialId', {\n    materialIndex: materialIndex,\n    getMeshMaterialFn: function(mesh) {\n      var modelInstance = Object3DUtil.getModelInstance(mesh, true);\n      var objectType = mesh.userData.type || (modelInstance? modelInstance.model.getCategory() : 'Object');\n      var modelId = modelInstance? modelInstance.model.getFullID() : undefined;\n      // Add option to only include material with texture for 'Wall', 'Floor', 'Ceiling'\n      var sampleTexturedMaterialsOnly = false;\n      var meshKey = mesh.userData.type || modelId;\n      if (texturedObjects) {\n        if (texturedObjects === 'all') {\n          sampleTexturedMaterialsOnly = true;\n        } else {\n          sampleTexturedMaterialsOnly = texturedObjects.indexOf(objectType) >= 0;\n        }\n      }\n      //console.log('texturedObjects', texturedObjects, sampleTexturedMaterialsOnly, objectType);\n      if (Array.isArray(mesh.material)) {\n        var materials = mesh.material.map(function (m, i) {\n          return getRemappedMaterial(m, objectType, meshKey + '#' + i, sampleTexturedMaterialsOnly);\n        });\n        return new THREE.MultiMaterial(materials);\n      } else if (mesh.material instanceof THREE.MultiMaterial) {\n        var materials = mesh.material.materials.map(function(m, i) {\n          return getRemappedMaterial(m, objectType, meshKey + '#' + i, sampleTexturedMaterialsOnly);\n        });\n        return new THREE.MultiMaterial(materials);\n      } else {\n        var key = (mesh.material.index != undefined)? meshKey + '#' + mesh.material.index : meshKey;\n        return getRemappedMaterial(mesh.material, objectType, key, sampleTexturedMaterialsOnly);\n      }\n    }\n  });\n};\n\nSceneUtil.colorObjects = function (object3Ds, opts) {\n  opts = opts || {};\n  var getMaterialFn = opts.getMaterialFn || getMaterial;\n  var palette = opts.palette || Colors.palettes.d3_unknown_category19p;\n  var idIndex = opts.index || opts.objectIndex || new Index();\n  var unknownIdx = idIndex.indexOf('unknown', true);\n  for (var i = 0; i < object3Ds.length; i++) {\n    var object = object3Ds[i];\n    var id = opts.getId? opts.getId(object) : object.id;\n    var colorIdx = (id != undefined)? idIndex.indexOf(id, true, { category: object.userData.type }) : unknownIdx;\n    colorObj(object, getMaterialFn(colorIdx, idIndex.metadata(colorIdx, 'color'), palette), opts);\n  }\n  if (opts.callback) {\n    opts.callback(null, { index: idIndex });\n  }\n  return idIndex;\n};\n\nSceneUtil.__precomputeSemanticEncoding = function(sceneState, encodingType, labelMapping) {\n  // Preprocess sceneState for using labelMapping\n  sceneState.__semanticEncodings = sceneState.__semanticEncodings || {};\n  var encname = _.get(labelMapping, 'name', encodingType);\n  if (!sceneState.__semanticEncodings[encname]) {\n    //console.log('precomputing semantic encodings for ' + encname);\n    var object3Ds = sceneState.modelInstances.map(function(x) { return x.object3D; });\n    object3Ds = object3Ds.concat(sceneState.extraObjects);\n    if (encodingType === 'roomType' || encodingType === 'roomId') {\n      var isId = encodingType === 'roomId';\n      var roomIdIndex = sceneState.getRoomIndex();\n      sceneState.__semanticEncodings[encname] = {\n        'index': isId? roomIdIndex : null // TODO: roomTypeIndex\n      };\n      for (var i = 0; i < object3Ds.length; i++) {\n        var object3D = object3Ds[i];\n        object3D.userData.semanticEncoding = object3D.userData.semanticEncoding || {};\n        var objRooms = (object3D.userData.roomId != undefined)? [object3D.userData.roomId] : object3D.userData.roomIds;\n        var inRoom = objRooms && objRooms.length > 0;\n        if (isId) {\n          if (inRoom) {\n            object3D.userData.semanticEncoding[encname] = roomIdIndex.indexOf(objRooms[0]) + 1;\n          } else {\n            object3D.userData.semanticEncoding[encname] = 0;\n          }\n        } else {\n          if (inRoom) {\n            // HACK!!! Take first room as main room type\n            var roomMetadata = roomIdIndex.metadata(roomIdIndex.indexOf(objRooms[0]));\n            var roomType = roomMetadata.room.userData.roomType || roomMetadata.room.userData.regionType;\n            if (_.isArray(roomType)) { roomType = roomType[0]; }\n            object3D.userData.semanticEncoding[encname] = labelMapping.index(roomType);\n          } else {\n            // HACK!!! Assume outside is last index\n            object3D.userData.semanticEncoding[encname] = labelMapping.maxIndex;\n          }\n        }\n      }\n    } else if (encodingType === 'objectType' || encodingType === 'objectId') {\n      var isId = encodingType === 'objectId';\n      var objectIdIndex = isId? sceneState.getObjectIndex() : null;\n      sceneState.__semanticEncodings[encname] = {\n        'index': isId? objectIdIndex : null // TODO: objectTypeIndex\n      };\n      for (var i = 0; i < object3Ds.length; i++) {\n        var object3D = object3Ds[i];\n        object3D.userData.semanticEncoding = object3D.userData.semanticEncoding || {};\n        if (isId) {\n          object3D.userData.semanticEncoding[encname] = objectIdIndex.indexOf(object3D.userData.id) + 1;\n        } else {\n          var modelInstance = Object3DUtil.getModelInstance(object3D, false);\n          var objectType = modelInstance? modelInstance.model.getCategories() : (object3D.userData.type || 'Object');\n          object3D.userData.semanticEncoding[encname] = labelMapping.indexOneOf(objectType);\n          //console.log('got ', objectType, object3D.userData.semanticEncoding[encname]);\n        }\n      }\n    }\n  }\n  return sceneState.__semanticEncodings[encname];\n};\n\n/**\n * Helper function to render the scene indexed by id\n * @function renderIndexed\n * @static\n * @param sceneState {scene.SceneState|THREE.Object3D}\n * @param opts Options on how to render/index the scene\n * @param opts.renderer {gfx.Renderer} Renderer to use (NOTE: for indexed render to happen well, renderer should not have any special effects such as ambientOcclusion,e tc)\n * @param opts.camera {THREE.Camera} Camera to use when rendering\n * @param [opts.index] {ds.Index} Index of labels to integers\n * @param [opts.getIndex] {function(THREE.Object3D): int} Function that returns the index to use\n * @param [opts.getId] {function(THREE.Object3D): string} Function that returns the id to index\n * @param [opts.palette]\n * @param [opts.targetObjects]\n * @param [opts.colorBy]\n * @returns {{pixels, nPixels: number, index}}\n */\nSceneUtil.renderIndexed = function(sceneState, opts) {\n  var getMaterialFn = getIndexMaterial;\n  if (sceneState instanceof THREE.Object3D) {\n    var idIndex = new Index() || opts.index;\n    var unknownIdx = idIndex.indexOf('unknown', true);\n\n    var getId = opts.getId || function(x) { return x.id; };\n    var targetObjects = opts.targetObjects || [];\n    colorObj(sceneState, getMaterialFn(unknownIdx, null, opts.palette), { isTemporary: true});\n    for (var i = 0; i < targetObjects.length; i++) {\n      var obj = targetObjects[i];\n      var colorIdx = unknownIdx;\n      if (opts.getIndex) {\n        colorIdx = opts.getIndex(obj);\n      } else {\n        var id = getId(obj);\n        colorIdx = (id != undefined) ? idIndex.indexOf(id, true) : unknownIdx;\n      }\n      colorObj(obj, getMaterialFn(colorIdx, null, opts.palette), { isTemporary: true});\n    }\n\n    var colorByIndex = idIndex;\n    var pixels = opts.renderer.render(sceneState, opts.camera);\n    for (var i = 0; i < targetObjects.length; i++) {\n      SceneUtil.revertMaterial(targetObjects[i]);\n    }\n    SceneUtil.revertMaterial(sceneState);\n\n    return {\n      pixels: pixels,\n      nPixels: pixels.length / 4,\n      index: colorByIndex,\n      width: opts.renderer.width,\n      height: opts.renderer.height\n    };\n  } else {\n    // TODO: Use callback for rendering parts....\n    var colorByIndex = SceneUtil.colorScene(sceneState, opts.colorBy, {\n      index: opts.index,\n      getIndex: opts.getIndex,\n      getId: opts.getId,\n      getMaterialFn: getMaterialFn,\n      isTemporary: true\n    });\n    var pixels = opts.renderer.render(sceneState.fullScene, opts.camera);\n    SceneUtil.revertMaterials(sceneState);\n    return {\n      pixels: pixels,\n      nPixels: pixels.length / 4,\n      index: colorByIndex,\n      width: opts.renderer.width,\n      height: opts.renderer.height\n    };\n  }\n};\n\nSceneUtil.renderWithMaterial = function(sceneState, opts) {\n  var scene = sceneState.fullScene || sceneState;\n  var oldOverrideMaterial = scene.overrideMaterial;\n  scene.overrideMaterial = opts.material;\n  var pixels = opts.renderer.render(scene, opts.camera);\n  scene.overrideMaterial = oldOverrideMaterial;\n  return pixels;\n};\n\nSceneUtil.renderWithRemappedMaterials = function(sceneState, opts) {\n  SceneUtil.__remapSceneModelMaterials(sceneState, _.defaults({ isTemporary: true }, opts));\n  var pixels = opts.renderer.render(sceneState.fullScene, opts.camera);\n  SceneUtil.revertMaterials(sceneState);\n  return {\n    pixels: pixels,\n    nPixels: pixels.length / 4\n  };\n};\n\nSceneUtil.renderColored = function(sceneState, opts) {\n  if (sceneState instanceof THREE.Object3D) {\n    var material = SceneUtil.__getColorByMaterial(opts.colorBy, opts);\n    if (material) {\n      colorObj(sceneState, material, { isTemporary: true});\n      var pixels = opts.renderer.render(sceneState, opts.camera);\n      SceneUtil.revertMaterial(sceneState);\n      return pixels;\n    } else {\n      console.log('Unsupported colorBy for Object3D: ' + opts.colorBy);\n      return null;\n    }\n  } else {\n    SceneUtil.colorScene(sceneState, opts.colorBy, _.merge(Object.create(null), opts, {\n      isTemporary: true\n    }));\n    var pixels = opts.renderer.render(sceneState.fullScene, opts.camera);\n    SceneUtil.revertMaterials(sceneState);\n    return pixels;\n  }\n};\n\nSceneUtil.getPixelCounts = function(sceneState, opts) {\n  var result = SceneUtil.renderIndexed(sceneState, opts);\n  result.counts = ImageUtil.getIndexCounts(result.pixels, result.index? function (index) {\n    return result.index.get(index);\n  }: null);\n  return result;\n};\n\nSceneUtil.ensureObjectSegmentation = function(sceneState, opts) {\n  async.forEachSeries( sceneState.modelInstances,\n    function(modelInstance, cb) {\n      modelInstance.model.segmentations = modelInstance.model.segmentations || {};\n      if (!modelInstance.model.segmentations[opts.segmentType]) {\n        var segmentationInfo = modelInstance.model.info[opts.segmentType];\n        if (segmentationInfo) {\n          var IndexedSegmentation = __webpack_require__(/*! geo/IndexedSegmentation */ \"./js/lib/geo/IndexedSegmentation.js\");\n          modelInstance.model.segmentations[opts.segmentType] = new IndexedSegmentation({\n            filename: segmentationInfo.file,\n            segmentType: opts.segmentType\n          });\n        }\n      }\n      var segmentation = modelInstance.model.segmentations[opts.segmentType];\n      if (segmentation) {\n        segmentation.load({callback: function(err, res) {\n          if (err) {\n            console.warn('Error fetching ' + opts.segmentType + ' for ' + modelInstance.model.getFullID());\n          }\n          console.log('done with ' + modelInstance.model.getFullID());\n          cb(null, res);\n        }});\n      } else {\n        console.warn('No ' + opts.segmentType + ' for ' + modelInstance.model.getFullID());\n        cb('No ' + opts.segmentType + ' for ' + modelInstance.model.getFullID(), null);\n      }\n    },\n    function(err, results) {\n      opts.callback(err, results);\n    }\n  );\n};\n\nSceneUtil.clusterObjectsByBoundingBoxes = function (objects) {\n  // order objects by size\n  var sortedObjects = _.sortBy(objects, function (o) {\n    return -o.getBBoxDims().length();\n  });\n\n  // iterate from largest to smallest, merging into overlapping cluster\n  var clusters = [];\n  _.forOwn(sortedObjects, function (o) {\n    var compatibleCluster = null;\n    if (clusters.length) {\n      var intersections = _.map(clusters, function (cluster) {\n        var clusterMembers = cluster.clusterMembers || [];\n        if (clusterMembers.length) {\n          var intersection = cluster.bbox.intersection(o.getBBox());\n          if (intersection) {\n            clusterMembers.push(o);\n            var intDiag = intersection.dimensions().length();\n            var unionBBox = cluster.bbox.union(o.getBBox());\n            var oDiag = o.getBBox().dimensions().length();\n            return { bbox: unionBBox, overlap: intDiag / oDiag, clusterMembers: clusterMembers };\n          }\n        }\n      });\n      var maxOverlapIntersection = _.maxBy(intersections, function (i) {\n        if (i) return i.overlap;\n      });\n      if (maxOverlapIntersection && maxOverlapIntersection > 0.1) {\n        compatibleCluster = maxOverlapIntersection;\n      }\n    }\n\n    if (compatibleCluster) {\n      compatibleCluster.clusterMembers.push(o);\n    } else {\n      var cluster = { bbox: o.getBBox(), overlap: 1.0, clusterMembers: [o] };\n      clusters.push(cluster);\n    }\n\n  });\n\n  return clusters;\n};\n\nfunction triangleUpFilter(up, v1,v2,v3) {\n  var normal = GeometryUtil.computeFaceNormal(v1,v2,v3);\n  return (normal.dot(up) >= 0.9);\n}\n\nSceneUtil.computeRoomFloorArea = function(room, opts) {\n  opts = opts || {};\n  var upFilter = triangleUpFilter.bind(null, opts.up || Constants.worldUp);\n  // note that this won't work if floor/ceiling is hidden\n  var roomCeiling = Object3DUtil.findNodes(room, function (o) {\n    return o.userData.type === 'Ceiling';\n  });\n  var roomFloor = Object3DUtil.findNodes(room, function (o) {\n    return o.userData.type === 'Floor' || o.userData.type === 'Ground';\n  });\n  var surface = roomFloor.length? roomFloor[0] : (roomCeiling.length? roomCeiling[0] : null);\n  if (surface) {\n    // surface may be extruded, so filter out only those that are face up\n    var area = Object3DUtil.getSurfaceArea(surface, { includeChildModelInstance: false, transform: opts.transform, triFilter: upFilter });\n    return area;\n  }\n};\n\nSceneUtil.getRoomFloorArea = function(room) {\n  if (room.userData.floorArea == undefined) {\n    room.userData.floorArea = SceneUtil.computeRoomFloorArea(room);\n  }\n  return room.userData.floorArea;\n};\n\n/**\n * Samples a room in the scene weighted by floor area\n * @function sampleRoom\n * @static\n * @param rooms {THREE.Object3D[]}\n * @param opts\n * @returns {*}\n */\nSceneUtil.sampleRoom = function(rooms, opts) {\n  opts = opts || {};\n  var totalArea = 0;\n  var cumulativeAreas = [];\n  for (var i = 0; i < rooms.length; i++) {\n    var room = rooms[i];\n    var area = SceneUtil.getRoomFloorArea(room);\n    totalArea += area;\n    cumulativeAreas.push(totalArea);\n  }\n  var rng = opts.rng || RNG.global;\n  var r = rng.random() * totalArea;\n  var index = _.sortedIndex(cumulativeAreas, r);\n  return rooms[index];\n};\n\nSceneUtil.getWallsBBox = function(sceneState) {\n  var walls = sceneState.findNodes(function (o) {\n    return o.userData.type === 'Wall' || o.userData.archType === 'Wall';\n  });\n  return Object3DUtil.getBoundingBox(walls);\n};\n\nSceneUtil.getFloorSamples = function(object3D, nsamples) {\n    var floors = Object3DUtil.findNodes(object3D, function(node) {\n        return node.userData.type === 'Floor' || node.userData.type === 'Ground';\n    });\n    if (floors.length > 0) {\n        object3D.updateMatrixWorld();\n        var sampledPoints = MeshSampling.sampleObject(floors, nsamples, {\n            weightFn: 'area',\n            recursive: true,\n            convertSample: function(s) { return s.worldPoint; },\n            skipUVColors: true\n        });\n        return _.flatten(sampledPoints);\n    } else {\n        return [];\n    }\n};\n\nSceneUtil.sampleUpwardSurfaces = function(object3D, nsamples) {\n  object3D.updateMatrixWorld();\n  var sampledPoints = MeshSampling.sampleObject(object3D, nsamples, {\n    weightFn: {\n      name: 'areaWithNormal',\n      args: { targetNormal: Constants.worldUp }\n    },\n    recursive: true,\n    convertSample: function(s) { return s.worldPoint; },\n    skipUVColors: true\n  });\n  return _.flatten(sampledPoints);\n};\n\nSceneUtil.estimateFloorHeight = function(level, point, nsamples, maxDist, kNeighbors, sampleUpwardSurfaces) {\n    // Estimate floor height for point by considering 2D neighbors around it\n    if (!level.__floorSamples) {\n      level.__floorSamples = SceneUtil.getFloorSamples(level, nsamples);\n      if (level.__floorSamples.length === 0 && sampleUpwardSurfaces) {\n        level.__floorSamples = SceneUtil.sampleUpwardSurfaces(level, nsamples);\n      }\n    }\n    if (!level.__floorSamplesVPTree2DL2) {\n      level.__floorSamplesVPTree2DL2 = VPTreeFactory.build(level.__floorSamples, function (a, b) {\n          var dx = a.x - b.x;\n          var dz = a.z - b.z;\n          return Math.sqrt(dx * dx + dz * dz);\n      });\n    }\n    var closest = level.__floorSamplesVPTree2DL2.search(point, kNeighbors, maxDist);\n    if (closest && closest.length > 1) {\n      var csamples = _.map(closest, function(c) { return level.__floorSamples[c.i].y; } );\n      //console.log('got closest', csamples);\n      if (csamples.length === 1) { return csamples[0].y; }\n      else {\n        var sum = _.sum(csamples, function(p) { return p.y; });\n        return sum/csamples.length;\n      }\n    }\n};\n\n\nSceneUtil.sampleRoomFloor = function(room, nsamples, opts) {\n  var roomFloor = Object3DUtil.findNodes(room, function (o) {\n    return o.userData.type === 'Floor' || o.userData.type === 'Ground';\n  });\n  if (roomFloor.length) {\n    opts = _.defaults(opts, { up: Constants.worldUp });\n    return SceneUtil.sampleObject(roomFloor[0], nsamples, opts);\n  }\n};\n\nSceneUtil.sampleObject = function(object, nsamples, opts) {\n  // Sample points from object with normal\n  opts = _.defaults(opts, {\n    weightFn: { name: 'areaWithNormal', args: { targetNormal: opts.up } }\n  });\n  var samples = MeshSampling.sampleObject(object, nsamples, opts);\n  return _.flatten(samples);\n};\n\nfunction addContains(a,b) {\n  a.contains = a.contains || [];\n  a.contains.push(b.id);\n  b.inside = a.inside || [];\n  b.inside.push(a.id);\n}\n\nSceneUtil.computeStatistics = function(sceneState, opts) {\n  opts = opts || {};\n  var transform;\n  if (opts.transform) {\n    transform = opts.transform.clone();\n  } else {\n    var sceneTransformMatrixInverse = new THREE.Matrix4();\n    sceneTransformMatrixInverse.getInverse(sceneState.scene.matrixWorld);\n    transform = sceneTransformMatrixInverse;\n  }\n  var scaleBy = opts.unit ? (sceneState.info.defaultUnit / opts.unit) : 1.0;\n  if (opts.unit) {\n    var scaleMat = new THREE.Matrix4();\n    scaleMat.makeScale(scaleBy, scaleBy, scaleBy);\n    transform.multiply(scaleMat);\n  }\n  var up = Object3DUtil.toVector3(sceneState.info.defaultUp);\n\n  var relations = opts.relations || {};\n  var portalsByRoom = relations.portals? _.groupBy(relations.portals, 'room') : {};\n  var portalsById = relations.portals? _.groupBy(relations.portals, 'portal') : {};\n\n  var nodes = [];\n  var rooms = sceneState.getRooms();\n  for (var i = 0; i < rooms.length; i++) {\n    var room = rooms[i];\n    var stats = { type: 'Room', id: room.userData.id };\n    var area = SceneUtil.computeRoomFloorArea(room, { transform: transform, up: up });\n    if (area != undefined) {\n      stats.floorArea = area;\n    }\n    var portals = portalsByRoom[room.userData.id];\n    if (portals) {\n      var portalCounts = _.countBy(portals, 'portalType');\n      stats.nwindows = portalCounts['window'];\n      stats.ndoors = portalCounts['door'];\n      // Attach portals to this room\n      _.each(portals, function(p) {\n        var portalObject = sceneState.findNodeById(p.portal);\n        if (portalObject) {\n          Object3DUtil.attachToParent(portalObject, room);\n        }\n      });\n    }\n    var bboxRoom = Object3DUtil.computeBoundingBox(room, transform, function(x) {\n      return (x.userData.type !== 'ModelInstance');\n    });\n    room.traverse(function(x) {\n      if (x.userData.type === 'ModelInstance') {\n        x.userData.__isObject = true;\n        Object3DUtil.traverseAncestors(x, function(a) {\n          a.userData.__hasObject = true;\n          return a.id !== room.id;\n        });\n      } else if (x.parent && x.parent.userData.__isObject) {\n        x.userData.__isObject = true;\n      }\n    });\n    var bboxObjects = Object3DUtil.computeBoundingBox(room, transform, function(x) {\n      return x.userData.__isObject || x.userData.__hasObject;\n    });\n    stats.bboxRoom =  bboxRoom;  // Bounding box of room itself\n    if (bboxObjects.valid()) {\n      stats.bboxObjects = bboxObjects; // Bounding box of the objects in the room\n    }\n    nodes.push(stats);\n  }\n  \n  for (var i = 0; i < nodes.length; i++) {\n    for (var j = i+1; j < nodes.length; j++) {\n      var bi = nodes[i].bboxRoom;\n      var bj = nodes[j].bboxRoom;\n      if (bi.contains(bj)) {\n        addContains(nodes[i], nodes[j]);\n      }\n      if (bj.contains(bi)) {\n        addContains(nodes[j], nodes[i]);\n      }\n    }\n  }\n  var statistics = { nodes: nodes };\n  return statistics;\n};\n\n/**\n * Returns list of materials for the scene\n * @function computeMaterials\n * @static\n * @param sceneState {scene.SceneState}\n * @param opts\n * @returns {Array}\n */\nSceneUtil.computeMaterials = function(sceneState, opts) {\n  opts = opts || {};\n  var getTextureName = opts.getTextureName ||  function (name) {\n    return name;\n  };\n  // Compute for each object/materialIndex the set of materials and colors used\n  var nodes = sceneState.getObject3Ds();\n  var materials = [];\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    var id = node.userData.id;\n    var type = node.userData.type;\n    var nodeMaterials = Object3DUtil.getAllMeshMaterials(node);\n    var modelInstance = Object3DUtil.getModelInstance(node);\n    var roomIds = node.userData.roomIds || (node.userData.roomId? [node.userData.roomId] : undefined);\n    var roomTypes = roomIds? _.flatMap(roomIds, function(roomId) {\n      var room = sceneState.findNode(function(x) { return x.userData.id === roomId; });\n      return room? room.userData.roomType : [];\n    }) : undefined;\n    if (roomTypes && roomTypes.length === 0) {\n      roomTypes = undefined;\n    }\n    materials.push({\n      id: id,\n      modelId: modelInstance? modelInstance.model.getFullID() : undefined,\n      category: modelInstance? modelInstance.model.getCategories().join(',') : node.userData.type,\n      roomIds: roomIds,\n      roomTypes: roomTypes,\n      materials: nodeMaterials.map(function(materialInfo) {\n        var mat = materialInfo.material;\n        return {\n          mesh: materialInfo.mesh.userData.id || id,\n          type: materialInfo.mesh.userData.type || type,\n          material: opts.includeMaterial? mat : undefined,\n          materialId: opts.includeMaterialId? mat.id : undefined,\n          materialIndex: materialInfo.index,\n          opacity: mat.transparent? mat.opacity : 1.0,\n          color:  mat.color? '#' + mat.color.getHexString() : undefined,\n          texture: mat.map? getTextureName(mat.map.sourceFile || mat.map.name): undefined\n        };\n      })\n    });\n  }\n  //console.log('materials', materials);\n  return materials;\n};\n\nSceneUtil.__getMaterialIdMap = function(materialIndex, opts) {\n  if (!materialIndex) return null;\n  var materialIdMap = {};\n  //console.log(materialIndex);\n  for (var i = 0; i < materialIndex.size(); i++) {\n    var id = materialIndex.get(i);\n    var metadata = materialIndex.metadata(i);\n    if (metadata) {\n      for (var j = 0; j < metadata.materials.length; j++) {\n        var m = metadata.materials[j];\n        if (opts.getMaterialIndexId) {\n          materialIdMap[m.materialId] = opts.getMaterialIndexId(metadata, id);\n        } else {\n          materialIdMap[m.materialId] = id;\n        }\n      }\n    }\n  }\n  return materialIdMap;\n};\n\nSceneUtil.__getMaterialIndex = function(sceneState, opts) {\n  var attrnames = opts.attributes;\n  var prefix = opts.prefix || '';\n  var materialsByObject = SceneUtil.computeMaterials(sceneState, opts);\n  var materials = _.flatMap(materialsByObject, function(m) { return m.materials; });\n  var groupedMaterials = _.groupBy(materials, function(x) {\n    var attributes = attrnames.map(function(attr) { return x[attr]; });\n    return attributes.join('-');\n  });\n  var index = new Index();\n  index.add('unknown');\n  var v = _.values(groupedMaterials);\n  for (var i = 0; i < v.length; i++) {\n    var grouped = v[i];\n    var materialInfo = {\n      id: prefix + (i+1),\n      materials: grouped.map(function(g) { return _.omit(g, attrnames); })\n    };\n    _.each(attrnames, function(attr) {\n      materialInfo[attr] = grouped[0][attr];\n    });\n    index.add(materialInfo.id, materialInfo);\n  }\n  if (opts.computeMaterialIdMap) {\n    index.materialIdMap = SceneUtil.__getMaterialIdMap(index, opts);\n  }\n  return index;\n};\n\nSceneUtil.getMaterialIndex = function(sceneState, opts) {\n  // consider two materials the same if they have the same color, texture, and opacity\n  return SceneUtil.__getMaterialIndex(sceneState,\n    _.defaults(Object.create(null), opts || {},\n      { includeMaterialId: true, prefix: 'm', attributes: ['color', 'opacity', 'texture' ]}));\n};\n\nSceneUtil.getTextureIndex = function(sceneState, opts) {\n  // consider two materials to be the same if they have the same texture\n  return SceneUtil.__getMaterialIndex(sceneState,\n    _.defaults(Object.create(null), opts || {},\n      { includeMaterialId: true, prefix: 't', attributes: ['texture']}));\n};\n\n/**\n * PortalRelation information\n * @typedef PortalRelation\n * @type {object}\n * @property {string} portalType What kind of portal is it (door, windown, unknown)?\n * @property {string} portal Object instance id of the portal\n * @property {string} wall Object instance id of the wall\n * @property {string} room Object instance id of the room\n */\n\n/**\n * SupportRelation information\n * @typedef SupportRelation\n * @type {object}\n * @property {string} child Object instance id of the support child\n * @property {string} parent Object instance id of the support parent\n * @property {{distance: number, faceIndex: int, normSim: number, normal: number[], point: number[], uv: number[], meshId: string}} parentAttachment\n * @property {{type: string, frame: string, bbfaceIndex: int, local: object, world: object, index: 2}} parentAttachment\n */\n\n/**\n * Identifies and returns portal relations\n * @param sceneState {scene.SceneState}\n * @returns {PortalRelation[]}\n */\nSceneUtil.identifyPortalRelations = function(sceneState) {\n  // Start with door/window to wall association\n  var portalRelations = [];\n  for (var i = 0; i < sceneState.modelInstances.length; i++) {\n    var modelInstance = sceneState.modelInstances[i];\n    var obj = modelInstance.object3D;\n    if (obj) {\n      var objId = obj.userData.id;\n      var wallIds = obj.userData.wallIds || [];\n      for (var j = 0; j < wallIds.length; j++) {\n        var wallId = wallIds[j];\n        var li = wallId.lastIndexOf('_');\n        var roomId = wallId.substring(0, li);\n        var portalType = modelInstance.model.isDoor()? 'door' :\n          (modelInstance.model.isWindow()? 'window' : 'unknown');\n        portalRelations.push({ portalType: portalType, portal: objId , wall: wallIds[j], room: roomId });\n      }\n    }\n  }\n  return portalRelations;\n};\n\n/**\n * Identifies relations between objects in the scene\n * @function identifyRelations\n * @static\n * @param sceneState {scene.SceneState}\n * @param opts\n * @param callback\n * @returns {{portals: PortalRelation[], support: SupportRelation[]}}\n */\nSceneUtil.identifyRelations = function(sceneState, opts, callback) {\n  var portalRelations = SceneUtil.identifyPortalRelations(sceneState);\n  var supportRelations = [];\n  var relations = {\n    portals: portalRelations,\n    support: supportRelations\n  };\n  // Support relations\n  sceneState.identifySupportHierarchy({ portalRelations: portalRelations, assetManager: opts.assetManager, aggregatedSceneStatistics: opts.aggregatedSceneStatistics },\n    function(err, supportAttachments) {\n      SceneUtil.supportAttachmentsToRelations(supportAttachments, supportRelations);\n      callback(err, relations);\n  });\n  return relations;\n};\n\n/**\n * Converts support attachments to support relations for export\n * @param supportAttachments {Attachment[]}\n * @param [supportRelations] {SupportRelation[]}\n * @returns {SupportRelation[]}\n */\nSceneUtil.supportAttachmentsToRelations = function(supportAttachments, supportRelations) {\n  supportRelations = supportRelations || [];\n  if (supportAttachments) {\n    for (var i = 0; i < supportAttachments.length; i++) {\n      var attachment = supportAttachments[i];\n      if (attachment) {\n        // TODO: Add bbfaceIndex to parentAttachment and position of child attachment point in parent frame\n        var parentAttachment = _.pick(attachment.parentAttachment, ['distance', 'faceIndex', 'normSim', 'normal', 'point', 'uv']);\n        parentAttachment.meshId = Object3DUtil.getSceneGraphPath(attachment.parentAttachment, attachment.parent);\n        supportRelations.push({\n          child: attachment.child.userData.id,\n          parent: attachment.parent.userData.id,\n          parentAttachment: parentAttachment,\n          childAttachment: attachment.childAttachment\n        });\n      }\n    }\n  }\n  return supportRelations;\n};\n\n/**\n * Converts support relations to support attachments\n * @param sceneState {scene.SceneState}\n * @param supportRelations {SupportRelation[]}\n * @param [supportAttachments] {Attachment[]}\n * @returns {Attachment[]}\n */\nSceneUtil.relationsToSupportAttachments = function(sceneState, supportRelations, supportAttachments) {\n  supportAttachments = supportAttachments || [];\n  if (supportRelations) {\n    for (var i = 0; i < supportRelations.length; i++) {\n      var relation = supportRelations[i];\n      if (relation) {\n        //console.log('do relation', relation);\n        var child = sceneState.findNodeById(relation.child);\n        //console.log('got child', child);\n        var parent = sceneState.findNodeById(relation.parent);\n        //console.log('got parent', parent);\n        supportAttachments.push({\n          child: child,\n          childInst: Object3DUtil.getModelInstance(child, false),\n          parent: parent,\n          parentInst: Object3DUtil.getModelInstance(parent, false),\n          parentSurfaceNorm: null, // TODO: populate\n          childWorldBBFaceIndex: null, // TODO: populate\n          parentAttachment: null, // TODO populate\n          childAttachment: null // TODO populate\n        });\n      }\n    }\n  }\n  return supportAttachments;\n};\n\n/**\n * Use BVH to identify subgroups based on the support relations\n * @param sceneState {scene.SceneState}\n * @param supportRelations {scene.SupportRelation[]}\n * @param opts Options for creating a BVH\n * @returns {Map} Mapping of parent to BVH\n */\nSceneUtil.identifyGroupings = function(sceneState, supportRelations, opts) {\n  console.time('identifyGroupings');\n  opts = opts || {};\n  var bvhConfig = _.defaults(Object.create(null), opts, {\n    splitStrategy: BVH.SplitStrategy.SURFACE_AREA_HEURISTIC,\n    axisChoiceStrategy: BVH.AxisChoiceStrategy.OPTIMAL\n  });\n  var groupedRelations = _.groupBy(supportRelations, 'parent');\n  var grouped = _.mapValues(groupedRelations, function(rels) {\n    var object3Ds = _.map(rels, function (rel) {\n      var object3D = sceneState.findNodeById(rel.child);\n      return object3D;\n    });\n    var bvh = new BVH(object3Ds, bvhConfig);\n    return bvh;\n  });\n  console.timeEnd('identifyGroupings');\n  return grouped;\n};\n\n/**\n * Tries to identify outlier objects that are shouldn't be part of the scene\n * @param sceneState\n * @param opts\n * @returns {{outliers: Array, root: *}}\n */\nSceneUtil.detectOutlierObjects = function(sceneState, opts) {\n  console.time('detectOutlierObjects');\n  opts = opts || {};\n  var bvh = opts.bvh;\n  var minObjects = opts.minObjects || 10;\n  var maxDistance = (opts.maxDistance != undefined)? opts.maxDistance : 0.25*Constants.metersToVirtualUnit;\n  var upFilter = triangleUpFilter.bind(null, Constants.worldUp);\n  var vu2m2 = Constants.virtualUnitToMeters * Constants.virtualUnitToMeters;\n  function isOkay(node) {\n    if (node.objects.length > minObjects) { return true; }\n    var totalSurfaceArea = 0;\n    for (var i = 0; i < node.objects.length; i++) {\n      var obj = node.objects[i];\n      if (/*obj.userData.type === 'Ceiling' || */ obj.userData.type === 'Floor' || obj.userData.type ==='Ground') {\n        var surfaceArea = Object3DUtil.getSurfaceArea(obj, { includeChildModelInstance: false, triFilter: upFilter }) * vu2m2;\n        totalSurfaceArea += surfaceArea;\n        console.log('Surface area: ' + surfaceArea + ', total: ' + totalSurfaceArea + ', bb: ' + Object3DUtil.getBoundingBox(obj).toString());\n        if (totalSurfaceArea > 3) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  if (!bvh) {\n    var bvhConfig = _.defaults(Object.create(null), opts, {\n      splitStrategy: BVH.SplitStrategy.SURFACE_AREA_HEURISTIC,\n      axisChoiceStrategy: BVH.AxisChoiceStrategy.OPTIMAL\n    });\n    var object3Ds = sceneState.getObject3Ds();\n    bvh = new BVH(object3Ds, bvhConfig);\n  }\n  var outliers = [];\n  var root = bvh.root;\n  while (root.left && root.right) {\n    var left = root.left;\n    var right = root.right;\n    // Check if the two branches are disjoint or close together\n    var bbDistance = left.bbox.distanceTo(right.bbox); // 0 if intersecting\n    if (Constants.isBrowser) {\n      console.log('BBDistance: ' + bbDistance, left, right);\n    }\n//    if (left.bbox.intersects(right.bbox)) {\n    if (bbDistance <= maxDistance) { // Less than some distance apart\n      break;\n    } else {\n      // Check two sides of root to make sure both have room or ground\n      var lOkay = isOkay(left);\n      var rOkay = isOkay(right);\n      if (!lOkay || !rOkay) {\n        if (!lOkay && !rOkay) {\n          console.warn('Neither branch good, giving up');\n          break;\n        } else {\n          // Check difference between left and right\n          if (!lOkay) {\n            outliers = outliers.concat(left.objects);\n            root = right;\n          } else {\n            outliers = outliers.concat(right.objects);\n            root = left;\n          }\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  console.timeEnd('detectOutlierObjects');\n  if (Constants.isBrowser) {\n    console.log('New root ', root);\n    console.log('Outliers ', outliers);\n  }\n  return { outliers: outliers, root: root };\n};\n\nSceneUtil.getAggregatedSceneStatistics = function(cache, cb, opts) {\n  opts = opts || {};\n  if (cache.aggregatedSceneStatistics) {\n    setTimeout(function() { cb(null, cache.aggregatedSceneStatistics); }, 0);\n  } else {\n    var p5dSceneAssetGroup = AssetGroups.getAssetGroup('p5dScene');\n    cache.aggregatedSceneStatistics = new SceneStatistics();\n    cache.aggregatedSceneStatistics.importCsvs({\n      fs: opts.fs || Constants.sys.fs,\n      basename: p5dSceneAssetGroup.rootPath + '/stats/suncg',\n      stats: opts.stats || ['materials', 'relations'],\n      callback: function(err, data) {\n        if (err) {\n          console.error('error loading scene statistics', err);\n        }\n        cb(err, cache.aggregatedSceneStatistics);\n      }\n    });\n  }\n};\n\nSceneUtil.visualizeWallLines = function(sceneState, walls) {\n  //console.log('visualizeWallLines', walls);\n  sceneState.fullScene.updateMatrixWorld();\n  var sceneTransformMatrix = new THREE.Matrix4();\n  sceneTransformMatrix.copy(sceneState.scene.matrixWorld);\n  var unit = 1.0;\n  var scaleBy = unit / sceneState.info.defaultUnit;\n  var scaleMat = new THREE.Matrix4();\n  scaleMat.makeScale(scaleBy, scaleBy, scaleBy);\n  sceneTransformMatrix.multiply(scaleMat);\n\n  var wallLines = new THREE.Group();\n  wallLines.name = 'WallLines';\n  for (var i = 0; i < walls.length; i++) {\n    var wall = walls[i];\n    var p0 = wall.points[0];\n    var p1 = wall.points[1];\n    var points1 = wall.points.map(function(p) {\n      var res = new THREE.Vector3(p[0], p0[1], p[2]);\n      res.applyMatrix4(sceneTransformMatrix);\n      return res;\n    });\n    var points2 = wall.points.map(function(p) {\n      var res = new THREE.Vector3(p[0], p1[1], p[2]);\n      res.applyMatrix4(sceneTransformMatrix);\n      res.y += 0.05*Constants.metersToVirtualUnit;\n      return res;\n    });\n    var line1 = new MeshHelpers.FatLines(points1, 0.05*Constants.metersToVirtualUnit, 'blue');\n    wallLines.add(line1);\n    var line2 = new MeshHelpers.FatLines(points2, 0.05*Constants.metersToVirtualUnit, 'blue');\n    wallLines.add(line2);\n  }\n  sceneState.debugNode.add(wallLines);\n  // Make sure debugNode is visible\n  Object3DUtil.setVisible(sceneState.debugNode, true);\n  return wallLines;\n};\n\nmodule.exports = SceneUtil;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/SceneUtil.js?");

/***/ }),

/***/ "./js/lib/scene/WssSceneLoader.js":
/*!****************************************!*\
  !*** ./js/lib/scene/WssSceneLoader.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Scene Loader for WSS Scene files\n */\n\n\n\nvar SceneState = __webpack_require__(/*! scene/SceneState */ \"./js/lib/scene/SceneState.js\");\nvar SceneLoader = __webpack_require__(/*! scene/SceneLoader */ \"./js/lib/scene/SceneLoader.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nfunction WssSceneLoader(params) {\n  SceneLoader.call(this, params);\n  this.defaultSource = 'wss';\n}\n\nWssSceneLoader.prototype = Object.create(SceneLoader.prototype);\nWssSceneLoader.prototype.constructor = WssSceneLoader;\n\nWssSceneLoader.prototype.parse = function (json, callbackFinished, url) {\n  // The json stores an array of models directly\n  // Each model has the following information\n  //   index: instance id\n  //   modelID: wss model id (for looking up model information)\n  //   parentIndex: instance id of the parent model (i.e. model that this one is attached to)\n  //   renderStateArr: array of booleans indicating if the model is pickable, inserting, selectable, selected (ignore)\n  //   cu(x),cv(y),cw(z): three 3d vectors for the local coordinates\n  //   parentMeshI: mesh index of the parent that this instance attaches to\n  //   parentTriI: triangle of mesh of the parent that this instance attaches to\n  //   parentUV: ????\n  //   cubeFace: 0-5 indicating tumble state\n  //   scale: scalar indicating the scale\n  //   rotation: rotation in radians around cw starting from cu\n  //   transform: 16 value array indicating global transform\n  var models;\n  var cameras;\n  json = _.cloneDeep(json);  // Make a copy, we sometimes mutate\n  json = json.scene || json;\n  if (json.length) {\n    // Simple array...\n    models = json;\n  } else {\n    // TODO: handle json.cameras;\n    models = json.objects;\n    if (json.cameras) {\n      cameras = json.cameras.map(function (cam) {\n        return {\n          name: cam['name'],\n          up: cam['up'],\n          position: cam['eye'],\n          target: cam['lookAt']\n        };\n      });\n    }\n  }\n\n  var sceneResult = new SceneState(null, null);\n  sceneResult.modelInstancesMeta = models;\n  if (cameras) {\n    // Set current camera\n    sceneResult['json'] = {\n      scene: {\n        camera: cameras\n      }\n    };\n    sceneResult.applyCameraState('current');\n  }\n\n  // Get all models at flat list for now!\n  for (var i = 0; i < models.length; i++) {\n    var m = models[i];\n    // Older version of wss format in SceneStudio DB represented each model as a string...\n    if (typeof m === 'string') {\n      m = JSON.parse(m);\n      models[i] = m;\n    }\n    // Get the model instance\n    this.__loadModel(sceneResult, i, m.modelID, callbackFinished);\n  }\n\n};\n\n// Exports\nmodule.exports = WssSceneLoader;\n\n\n//# sourceURL=webpack://STK/./js/lib/scene/WssSceneLoader.js?");

/***/ }),

/***/ "./js/lib/search/BasicSearchController.js":
/*!************************************************!*\
  !*** ./js/lib/search/BasicSearchController.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar PubSub = __webpack_require__(/*! PubSub */ \"./js/lib/PubSub.js\");\nvar SearchModule = __webpack_require__(/*! search/SearchModule */ \"./js/lib/search/SearchModule.js\");\nvar SolrQuerier = __webpack_require__(/*! search/SolrQuerier */ \"./js/lib/search/SolrQuerier.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\n\n/**\n * BasicBasicSearchController - Simple search controller that don't have a search panel attached to it\n * \n * @param params\n * @constructor\n * @memberOf search\n */\nfunction BasicSearchController(params) {\n  PubSub.call(this);\n  var defaults = {\n    boostFields: ['name'],  // Fields to boost score when returning search results\n    encodeQuery: false,     // Whether query should be encoded or not\n    source: Constants.defaultModelSource,\n    deferInit: false,\n    searchTimeout: 10000    // Timeout in milliseconds\n  };\n  params = _.defaults(Object.create(null), params, defaults);\n\n  this.rng = params.rng || RNG.global;\n  this.boostFields = params.boostFields;\n  this.encodeQuery = params.encodeQuery;\n  this.searchTimeout = params.timeout;  // Timeout in milliseconds\n  this.searchModulesBySource = {};  // Custom search modules by source\n\n  this.useFiltered = true;\n  this.__initializeFilters();\n\n  this.sources = params.sources;\n  if (!this.sources) {\n    this.sources = Object.keys(this.searchUrls);\n  }\n  // Restrict sources for overall models3d search\n  if (params.restrictModelSources) {\n    var sources = this.sources.filter(function (elem) { return elem !== 'models3d' && elem !== 'scans'; }) ;\n    this.restrictModelSources(sources);\n  }\n\n  this.defaultSearchModule = new SolrQuerier({\n    timeout: this.searchTimeout\n  });\n\n  if (!params.deferInit) {\n    this.init();\n  }\n}\n\nBasicSearchController.prototype = Object.create(PubSub.prototype);\nBasicSearchController.prototype.constructor = BasicSearchController;\n\nBasicSearchController.prototype.init = function() {\n  this.__registerSearchModules();\n};\n\nBasicSearchController.prototype.__initializeFilters = function(assetTypeFilterOptions) {\n  assetTypeFilterOptions = assetTypeFilterOptions || {};\n  assetTypeFilterOptions['model'] = assetTypeFilterOptions['model'] || {};\n  assetTypeFilterOptions['scan'] = assetTypeFilterOptions['scan'] || {};\n  assetTypeFilterOptions['scene'] = assetTypeFilterOptions['scene'] || {};\n  assetTypeFilterOptions['room'] = assetTypeFilterOptions['room'] || {};\n  assetTypeFilterOptions['texture'] = assetTypeFilterOptions['texture'] || {};\n  this.__searchOptionsByAssetType = {\n    'model': {\n      name: 'models3d',\n      defaultFilter: assetTypeFilterOptions['model'].filter,  // filter that will apply for all models\n      groupFilter: ' +hasModel:true -modelSize:[' + Constants.maxModelSize + ' TO * ]',  // filter just for when all models are queried\n      searchUrl: Constants.models3dSearchUrl,\n      //var modelFields = 'fullId,name,source,id,tags,category,category0,wnlemmas,unit,up,front,nfaces,materials,scenes,datasets,hasModel,popularity,score';\n      fields: ''\n    },\n    'scan': {\n      name: 'scans',\n      defaultFilter: assetTypeFilterOptions['scan'].filter,  // filter that will apply for all scans\n      searchUrl: Constants.models3dSearchUrl,\n      fields: ''\n    },\n    'scene': {\n      name: 'scenes',\n      defaultFilter: assetTypeFilterOptions['scene'].filter,\n      searchUrl: Constants.scenesSearchUrl,\n      // TODO: If data is too big, only get it when user requests it\n      // Also, add other informative fields for scenes\n      fields: 'fullId,name,source,id,format,data,description,category,nmodels,nrooms,nlevels,nobjects,ndoors,nwindows,nwalls,npeople,nmisc,minPoint,maxPoint,dims,levelRating,overallRating'\n    },\n    'room': {\n      name: 'rooms',\n      defaultFilter: assetTypeFilterOptions['room'].filter,\n      searchUrl: Constants.roomsSearchUrl,\n      // TODO: If data is too big, only get it when user requests it\n      // Also, add other informative fields for scenes\n      //fields: 'fullId,name,source,id,format,data,description,category,nmodels,nrooms,nfloors'\n      fields: ''\n    },\n    'texture': {\n      name: 'textures',\n      defaultFilter: assetTypeFilterOptions['texture'].filter,\n      searchUrl: Constants.texturesSearchUrl,\n      fields: 'fullId,name,source,id,tags,category,imageSize,fileSize'\n    }\n  };\n\n  var assetGroups = AssetGroups.getAssetGroups();\n\n  this.searchUrls = {};\n  this.defaultSearchOptionsFiltered = {};\n  this.defaultSearchOptionsUnfiltered = {};\n  // Asset types\n  for (var type in this.__searchOptionsByAssetType) {\n    if (this.__searchOptionsByAssetType.hasOwnProperty(type)) {\n      var assetType = this.__searchOptionsByAssetType[type];\n      var name = assetType.name;\n      this.searchUrls[name] = assetType.searchUrl;\n      this.defaultSearchOptionsUnfiltered[name] = {\n        fields: assetType.fields\n      };\n      var filter = assetType.defaultFilter || '';\n      if (assetType.groupFilter) {\n        filter = filter + ' ' + assetType.groupFilter;\n      }\n      this.defaultSearchOptionsFiltered[name] = {\n        filter: filter,\n        fields: assetType.fields\n      };\n    }\n  }\n  // Specific asset groups\n  for (var name in assetGroups) {\n    if (assetGroups.hasOwnProperty(name)) {\n      if (this.searchUrls[name]) {\n        // Ignore (already added), happens for textures\n        // console.log('Ignoring ' + name);\n        continue;\n      }\n      var assetGroup = assetGroups[name];\n      var assetTypeOptions = this.__searchOptionsByAssetType[assetGroup.type] || {};\n      this.searchUrls[name] = assetGroup.searchUrl || assetTypeOptions.searchUrl;\n      if (!this.searchUrls[assetGroup.assetType]) {\n        this.searchUrls[assetGroup.assetType] = this.searchUrls[name];\n      }\n      var filter = '+source:' + name;\n      this.defaultSearchOptionsUnfiltered[name] = {\n        filter: filter,\n        fields: assetTypeOptions.fields\n      };\n      if (assetGroup.defaultFilter) {\n        // Add filter for this asset group (other than the source:name filter)\n        filter = filter + ' ' + assetGroup.defaultFilter;\n      }\n      if (assetTypeOptions.defaultFilter) {\n        // Add filter for this assetType\n        filter = filter + ' ' + assetTypeOptions.defaultFilter;\n      }\n      this.defaultSearchOptionsFiltered[name] = {\n        filter: filter,\n        fields: assetTypeOptions.fields\n      };\n    }\n  }\n  this.enableFiltering(this.useFiltered);\n};\n\nBasicSearchController.prototype.__registerSearchModules = function() {\n  var assetGroups = AssetGroups.getAssetGroups();\n  //console.log('got sources', this.sources);\n  for (var i = 0; i < this.sources.length; i++) {\n    var name = this.sources[i];\n    var assetGroup = assetGroups[name];\n    //console.log('got asset group', assetGroup);\n    if (assetGroup && assetGroup.assetDb) {\n      if (!this.searchModulesBySource[assetGroup.name]) {\n        this.registerSearchModule(assetGroup.name, assetGroup.assetDb);\n      }\n    }\n  }\n};\n\nBasicSearchController.prototype.enableFiltering = function (filter) {\n    this.useFiltered = filter;\n    if (filter) {\n      this.defaultSearchOptions = this.defaultSearchOptionsFiltered;\n    } else {\n      this.defaultSearchOptions = this.defaultSearchOptionsUnfiltered;\n    }\n  };\n\nBasicSearchController.prototype.setFilter = function (assetType, filter) {\n  var options = {};\n  options[assetType] = { filter: filter };\n  this.__initializeFilters(options);\n};\n\nBasicSearchController.prototype.restrictModelSources = function (sources) {\n  var query = '(' + sources.join(' OR ') + ')';\n  this.defaultSearchOptionsFiltered['models3d']['filter'] = this.defaultSearchOptionsFiltered['models3d']['filter'] + ' +source:' + query;\n  this.defaultSearchOptionsUnfiltered['models3d']['filter'] = this.defaultSearchOptionsUnfiltered['models3d']['filter'] + ' +source:' + query;\n};\n\nBasicSearchController.prototype.hasSource = function (source) {\n  return this.sources.indexOf(source) >= 0;\n};\n\nBasicSearchController.prototype.encodeQueryText = function (text) {\n  // Do a normal encodeURIComponent, but then replace\n  // '%20' with '+' so that spaces are handled in the way\n  // that Solr expects them.\n  text = encodeURIComponent(text);\n  text = text.replace(/%20/g, '+');\n  return text;\n};\n\nBasicSearchController.prototype.searchByIds = function (source, ids, searchSucceededCallback, searchFailedCallback) {\n  if (!ids || ids.length === 0) {\n    searchFailedCallback('Please specify ids for searchByIds');\n    return;\n  }\n  var query;\n  ids = ids.map(function(x) { return x.trim(); }).filter(function(x) { return x.length > 0; });\n  var hasFullId = ids.findIndex(function(x) { return x.indexOf('.') > 0; }) >= 0;\n  if (/*source !== 'textures' && */ hasFullId) {\n    query = this.getQuery('fullId', ids);\n  } else {\n    query = this.getQuery('id', ids);\n  }\n  // TODO: support pagination\n  var sortOrder = this.getQuerySortOrder();\n  this.query(\n    {\n      source: source, query: query, order: sortOrder, start: 0, limit: ids.length,\n      success: searchSucceededCallback,\n      error: searchFailedCallback\n    });\n};\n\nBasicSearchController.prototype.getQuery = function (field, values) {\n  if (values instanceof Array) {\n    return field + ':(' + values.join(' OR ') + ')';\n  } else {\n    return field + ':' + values;\n  }\n};\n\nBasicSearchController.prototype.__getSearchUrl = function(source) {\n  var solrUrl = this.searchUrls[source];\n  if (!solrUrl) {\n    solrUrl = this.searchUrls['models3d'];\n  }\n  return solrUrl;\n};\n\n// Custom search modules (not part of solr)\nBasicSearchController.prototype.registerSearchModule = function (source, searchModule) {\n  if (!searchModule) {\n    console.warn('No search module given for ' + source);\n    return;\n  }\n  if (typeof searchModule === 'string') {\n    // Just a solr url\n    this.searchUrls[source] = searchModule;\n  } else {\n    this.searchModulesBySource[source] = searchModule;\n  }\n};\n\n// New search module interface for search panel\n// Faceted search for a field with search succeeded/failed callbacks\nBasicSearchController.prototype.facetFieldSearch = function (params, callback) {\n  var source = params.source || this.source;\n  var solrUrl = params.url || this.__getSearchUrl(source);\n  var defaultOptions = this.defaultSearchOptions[source];\n  params = _.defaults(Object.create(null), params, defaultOptions || {},\n    { url: solrUrl, facetSort: SearchModule.facetOrderCount });\n  return this.defaultSearchModule.facetFieldSearch(params, callback);\n};\n\n// Stats search for a field with search succeeded/failed callbacks\nBasicSearchController.prototype.getStats = function (params, callback) {\n  var source = params.source || this.source;\n  var solrUrl = params.url || this.__getSearchUrl(source);\n  var defaultOptions = this.defaultSearchOptions[source];\n  params = _.defaults(Object.create(null), params, defaultOptions || {}, { url: solrUrl });\n  return this.defaultSearchModule.getStats(params, callback);\n};\n\nBasicSearchController.prototype.lookupFields = function (url, callback) {\n  return this.defaultSearchModule.lookupFields({url: url }, callback);\n};\n\nBasicSearchController.prototype.getRandomSortOrder = function () {\n  return this.defaultSearchModule.getRandomSortOrder(this.rng);\n};\n\nBasicSearchController.prototype.queryIds = function(ids, callback) {\n  this.searchByIds(this.source, ids, function (data) {\n    callback(null, data);\n  }, function (err) {\n    callback(err);\n  });\n};\n\nBasicSearchController.prototype.getQueryUrl = function (opts) {\n  var updatedQueryOpts = this.__createQueryOptions(opts);\n  return this.defaultSearchModule.getQueryUrl(updatedQueryOpts);\n};\n\nBasicSearchController.prototype.__createQueryOptions = function (queryOpts) {\n  if (queryOpts.searchText && !queryOpts.query) {\n    var searchTerm = this.encodeQuery ? this.encodeQueryText(queryOpts.searchText) : queryOpts.searchText;\n    var solrQuery = searchTerm;\n    if (this.encodeQuery && this.boostFields) {\n      for (var i = 0; i < this.boostFields.length; i++) {\n        solrQuery = solrQuery + ' ' + this.boostFields[i] + ':' + searchTerm + '^2 ';\n      }\n    }\n    queryOpts = _.clone(queryOpts);\n    queryOpts.query = solrQuery;\n  }\n\n  var source = queryOpts.source || this.source;\n  var solrUrl = queryOpts.url || this.__getSearchUrl(source);\n  var solrQuery = queryOpts.query;\n  // Create query data object\n  // Add default options to query data\n  var defaultOptions = this.defaultSearchOptions[source];\n  //console.log('got defaultOptions', defaultOptions, source, this);\n  if (defaultOptions) {\n    // Skip additional filtering of query if only looking for single fullId model\n    var skipFilter = solrQuery.indexOf('fullId:') >= 0;\n    if (skipFilter) {\n      defaultOptions = _.omit(defaultOptions, 'filter');\n    }\n  }\n  //console.log('got defaultOptions', defaultOptions);\n  return _.defaults(Object.create(null), queryOpts, defaultOptions || {}, { url: solrUrl });\n};\n\nBasicSearchController.prototype.query = function(queryOpts, callback) {\n  var updatedQueryOpts = this.__createQueryOptions(queryOpts);\n  //console.log('querying', updatedQueryOpts);\n  var searchModule = this.searchModulesBySource[queryOpts.source];\n  if (searchModule) {\n    searchModule.query(updatedQueryOpts, callback);\n  } else {\n    this.defaultSearchModule.query(updatedQueryOpts, callback);\n  }\n};\n\nmodule.exports = BasicSearchController;\n\n\n//# sourceURL=webpack://STK/./js/lib/search/BasicSearchController.js?");

/***/ }),

/***/ "./js/lib/search/SearchModule.js":
/*!***************************************!*\
  !*** ./js/lib/search/SearchModule.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Interface for search\n * @interface\n * @memberOf search\n */\nfunction SearchModule() {\n}\n\nSearchModule.facetOrderCount = 'count';\nSearchModule.facetOrderIndex = 'index';\n\n/**\n * Faceted search for a field with error first callback\n * @param params Facet search parameters\n * @param params.facetField {string} Field to facet on (ex: 'category')\n * @param [params.facetSort] {string} How to sort the results\n * @param [params.facetLimit=-1] {int} Number of facet results to return\n * @param [params.facetMinCount=0] {int} Minimum number of results for that facet to be returned\n * @param [params.url=this.url] {string} Search url\n * @param [params.query=*:*] {string} Query string\n * @param [params.filter] {string} Additional filter (ex: '+datasets:ShapeNet')\n * @param callback Error first callback\n */\nSearchModule.prototype.facetFieldSearch = function (params, callback) {\n};\n\n/**\n * Execute basic query\n * @param params Query parameters\n * @param [params.url=this.url] {string} Search url\n * @param [params.query=*:*] {string} Query\n * @param [params.start=0] {int} Record to start at\n * @param [params.limit=0] {int} Limit on number of records to fetch\n * @param [params.sort] {string} Sort order\n * @param [params.fields] {string} Fields to return\n * @param [params.filter] {string} Additional solr filter (ex: '+datasets:ShapeNet')\n * @param callback\n */\nSearchModule.prototype.query = function (params, callback) {\n};\n\n/**\n * Retrieves statistics for a field with error first callback\n * @param [params.url=this.url] {string} Search url\n * @param [params.query=*:*] {string} Query string\n * @param [params.filter] {string} Additional filter (ex: '+datasets:ShapeNet')\n * @param params.field {string} Field to get statistics on\n * @param callback Error first callback\n */\nSearchModule.prototype.getStats = function (params, callback) {\n\n};\n\n/**\n * Lookup queriable fields and their types\n * @param params.url Url for looking up fields\n * @param callback Error first callback\n */\nSearchModule.prototype.lookupFields = function (params, callback) {\n};\n\n\n//# sourceURL=webpack://STK/./js/lib/search/SearchModule.js?");

/***/ }),

/***/ "./js/lib/search/SolrQuerier.js":
/*!**************************************!*\
  !*** ./js/lib/search/SolrQuerier.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Responsible for querying a Solr index\n * @param opts Configuration\n * @param opts.url {string} Solr url to query\n * @param [opts.timeout=5000] {int} Timeout (in milliseconds) to wait for the response\n * @param [opts.limit=100] {int} Limit on the number of entries to query\n * @constructor\n * @memberOf search\n */\nfunction SolrQuerier(opts) {\n  var url = opts.url;\n  if (url) {\n    if (url.endsWith('/select') || url.endsWith('/fields')) {\n      var i = url.lastIndexOf('/');\n      url = url.substring(0, i);\n    }\n    this.schemaUrl = url + '/fields';\n    this.searchUrl = url + '/select';\n  }\n  this.timeout = opts.timeout || 5000;\n  this.limit = opts.limit || 100;\n}\n\nSolrQuerier.prototype.escapeValue = function(str) {\n  var pattern = /([\\!\\*\\+\\-\\=<>\\&\\|\\(\\)\\[\\]\\{\\}\\^\\~\\?\\:\\\\/\" ])/g;\n  return str.replace(pattern, \"\\\\$1\");\n};\n\nSolrQuerier.prototype.quoteValue = function(str) {\n  var pattern = /([\"])/g;\n  return '\"' + str.replace(pattern, \"\\\\$1\") + '\"';\n};\n\nSolrQuerier.prototype.getRandomSortOrder = function (rng) {\n  var seed = Math.floor((rng.random() * 1000000000) + 1);\n  return 'random_' + seed + ' desc';\n};\n\n/**\n * Returns a solr query string for querying records with field matching any one of the specified values\n * @param field {string} Field name\n * @param values {string|string[]} List of values to match\n * @param [escape] {string|function(string)} Whether and how to escape values\n * @returns {string} Solr query string\n */\nSolrQuerier.prototype.getQuery = function (field, values, escape) {\n  if (escape && typeof escape !== 'function') {\n    if (escape === 'quote') {\n      escape = this.quoteValue;\n    } else {\n      escape = this.escapeValue;\n    }\n  }\n  if (values instanceof Array) {\n    if (values.length) {\n      var escaped = escape? _.map(values, function(x) { return escape(x); }) : values;\n      return field + ':(' + escaped.join(' OR ') + ')';\n    } else {\n      return '';\n    }\n  } else {\n    var escaped = escape? escape(values) : values;\n    return field + ':' + escaped;\n  }\n};\n\n/**\n * Returns a compound query string\n * @param conj {string} Conjuction (`AND|OR`)\n * @param terms {string[]} Terms to join\n * @returns {string}\n */\nSolrQuerier.prototype.getCompoundQuery = function (conj, terms) {\n  var scope = this;\n  var rest = Array.prototype.slice.call(arguments, 1);\n  var parts = _.map(rest, function(x) { return scope.getQuery(x.field, x.value, x.escape); });\n  parts = _.filter(parts, function(x) { return x.length; });\n  return parts.join(' ' + conj + ' ');\n};\n\nSolrQuerier.prototype.getQueryUrl = function (params) {\n  // Get base solr query URL\n  var solrUrl = params.url || this.searchUrl;\n  var queryData = this.__toQueryData(params);\n  // Construct query params string from query data\n  var queryParams = _.param(queryData);\n  // Return full query URL\n  return solrUrl + '?' + queryParams;\n};\n\n/**\n * Execute basic query\n * @param params Query parameters\n * @param [params.url=this.searchUrl] {string} Solr search url\n * @param [params.query=*:*] {string} Solr query\n * @param [params.start=0] {int} Record to start at\n * @param [params.limit=0] {int} Limit on number of records to fetch\n * @param [params.sort] {string} Sort order\n * @param [params.fields] {string} Fields to return\n * @param [params.filter] {string} Additional solr filter (ex: '+datasets:ShapeNet')\n * @param [params.format=json] {string} Query results format\n * @param callback\n */\nSolrQuerier.prototype.query = function (params, callback) {\n  var solrUrl = params.url || this.searchUrl;\n  var queryData = this.__toQueryData(params);\n  return this.__query(solrUrl, queryData, _.getCallback(params, callback));\n};\n\nSolrQuerier.prototype.__toQueryData = function(params) {\n  var solrQuery = params.query || '*:*';\n\n  var start = params.start || 0;\n  var limit = params.limit || this.limit;\n  var fields = params.fields;\n  var format = params.format || 'json';\n  var filter = params.filter;\n\n// Setup queryData\n  var queryData = {\n    'q': solrQuery,\n    'wt': format,\n    'start': start,\n    'rows': limit\n  };\n\n  if (fields) {\n    queryData['fl'] = fields;\n  }\n  if (filter) {\n    queryData['fq'] = filter;\n  }\n  // NOTE: Add additional fields here\n  // Filter down list of things that solr support\n  var otherValidFields = ['sort', 'group', 'group.query', 'group.limit'];\n  for (var i = 0; i < otherValidFields.length; i++) {\n    var f = otherValidFields[i];\n    if (params[f] != undefined && params[f] !== '') {\n      queryData[f] = params[f];\n    }\n  }\n  return queryData;\n};\n\n/**\n * Faceted search for a field with error first callback\n * @param params Facet search parameters\n * @param params.facetField {string} Field to facet on (ex: 'category')\n * @param [params.facetSort] {string} How to sort the results\n * @param [params.facetLimit=-1] {int} Number of facet results to return\n * @param [params.facetMinCount=0] {int} Minimum number of results for that facet to be returned\n * @param [params.url=this.searchUrl] {string} Solr search url\n * @param [params.query=*:*] {string} Solr query\n * @param [params.filter] {string} Additional solr filter (ex: '+datasets:ShapeNet')\n * @param callback Error first callback\n */\nSolrQuerier.prototype.facetFieldSearch = function (params, callback) {\n  var solrUrl = params.url || this.searchUrl;\n  var solrQuery = params.query || '*:*';\n\n  var filter = params.filter;\n  var facetField = params['facet.field'] || params.facetField;\n  var facetSort = params['facet.sort'] || params.facetSort;\n  var facetLimit = params['facet.limit'] || params.facetLimit || -1;\n  var facetMinCount = params['facet.mincount'] || params.facetMinCount || 0;\n\n  // Setup queryData\n  var queryData = {\n    'q': solrQuery,\n    'fq': filter,\n    'wt': 'json',\n    'start': 0,\n    'rows': 0,\n    'facet': true,\n    'facet.sort': facetSort,\n    'facet.limit': facetLimit,\n    'facet.field': facetField,\n    'facet.mincount': facetMinCount\n  };\n  return this.__query(solrUrl, queryData, _.getCallback(params, callback));\n};\n\n/**\n * Retrieves statistics for a field with error first callback\n * @param [params.url=this.searchUrl] {string} Solr search url\n * @param [params.query=*:*] {string} Solr query\n * @param [params.filter] {string} Additional solr filter (ex: '+datasets:ShapeNet')\n * @param params.field {string} Field to get statistics on\n * @param callback Error first callback\n */\nSolrQuerier.prototype.getStats = function (params, callback) {\n  var solrUrl = params.url || this.searchUrl;\n  var solrQuery = params.query || '*:*';\n\n  var filter = params.filter;\n  var field = params.field;\n\n  var queryData = {\n    'q': solrQuery,\n    'fq': filter,\n    'wt': 'json',\n    'start': 0,\n    'rows': 0,\n    'stats': true,\n    'stats.field': field\n  };\n  return this.__query(solrUrl, queryData, _.getCallback(params, callback));\n};\n\n/**\n * Lookup queriable fields and their types\n * @param [params.url=this.schemaUrl] Url for looking up fields\n * @param callback Error first callback\n */\nSolrQuerier.prototype.lookupFields = function (params, callback) {\n  var solrUrl = params.url || this.schemaUrl;\n  var method = 'GET';\n  var cb =  _.getCallback(params, callback);\n  return _.ajax\n  ({\n    type: method,\n    url: solrUrl,\n    contentType: 'application/json;charset=utf-8',\n    dataType: 'json',\n    callback: callback,\n    timeout: this.timeout\n  });\n};\n\n\nSolrQuerier.prototype.__query = function (solrUrl, queryData, callback) {\n  var timeout = this.searchTimeout;\n  return _.ajax\n  ({\n    type: 'POST',\n    url: solrUrl,\n    data: queryData,\n    dataType: 'jsonp',      // At some point, we might want to switch to a PHP script that queries Solr locally, and then we could use regular JSON again.\n    jsonp: 'json.wrf',      // Solr requires the JSONP callback to have this name.\n    traditional: true,      // If facet.field is array, it will become facet.field=a1&facet.field=a2 instead of facet.field[]=a1&facet.field[]=a2\n    callback: callback,\n    timeout: timeout       // in milliseconds. With JSONP, this is the only way to get the error handler to fire.\n  });\n};\n\nmodule.exports = SolrQuerier;\n\n\n//# sourceURL=webpack://STK/./js/lib/search/SolrQuerier.js?");

/***/ }),

/***/ "./js/lib/search/SolrQueryParser.js":
/*!******************************************!*\
  !*** ./js/lib/search/SolrQueryParser.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* TODO: Develop this more, have assetsDb use this instead of its custom parsing */\n\nvar self = {};\n\nvar lucenequeryparser = __webpack_require__(/*! lucene-query-parser */ \"../node_modules/lucene-query-parser/lib/lucene-query-parser.js\");\n\nfunction simpleParse(query) {\n  var queryTerms = query.split(' ');\n  var queryFields = [];\n  for (var i = 0; i < queryTerms.length; i++) {\n    var p = queryTerms[i].split(':');\n    queryFields.push({ name: p[0], value: p[1] });\n  }\n  return queryFields;\n}\nself.simpleParse = simpleParse;\n\nfunction luceneParse(query, options) {\n  var results = lucenequeryparser.parse(query, options);\n  //console.log(results);\n  return results;\n}\n\nself.luceneParse = luceneParse;\n\nfunction getLeftmostNode(parse) {\n  if (parse.right) {\n    return getRightmostNode(parse.right);\n  } else if (parse.left) {\n    return getRightmostNode(parse.left);\n  } else {\n    return parse;\n  }\n}\n\nself.getLeftmostNode = getLeftmostNode;\n\nfunction getRightmostNode(parse) {\n  if (parse.right) {\n    return getRightmostNode(parse.right);\n  } else if (parse.left) {\n    return getRightmostNode(parse.left);\n  } else {\n    return parse;\n  }\n}\n\nself.getRightmostNode = getRightmostNode;\n\nfunction acceptAll() {\n  return true;\n}\n\nfunction orFilter() {\n  var fns = arguments;\n  return function() {\n    for (var i = 0; i < fns.length; i++) {\n      if (fns[i].apply(null, arguments)) {\n        return true;\n      }\n      return false;\n    }\n  };\n}\n\nfunction andFilter() {\n  var fns = arguments;\n  return function() {\n    for (var i = 0; i < fns.length; i++) {\n      if (!fns[i].apply(null, arguments)) {\n        return false;\n      }\n      return true;\n    }\n  };\n}\n\nfunction termMatchFilterSingle(v, term) {\n  if (term === '*') {\n    if (v == undefined) {\n      return false;\n    }\n  } else if (term.indexOf('*') >= 0) {\n    var regex = new RegExp(term.replace('*', '.*'));\n    return v.search(regex) >=0;\n  } else if (term.startsWith('/') && term.endsWith('/')) {\n    var regex = new RegExp(term.substring(0, term.length-1));\n    return v.search(regex) >=0;\n  } else if (v !== term) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction inclusiveRangeFilterSingle(v, min, max) {\n  return ((v != undefined) &&\n    (min === '*' || v >= min) &&\n    (max === '*' || v <= max));\n}\n\nfunction exclusiveRangeFilterSingle(v, min, max) {\n  return ((v != undefined) &&\n    (min === '*' || v > min) &&\n    (max === '*' || v < max));\n}\n\nfunction termMatchFilter(field, term) {\n  return function(d) {\n    var v = d[field];\n    if (Array.isArray(v)) {\n      return _.any(v, function(x) { return termMatchFilterSingle(x, term); });\n    } else {\n      return termMatchFilterSingle(v, term);\n    }\n  };\n}\n\nfunction rangeFilter(field, min, max, isInclusive) {\n  if (isInclusive) {\n    return function(d) {\n      var v = d[field];\n      if (Array.isArray(v)) {\n        return _.any(v, function(x) { return inclusiveRangeFilterSingle(x, min, max); });\n      } else {\n        return inclusiveRangeFilterSingle(v, min, max);\n      }\n    };\n  } else {\n    return function(d) {\n      var v = d[field];\n      if (Array.isArray(v)) {\n        return _.any(v, function(x) { return exclusiveRangeFilterSingle(x, min, max); });\n      } else {\n        return exclusiveRangeFilterSingle(v, min, max);\n      }\n    };\n  }\n}\n\nfunction parseToFilter(parse) {\n  if (parse.field) {\n    if (parse.term != undefined ) {\n      return termMatchFilter(parse.field, parse.term);\n    } else if (parse.term_min != undefined && parse.term_max != undefined) {\n      return rangeFilter(parse.field, parse.term_min, parse.term_max);\n    } else {\n      console.error('Cannot handle parse term');\n      console.log(parse);\n    }\n  } else if (parse.operator) {\n    var composeFn;\n    if (parse.operator === 'AND') {\n      composeFn = andFilter;\n    } else if (parse.operator === 'OR') {\n      composeFn = orFilter;\n    } else {\n      throw new Error('Unsupported operator ' + parse.operator);\n    }\n    var fl = parseToFilter(parse.left);\n    var fr = parseToFilter(parse.right);\n    return composeFn(fl, fr);\n  } else if (parse.left) {\n    // Only the left side\n    var fl = parseToFilter(parse.left);\n    return fl;\n  } else {\n    // Accept all\n    return acceptAll;\n  }\n}\n\nfunction getFilter(query) {\n  var parse = luceneParse(query);\n  return parseToFilter(parse);\n}\n\nself.getFilter = getFilter;\n\nmodule.exports = self;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/search/SolrQueryParser.js?");

/***/ }),

/***/ "./js/lib/ssg/SceneStatistics.js":
/*!***************************************!*\
  !*** ./js/lib/ssg/SceneStatistics.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var AssetGroups = __webpack_require__(/*! assets/AssetGroups */ \"./js/lib/assets/AssetGroups.js\");\nvar Index = __webpack_require__(/*! ds/Index */ \"./js/lib/ds/Index.js\");\nvar IndexedCounters = __webpack_require__(/*! ds/IndexedCounters */ \"./js/lib/ds/IndexedCounters.js\");\nvar Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nvar supportSurfaces = ['vertical', 'vertical', 'down', 'up', 'vertical', 'vertical'];\nvar attachmentTypes = ['left','right','bottom','top','front','back'];\n\n/**\n * Scene statistics that we have computed\n * @constructor\n * @memberOf ssg\n */\nfunction SceneStatistics() {\n  // Materials\n  this.__materialIndex = new Index({name: 'material', filename: 'materials'});\n  this.__textureIndex = new Index({name: 'texture', filename: 'textures'});\n  this.__objectMaterialIdIndex = new Index({name: 'object', filename: 'objectMaterialId'});\n\n  this.__objectMaterialCounts = new IndexedCounters({ name: 'materialCounts', indices: [this.__objectMaterialIdIndex, this.__materialIndex]});\n  this.__objectTextureCounts = new IndexedCounters({ name: 'textureCounts', indices: [this.__objectMaterialIdIndex, this.__textureIndex]});\n\n  // Relations\n  this.__relationIndex = new Index({name: 'relation'});\n  this.__objectIdIndex = new Index({name: 'objectId'});\n  this.__objectTypeIndex = new Index({name: 'objectType'});\n  this.__bbfaceTypeIndex = new Index({name: 'bbfaceType'});\n  this.__bbfaceTypeIndex.addAll(attachmentTypes);\n  this.__supportSurfaceTypeIndex = new Index({name: 'supportSurfaceType'});\n  this.__supportSurfaceTypeIndex.addAll(supportSurfaces);\n\n  this.__objectIdRelationCounts = new IndexedCounters(\n    { name: 'objectIdRelationCounts', indices: [this.__relationIndex, this.__objectIdIndex,  this.__objectIdIndex],\n      fieldnames: [null, 'objectId1', 'objectId2']});\n  this.__objectTypeRelationCounts = new IndexedCounters(\n    { name: 'objectTypeRelationCounts', indices: [this.__relationIndex, this.__objectTypeIndex,  this.__objectTypeIndex],\n      fieldnames: [null, 'objectType1', 'objectType2'] });\n  this.__objectIdChildAttachmentCounts = new IndexedCounters({ name: 'objectIdChildAttachmentCounts', indices: [this.__objectIdIndex, this.__bbfaceTypeIndex]});\n  this.__objectTypeChildAttachmentCounts = new IndexedCounters({ name: 'objectTypeChildAttachmentCounts', indices: [this.__objectTypeIndex, this.__bbfaceTypeIndex]});\n  this.__objectIdSupportSurfaceCounts = new IndexedCounters({ name: 'objectIdSupportSurfaceCounts', indices: [this.__objectIdIndex, this.__supportSurfaceTypeIndex]});\n  this.__objectTypeSupportSurfaceCounts = new IndexedCounters({ name: 'objectTypeSupportSurfaceCounts', indices: [this.__objectTypeIndex, this.__supportSurfaceTypeIndex]});\n\n  // Object room relations\n  // this.__roomTypeIndex = new Index({name: 'roomType', filename: 'roomType'});\n  // this.__objectIdRoomTypeRelationCounts = new IndexedCounters(\n  //   { name: 'objectIdRoomTypeRelationCounts', indices: [this.__relationIndex, this.__objectIdIndex,  this.__roomTypeIndex]});\n  // this.__objectTypeRoomTypeRelationCounts = new IndexedCounters(\n  //   { name: 'objectTypeRoomTypeRelationCounts', indices: [this.__relationIndex, this.__objectTypeIndex,  this.__roomTypeIndex]});\n}\n\n\nSceneStatistics.prototype.bbfaceIndexToSupportSurfaceIndex = function(i) {\n  return this.__supportSurfaceTypeIndex.indexOf(supportSurfaces[i]);\n};\n\nSceneStatistics.prototype.bbfaceIndexToAttachmentTypeIndex = function(i) {\n  return this.__bbfaceTypeIndex.indexOf(attachmentTypes[i]);\n};\n\nSceneStatistics.prototype.getAttachmentType = function(i) {\n  return this.__bbfaceTypeIndex.get(i);\n};\n\nSceneStatistics.prototype.getSupportSurfaceType = function(i) {\n  return this.__supportSurfaceTypeIndex.get(i);\n};\n\nfunction __getKey(obj, attrnames) {\n  var attributes = attrnames.map(function (attr) {\n    return obj[attr];\n  });\n  return attributes.join('-');\n}\n\nSceneStatistics.prototype.getMaterialIndex = function() {\n  return this.__materialIndex;\n};\n\nSceneStatistics.prototype.getTextureIndex = function() {\n  return this.__textureIndex;\n};\n\nSceneStatistics.prototype.getMaterialKey = function(mat) {\n  return __getKey(mat, ['color', 'opacity', 'texture']);\n};\n\nSceneStatistics.prototype.getTextureKey = function(mat) {\n  return __getKey(mat, ['texture']);\n};\n\nSceneStatistics.prototype.hasTexture = function(v) {\n  // wallp_1_1 and wallp_0 are not real textures\n  return !v.endsWith('-') && !v.endsWith('-wallp_1_1.jpg') && !v.endsWith('-wallp_0.jpg');\n};\n\nSceneStatistics.prototype.updateMaterials = function(input) {\n  // Update material statistics\n  var materials = input.materials? input.materials : input;\n  for (var i = 0; i < materials.length; i++) {\n    var m = materials[i];\n    for (var j = 0; j < m.materials.length; j++) {\n      var matInfo = m.materials[j];\n      var materialKey = this.getMaterialKey(matInfo);\n      var textureKey = this.getTextureKey(matInfo);\n\n      var matIndexSuffix = (matInfo['materialIndex'] != null)? ('#' + matInfo['materialIndex']):'';\n      var objectMaterialId = (matInfo['type'] || m.modelId || m.category) + matIndexSuffix;\n      this.__objectMaterialCounts.add([objectMaterialId, materialKey]);\n      this.__objectTextureCounts.add([objectMaterialId, textureKey]);\n    }\n  }\n};\n\nSceneStatistics.prototype.getTextureCounts = function() {\n  return this.__objectTextureCounts;\n};\n\nSceneStatistics.prototype.getMaterialCounts = function(filter) {\n  if (filter) {\n    return this.__objectMaterialCounts? this.__objectMaterialCounts.filter(filter) : null;\n  } else {\n    return this.__objectMaterialCounts;\n  }\n};\n\nSceneStatistics.prototype.getTexturedMaterialCounts = function(textureSet) {\n  if (this.__objectTexturedMaterialCounts === undefined) {\n    var scope = this;\n    this.__objectTexturedMaterialCounts = this.getMaterialCounts(function(count, keys, indices) {\n      var k = keys[keys.length-1];\n      var v = indices[keys.length-1].get(k);\n      return scope.hasTexture(v);\n    });\n  }\n  if (!textureSet || textureSet === 'all') {\n    return this.__objectTexturedMaterialCounts;\n  } else {\n    // Break textures apart by set and then return appropriate set\n    var textureAssets = AssetGroups.getAssetGroup('p5dTexture');\n    if (textureAssets && textureAssets.assetDb) {\n      var assetInfos = textureAssets.assetDb.assetInfos;\n      var splits = _.groupBy(assetInfos, 'split');\n      var counts = this.__objectTexturedMaterialCounts;\n      this.__objectTexturedMaterialCountsGrouped = _.mapValues(splits, function(g, k) {\n        var textures = new Set(_.map(g, 'name'));\n        //console.log('split ' + k, textures);\n        return counts.filter(function(count, keys, indices) {\n          var k = keys[keys.length-1];\n          var v = indices[keys.length-1].get(k);\n          var parts = v.split('-');\n          var tex = parts[parts.length-1];\n          //console.log('checking ' + tex);\n          return textures.has(tex);\n        });\n      });\n      //console.log('textureSet ' + textureSet, this.__objectTexturedMaterialCountsGrouped[textureSet]);\n      return this.__objectTexturedMaterialCountsGrouped[textureSet];\n    } else {\n      console.warn('Cannot get texture assets');\n      return this.__objectTexturedMaterialCounts;\n    }\n  }\n};\n\n\nSceneStatistics.prototype.getObjectIdRelationCounts = function(filter) {\n  if (filter) {\n    return this.__objectIdRelationCounts? this.__objectIdRelationCounts.filter(filter) : null;\n  } else {\n    return this.__objectIdRelationCounts;\n  }\n};\n\nSceneStatistics.prototype.getObjectTypeRelationCounts = function(filter) {\n  if (filter) {\n    return this.__objectTypeRelationCounts? this.__objectTypeRelationCounts.filter(filter) : null;\n  } else {\n    return this.__objectTypeRelationCounts;\n  }\n};\n\nSceneStatistics.prototype.getObjectIdChildAttachmentCounts = function(filter) {\n  if (filter) {\n    return this.__objectIdChildAttachmentCounts? this.__objectIdChildAttachmentCounts.filter(filter) : null;\n  } else {\n    return this.__objectIdChildAttachmentCounts;\n  }\n};\n\nSceneStatistics.prototype.getObjectTypeChildAttachmentCounts = function(filter) {\n  if (filter) {\n    return this.__objectTypeChildAttachmentCounts? this.__objectTypeChildAttachmentCounts.filter(filter) : null;\n  } else {\n    return this.__objectTypeChildAttachmentCounts;\n  }\n};\n\nSceneStatistics.prototype.getObjectIdSupportSurfaceCounts = function(filter) {\n  if (filter) {\n    return this.__objectIdSupportSurfaceCounts? this.__objectIdSupportSurfaceCounts.filter(filter) : null;\n  } else {\n    return this.__objectIdSupportSurfaceCounts;\n  }\n};\n\nSceneStatistics.prototype.getObjectTypeSupportSurfaceCounts = function(filter) {\n  if (filter) {\n    return this.__objectTypeSupportSurfaceCounts? this.__objectTypeSupportSurfaceCounts.filter(filter) : null;\n  } else {\n    return this.__objectTypeSupportSurfaceCounts;\n  }\n};\n\nSceneStatistics.prototype.__updatePortals = function(nodesById, portals) {\n  for (var i = 0; i < portals.length; i++) {\n    var portal = portals[i];\n    this.__objectTypeRelationCounts.add(['portal', portal.portalType, 'wall']);\n  }\n};\n\nSceneStatistics.prototype.__updateSupport = function(nodesById, support) {\n  var assetGroup = AssetGroups.getAssetGroup('p5d');\n\n  function getNode(nodeId) {\n    var node = nodesById[nodeId];\n    if (node) { return node; }\n    if (nodeId.endsWith('f')) {\n      // Floor\n      return { type: 'Floor' };\n    } else if (nodeId.endsWith('c')) {\n      // Ceiling\n      return { type: 'Ceiling' };\n    } else {\n      // TODO: Try to split into 3 and see if it is a wall\n      return { type: 'Wall' };\n    }\n  }\n\n  function getObjectId(node) {\n    return (node.type === 'Object')? 'p5d.' + node.modelId : node.type;\n  }\n\n  function getObjectTypes(node) {\n    // TODO: Lookup object type from modelId\n    if (node.type === 'Object') {\n      var modelInfo = assetGroup.getAssetInfo('p5d.' + node.modelId);\n      return modelInfo.category;\n    } else {\n      return [node.type];\n    }\n  }\n\n  for (var si = 0; si < support.length; si++) {\n    var s = support[si];\n    var parentNode = getNode(s.parent);\n    var childNode = getNode(s.child);\n    var parentId = getObjectId(parentNode);\n    var childId = getObjectId(childNode);\n    var parentTypes = getObjectTypes(parentNode);\n    var childTypes = getObjectTypes(childNode);\n    // Update relation counts\n    this.__objectIdRelationCounts.add(['supports', parentId, childId]);\n    this.__objectIdRelationCounts.add(['supportedBy', childId, parentId]);\n    for (var i = 0; i < parentTypes.length; i++) {\n      var parentType = parentTypes[i];\n      for (var j = 0; j < childTypes.length; j++) {\n        var childType = childTypes[j];\n        this.__objectTypeRelationCounts.add(['supports', parentType, childType]);\n        this.__objectTypeRelationCounts.add(['supportedBy', childType, parentType]);\n      }\n    }\n    // Update support surface counts\n    var parentAttachment = s.parentAttachment;\n    // TODO: Get directly from data\n    parentAttachment.bbfaceIndex = Object3DUtil.findClosestBBFaceByOutNormal(Object3DUtil.toVector3(parentAttachment.normal));\n    var supportSurface = supportSurfaces[parentAttachment.bbfaceIndex];\n    this.__objectIdSupportSurfaceCounts.add([parentId, supportSurface]);\n    for (var i = 0; i < parentTypes.length; i++) {\n      var parentType = parentTypes[i];\n      this.__objectTypeSupportSurfaceCounts.add([parentType, supportSurface]);\n    }\n    // Update attachment\n    var childAttachment = s.childAttachment;\n    var attachmentType = attachmentTypes[childAttachment.bbfaceIndex];\n    this.__objectIdChildAttachmentCounts.add([childId, attachmentType]);\n    for (var j = 0; j < childTypes.length; j++) {\n      var childType = childTypes[j];\n      this.__objectTypeChildAttachmentCounts.add([childType, attachmentType]);\n    }\n  }\n\n};\n\nSceneStatistics.prototype.updateRelations = function(scene, sceneStats) {\n  // Update support hierarchy and other relation statistics\n  var relations = sceneStats.relations;\n  var instanceLookupTable = {};\n  for (var i = 0; i < scene.levels.length; i++) {\n    var level = scene.levels[i];\n    for (var j = 0; j < level.nodes.length; j++) {\n      var node = level.nodes[j];\n      instanceLookupTable[node.id] = node;\n    }\n  }\n  //this.__updatePortals(instanceLookupTable, relations.portals);\n  this.__updateSupport(instanceLookupTable, relations.support);\n};\n\nSceneStatistics.prototype.importCsvs = function(opts) {\n  var statsToImport = opts.stats || ['materials'];\n  var funcNames = _.map(statsToImport, function(s) { return '__' + s + '_importCsvs'; });\n  this.__run(funcNames, opts);\n};\n\nSceneStatistics.prototype.exportCsvs = function(opts) {\n  var statsToExport = opts.stats || ['materials'];\n  var funcNames = _.map(statsToExport, function(s) { return '__' + s + '_exportCsvs'; });\n  this.__run(funcNames, opts);\n};\n\nSceneStatistics.prototype.__run = function(names, opts) {\n  var scope = this;\n  var jobs = _.map(names, function(name) {\n    return function(cb) {\n      if (scope[name]) {\n        scope[name](_.defaults({callback: cb}, opts));\n      } else {\n        console.error('No function with name: SceneStatistics.' + name);\n      }\n    };\n  });\n  async.parallel(jobs, function(err, results) {\n    opts.callback(err, results);\n  });\n};\n\nSceneStatistics.prototype.__exportStats = function(stats, opts) {\n  var jobs = _.map(stats, function(stat) {\n    return function(cb) {\n      stat.exportCsv({\n        fs: opts.fs,\n        filename: opts.basename + '.' + stat.filename + '.csv',\n        callback: cb\n      });\n    };\n  });\n  async.parallel(jobs, function(err, results) {\n    opts.callback(err, results);\n  });\n};\n\nSceneStatistics.prototype.__importStats = function(stats, opts) {\n  var jobs = _.map(stats, function(stat) {\n    return function(cb) {\n      stat.importCsv({\n        fs: opts.fs,\n        filename: opts.basename + '.' + stat.filename + (opts.useSavedIndex? '.index':'') + '.csv',\n        useSavedIndex: opts.useSavedIndex,\n        callback: cb\n      });\n    };\n  });\n  async.parallel(jobs, function(err, results) {\n    opts.callback(err, results);\n  });\n};\n\n// Relations\nSceneStatistics.prototype.__relations_importCsvs = function(opts) {\n  var scope = this;\n  console.time('importRelationCsvs');\n  async.series([\n    function (callback) {\n      scope.__importStats([\n        scope.__objectIdIndex, scope.__objectTypeIndex, scope.__relationIndex,\n        scope.__bbfaceTypeIndex, scope.__supportSurfaceTypeIndex],\n        {\n          fs: opts.fs,\n          basename: opts.basename,\n          callback: function(err,res) {\n            console.log('imported relation indices');\n            callback(err, res);\n          }\n        }\n      );\n    },\n    function (callback) {\n      scope.__importStats([\n          scope.__objectIdRelationCounts, scope.__objectTypeRelationCounts,\n          scope.__objectIdChildAttachmentCounts, scope.__objectTypeChildAttachmentCounts,\n          scope.__objectIdSupportSurfaceCounts, scope.__objectTypeSupportSurfaceCounts],\n        {\n          fs: opts.fs,\n          basename: opts.basename,\n          useSavedIndex: true,\n          callback: function(err,res) {\n            console.log('imported relation counts');\n            callback(err, res);\n          }\n        }\n      );\n    }\n  ], function(err, results) {\n    opts.callback(err, results);\n    console.timeEnd('importRelationCsvs');\n  });\n};\n\nSceneStatistics.prototype.__relations_exportCsvs = function(opts) {\n  var scope = this;\n  scope.__exportStats([\n      // indices\n      scope.__objectIdIndex, scope.__objectTypeIndex, scope.__relationIndex,\n      scope.__bbfaceTypeIndex, scope.__supportSurfaceTypeIndex,\n      // counts\n      scope.__objectIdRelationCounts, scope.__objectTypeRelationCounts,\n      scope.__objectIdChildAttachmentCounts, scope.__objectTypeChildAttachmentCounts,\n      scope.__objectIdSupportSurfaceCounts, scope.__objectTypeSupportSurfaceCounts\n  ], opts);\n};\n\n// Materials\nSceneStatistics.prototype.__materials_importCsvs = function(opts) {\n  var scope = this;\n  console.time('importMaterialCsvs');\n  async.series([\n    function (callback) {\n      scope.__importStats(\n        [scope.__materialIndex, scope.__textureIndex, scope.__objectMaterialIdIndex],\n        {\n          fs: opts.fs,\n          basename: opts.basename,\n          callback: function(err,res) {\n            console.log('imported material indices');\n            callback(err, res);\n          }\n        }\n      );\n    },\n    function (callback) {\n      scope.__importStats(\n        [scope.__objectMaterialCounts, scope.__objectTextureCounts],\n        {\n          fs: opts.fs,\n          basename: opts.basename,\n          useSavedIndex: true,\n          callback: function(err,res) {\n            console.log('imported material counts');\n            callback(err, res);\n          }\n        }\n      );\n    }\n  ], function(err, results) {\n    opts.callback(err, results);\n    console.timeEnd('importMaterialCsvs');\n  });\n};\n\nSceneStatistics.prototype.__materials_exportCsvs = function(opts) {\n  var scope = this;\n  scope.__exportStats([\n    scope.__materialIndex, scope.__textureIndex, scope.__objectMaterialIdIndex,\n    scope.__objectMaterialCounts, scope.__objectTextureCounts], opts);\n};\n\nmodule.exports = SceneStatistics;\n\n//# sourceURL=webpack://STK/./js/lib/ssg/SceneStatistics.js?");

/***/ }),

/***/ "./js/lib/util/BinaryView.js":
/*!***********************************!*\
  !*** ./js/lib/util/BinaryView.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar BinaryView = function () {\n};\n\n// dataview is a jDataView object\nBinaryView.getLine = function (dataview, offset) {\n  var byteLength = dataview.buffer.byteLength;\n  if (offset >= byteLength) return null;\n  var i = offset;\n  while (i < byteLength) {\n    var c = dataview.getChar(i);\n    if (c === '\\n') {\n      break;\n    }\n    i++;\n  }\n  var str = dataview.getString(i - offset, offset);\n  return {\n    offset: offset,\n    next: i + 1,\n    string: str\n  };\n};\n\nmodule.exports = BinaryView;\n\n\n\n//# sourceURL=webpack://STK/./js/lib/util/BinaryView.js?");

/***/ }),

/***/ "./js/lib/util/Colors.js":
/*!*******************************!*\
  !*** ./js/lib/util/Colors.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Colors\n * @module Colors\n **/\nvar self = {};\n\n/**\n * An ordered list of colors\n * @typedef {Object} Palette\n * @property name {string}\n * @property colors {Array.<string|number|THREE.Color>} List of colors in the palette\n * @static\n **/\n\n/**\n * Predefined palettes\n * @static\n * @enum\n */\nself.palettes = {\n  // Colors from http://bl.ocks.org/aaizemberg/78bd3dade9593896a59d\n  d3_category20: {\n    name: 'd3_category_20',\n    colors: [\n      '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78',\n      '#2ca02c', '#98df8a', '#d62728', '#ff9896',\n      '#9467bd', '#c5b0d5', '#8c564b', '#c49c94',\n      '#e377c2', '#f7b6d2', '#7f7f7f', '#c7c7c7',\n      '#bcbd22', '#dbdb8d', '#17becf', '#9edae5']\n  },\n  d3_category18: {\n    // Just like d3_category20 but no grays!\n    name: 'd3_category_18',\n    colors: [\n      '#1f77b4', '#aec7e8', '#ff7f0e', '#ffbb78',\n      '#2ca02c', '#98df8a', '#d62728', '#ff9896',\n      '#9467bd', '#c5b0d5', '#8c564b', '#c49c94',\n      '#e377c2', '#f7b6d2', '#bcbd22', '#dbdb8d',\n      '#17becf', '#9edae5']\n  },\n  d3_category18p: {\n    // Just like d3_category18 but with the more pastel colors coming before the darker colors\n    name: 'd3_category_18p',\n    colors: [\n      '#aec7e8', '#1f77b4', '#ffbb78', '#ff7f0e',\n      '#98df8a', '#2ca02c', '#ff9896', '#d62728',\n      '#c5b0d5', '#9467bd', '#c49c94', '#8c564b',\n      '#f7b6d2', '#e377c2', '#dbdb8d', '#bcbd22',\n      '#9edae5', '#17becf']\n  },\n  d3_category19p: {\n    // Just like d3_category18p but with the first color a blue gray (we don't always use the first color for some reason)!\n    name: 'd3_category_19p',\n    colors: [\n      '#708090',\n      '#aec7e8', '#1f77b4', '#ffbb78', '#ff7f0e',\n      '#98df8a', '#2ca02c', '#ff9896', '#d62728',\n      '#c5b0d5', '#9467bd', '#c49c94', '#8c564b',\n      '#f7b6d2', '#e377c2', '#dbdb8d', '#bcbd22',\n      '#9edae5', '#17becf']\n  },\n  unknown: {\n    name: 'unknown',\n    colors: [ '#A9A9A9' ]\n  }\n};\nself.palettes['d3_unknown_category19p'] = {\n  name: 'd3_unknown_category19p',\n  colors: self.palettes.unknown.colors.concat(self.palettes.d3_category19p.colors)\n};\nself.palettes['d3_unknown_category18'] = {\n  name: 'd3_unknown_category18',\n  colors: self.palettes.unknown.colors.concat(self.palettes.d3_category18.colors)\n};\n\nfunction toColor(value) {\n  if (value instanceof THREE.Color) {\n      return value;\n  } else {\n    var color = new THREE.Color();\n    if (typeof value === 'string') {\n      var style = value;\n      if (/^\\#([0-9a-fA-F]{6})$/i.test(style)) {\n        color.setHex(parseInt(style.substr(1, 6), 16));\n      } else if (/^\\#([0-9a-fA-F]{8})$/i.test(style)) {\n        color.setHex(parseInt(style.substr(1, 6), 16));\n      } else {\n        color.setStyle(style);\n      }\n    } else if (value && (value.count || value.length)) {\n      color.setRGB(value[0], value[1], value[2]);\n    } else {\n      color.set(value);\n    }\n    return color;\n  }\n}\nself.toColor = toColor;\n\nfunction createColor(id, palette, addToPalette) {\n  var colorIdx = id;\n  if (palette) {\n    if (colorIdx < palette.colors.length && palette.colors[colorIdx] != undefined) {\n      return toColor(palette.colors[colorIdx]);\n    } else {\n      palette.extra_colors_start = palette.extra_colors_start || palette.colors.length;\n      colorIdx = id - palette.extra_colors_start;\n    }\n  }\n  var c = generateColor(colorIdx);\n  if (addToPalette && palette) {\n    palette.colors[colorIdx] = c;\n  }\n  return c;\n}\n\nself.createColor = createColor;\n\n//self.ColorSpaces = { RGB: 0, HSL: 1 };\n\nfunction createPalette(name, colors, n, interpolateSpace) {\n    if (n) {\n      // interpolate between colors (n extra in between each pair)\n      var t = n+1;\n      var r = 1.0/t;\n      var finalColors = [];\n      if (interpolateSpace === 'hsl') {\n        var hslColors = colors.map(function (x) {\n          return getHSL(toColor(x));\n        });\n        for (var i = 0; i < colors.length - 1; i++) {\n          var c1 = hslColors[i];\n          var c2 = hslColors[i + 1];\n          var offset = {h: (c2.h - c1.h) * r, s: (c2.s - c1.s) * r, l: (c2.l - c1.l) * r};\n\n          for (var j = 0; j < t; j++) {\n            var c = new THREE.Color();\n            c.setHSL(c1.h + j * offset.h, c1.s + j * offset.s, c1.l + j * offset.l);\n            finalColors.push(c);\n          }\n        }\n      } else {\n        // Assume RGB\n        var rgbColors = colors.map(function (x) {\n          return toColor(x);\n        });\n        for (var i = 0; i < colors.length - 1; i++) {\n          var c1 = rgbColors[i];\n          var c2 = rgbColors[i + 1];\n          var offset = {r: (c2.r - c1.r) * r, g: (c2.g - c1.g) * r, b: (c2.b - c1.b) * r};\n\n          for (var j = 0; j < t; j++) {\n            var c = new THREE.Color();\n            c.setRGB(c1.r + j * offset.r, c1.g + j * offset.g, c1.b + j * offset.b);\n            finalColors.push(c);\n          }\n        }\n      }\n      finalColors.push(toColor(colors[colors.length - 1]));\n      return {name: name, colors: finalColors};\n    } else {\n      return {name: name, colors: colors};\n    }\n}\nself.createPalette = createPalette;\n\nfunction getHSL(color) {\n  var hsl = { h: 0, s: 0, l: 0 };\n  color.getHSL(hsl);\n  return hsl;\n}\nself.getHSL = getHSL;\n\n// Interpolate between color c1 and c2, with weight being weight in the direction of c2\nfunction interpolateColor(color1, color2, opts) {\n  if (typeof(opts) === 'number') {\n    opts = { weight: opts };\n  } else {\n    opts = opts || {};\n  }\n  var c = opts.result || new THREE.Color();\n  var weight = (opts.weight != undefined)? opts.weight : 0.5;\n  if (opts.space === 'hsl') {\n    var c1 = getHSL(color1);\n    var c2 = getHSL(color2);\n    var offset = {h: c2.h - c1.h, s: c2.s - c1.s, l: c2.l - c1.l};\n    c.setHSL(c1.h + weight * offset.h, c1.s + weight * offset.s, c1.l + weight * offset.l);\n  } else {\n    var c1 = color1;\n    var c2 = color2;\n    var offset = {r: c2.r - c1.r, g: c2.g - c1.g, b: c2.b - c1.b};\n    c.setRGB(c1.r + weight * offset.r, c1.g + weight * offset.g, c1.b + weight * offset.b);\n  }\n  //console.log('get color for ' + opts.weight, c);\n  return c;\n}\n\nself.interpolateColor = interpolateColor;\n\nfunction getColorFunction(opts) {\n  if (opts.type === 'interpolate') {\n    //console.log('getColorFunction', opts);\n    var colors = _.map(opts.colors, toColor);\n    var maxWeight = opts.maxWeight || (colors.length-1);\n    var minWeight = opts.minWeight || 0;\n    var range = (maxWeight - minWeight) || 1; // Make sure we don't divide by 0\n    var nsteps = colors.length-1;\n    return function(w) {\n      if (!_.isFinite(w)) {\n        return opts.infinity || 'gray';\n      }\n      var weight = (w - minWeight) / range;\n      var i = Math.min(Math.floor(weight*nsteps), nsteps);\n      var j = Math.min(i+1, nsteps);\n      var color1 = colors[i];\n      var color2 = colors[j];\n      var cw = weight - i*1.0/nsteps;\n      if (opts.debug) {\n        console.log('get color for w=' + w + ', weight= ' + weight + ', cw=' + cw, i, j, color1, color2);\n      }\n      return interpolateColor(color1, color2, { weight: cw, space: opts.space, result: opts.result });\n    };\n  } else if (opts.type === 'map') {\n    return function(w) {\n      return opts.mapping[w];\n    };\n  } else {\n    throw 'Unsupported color function type: ' + opts.type;\n  }\n}\n\nself.getColorFunction = getColorFunction;\n\nfunction concatPalettes(name, palettes) {\n  var colors = [];\n  for (var i = 0; i < palettes.length; i++) {\n    //console.log('push', palettes.length);\n    Array.prototype.push.apply(colors,palettes[i].colors);\n  }\n  return { name: name, colors: colors };\n}\nself.concatPalettes = concatPalettes;\n\nfunction generateColor(colorIdx) {\n  var c = new THREE.Color();\n  var h = (-3.88 * colorIdx) % (2 * Math.PI);\n  if (h < 0) h += 2 * Math.PI;\n  h /= 2 * Math.PI;\n  var ls = [0.5, 0.6, 0.45, 0.55, 0.35, 0.4];\n  var lvalue = ls[Math.floor(colorIdx / 13) % ls.length];\n  //console.log(lvalue);\n  //c.setHSV(h, 0.6 + 0.2 * Math.sin(0.42 * colorIdx), 1);\n  c.setHSL(h, 0.4 + 0.2 * Math.sin(0.42 * colorIdx), lvalue);\n  return c;\n}\nself.generateColor = generateColor;\n\nvar phi = (1 + Math.sqrt(5))/2;\nvar invPhi = 1.0/phi;\nfunction generatePhiColor(colorIdx) {\n  var startColor = new THREE.Color(0x4FD067);\n  var hsb = getHSL(startColor);\n  var hue = hsb.h + colorIdx*invPhi;\n  hue = hue - Math.floor(hue);\n  var c = new THREE.Color();\n  c.setHSL(hue, 0.5, 0.95);\n  // Switch blue and green for nice pretty colors\n  return new THREE.Color(c.r, c.b, c.g);\n}\nself.generatePhiColor = generatePhiColor;\n\nfunction isValidColor(color) {\n  return isFinite(color.r) && isFinite(color.g) && isFinite(color.b);\n}\nself.isValidColor = isValidColor;\n\nfunction lighten(color) {\n  var c = toColor(color).clone();\n  var hsl = getHSL(c);\n  c.offsetHSL(0, 0, (1.0 - hsl.l)/2);\n  return c;\n}\nself.lighten = lighten;\n\nfunction darken(color) {\n  var c = toColor(color).clone();\n  var hsl = getHSL(c);\n  c.offsetHSL(0, 0, -hsl.l/2);\n  return c;\n}\nself.darken = darken;\n\n_.each(self.palettes, function(x) {\n  x.colors = _.map(x.colors, function(c) { return toColor(c); });\n});\n\nmodule.exports = self;\n\n\n//# sourceURL=webpack://STK/./js/lib/util/Colors.js?");

/***/ }),

/***/ "./js/lib/util/ImageUtil.js":
/*!**********************************!*\
  !*** ./js/lib/util/ImageUtil.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Utility functions for working with scenes\n * @module ImageUtil\n */\nvar ImageUtil = {};\nvar Constants = __webpack_require__(/*! Constants */ \"./js/lib/Constants.js\");\nvar Colors = __webpack_require__(/*! util/Colors */ \"./js/lib/util/Colors.js\");\nvar TypeUtils = __webpack_require__(/*! data/TypeUtils */ \"./js/lib/data/TypeUtils.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\nImageUtil.DISABLE_IMAGE_RESIZE = false;\n\n/**\n * Extract image data from element\n * @param image\n * @return {{data: *, width: int, height: int}}\n * @static\n */\nfunction getImageData (image) {\n  if (image.data) {\n    return { data: image.data, width: image.width, height: image.height, channels: image.channels };\n  }\n  // Use document canvas to draw image\n  if (document) {\n    var canvas = document.createElement('canvas');\n    canvas.width = image.width;\n    canvas.height = image.height;\n    var context = canvas.getContext('2d');\n    if (context) {\n      context.drawImage(image, 0, 0);\n      return context.getImageData(0, 0, image.width, image.height);\n    }\n  }\n  console.error('Cannot get image data: cannot create context');\n}\nImageUtil.getImageData = getImageData;\n\nfunction recolorImageData(image, recolorFn) {\n  var imageData = getImageData(image);\n  var data = imageData.data;\n  for (var i = 0; i < data.length; i+=4) {\n    recolorFn(data, i);\n  }\n  return imageData;\n}\n\nImageUtil.recolorImageData = recolorImageData;\n\nfunction toSharpImage(image) {\n  if (ImageUtil.sharp) {\n    if (_.isPlainObject(image)) {\n      var imageData = {data: image.data, width: image.width, height: image.height, channels: image.channels};\n      // TODO(AXC): Remove this weird hack!!!!\n      var buffer = imageData.data.buffer || imageData.data;\n      if (Constants.sys && Constants.sys.Buffer) {\n        buffer = new Constants.sys.Buffer(buffer);\n      }\n      return ImageUtil.sharp(buffer, {raw: {width: image.width, height: image.height, channels: image.channels || 4}});\n    } else {\n      if (Constants.sys && Constants.sys.Buffer) {\n        return ImageUtil.sharp(Constants.sys.Buffer.from(image)).toColorspace('srgb');\n      }\n    }\n  }\n}\n\nfunction toMimeType(image, options, callback) {\n  var sharpImage = toSharpImage(image);\n  try {\n    if (sharpImage) {\n      if (options.mimeType.endsWith(\"jpeg\")) {\n        return sharpImage.jpeg(options).toBuffer(callback);\n      } else if (options.mimeType.endsWith(\"png\")) {\n        return sharpImage.png(options).toBuffer(callback);\n      } else {\n        callback(\"Unsupported mimeType: \" + options.mimeType);\n      }\n    }\n  } catch (e) {\n    callback(e);\n  }\n}\n\nImageUtil.toMimeType = toMimeType;\n\nfunction saveImage(image, path, callback) {\n  var sharpImage = toSharpImage(image);\n  try {\n    if (sharpImage) {\n      sharpImage.toFile(path, function (err, info) {\n        if (err) {\n          console.error('Error saving image to ' + path);\n        }\n        callback(err, info);\n      });\n    }\n  } catch (e) {\n    callback(e);\n  }\n}\n\nImageUtil.saveImage = saveImage;\n\nfunction bufferToRawPixels(buffer, callback) {\n  var sharpImage = toSharpImage(buffer);\n  if (sharpImage) {\n    sharpImage\n      .raw()\n      .toBuffer(function (err, data, info) {\n        if (err) {\n          callback(err);\n        } else {\n          // Make sure it is there is alpha channel\n          if (info.channels === 3) {\n            var npixels = info.width*info.height;\n            var withAlpha = Constants.sys.Buffer.alloc(npixels*4, 255);\n            for (var i = 0; i < npixels; i++) {\n              withAlpha[i*4] = data[i*3];\n              withAlpha[i*4+1] = data[i*3+1];\n              withAlpha[i*4+2] = data[i*3+2];\n            }\n            callback(err, {data: withAlpha, width: info.width, height: info.height, channels: 4});\n          } else {\n            callback(err, {data: data, width: info.width, height: info.height, channels: info.channels});\n          }\n        }\n      });\n  } else {\n    callback(\"Error reading image\");\n  }\n}\n\nImageUtil.bufferToRawPixels = bufferToRawPixels;\n\n// Copied from THREE WebGLTextures\nfunction isPowerOfTwo( image ) {\n  return THREE.Math.isPowerOfTwo(image.width) && THREE.Math.isPowerOfTwo(image.height);\n}\n\nfunction makePowerOfTwo(image, callback) {\n  var width = THREE.Math.floorPowerOfTwo( image.width );\n  var height = THREE.Math.floorPowerOfTwo( image.height );\n  if (document) {\n    var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\n    canvas.width = width;\n    canvas.height = height;\n    var context = canvas.getContext( '2d' );\n    if (context) {\n      context.drawImage(image, 0, 0, canvas.width, canvas.height);\n      callback(null, canvas);\n      return;\n    }\n  }\n  try {\n    var sharpImage = toSharpImage(image);\n    if (sharpImage) {\n        sharpImage.resize(width, height)\n        .toBuffer(function (err, data, info) {\n          if (err) {\n            callback(err, image);\n          } else {\n            callback(err, {src: image.src, path: image.path, data: data, width: info.width, height: info.height, channels: info.channels});\n          }\n        });\n    } else {\n      callback('Cannot resize image to power of two', image);\n    }\n  } catch (e) {\n    callback(e, image);\n  }\n}\n\nfunction textureNeedsPowerOfTwo( texture ) {\n  return ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) ||\n    ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter );\n}\n\nfunction ensurePowerOfTwo(image, texture, callback) {\n  if ( !ImageUtil.DISABLE_IMAGE_RESIZE && (!texture || textureNeedsPowerOfTwo(texture)) && !isPowerOfTwo(image)) {\n    return makePowerOfTwo(image, callback);\n  } else {\n    return callback(null, image);\n  }\n}\nImageUtil.ensurePowerOfTwo = ensurePowerOfTwo;\n\nfunction getIndexCounts(pixels, remapIndexFn) {\n  // pixels should be UInt8Array where each pixel is RGBA\n  var counts = {};\n  for (var i = 0; i < pixels.length; i+=4) {\n    // Convert to ARGB\n    var index = ((255-pixels[i+3]) << 24) ^ (pixels[i] << 16) ^ (pixels[i+1] << 8) ^ (pixels[i+2]) ;\n    if (remapIndexFn) {\n      index = remapIndexFn(index);\n    }\n    if (counts[index]) {\n      counts[index]++;\n    } else {\n      counts[index] = 1;\n    }\n  }\n  return counts;\n}\n\nImageUtil.getIndexCounts = getIndexCounts;\n\n// get counts for a rectangular region\nfunction getIndexCountsRect(pixelBuffer, rect, remapIndexFn) {\n  // pixels should be UInt8Array where each pixel is RGBA\n  var counts = {};\n  var pixels = pixelBuffer.data;\n  var numElementsPerRow = 4 * pixelBuffer.width;\n  for (var x = rect.min.x; x < rect.max.x; x++) {\n    for (var y = rect.min.y; y < rect.max.y; y++) {\n      var i = numElementsPerRow*y + 4*x;\n      // Convert to ARGB\n      var index = ((255-pixels[i+3]) << 24) ^ (pixels[i] << 16) ^ (pixels[i+1] << 8) ^ (pixels[i+2]) ;\n      if (remapIndexFn) {\n        index = remapIndexFn(index);\n      }\n      if (counts[index]) {\n        counts[index]++;\n      } else {\n        counts[index] = 1;\n      }\n    }\n  }\n  return counts;\n}\n\nImageUtil.getIndexCountsRect = getIndexCountsRect;\n\nfunction drawRect(pixelBuffer, rect, color, width) {\n  var pixels = pixelBuffer.data;\n  var numElementsPerRow = 4 * pixelBuffer.width;\n  var x1 = Math.max(rect.min.x, 0);\n  var x2 = Math.min(rect.max.x+1, pixelBuffer.width);\n  var y1 = Math.max(rect.min.y, 0);\n  var y2 = Math.min(rect.max.y+1, pixelBuffer.height);\n  for (var x = x1; x < x2; x++) {\n    for (var y = y1; y < y2; y++) {\n      var fill = false;\n      if (width > 0) {\n        fill = ((x - x1) < width || (x2 - x) <= width || (y - y1) < width || (y2 - y) <= width);\n      } else {\n        fill = true;\n      }\n      if (fill) {\n        var i = numElementsPerRow*y + 4*x;\n        pixels[i] = color.r*255;\n        pixels[i+1] = color.g*255;\n        pixels[i+2] = color.b*255;\n        pixels[i+3] = 255;\n      }\n    }\n  }\n}\nImageUtil.drawRect = drawRect;\n\nImageUtil.getPixel = function(pixelBuffer, x, y, fn) {\n  var d = pixelBuffer.data;\n  var numElementsPerRow = 4 * pixelBuffer.width;\n  var idx = numElementsPerRow*y + 4*x;\n  return fn? fn(d, idx) : d.slice(idx, idx+4);\n};\n\nImageUtil.decodePixelValue = function(array, offset) {\n  var i = offset || 0;\n  var d = array;\n  return ((255-d[i+3]) << 24) ^ (d[i] << 16) ^ (d[i+1] << 8) ^ (d[i+2]);\n};\n\nImageUtil.decodeVector3 = function(array, offset, normalize, out) {\n  out = out || new THREE.Vector3();\n  var i = offset || 0;\n  var d = array;\n  if (normalize) {\n    out.set(d[i]/255, d[i+1]/255, d[i+2]/255);\n  } else {\n    out.set(d[i], d[i+1], d[i+2]);\n  }\n  return out;\n};\n\nImageUtil.decodeNormal = function(array, offset, out) {\n  out = ImageUtil.decodeVector3(array, offset, true, out);\n  out.multiplyScalar(2).subScalar(1).normalize();\n  return out;\n};\n\n\nfunction combinePixels(pixelSet, combineFn) {\n  // pixels should be UInt8Array where each pixel is RGBA\n  var output = [];\n  var npixels = pixelSet[0].length;\n  for (var i = 0; i < npixels; i+=4) {\n    var slices = _.map(pixelSet, function(x) { return x.slice(i, i+4); });\n    output[i/4] = combineFn(slices);\n  }\n  return output;\n}\n\nImageUtil.combinePixels = combinePixels;\n\nfunction offsetToVector2(offset, width, height, toNormalized) {\n  var numElementsPerRow = width;\n  var y = Math.floor(offset/numElementsPerRow);\n  var x = Math.floor(offset - numElementsPerRow*y);\n  if (toNormalized) {\n    x = (x/width)*2-1;\n    y = (y/height)*2-1;  // TODO: sometimes need to be flipped too...\n  }\n  return new THREE.Vector2(x,y);\n}\nImageUtil.offsetToVector2 = offsetToVector2;\n\nfunction flipPixelsY(p, width, height) {\n  var t;\n  var numPixelsPerRow = 4 * width;\n  for (var row = 0; row < height / 2; row++) {\n    var yOut = height - row - 1;\n    var base = numPixelsPerRow * row;\n    var baseOut = numPixelsPerRow * yOut;\n    for (var col = 0; col < width; col++) {\n      var step = col << 2;  // 4*x\n      var idx = base + step;\n      var idxOut = baseOut + step;\n      t = p[idxOut    ]; p[idxOut    ] = p[idx    ]; p[idx    ] = t;  // R\n      t = p[idxOut + 1]; p[idxOut + 1] = p[idx + 1]; p[idx + 1] = t;  // G\n      t = p[idxOut + 2]; p[idxOut + 2] = p[idx + 2]; p[idx + 2] = t;  // B\n      t = p[idxOut + 3]; p[idxOut + 3] = p[idx + 3]; p[idx + 3] = t;  // A\n    }\n  }\n}\n\nImageUtil.flipPixelsY = flipPixelsY;\n\nfunction encodePixels(array, encodingFn, targetData) {\n  targetData = targetData || new Uint8Array(array.length);\n  for (var i = 0; i < array.length; i+=4) {\n    var v = encodingFn(array.slice(i, i+4));\n    targetData[i] = v[0];\n    targetData[i+1] = v[1];\n    targetData[i+2] = v[2];\n    targetData[i+3] = v[3];\n  }\n  return targetData;\n}\n\nImageUtil.encodePixels = encodePixels;\n\n\nfunction recolorIndexed(array, palette, targetData) {\n  return encodePixels(array, function(x) {\n    var index = ImageUtil.decodePixelValue(x);\n    var c = Colors.createColor(index, palette, true);\n    return [Math.floor(c.r*255), Math.floor(c.g*255), Math.floor(c.b*255), 255];\n  }, targetData);\n}\n\nImageUtil.recolorIndexed = recolorIndexed;\n\n\nfunction orthographicDepthToViewZ(near, far, d) {\n  return d * ( near - far ) - near;\n}\n\nfunction perspectiveDepthToViewZ(near, far, d) {\n  return ( near * far ) / ( ( far - near ) * d - far );\n}\n\nvar unpack_factors = [1.0/(256*256*256*256), 1.0/(256*256*256), 1.0/(256*256), 1.0/256];\n\nfunction unpackRGBAdepth(pixels, camera, datatype, metersToUnit, useBasicPacking) {\n  datatype = datatype || 'uint16';\n  metersToUnit = metersToUnit || 1000;  // millimeters\n\n  var scaleFactor = metersToUnit * Constants.virtualUnitToMeters;\n  var npixels = pixels.length / 4;\n  var arrayType = TypeUtils.nameToTypedArray(datatype);\n  var d = new arrayType(npixels);\n  var sum = 0;\n  var sum_opaque = 0;\n  var nopaque = 0;\n  // var min = Infinity;\n  // var max = -Infinity;\n  for (var i = 0; i < npixels; i++) {\n    var b = i << 2;  // 4 * i\n    var transparent = 0;\n    var pd = 0;\n    if (useBasicPacking) {\n      pd = pixels[b]/255;\n      transparent = (pixels[b+3] === 0);\n    } else {\n      for (var j = 0; j < 4; j++) {\n        pd += pixels[b + j] * unpack_factors[j];\n      }\n    }\n\n    var v = 0;\n    if (pd != 0) {  // Convert from packed depth buffer value pd to real depth v\n      if (camera.isOrthographicCamera || camera.inOrthographicMode)  {\n        v = -orthographicDepthToViewZ(camera.near, camera.far, pd);\n      } else {\n        // Assume other cases are perspective\n        v = -perspectiveDepthToViewZ(camera.near, camera.far, pd);\n      }\n      v = scaleFactor * v;\n      // min = Math.min(v, min);\n      // max = Math.max(v, max);\n    }\n\n    d[i] = v;  // NOTE: coerces v into datatype\n    sum += d[i];\n    if (!transparent) {\n      nopaque++;\n      sum_opaque++;\n    }\n  }\n  // console.log('min=' + min + ', max=' + max);\n  // console.log('min=' + _.min(d), 'max=' + _.max(d), 'ave=' + (sum/npixels), 'opaque_ave=' + (sum_opaque/nopaque), 'opaque=' + (nopaque/npixels));\n  return d;\n}\nImageUtil.unpackRGBAdepth = unpackRGBAdepth;\n\n\nmodule.exports = ImageUtil;\n\n\n//# sourceURL=webpack://STK/./js/lib/util/ImageUtil.js?");

/***/ }),

/***/ "./js/lib/util/LabelMapping.js":
/*!*************************************!*\
  !*** ./js/lib/util/LabelMapping.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Object3DUtil = __webpack_require__(/*! geo/Object3DUtil */ \"./js/lib/geo/Object3DUtil.js\");\nvar _ = __webpack_require__(/*! util/util */ \"./js/lib/util/util.js\");\n\n/**\n * Simple remapping of one label set to another\n * @param opts\n * @param opts.mapping {Map<string,Object>} Map of label to objects (object should contain `index` field)\n * @param [opts.name] {string} Name for mapping\n * @param [opts.maxIndex] {int} Max value of index\n * @param [opts.defaultIndex] {int} Default index to return for a label if label not found\n * @constructor\n * @memberOf util\n */\nfunction LabelMapping(opts) {\n  this.name = opts.name;\n  this.mapping = opts.mapping;\n  this.indices = _.uniq(_.map(this.mapping, function(m) { return m.index; }));\n  this.maxIndex = (opts.maxIndex != undefined)? opts.maxIndex : _.max(this.indices);\n  this.defaultIndex = opts.defaultIndex;\n}\n\nLabelMapping.prototype.index = function(label) {\n  return _.get(this.mapping, [label, 'index'], this.defaultIndex);\n};\n\nLabelMapping.prototype.indexOneOf = function(label) {\n  if (_.isArray(label)) {\n    for (var i = 0; i < label.length; i++) {\n      var m = this.mapping[label[i]];\n      if (m) { return m.index; }\n    }\n    return this.defaultIndex;\n  } else {\n    return this.index(label);\n  }\n};\n\nfunction Loader(params) {\n  this.opts = params;\n  this.fs = params.fs;\n}\n\nLoader.prototype.load = function(file, callback) {\n  var filename = file.name || file;\n  var scope = this;\n  this.fs.readAsync(file, 'utf-8', function(err, data) {\n    if (err) {\n      callback(err);\n    } else {\n      callback(null, scope.parse(filename, data));\n    }\n  });\n};\n\nLoader.prototype.parse = function(filename, data) {\n  var opts = _.defaults(Object.create(null), { filename: filename }, this.opts);\n  if (opts.fields && !opts.remapFields) {\n    opts.remapFields = _.invert(opts.fields);\n  }\n  if (!opts.keyBy) {\n    opts.keyBy = _.get(opts, 'remapFields.label', 'label');\n  }\n  var IOUtil = __webpack_require__(/*! io/IOUtil */ \"./js/lib/io/IOUtil.js\");\n  var parsed = IOUtil.parseDelimited(data, opts);\n  return new LabelMapping({ name: opts.name || filename, mapping: parsed.data, defaultIndex: opts.defaultIndex, maxIndex: opts.maxIndex });\n};\n\nLabelMapping.Loader = Loader;\n\nmodule.exports = LabelMapping;\n\n//# sourceURL=webpack://STK/./js/lib/util/LabelMapping.js?");

/***/ }),

/***/ "./js/lib/util/TaskQueue.js":
/*!**********************************!*\
  !*** ./js/lib/util/TaskQueue.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var PubSub = __webpack_require__(/*! PubSub */ \"./js/lib/PubSub.js\");\nvar async = __webpack_require__(/*! async */ \"../node_modules/async/dist/async.js\");\n\n/**\n * Basic task queue (wrapper around async.queue)\n * If we need more functionality, consider switching to https://github.com/diamondio/better-queue\n * @param opts Options to the task queue\n * @param [opts.concurrency=1] {int} Max number of concurrent tasks\n * @param [opts.taskHandler] {function(task,callback)} What to do for each task.  By default, the task will be called with the callback function.\n * @constructor\n */\nfunction TaskQueue(opts) {\n  PubSub.call(this);\n  opts = opts || {};\n  var concurrency = opts.concurrency || 1;\n  var handler = opts.taskHandler || function(task, callback) {\n      task(callback);\n  };\n  var scope = this;\n  this.__queue = async.queue(handler, concurrency);\n  this.__queue.drain = function() {\n    scope.Publish('drain');\n  };\n}\n\nTaskQueue.prototype = Object.create(PubSub.prototype);\nTaskQueue.prototype.constructor = TaskQueue;\n\n/**\n * Queue another task onto the task queue\n * @param task\n */\nTaskQueue.prototype.push = function(task) {\n  this.__queue.push(task);\n};\n\n/**\n * Queue another task onto the task queue (alias for queue)\n * @param task\n */\nTaskQueue.prototype.defer = function(task) {\n  this.push(task);\n};\n\n/**\n * Wait for all tasks to finish\n * @param callback\n */\nTaskQueue.prototype.awaitAll = function(callback) {\n  if (this.__queue.idle()) {\n    setTimeout(function() { callback(); }, 0);\n  } else {\n    var scope = this;\n    this.SubscribeOnce('drain', this, function() {\n      // Keep waiting until it done, really really done!\n      setTimeout(function() { scope.awaitAll(callback); }, 0);\n    });\n  }\n};\n\nmodule.exports = TaskQueue;\n\n//# sourceURL=webpack://STK/./js/lib/util/TaskQueue.js?");

/***/ }),

/***/ "./js/lib/util/util.js":
/*!*****************************!*\
  !*** ./js/lib/util/util.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Provides various utility functions on top of existing functions already provided by lodash.\n * @module util\n * @extends lodash\n **/\n\nvar _ = __webpack_require__(/*! lodash */ \"../node_modules/lodash/lodash.js\");\n\nvar JSONUtil = __webpack_require__(/*! io/JSONUtil */ \"./js/lib/io/JSONUtil.js\");\n_.getJSON = JSONUtil.getJSON;\n\n_.gotoURL = function(url) {\n  window.location.replace(url);\n};\n\nvar Ajax = __webpack_require__(/*! io/Ajax */ \"./js/lib/io/Ajax.js\");\n_.mixin(Ajax);\n\n_.toPromise = function(cbFn) {\n  return new Promise((resolve, reject) =>\n      cbFn((err, res) => { if (err) { reject(err); } else { resolve(res); } }));\n};\n\nvar RNG = __webpack_require__(/*! math/RNG */ \"./js/lib/math/RNG.js\");\n/** generate a random id of specified length */\nfunction generateRandomId(charCount, charSet) {\n  charCount = charCount || 5;\n  charSet = charSet || 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n  var charSetSize = charSet.length;\n  var id = '';\n  for (var i = 1; i <= charCount; i++) {\n    var randPos = Math.floor(RNG.global.random() * charSetSize);\n    id += charSet[randPos];\n  }\n  return id;\n}\n\n_.generateRandomId = generateRandomId;\n\nfunction basicIterator(start, end, incr, getElement) {\n  incr = incr || 1;\n  getElement = getElement || function(i) { return i; };\n  this.index = start;\n  this.next = function() {\n    if (this.index < end) {\n      var res = getElement(this.index);\n      this.index += incr;\n      return { value: res, done: false };\n    } else {\n      return { done: true };\n    }\n  };\n}\n\n_.getIterator = function(start, end, incr, getElement) { return new basicIterator(start, end, incr, getElement); };\n\n_.getEnumValue = function(v, name, values) {\n  var ev = values[v];\n  if (ev == undefined) {\n    throw 'Invalid value ' + ev + ' for ' + name;\n  } else {\n    return ev;\n  }\n};\n\n_.isReversed = function(a1, a2) {\n  if (a1.length === a2.length) {\n    var matched = true;\n    for (var j = 0; j < a1.length; j++) {\n      if (a1[j] !== a2[a2.length - j - 1]) {\n        matched = false;\n        break;\n      }\n    }\n    return matched;\n  } else {\n    return false;\n  }\n};\n\n_.templatizeCollection = function(d) {\n  _.each(d, function (v, k) {\n    if (typeof (v) === 'string') {\n      d[k] = _.template(v);\n    }\n  });\n};\n\n/**\n * Resolve relative path wrt to base path\n * @param basePath {string}\n * @param relPath {string}\n * @returns {string}\n * @static\n */\nfunction getPath(basePath, relPath) {\n  var base = basePath;\n  var rel = relPath;\n  while (rel.startsWith(\"../\")) {\n    rel = rel.substr(3);\n    if (base.charAt(base.length-1) == \"/\") {\n      base = base.substr(0, base.length-1);\n    }\n    var n = base.lastIndexOf(\"/\");\n    if (n > 0) {\n      base = base.substr(0, n);\n    } else {\n      base = \"\";\n    }\n  }\n  if (base.endsWith(\"/\") || base === \"\")\n    return base + rel;\n  else return base + \"/\" + rel;\n}\n_.getPath = getPath;\n\n_.getFileExtension = function(str) {\n  var parts = str.split('.');\n  if (parts.length > 1) {\n    return parts[parts.length-1];\n  } else {\n    return '';\n  }\n};\n\n_.getDirname = function(str) {\n  var n = str.lastIndexOf(\"/\");\n  if (n >= 0) {\n    return str.substr(0, n+1);\n  } else {\n    return \"\";\n  }\n};\n\n// Take a string and returns ascii char codes\n_.toCharCodes = function(s) {\n  return _.map(s, function (x) {\n    return x.charCodeAt(0);\n  });\n};\n\n// Take a string and encode first 4 characters as int32\n_.strToInt32 = function(s) {\n  var c = _.toCharCodes(s);\n  return c[0] << 24 ^ c[1] << 16 ^ c[2] << 8 ^ c[3] << 0;\n};\n\n_.getUrlParams = function () {\n  var nestedParamRegex = /^(.+)\\[(.+)\\]$/;\n  var vars = {}, hash;\n  var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');\n  for(var i = 0; i < hashes.length; i++) {\n    hash = hashes[i].split('=');\n    var name = decodeURIComponent(hash[0]);\n    var value = decodeURIComponent(hash[1]);\n    var lowercase = value.toLowerCase();\n    if (lowercase === 'false') { value = false; }\n    else if (lowercase === 'true') { value = true; }\n    //vars.push(name);\n    var m = name.match(nestedParamRegex);\n    if (m) {\n      var n1 = m[1];\n      var n2 = m[2];\n      if (!vars[n1]) { vars[n1] = {}; }\n      vars[n1][n2] = value;\n    } else {\n      vars[name] = value;\n    }\n  }\n  return vars;\n};\n\n_.getUrlParam = function (name, defaultValue, parseFn) {\n  var v = _.getUrlParams()[name];\n  v = (v != undefined)? v : defaultValue;\n  if (parseFn) {\n    v = parseFn(v);\n  }\n  return v;\n};\n\n// Stuffs arguments into object\nfunction processArguments(args, argNames) {\n  if (args.length === 1) {\n    // Assume single argument is object - return as is\n    return args[0];\n  } else {\n    var res = {};\n    var n = Math.min(argNames.length, args.length);\n    for (var i = 0; i < n; i++) {\n      res[argNames[i]] = args[i];\n    }\n    return res;\n  }\n}\n\n_.processArguments = processArguments;\n\n// Prepares str for csv encoding for escaping it\nfunction escapeCsv(str, formatter) {\n  if (str == undefined) { str = ''; }\n  if (formatter) {\n    str = formatter(str);\n  }\n  var result = str.toString().replace(/\"/g, '\"\"');\n  if (result.search(/(\"|,|\\n)/g) >= 0) {\n    result = '\"' + result + '\"';\n  }\n  return result;\n}\n\n_.escapeCsv = escapeCsv;\n\nfunction toDelimitedString(rec, delimiter, fields, constants, formatter) {\n  var list = rec;\n  if (!_.isArray(list)) {\n    list = _.map(fields, function(f) { return list[f]; });\n  }\n  if (delimiter === ',') {\n    list = _.map(list, function(x) { return escapeCsv(x, formatter); } );\n  }\n  if (constants) {\n    list = _.concat(constants, list);\n  }\n  return list.join(delimiter);\n}\n\n_.toDelimitedString = toDelimitedString;\n\n/**\n * Takes a string and returns a hash using letters [0-9a-b]\n * @static\n */\nfunction strhash( str ) {\n  if (str.length % 32 > 0) str += Array(33 - str.length % 32).join(\"z\");\n  var hash = '';\n  var bytes = [];\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var a = 0;\n  var dict = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','1','2','3','4','5','6','7','8','9'];\n  for (i = 0; i < str.length; i++ ) {\n    var ch = str.charCodeAt(i);\n    bytes[j++] = (ch < 127) ? ch & 0xFF : 127;\n  }\n  var chunk_len = Math.ceil(bytes.length / 32);\n  for (i=0; i<bytes.length; i++) {\n    j += bytes[i];\n    k++;\n    if ((k == chunk_len) || (i == bytes.length-1)) {\n      a = Math.floor( j / k );\n      if (a < 32)\n        hash += '0';\n      else if (a > 126)\n        hash += 'z';\n      else\n        hash += dict[  Math.floor( (a-32) / 2.76) ];\n      j = k = 0;\n    }\n  }\n  return hash;\n}\n_.strhash = strhash;\n\nfunction snapTo(n, d) {\n  var i = Math.round(n/d);\n  return i*d;\n}\n\n_.snapTo = snapTo;\n\nvar EPSILON = 10e-10;\nfunction roundIfClose(v, epsilon) {\n  epsilon = epsilon || EPSILON;\n  var r = Math.round(v);\n  return (Math.abs(v-r) < epsilon)?  r:v;\n}\n\n_.roundIfClose = roundIfClose;\n\n/**\n * Invert map of arrays: `{ string: [k1, k2...], ...}  to { k1: string, k2: string,...}`\n * @static\n */\nfunction invertMulti(map, iteratee) {\n  var res = {};\n  if (typeof iteratee === 'string') {\n    var field = iteratee;\n    iteratee = function(v, k) { return _.get(v, field); };\n  }\n  _.each(map, function(v,k) {\n    var els = iteratee? iteratee(v,k) : v;\n    for (var i = 0; i < els.length; i++) {\n      res[els[i]] = k;\n    }\n  });\n  return res;\n}\n\n_.invertMulti = invertMulti;\n\n/**\n * Group by array element.\n * @param collection\n * @param iteratee\n * @example\n * // returns { k1: [ {id: 1, ...}, ... ],\n * //           k2: [ {id: 1, ...}, ... ],\n * //           k3: [ {id: 2, ...}, ... ],\n * //           k4: [ {id: 2, ...}, ...],\n * //           ...}\n * groupByMulti([ { id: 1, a: [k1, k2...], ...}, { id: 2, a: [k3, k4],...},... ])\n * @static\n */\nfunction groupByMulti(collection, iteratee) {\n  var res = {};\n  if (typeof iteratee === 'string') {\n    var field = iteratee;\n    iteratee = function(v, k) { return v[field]; };\n  }\n  _.each(collection, function(v,k) {\n    var keys = iteratee(v,k);\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      if (res[key]) {\n        res[key].push(v);\n      } else {\n        res[key] = [v];\n      }\n    }\n  });\n  return res;\n}\n\n_.groupByMulti = groupByMulti;\n\n/**\n * Count by array element.\n * @param collection\n * @param iteratee\n * @example\n * // returns { k1: c1 ],\n * //           k2: c2 ],\n * //           k3: c3 ],\n * //           k4: c4 ],\n * //           ...}\n * countByMulti([ { id: 1, a: [k1, k2...], ...}, { id: 2, a: [k3, k4],...},... ])\n * @static\n */\nfunction countByMulti(collection, iteratee, aggrFn, countFn) {\n  var res = {};\n  if (typeof iteratee === 'string') {\n    var field = iteratee;\n    iteratee = function(v, k) { return v[field]; };\n  }\n  aggrFn = aggrFn || function(aggr, d) {\n    //console.log('aggregating', aggr, d);\n    if (aggr == undefined) { return d; }\n    else { return d + aggr; }\n  };\n  countFn = countFn || function(v,k) { return 1; };\n  _.each(collection, function(v,k) {\n    var keys = iteratee(v,k);\n    //console.log('processing', v, k, keys);\n    if (!Array.isArray(keys)) {\n      keys = [keys];\n    }\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      res[key] = aggrFn(res[key], countFn(v,k));\n    }\n  });\n  return res;\n}\n\n_.countByMulti = countByMulti;\n\n/**\n * Sort array and returns sorted array along with sortedIndices indicating the indices of the original array\n * @static\n */\nfunction sortWithIndices(toSort) {\n  var result = [];\n  for (var i = 0; i < toSort.length; i++) {\n    result[i] = [toSort[i], i];\n  }\n  result.sort(function(left, right) {\n    return (left[0] < right[0]) ? -1 : 1;\n  });\n  result.sortedIndices = [];\n  for (var j = 0; j < toSort.length; j++) {\n    result.sortedIndices.push(result[j][1]);\n    result[j] = result[j][0];\n  }\n  return result;\n}\n\n_.sortWithIndices = sortWithIndices;\n\n/**\n * Clamp value to between min and max\n * @param value {number} Value to clamp\n * @param min {number} Minimum value\n * @param max {number} Maximum value\n * @returns {number}\n * @static\n */\nfunction clamp(value, min, max) {\n  return Math.max( min, Math.min( max, value ) );\n}\n\n_.clamp = clamp;\n\nfunction safeDivide(n, d, defaultValue) {\n  if (d === 0) {\n     return defaultValue;\n  } else {\n    return n/d;\n  }\n}\n\n_.safeDivide = safeDivide;\n\n\nfunction parseRegex(string) {\n  if (string != null && typeof(string) === 'string') {\n    return new RegExp(string);\n  } else if (string instanceof RegExp) {\n    return string;\n  }\n}\n_.parseRegex = parseRegex;\n\nfunction parseSortBy(string) {\n  if (string != null && typeof(string) === 'string') {\n    var lc = string.toLowerCase();\n    if (lc.endsWith(' asc') || lc.endsWith(' desc')) {\n      var i = string.lastIndexOf(' ');\n      var fieldname = string.substr(0, i).trim();\n      var order = lc.substr(i).trim();\n      return { fieldname: fieldname, order: order };\n    } else {\n      return { fieldname: string, order: 'asc' };\n    }\n  }\n}\n_.parseSortBy = parseSortBy;\n\nfunction parseBoolean(string) {\n  if (string != null && typeof(string) === 'string') {\n    string = string.toLowerCase().trim();\n    return (string === 'true' || string === 'yes' || string === '1');\n  } else if (typeof(string) === 'boolean') {\n    return string;\n  } else {\n    return false;\n  }\n}\n\n_.parseBoolean = parseBoolean;\n\nfunction parseList(string, delimiter) {\n  delimiter = delimiter || ',';\n  if (string != null && typeof(string) === 'string') {\n    var list = string.split(delimiter).map(function(x) { return x.trim(); });\n    return list;\n  } else if (Array.isArray(string)) {\n    return string;\n  }\n}\n\n_.parseList = parseList;\n\nfunction parseVector(string, delimiter) {\n  delimiter = delimiter || ',';\n  if (string != null && typeof(string) === 'string') {\n    var list = string.split(delimiter).map(function(x) { return parseFloat(x.trim()); });\n    return list;\n  } else if (Array.isArray(string)) {\n    return string;\n  }\n}\n\n_.parseVector = parseVector;\n\n_.cmd = {\n  parseBoolean: function(x, accum) { return parseBoolean(x); },\n  parseList: function(x, accum) { return parseList(x); },\n  parseFloat: function(x, accum) { return parseFloat(x); },\n  parseInt: function(x, accum) { return parseInt(x); },\n  parseVector: function(x, accum) { return parseVector(x); },\n  parseRegex: function(x, accum) { return parseRegex(x); },\n  collect: function(x, accum) {\n    accum.push(x);\n    return accum;\n  }\n};\n\n_.replaceVars = function (str, vars) {\n  if (str && _.isString(str) && str.indexOf('${') >= 0) {\n    for (var v in vars) {\n      if (vars.hasOwnProperty(v)) {\n        var target = '${' + v + '}';\n        if (str.indexOf(target) >= 0) {\n          str = _.replaceAll(str, target, vars[v]);\n          if (str.indexOf('${') < 0) {\n            break;\n          }\n        }\n      }\n    }\n  }\n  return str;\n};\n\n_.cloneDeepWithReplaceVars = function (obj, vars, opts) {\n  if (opts && opts.optionalPrefix) {\n    var extraVars = {};\n    _.each(vars, function(v,k) {\n      extraVars[k] = v;\n      extraVars[opts.optionalPrefix + '.' + k] = v;\n    });\n    //console.log('extraVars', extraVars)\n    vars = extraVars;\n  }\n  var cloned =  _.cloneDeepWith(obj, function (x) {\n    if (_.isString(x)) { return _.replaceVars(x, vars); }\n  });\n  return cloned;\n};\n\n_.appendVarPrefix = function (str, name) {\n  if (str && _.isString(str)) {\n    str = str.replace(/\\$\\{([a-zA-Z_0-9]+)\\}/g, '${' + name + '.$1}');\n  }\n  return str;\n};\n\nfunction findVars(obj, vars) {\n  if (obj) {\n    if (_.isString(obj)) {\n      var matched = obj.match(/\\$\\{([a-zA-Z_0-9.]+)\\}/g);\n      if (matched) {\n        for (var i = 0; i < matched.length; i++) {\n          vars.add(matched[i]);\n        }\n      }\n    } else if (_.isPlainObject(obj) || _.isArray(obj)) {\n      _.each(obj, function(v,k) {\n        findVars(v, vars);\n      });\n    }\n  }\n  return vars;\n}\n\n_.findVars = function (obj) {\n  var vars = findVars(obj, new Set());\n  var res = [];\n  vars.forEach(function(v) {\n    res.push(v.substring(2,v.length-1));\n  });\n  return res;\n};\n\n_.createDefaultVars = function (obj, prefix) {\n  prefix = prefix || '';\n  var vars = _.findVars(obj);\n  var defaults = {};\n  for (var i = 0; i < vars.length; i++) {\n    var path = vars[i];\n    _.set(defaults, path, '${' + prefix + path + '}');\n  }\n  return defaults;\n};\n\n// Interpolate lodash templates with values in vars\n_.interpolate = function(obj, vars, options) {\n  // Default options to template\n  var defaultOptions = { imports: { '_': _ }, strict: false };\n  options = _.defaults(Object.create(null), options || {}, defaultOptions);\n  // Default variables\n  var defaultVars = options.defaults || {};\n  vars = _.defaults(Object.create(null), vars, defaultVars);\n  // Clone and replace!\n  var cloned =  _.cloneDeepWith(obj, function (value, key, parent, stack) {\n    var root = stack? stack.get(obj) : {};\n    var parentVars = stack? stack.get(parent) : {};\n    if (_.isString(value) && (!options.isPossibleTemplate || options.isPossibleTemplate(value))) {\n      var v = _.merge(vars, root);\n      v = _.defaults(Object.create(null), parentVars, v);\n      var t = _.template(value, options);\n      //console.log('resolving template ', value, v);\n      var r = t(v);\n      if (options.inferType) {\n        if (r === 'true') {\n          return true;\n        } else if (r === 'false') {\n          return false;\n        }\n      }\n      return r;\n    }\n  });\n  return cloned;\n};\n\n_.splitPrefixId = function(prefixLength, separator, id) {\n  var prefix = id.substr(0,prefixLength);\n  var rest = id.substr(prefixLength);\n  var path = '';\n  for (var i = 0; i < prefix.length; i++) {\n    path = path + prefix.charAt(i) + separator;\n  }\n  path = path + rest;\n  return path;\n};\n\n_.getPrefix = function(prefixLength, separator, id) {\n  var prefix = id.substr(0,prefixLength);\n  var rest = id.substr(prefixLength);\n  var path = '';\n  for (var i = 0; i < prefix.length; i++) {\n    path = path + prefix.charAt(i) + separator;\n  }\n  return path;\n};\n\n// Lodash product/permutation (https://gist.github.com/wassname/a882ac3981c8e18d2556)\n/**\n * Lodash mixins for combinatorics\n * Inspired by python itertools: https://docs.python.org/2.7/library/itertools.html\n *\n * Usage:\n *   permutations([0,1,2],2)                 // [[0,1],[0,2],[1,0],[1,2],[2,0],[2,1]]\n *   combinations([0,1,2],2)                 // [[0,1],[0,2],[1,2]]\n *   combinations_with_replacement([0,1,2],2)// [[0,0],[0,1],[0,2],[1,1],[1,2],[2,2]]\n *   product([0,1,2],[0,1,2])                // [[0,0],[0,1],[0,2],[1,0],[1,1],[1,2],[2,0],[2,1],[2,2]]\n *\n * Multiple input types:\n *   product('me','hi')\n *   product({who:['me','you'],say:['hi','by']})\n *   product(['me','you'],['hi','by'])\n *   product(['me','hi'])\n *   combinations([0,1,2,3],2)\n *   permutations([1,2,3],2)\n *   permutations('cat',2)\n */\n\n/**\n * Generate all combination of arguments when given arrays or strings\n * e.g. [['Ben','Jade','Darren'],['Smith','Miller']] to [['Ben','Smith'],[..]]\n * e.g. 'the','cat' to [['t', 'c'],['t', 'a'], ...]\n * @private\n **/\nfunction _cartesianProductOf(args) {\n  if (arguments.length>1) args=_.toArray(arguments);\n\n  // strings to arrays of letters\n  args=_.map(args, function(opt) { return typeof opt==='string'?_.toArray(opt):opt; } );\n\n  return _.reduce(args, function(a, b) {\n    return _.flatten(_.map(a, function(x) {\n      return _.map(b, function(y) {\n        return _.concat(x,[y]);\n      });\n    }), true);\n  }, [ [] ]);\n}\n\n/** Generate all combination of arguments from objects\n *  {Object} opts    - An object or arrays with keys describing options  {firstName:['Ben','Jade','Darren'],lastName:['Smith','Miller']}\n *  {Array}        - An array of objects e.g. [{firstName:'Ben',LastName:'Smith'},{..]\n * @private\n * @static\n **/\nfunction _cartesianProductObj(optObj){\n  var keys = _.keys(optObj);\n  var opts = _.values(optObj);\n  var combs = _cartesianProductOf(opts);\n  return _.map(combs,function(comb){\n    return _.zipObject(keys,comb);\n  });\n}\n\n/**\n * Generate the cartesian product of input objects, arrays, or strings\n *\n * @example\n * product('me','hi')\n * // => [[\"m\",\"h\"],[\"m\",\"i\"],[\"e\",\"h\"],[\"e\",\"i\"]]\n *\n * @example\n * product([1,2,3],['a','b','c']\n * // => [[1,\"a\"],[1,\"b\"],[1,\"c\"],[2,\"a\"],[2,\"b\"],[2,\"c\"],[3,\"a\"],[3,\"b\"],[3,\"c\"]]\n *\n * @example\n * product({who:['me','you'],say:['hi','by']})\n * // => [{\"who\":\"me\",\"say\":\"hi\"},{\"who\":\"me\",\"say\":\"by\"},{\"who\":\"you\",\"say\":\"hi\"},{\"who\":\"you\",\"say\":\"by\"}]\n *\n * @example\n * // It also takes in a single array of args\n * product(['me','hi'])\n * // => [[\"m\",\"h\"],[\"m\",\"i\"],[\"e\",\"h\"],[\"e\",\"i\"]]\n * @static\n */\nfunction product(opts){\n  if (arguments.length===1 && !_.isArray(opts))\n    return _cartesianProductObj(opts);\n  else if (arguments.length===1)\n    return _cartesianProductOf(opts);\n  else\n    return _cartesianProductOf(arguments);\n}\n\n/**\n * Generate permutations, in all possible orderings, with no repeat values\n *\n * @example\n * permutations([1,2,3],2)\n * // => [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]\n *\n * @example\n * permutations('cat',2)\n * // => [[\"c\",\"a\"],[\"c\",\"t\"],[\"a\",\"c\"],[\"a\",\"t\"],[\"t\",\"c\"],[\"t\",\"a\"]]\n * @static\n */\nfunction permutations(obj, n){\n  if (typeof obj=='string') obj = _.toArray(obj);\n  n = n?n:obj.length;\n  // make n copies of keys/indices\n  for (var j = 0, nInds=[]; j < n; j++) {\n    nInds.push(_.keys(obj));\n  }\n  // get product of the indices, then filter to remove the same key twice\n  var arrangements = product(nInds).filter(function(pair) { return pair[0]!==pair[1]; });\n  return _.map(arrangements, function(indices) { return _.map(indices, function(i) { return obj[i]; }); });\n}\n\n\n\n/**\n * Generate n combinations of an object with no repeat values in each combination.\n *\n * @example\n * combinations([0,1,2,3],2)\n * // => [[0,1],[0,2],[0,3],[1,2],[1,3],[2,3]]\n * @static\n */\nfunction combinations(obj,n){\n  /* filter out keys out of order, e.g. [0,1] is ok but [1,0] isn't */\n  function isSorted(arr) {\n    return _.every(arr, function (value, index, array) {\n      return index === 0 || String(array[index - 1]) <= String(value);\n    });\n  }\n  // array with n copies of the keys of obj\n  return _(permutations(_.keys(obj),n))\n      .filter(isSorted)\n      .map(function(indices) { return _.map(indices, function(i) { return obj[i]; }); })\n      .value();\n}\n\n/**\n * Generate n combinations with repeat values.\n *\n * @example\n * combinations_with_replacement([0,1,2,3],2)\n * // => [[0,0],[0,1],[0,2],[0,3],[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]\n * @static\n */\nfunction combinations_with_replacement(obj,n){\n  if (typeof obj=='string') obj = _.toArray(obj);\n  n = n?n:obj.length;\n  // make n copies of keys/indices\n  for (var j = 0, nInds=[]; j < n; j++) {nInds.push(_.keys(obj)); }\n  // get product of the indices, then filter to keep elements in order\n  var arrangements = product(nInds).filter(function(pair) { return pair[0] <= pair[1]; });\n  return _.map(arrangements,function(indices) { return _.map(indices, function(i) { return obj[i]; }); });\n}\n\n_.combinations_with_replacement = combinations_with_replacement;\n_.combinations = combinations;\n_.product = product;\n_.permutations = permutations;\n\n_.dynamicCompare = function (property) {\n  return function (a,b) {\n    return (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;\n  };\n};\n\n_.dynamicCompareMap = function (map, property) {\n  return function (a,b) {\n    return (map[a][property] < map[b][property]) ? -1 : (map[a][property] > map[b][property]) ? 1 : 0;\n  };\n};\n\n// We could use underscore.string/replaceAll but unfortunately,\n// it uses regular expressions so strings need to be escaped\n//var replaceAll = require('underscore.string/replaceAll');\n_.replaceAll = function (str, find, replacement){\n  var u;\n  while (true) {\n    u = str.replace(find, replacement);\n    if (u === str) return str;\n    str = u;\n  }\n};\n\n// Add to array unique\n_.addUnique = function(array, element) {\n  if (array.indexOf(element) < 0) {\n    array.push(element);\n  }\n};\n\n_.mapKeysDeep = function(object, iteratee) {\n  iteratee = iteratee || _.identity;\n  if (_.isPlainObject(object)) {\n    var remapped = _.mapKeys(object, iteratee);\n    remapped = _.mapValues(remapped, function (v) {\n      return _.mapKeysDeep(v, iteratee);\n    });\n    return remapped;\n  } else {\n    return object;\n  }\n};\n\n// Put back aliases that were removed in lodash 4\n// (https://github.com/lodash/lodash/wiki/Changelog#notable-changes)\n// These are useful for modules using older version of underscore/lodash\n// Notably visualsearch\n_.all = _.every;\n_.any = _.some;\n_.backflow = _.flowRight;\n_.callback = _.iteratee;\n_.collect = _.map;\n_.compose = _.flowRight;\n_.contains = _.includes;\n_.detect = _.find;\n_.foldl = _.reduce;\n_.foldr = _.reduceRight;\n_.include = _.includes;\n_.inject = _.reduce;\n_.methods = _.functions;\n//_.object = _.fromPairs or _.zipObject\n//_#run = _#value;\n_.select = _.filter;\n_.unique = _.uniq;\n\n//console.log(_());\nmodule.exports = _;\n\n\n//# sourceURL=webpack://STK/./js/lib/util/util.js?");

/***/ }),

/***/ "./js/vendor/jbinary/bitview.js":
/*!**************************************!*\
  !*** ./js/vendor/jbinary/bitview.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("BitView = function(buf) {\n  this.buffer = buf;\n  this.u8 = new Uint8Array(buf);\n};\n\nBitView.prototype.getBit = function(idx) {\n  var v = this.u8[idx >> 3];\n  var off = idx & 0x7;\n  return (v >> (7-off)) & 1;\n};\n\nBitView.prototype.setBit = function(idx, val) {\n  var off = idx & 0x7;\n  if (val) {\n    this.u8[idx >> 3] |= (0x80 >> off);\n  } else {\n    this.u8[idx >> 3] &= ~(0x80 >> off);\n  }\n};\n\nBitView.prototype.getInt12 = function(idx) {\n  var bidx = idx/8 | 0;\n  var a = this.u8[bidx];\n  var b = this.u8[bidx + 1];\n  var c = this.u8[bidx + 2];\n  var off = idx % 8;\n  var abits = 8-off;\n  var bbits = Math.min(12-abits, 8);\n  var cbits = Math.max(12-abits-bbits, 0);\n  var am = ~(0xff << (abits));\n  var bm = (0xff << (8-bbits));\n  var cm = (0xff << (8-cbits));\n  a &= am;\n  b &= bm;\n  c &= cm;\n  return (((a << 16) + (b << 8) + c) >> (12-off)) - 2048;\n};\n\nBitView.prototype.setInt12 = function(idx, val) {\n  val += 2048;\n  var bidx = idx/8 | 0;\n  var off = idx % 8;\n  var v = val << (12-off);\n  var a = (v & 0xff0000) >> 16;\n  var b = (v & 0x00ff00) >> 8;\n  var c = v & 0x0000ff;\n  var abits = 8-off;\n  var bbits = Math.min(12-abits, 8);\n  var cbits = Math.max(12-abits-bbits, 0);\n  var am = (0xff << (abits));\n  this.u8[bidx] = (this.u8[bidx] & am) + a;\n  var bm = ~(0xff << (8-bbits));\n  this.u8[bidx+1] = (this.u8[bidx+1] & bm) + b;\n  var cm = ~(0xff << (8-cbits));\n  this.u8[bidx+2] = (this.u8[bidx+2] & cm) + c;\n};\n\nBitView.prototype.getInt6 = function(idx) {\n  var bidx = idx/8 | 0;\n  var a = this.u8[bidx];\n  var b = this.u8[bidx + 1];\n  var off = idx % 8;\n  var abits = 8-off;\n  var bbits = Math.max(6-abits, 0);\n  var am = ~((0xff << (abits)) + (0xff >> (8-(2-off))));\n  var bm = (0xff << (8-bbits));\n  a &= am;\n  b &= bm;\n  return (((a << 8) + b) >> (10-off)) - 32;\n};\n\nBitView.prototype.setInt6 = function(idx, val) {\n  val += 32;\n  var bidx = idx/8 | 0;\n  var off = idx % 8;\n  var v = val << (10-off);\n  var a = (v & 0xff00) >> 8;\n  var b = (v & 0x00ff);\n  var abits = 8-off;\n  var bbits = Math.max(6-abits, 0);\n  var am = ((0xff << (abits)) + (0xff >> (8-(2-off))));\n  this.u8[bidx] = (this.u8[bidx] & am) + a;\n  var bm = ~(0xff << (8-bbits));\n  this.u8[bidx+1] = (this.u8[bidx+1] & bm) + b;\n};\n\nBitView.test = function() {\n  var buf = new ArrayBuffer(3);\n  var bv = new BitView(buf);\n  var i,j;\n  for (j=0; j<12; j++) {\n    for (i=-2048; i<2048; i++) { \n      bv.setInt12(j,i); \n      if (bv.getInt12(j) != i) {\n        console.log('12-bit prob at', j, i);\n        console.log('expected', i, 'got', bv.getInt12(j));\n        break;\n      }\n    }\n  }\n  for (j=0; j<18; j++) {\n    for (i=-32; i<32; i++) { \n      bv.setInt6(j,i); \n      if (bv.getInt6(j) != i) {\n        console.log('6-bit prob at', j, i);\n        console.log('expected', i, 'got', bv.getInt6(j));\n        break;\n      }\n    }\n  }\n  return bv;\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/jbinary/bitview.js?");

/***/ }),

/***/ "./js/vendor/jbinary/jbinary.js":
/*!**************************************!*\
  !*** ./js/vendor/jbinary/jbinary.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(a){var b=this; true?module.exports=a(b,__webpack_require__(/*! jdataview */ \"./js/vendor/jbinary/jdataview.js\")):undefined}(function(a,b){\"use strict\";function c(a,b){return b&&a instanceof b}function d(a){for(var b=1,c=arguments.length;c>b;++b){var d=arguments[b];for(var e in d)void 0!==d[e]&&(a[e]=d[e])}return a}function e(a){return arguments[0]=m(a),d.apply(null,arguments)}function f(a,b,d){return c(d,Function)?d.call(a,b.contexts[0]):d}function g(a){return function(){var b=arguments,d=b.length-1,e=a.length-1,f=b[d];if(b.length=e+1,!c(f,Function)){var g=this;return new l(function(c,d){b[e]=function(a,b){return a?d(a):c(b)},a.apply(g,b)})}b[d]=void 0,b[e]=f,a.apply(this,b)}}function h(a,d){return c(a,h)?a.as(d):(c(a,b)||(a=new b(a,void 0,void 0,d?d[\"jBinary.littleEndian\"]:void 0)),c(this,h)?(this.view=a,this.view.seek(0),this.contexts=[],this.as(d,!0)):new h(a,d))}function i(a){return e(i.prototype,a)}function j(a){return e(j.prototype,a,{createProperty:function(){var b=(a.createProperty||j.prototype.createProperty).apply(this,arguments);return b.getBaseType&&(b.baseType=b.binary.getType(b.getBaseType(b.binary.contexts[0]))),b}})}var k=a.document;\"atob\"in a&&\"btoa\"in a||!function(){function b(a){var b,c,e,f,g,h;for(e=a.length,c=0,b=\"\";e>c;){if(f=255&a.charCodeAt(c++),c==e){b+=d.charAt(f>>2),b+=d.charAt((3&f)<<4),b+=\"==\";break}if(g=a.charCodeAt(c++),c==e){b+=d.charAt(f>>2),b+=d.charAt((3&f)<<4|(240&g)>>4),b+=d.charAt((15&g)<<2),b+=\"=\";break}h=a.charCodeAt(c++),b+=d.charAt(f>>2),b+=d.charAt((3&f)<<4|(240&g)>>4),b+=d.charAt((15&g)<<2|(192&h)>>6),b+=d.charAt(63&h)}return b}function c(a){var b,c,d,f,g,h,i;for(h=a.length,g=0,i=\"\";h>g;){do b=e[255&a.charCodeAt(g++)];while(h>g&&-1==b);if(-1==b)break;do c=e[255&a.charCodeAt(g++)];while(h>g&&-1==c);if(-1==c)break;i+=String.fromCharCode(b<<2|(48&c)>>4);do{if(d=255&a.charCodeAt(g++),61==d)return i;d=e[d]}while(h>g&&-1==d);if(-1==d)break;i+=String.fromCharCode((15&c)<<4|(60&d)>>2);do{if(f=255&a.charCodeAt(g++),61==f)return i;f=e[f]}while(h>g&&-1==f);if(-1==f)break;i+=String.fromCharCode((3&d)<<6|f)}return i}var d=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",e=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1];a.btoa||(a.btoa=b),a.atob||(a.atob=c)}();var l=a.Promise||function(a){this.then=a},m=Object.create;m||(m=function(a){var b=function(){};return b.prototype=a,new b});var n=h.prototype,o=n.typeSet={};n.toValue=function(a){return f(this,this,a)},n._named=function(a,b,c){return a.displayName=b+\" @ \"+(void 0!==c?c:this.view.tell()),a};var p=Object.defineProperty;if(p)try{p({},\"x\",{})}catch(q){p=void 0}else p=function(a,b,c,d){d&&(a[b]=c.value)};var r=\"jBinary.Cache\",s=0;n._getCached=function(a,b,c){if(a.hasOwnProperty(this.cacheKey))return a[this.cacheKey];var d=b.call(this,a);return p(a,this.cacheKey,{value:d},c),d},n.getContext=function(a){switch(typeof a){case\"undefined\":a=0;case\"number\":return this.contexts[a];case\"string\":return this.getContext(function(b){return a in b});case\"function\":for(var b=0,c=this.contexts.length;c>b;b++){var d=this.contexts[b];if(a.call(this,d))return d}}},n.inContext=function(a,b){this.contexts.unshift(a);var c=b.call(this);return this.contexts.shift(),c},i.prototype={inherit:function(a,b){function c(a,b){var c=f[a];c&&(d||(d=e(f)),b.call(d,c),d[a]=null)}var d,f=this;return c(\"params\",function(b){for(var c=0,d=b.length;d>c;c++)this[b[c]]=a[c]}),c(\"setParams\",function(b){b.apply(this,a)}),c(\"typeParams\",function(a){for(var c=0,d=a.length;d>c;c++){var e=a[c],f=this[e];f&&(this[e]=b(f))}}),c(\"resolve\",function(a){a.call(this,b)}),d||f},createProperty:function(a){return e(this,{binary:a,view:a.view})},toValue:function(a,b){return b!==!1&&\"string\"==typeof a?this.binary.getContext(a)[a]:f(this,this.binary,a)}},h.Type=i,j.prototype=e(i.prototype,{setParams:function(){this.baseType&&(this.typeParams=[\"baseType\"].concat(this.typeParams||[]))},baseRead:function(){return this.binary.read(this.baseType)},baseWrite:function(a){return this.binary.write(this.baseType,a)}}),d(j.prototype,{read:j.prototype.baseRead,write:j.prototype.baseWrite}),h.Template=j,n.as=function(a,b){var c=b?this:e(this);return a=a||o,c.typeSet=a===o||o.isPrototypeOf(a)?a:e(o,a),c.cacheKey=r,c.cacheKey=c._getCached(a,function(){return r+\".\"+ ++s},!0),c},n.seek=function(a,b){if(a=this.toValue(a),void 0!==b){var c=this.view.tell();this.view.seek(a);var d=b.call(this);return this.view.seek(c),d}return this.view.seek(a)},n.tell=function(){return this.view.tell()},n.skip=function(a,b){return this.seek(this.tell()+this.toValue(a),b)},n.slice=function(a,b,c){return new h(this.view.slice(a,b,c),this.typeSet)},n._getType=function(a,b){switch(typeof a){case\"string\":if(!(a in this.typeSet))throw new ReferenceError(\"Unknown type: \"+a);return this._getType(this.typeSet[a],b);case\"number\":return this._getType(o.bitfield,[a]);case\"object\":if(c(a,i)){var d=this;return a.inherit(b||[],function(a){return d.getType(a)})}return c(a,Array)?this._getCached(a,function(a){return this.getType(a[0],a.slice(1))},!0):this._getCached(a,function(a){return this.getType(o.object,[a])},!1)}},n.getType=function(a,b){var d=this._getType(a,b);return d&&!c(a,i)&&(d.name=\"object\"==typeof a?c(a,Array)?a[0]+\"(\"+a.slice(1).join(\", \")+\")\":\"object\":String(a)),d},n._action=function(a,b,c){if(void 0!==a){a=this.getType(a);var d=this._named(function(){return c.call(this,a.createProperty(this),this.contexts[0])},\"[\"+a.name+\"]\",b);return void 0!==b?this.seek(b,d):d.call(this)}},n.read=function(a,b){return this._action(a,b,function(a,b){return a.read(b)})},n.readAll=function(){return this.read(\"jBinary.all\",0)},n.write=function(a,b,c){return this._action(a,c,function(a,c){var d=this.tell();return a.write(b,c),this.tell()-d})},n.writeAll=function(a){return this.write(\"jBinary.all\",a,0)},function(a,b){for(var c=0,d=b.length;d>c;c++){var f=b[c];o[f.toLowerCase()]=e(a,{dataType:f})}}(i({params:[\"littleEndian\"],read:function(){return this.view[\"get\"+this.dataType](void 0,this.littleEndian)},write:function(a){this.view[\"write\"+this.dataType](a,this.littleEndian)}}),[\"Uint8\",\"Uint16\",\"Uint32\",\"Uint64\",\"Int8\",\"Int16\",\"Int32\",\"Int64\",\"Float32\",\"Float64\",\"Char\"]),d(o,{\"byte\":o.uint8,\"float\":o.float32,\"double\":o.float64}),o.array=j({params:[\"baseType\",\"length\"],read:function(){var a=this.toValue(this.length);if(this.baseType===o.uint8)return this.view.getBytes(a,void 0,!0,!0);var b;if(void 0!==a){b=new Array(a);for(var c=0;a>c;c++)b[c]=this.baseRead()}else{var d=this.view.byteLength;for(b=[];this.binary.tell()<d;)b.push(this.baseRead())}return b},write:function(a){if(this.baseType===o.uint8)return this.view.writeBytes(a);for(var b=0,c=a.length;c>b;b++)this.baseWrite(a[b])}}),o.binary=j({params:[\"length\",\"typeSet\"],read:function(){var a=this.binary.tell(),b=this.binary.skip(this.toValue(this.length)),c=this.view.slice(a,b);return new h(c,this.typeSet)},write:function(a){this.binary.write(\"blob\",a.read(\"blob\",0))}}),o.bitfield=i({params:[\"bitSize\"],read:function(){return this.view.getUnsigned(this.bitSize)},write:function(a){this.view.writeUnsigned(a,this.bitSize)}}),o.blob=i({params:[\"length\"],read:function(){return this.view.getBytes(this.toValue(this.length))},write:function(a){this.view.writeBytes(a,!0)}}),o[\"const\"]=j({params:[\"baseType\",\"value\",\"strict\"],read:function(){var a=this.baseRead();if(this.strict&&a!==this.value){if(c(this.strict,Function))return this.strict(a);throw new TypeError(\"Unexpected value (\"+a+\" !== \"+this.value+\").\")}return a},write:function(a){this.baseWrite(this.strict||void 0===a?this.value:a)}}),o[\"enum\"]=j({params:[\"baseType\",\"matches\"],setParams:function(a,b){this.backMatches={};for(var c in b)this.backMatches[b[c]]=c},read:function(){var a=this.baseRead();return a in this.matches?this.matches[a]:a},write:function(a){this.baseWrite(a in this.backMatches?this.backMatches[a]:a)}}),o.extend=i({setParams:function(){this.parts=arguments},resolve:function(a){for(var b=this.parts,c=b.length,d=new Array(c),e=0;c>e;e++)d[e]=a(b[e]);this.parts=d},read:function(){var a=this.parts,b=this.binary.read(a[0]);return this.binary.inContext(b,function(){for(var c=1,e=a.length;e>c;c++)d(b,this.read(a[c]))}),b},write:function(a){var b=this.parts;this.binary.inContext(a,function(){for(var c=0,d=b.length;d>c;c++)this.write(b[c],a)})}}),o[\"if\"]=j({params:[\"condition\",\"trueType\",\"falseType\"],typeParams:[\"trueType\",\"falseType\"],getBaseType:function(){return this.toValue(this.condition)?this.trueType:this.falseType}}),o.if_not=o.ifNot=j({setParams:function(a,b,c){this.baseType=[\"if\",a,c,b]}}),o.lazy=j({marker:\"jBinary.Lazy\",params:[\"innerType\",\"length\"],getBaseType:function(){return[\"binary\",this.length,this.binary.typeSet]},read:function(){var a=function(b){return 0===arguments.length?\"value\"in a?a.value:a.value=a.binary.read(a.innerType):d(a,{wasChanged:!0,value:b}).value};return a[this.marker]=!0,d(a,{binary:d(this.baseRead(),{contexts:this.binary.contexts.slice()}),innerType:this.innerType})},write:function(a){a.wasChanged||!a[this.marker]?this.binary.write(this.innerType,a()):this.baseWrite(a.binary)}}),o.object=i({params:[\"structure\",\"proto\"],resolve:function(a){var b={};for(var d in this.structure)b[d]=c(this.structure[d],Function)?this.structure[d]:a(this.structure[d]);this.structure=b},read:function(){var a=this,b=this.structure,d=this.proto?e(this.proto):{};return this.binary.inContext(d,function(){for(var e in b)this._named(function(){var f=c(b[e],Function)?b[e].call(a,d):this.read(b[e]);void 0!==f&&(d[e]=f)},e).call(this)}),d},write:function(a){var b=this,d=this.structure;this.binary.inContext(a,function(){for(var e in d)this._named(function(){c(d[e],Function)?a[e]=d[e].call(b,a):this.write(d[e],a[e])},e).call(this)})}}),o.skip=i({params:[\"length\"],read:function(){this.view.skip(this.toValue(this.length))},write:function(){this.read()}}),o.string=j({params:[\"length\",\"encoding\"],read:function(){return this.view.getString(this.toValue(this.length),void 0,this.encoding)},write:function(a){this.view.writeString(a,this.encoding)}}),o.string0=i({params:[\"length\",\"encoding\"],read:function(){var a=this.view,b=this.length;if(void 0===b){var c,d=a.tell(),e=0;for(b=a.byteLength-d;b>e&&(c=a.getUint8());)e++;var f=a.getString(e,d,this.encoding);return b>e&&a.skip(1),f}return a.getString(b,void 0,this.encoding).replace(/\\0.*$/,\"\")},write:function(a){var b=this.view,c=void 0===this.length?1:this.length-a.length;b.writeString(a,void 0,this.encoding),c>0&&(b.writeUint8(0),b.skip(c-1))}});h.loadData=g(function(b,d){var e;if(c(b,a.Blob)){var f;if(\"FileReader\"in a)f=new FileReader,f.onload=f.onerror=function(){d(this.error,this.result)},f.readAsArrayBuffer(b);else{f=new FileReaderSync;var g,h;try{h=f.readAsArrayBuffer(b)}catch(i){g=i}finally{d(g,h)}}}else{if(\"string\"!=typeof b)d(new TypeError(\"Unsupported source type.\"));else if(e=b.match(/^data:(.+?)(;base64)?,(.*)$/))try{var j=e[2],k=e[3];d(null,(j?atob:decodeURIComponent)(k))}catch(i){d(i)}else if(\"XMLHttpRequest\"in a){var l=new XMLHttpRequest;l.open(\"GET\",b,!0),\"responseType\"in l?l.responseType=\"arraybuffer\":\"overrideMimeType\"in l?l.overrideMimeType(\"text/plain; charset=x-user-defined\"):l.setRequestHeader(\"Accept-Charset\",\"x-user-defined\"),\"onload\"in l||(l.onreadystatechange=function(){4===this.readyState&&this.onload()});var m=function(a){d(new Error(a))};l.onload=function(){return 0!==this.status&&200!==this.status?m(\"HTTP Error #\"+this.status+\": \"+this.statusText):(\"response\"in this||(this.response=new VBArray(this.responseBody).toArray()),void d(null,this.response))},l.onerror=function(){m(\"Network error.\")},l.send(null)}else d(new TypeError(\"Unsupported source type.\"))}}),h.load=g(function(a,b,c){var d=h.loadData(a);h.load.getTypeSet(a,b,function(a){d.then(function(b){c(null,new h(b,a))},c)})}),h.load.getTypeSet=function(a,b,c){c(b)},n._toURI=\"URL\"in a&&\"createObjectURL\"in URL?function(a){var b=this.seek(0,function(){return this.view.getBytes()});return URL.createObjectURL(new Blob([b],{type:a}))}:function(a){var b=this.seek(0,function(){return this.view.getString(void 0,void 0,\"binary\")});return\"data:\"+a+\";base64,\"+btoa(b)},n._mimeType=function(a){return a||this.typeSet[\"jBinary.mimeType\"]||\"application/octet-stream\"},n.toURI=function(a){return this._toURI(this._mimeType(a))};if(k){var t=h.downloader=k.createElement(\"a\");t.style.display=\"none\"}return n.saveAs=g(function(a,b,c){if(\"string\"==typeof a){\"msSaveBlob\"in navigator?navigator.msSaveBlob(new Blob([this.read(\"blob\",0)],{type:this._mimeType(b)}),a):k?(t.parentNode||k.body.appendChild(t),t.href=this.toURI(b),t.download=a,t.click(),t.href=t.download=\"\"):c(new TypeError(\"Saving from Web Worker is not supported.\")),c()}else c(new TypeError(\"Unsupported storage type.\"))}),h});\n//# sourceMappingURL=jbinary.js.map\n\n//# sourceURL=webpack://STK/./js/vendor/jbinary/jbinary.js?");

/***/ }),

/***/ "./js/vendor/jbinary/jdataview.js":
/*!****************************************!*\
  !*** ./js/vendor/jbinary/jdataview.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("!function(a){var b=this; true?module.exports=a(b):undefined}(function(a){\"use strict\";function b(a,b){return\"object\"!=typeof a||null===a?!1:a.constructor===b||Object.prototype.toString.call(a)===\"[object \"+b.name+\"]\"}function c(a,c){return!c&&b(a,Array)?a:Array.prototype.slice.call(a)}function d(a,b){return void 0!==a?a:b}function e(a,c,f,g){if(e.is(a)){var h=a.slice(c,c+f);return h._littleEndian=d(g,h._littleEndian),h}if(!e.is(this))return new e(a,c,f,g);if(this.buffer=a=e.wrapBuffer(a),this._isArrayBuffer=j.ArrayBuffer&&b(a,ArrayBuffer),this._isPixelData= true&&j.PixelData&&b(a,CanvasPixelArray),this._isDataView=j.DataView&&this._isArrayBuffer,this._isNodeBuffer=!1,!this._isArrayBuffer&&!this._isPixelData&&!b(a,Array))throw new TypeError(\"jDataView buffer has an incompatible type\");this._littleEndian=!!g;var i=\"byteLength\"in a?a.byteLength:a.length;this.byteOffset=c=d(c,0),this.byteLength=f=d(f,i-c),this._offset=this._bitOffset=0,this._isDataView?this._view=new DataView(a,c,f):this._checkBounds(c,f,i),this._engineAction=this._isDataView?this._dataViewAction:this._isArrayBuffer?this._arrayBufferAction:this._arrayAction}function f(a){for(var b=j.ArrayBuffer?Uint8Array:Array,c=new b(a.length),d=0,e=a.length;e>d;d++)c[d]=255&a.charCodeAt(d);return c}function g(a){return a>=0&&31>a?1<<a:g[a]||(g[a]=Math.pow(2,a))}function h(a,b){this.lo=a,this.hi=b}function i(){h.apply(this,arguments)}var j={NodeBuffer:!1,DataView:\"DataView\"in a,ArrayBuffer:\"ArrayBuffer\"in a,PixelData: true&&\"CanvasPixelArray\"in a&&!(\"Uint8ClampedArray\"in a)&&\"document\"in a},k=a.TextEncoder,l=a.TextDecoder;if(j.PixelData)var m=document.createElement(\"canvas\").getContext(\"2d\"),n=function(a,b){var c=m.createImageData((a+3)/4,1).data;if(c.byteLength=a,void 0!==b)for(var d=0;a>d;d++)c[d]=b[d];return c};var o={Int8:1,Int16:2,Int32:4,Uint8:1,Uint16:2,Uint32:4,Float32:4,Float64:8};e.wrapBuffer=function(a){switch(typeof a){case\"number\":if(j.ArrayBuffer)a=new Uint8Array(a).buffer;else if(j.PixelData)a=n(a);else{a=new Array(a);for(var d=0;d<a.length;d++)a[d]=0}return a;case\"string\":a=f(a);default:return\"length\"in a&&!(j.ArrayBuffer&&b(a,ArrayBuffer)||j.PixelData&&b(a,CanvasPixelArray))&&(j.ArrayBuffer?b(a,ArrayBuffer)||(a=new Uint8Array(a).buffer,b(a,ArrayBuffer)||(a=new Uint8Array(c(a,!0)).buffer)):a=j.PixelData?n(a.length,a):c(a)),a}},e.is=function(a){return a&&a.jDataView},e.from=function(){return new e(arguments)},e.Uint64=h,h.prototype={valueOf:function(){return this.lo+g(32)*this.hi},toString:function(){return Number.prototype.toString.apply(this.valueOf(),arguments)}},h.fromNumber=function(a){var b=Math.floor(a/g(32)),c=a-b*g(32);return new h(c,b)},e.Int64=i,i.prototype=\"create\"in Object?Object.create(h.prototype):new h,i.prototype.valueOf=function(){return this.hi<g(31)?h.prototype.valueOf.apply(this,arguments):-(g(32)-this.lo+g(32)*(g(32)-1-this.hi))},i.fromNumber=function(a){var b,c;if(a>=0){var d=h.fromNumber(a);b=d.lo,c=d.hi}else c=Math.floor(a/g(32)),b=a-c*g(32),c+=g(32);return new i(b,c)};var p=e.prototype={compatibility:j,jDataView:!0,_checkBounds:function(a,b,c){if(\"number\"!=typeof a)throw new TypeError(\"Offset is not a number.\");if(\"number\"!=typeof b)throw new TypeError(\"Size is not a number.\");if(0>b)throw new RangeError(\"Length is negative.\");if(0>a||a+b>d(c,this.byteLength))throw new RangeError(\"Offsets are out of bounds.\")},_action:function(a,b,c,e,f){return this._engineAction(a,b,d(c,this._offset),d(e,this._littleEndian),f)},_dataViewAction:function(a,b,c,d,e){return this._offset=c+o[a],b?this._view[\"get\"+a](c,d):this._view[\"set\"+a](c,e,d)},_arrayBufferAction:function(b,c,e,f,g){var h,i=o[b],j=a[b+\"Array\"];if(f=d(f,this._littleEndian),1===i||(this.byteOffset+e)%i===0&&f)return h=new j(this.buffer,this.byteOffset+e,1),this._offset=e+i,c?h[0]:h[0]=g;var k=new Uint8Array(c?this.getBytes(i,e,f,!0):i);return h=new j(k.buffer,0,1),c?h[0]:(h[0]=g,void this._setBytes(e,k,f))},_arrayAction:function(a,b,c,d,e){return b?this[\"_get\"+a](c,d):this[\"_set\"+a](c,e,d)},_getBytes:function(a,b,e){e=d(e,this._littleEndian),b=d(b,this._offset),a=d(a,this.byteLength-b),this._checkBounds(b,a),b+=this.byteOffset,this._offset=b-this.byteOffset+a;var f=this._isArrayBuffer?new Uint8Array(this.buffer,b,a):(this.buffer.slice||Array.prototype.slice).call(this.buffer,b,b+a);return e||1>=a?f:c(f).reverse()},getBytes:function(a,b,e,f){var g=this._getBytes(a,b,d(e,!0));return f?c(g):g},_setBytes:function(a,b,e){var f=b.length;if(0!==f){if(e=d(e,this._littleEndian),a=d(a,this._offset),this._checkBounds(a,f),!e&&f>1&&(b=c(b,!0).reverse()),a+=this.byteOffset,this._isArrayBuffer)new Uint8Array(this.buffer,a,f).set(b);else for(var g=0;f>g;g++)this.buffer[a+g]=b[g];this._offset=a-this.byteOffset+f}},setBytes:function(a,b,c){this._setBytes(a,b,d(c,!0))},getString:function(a,b,c){var d=this._getBytes(a,b,!0);if(c=\"utf8\"===c?\"utf-8\":c||\"binary\",l&&\"binary\"!==c)return new l(c).decode(this._isArrayBuffer?d:new Uint8Array(d));var e=\"\";a=d.length;for(var f=0;a>f;f++)e+=String.fromCharCode(d[f]);return\"utf-8\"===c&&(e=decodeURIComponent(escape(e))),e},setString:function(a,b,c){c=\"utf8\"===c?\"utf-8\":c||\"binary\";var d;k&&\"binary\"!==c?d=new k(c).encode(b):(\"utf-8\"===c&&(b=unescape(encodeURIComponent(b))),d=f(b)),this._setBytes(a,d,!0)},getChar:function(a){return this.getString(1,a)},setChar:function(a,b){this.setString(a,b)},tell:function(){return this._offset},seek:function(a){return this._checkBounds(a,0),this._offset=a},skip:function(a){return this.seek(this._offset+a)},slice:function(a,b,c){function f(a,b){return 0>a?a+b:a}return a=f(a,this.byteLength),b=f(d(b,this.byteLength),this.byteLength),c?new e(this.getBytes(b-a,a,!0,!0),void 0,void 0,this._littleEndian):new e(this.buffer,this.byteOffset+a,b-a,this._littleEndian)},alignBy:function(a){return this._bitOffset=0,1!==d(a,1)?this.skip(a-(this._offset%a||a)):this._offset},_getFloat64:function(a,b){var c=this._getBytes(8,a,b),d=1-2*(c[7]>>7),e=((c[7]<<1&255)<<3|c[6]>>4)-1023,f=(15&c[6])*g(48)+c[5]*g(40)+c[4]*g(32)+c[3]*g(24)+c[2]*g(16)+c[1]*g(8)+c[0];return 1024===e?0!==f?0/0:1/0*d:-1023===e?d*f*g(-1074):d*(1+f*g(-52))*g(e)},_getFloat32:function(a,b){var c=this._getBytes(4,a,b),d=1-2*(c[3]>>7),e=(c[3]<<1&255|c[2]>>7)-127,f=(127&c[2])<<16|c[1]<<8|c[0];return 128===e?0!==f?0/0:1/0*d:-127===e?d*f*g(-149):d*(1+f*g(-23))*g(e)},_get64:function(a,b,c){c=d(c,this._littleEndian),b=d(b,this._offset);for(var e=c?[0,4]:[4,0],f=0;2>f;f++)e[f]=this.getUint32(b+e[f],c);return this._offset=b+8,new a(e[0],e[1])},getInt64:function(a,b){return this._get64(i,a,b)},getUint64:function(a,b){return this._get64(h,a,b)},_getInt32:function(a,b){var c=this._getBytes(4,a,b);return c[3]<<24|c[2]<<16|c[1]<<8|c[0]},_getUint32:function(a,b){return this._getInt32(a,b)>>>0},_getInt16:function(a,b){return this._getUint16(a,b)<<16>>16},_getUint16:function(a,b){var c=this._getBytes(2,a,b);return c[1]<<8|c[0]},_getInt8:function(a){return this._getUint8(a)<<24>>24},_getUint8:function(a){return this._getBytes(1,a)[0]},_getBitRangeData:function(a,b){var c=(d(b,this._offset)<<3)+this._bitOffset,e=c+a,f=c>>>3,g=e+7>>>3,h=this._getBytes(g-f,f,!0),i=0;(this._bitOffset=7&e)&&(this._bitOffset-=8);for(var j=0,k=h.length;k>j;j++)i=i<<8|h[j];return{start:f,bytes:h,wideValue:i}},getSigned:function(a,b){var c=32-a;return this.getUnsigned(a,b)<<c>>c},getUnsigned:function(a,b){var c=this._getBitRangeData(a,b).wideValue>>>-this._bitOffset;return 32>a?c&~(-1<<a):c},_setBinaryFloat:function(a,b,c,d,e){var f,h,i=0>b?1:0,j=~(-1<<d-1),k=1-j;0>b&&(b=-b),0===b?(f=0,h=0):isNaN(b)?(f=2*j+1,h=1):1/0===b?(f=2*j+1,h=0):(f=Math.floor(Math.log(b)/Math.LN2),f>=k&&j>=f?(h=Math.floor((b*g(-f)-1)*g(c)),f+=j):(h=Math.floor(b/g(k-c)),f=0));for(var l=[];c>=8;)l.push(h%256),h=Math.floor(h/256),c-=8;for(f=f<<c|h,d+=c;d>=8;)l.push(255&f),f>>>=8,d-=8;l.push(i<<d|f),this._setBytes(a,l,e)},_setFloat32:function(a,b,c){this._setBinaryFloat(a,b,23,8,c)},_setFloat64:function(a,b,c){this._setBinaryFloat(a,b,52,11,c)},_set64:function(a,b,c,e){\"object\"!=typeof c&&(c=a.fromNumber(c)),e=d(e,this._littleEndian),b=d(b,this._offset);var f=e?{lo:0,hi:4}:{lo:4,hi:0};for(var g in f)this.setUint32(b+f[g],c[g],e);this._offset=b+8},setInt64:function(a,b,c){this._set64(i,a,b,c)},setUint64:function(a,b,c){this._set64(h,a,b,c)},_setUint32:function(a,b,c){this._setBytes(a,[255&b,b>>>8&255,b>>>16&255,b>>>24],c)},_setUint16:function(a,b,c){this._setBytes(a,[255&b,b>>>8&255],c)},_setUint8:function(a,b){this._setBytes(a,[255&b])},setUnsigned:function(a,b,c){var d=this._getBitRangeData(c,a),e=d.wideValue,f=d.bytes;e&=~(~(-1<<c)<<-this._bitOffset),e|=(32>c?b&~(-1<<c):b)<<-this._bitOffset;for(var g=f.length-1;g>=0;g--)f[g]=255&e,e>>>=8;this._setBytes(d.start,f,!0)}};for(var q in o)!function(a){p[\"get\"+a]=function(b,c){return this._action(a,!0,b,c)},p[\"set\"+a]=function(b,c,d){this._action(a,!1,b,d,c)}}(q);p._setInt32=p._setUint32,p._setInt16=p._setUint16,p._setInt8=p._setUint8,p.setSigned=p.setUnsigned;for(var r in p)\"set\"===r.slice(0,3)&&!function(a){p[\"write\"+a]=function(){Array.prototype.unshift.call(arguments,void 0),this[\"set\"+a].apply(this,arguments)}}(r.slice(3));return e});\n//# sourceMappingURL=jdataview.js.map\n\n//# sourceURL=webpack://STK/./js/vendor/jbinary/jdataview.js?");

/***/ }),

/***/ "./js/vendor/three/cameras/CombinedCamera.js":
/*!***************************************************!*\
  !*** ./js/vendor/three/cameras/CombinedCamera.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n *\t@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog\n *\n *\tA general perpose camera, for setting FOV, Lens Focal Length,\n *\t\tand switching between perspective and orthographic views easily.\n *\t\tUse this only if you do not wish to manage\n *\t\tboth a Orthographic and Perspective Camera\n *\n */\n\n\nTHREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {\n\n\tTHREE.Camera.call( this );\n\n\tthis.fov = fov;\n\n\tthis.left = - width / 2;\n\tthis.right = width / 2;\n\tthis.top = height / 2;\n\tthis.bottom = - height / 2;\n\tthis.aspect = width / height;\n\n\t// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects\n\n\tthis.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, \torthoNear, orthoFar );\n\tthis.cameraP = new THREE.PerspectiveCamera( fov, this.aspect, near, far );\n\n\tthis.zoom = 1;\n\n\tthis.toPerspective();\n\n};\n\nTHREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );\nTHREE.CombinedCamera.prototype.constructor = THREE.CombinedCamera;\n\nTHREE.CombinedCamera.prototype.toPerspective = function () {\n\n\t// Switches to the Perspective Camera\n\tthis.cameraP.up = this.up;\n\tthis.cameraP.matrix = this.matrix;\n\tthis.cameraP.matrix.decompose(this.cameraP.position, this.cameraP.quaternion, this.cameraP.scale);\n\tthis.cameraP.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n\tthis.cameraP.aspect = this.aspect;\n\n\tthis.near = this.cameraP.near;\n\tthis.far = this.cameraP.far;\n\n\t//this.cameraP.fov =  this.fov / this.zoom ;\n\tthis.cameraP.fov =  this.fov;\n\n\tthis.cameraP.updateProjectionMatrix();\n\n\tthis.projectionMatrix = this.cameraP.projectionMatrix;\n\tthis.projectionMatrixInverse = this.cameraP.projectionMatrixInverse;\n\n\tthis.inPerspectiveMode = true;\n\tthis.inOrthographicMode = false;\n\n};\n\nTHREE.CombinedCamera.prototype.toOrthographic = function (target) {\n\t// Switches to the Orthographic camera estimating viewport from Perspective\n\tthis.cameraO.up = this.up;\n\tthis.cameraO.matrix = this.matrix;\n\tthis.cameraO.matrix.decompose(this.cameraO.position, this.cameraO.quaternion, this.cameraO.scale);\n\tthis.cameraO.matrixWorldNeedsUpdate = true;  // make sure matrixWorldNeedsUpdate is set\n\n\tvar fov = this.fov;\n\tvar aspect = this.aspect;\n\tvar near = this.cameraP.near;\n\tvar far = this.cameraP.far;\n\n\t// The size that we set is the mid plane of the viewing frustum\n\tif (target) {\n\t\tthis.hyperfocus = target.clone().sub(this.position).length();\n\t}\n\tvar hyperfocus = this.hyperfocus? this.hyperfocus : (near + far) / 2;\n\n\tvar halfHeight = Math.tan( fov * Math.PI / 180 / 2 ) * hyperfocus;\n\tvar halfWidth = halfHeight * aspect;\n\n\thalfHeight /= this.zoom;\n\thalfWidth /= this.zoom;\n\n\tthis.cameraO.left = - halfWidth;\n\tthis.cameraO.right = halfWidth;\n\tthis.cameraO.top = halfHeight;\n\tthis.cameraO.bottom = - halfHeight;\n\n\t// this.cameraO.left = -farHalfWidth;\n\t// this.cameraO.right = farHalfWidth;\n\t// this.cameraO.top = farHalfHeight;\n\t// this.cameraO.bottom = -farHalfHeight;\n\n\t// this.cameraO.left = this.left / this.zoom;\n\t// this.cameraO.right = this.right / this.zoom;\n\t// this.cameraO.top = this.top / this.zoom;\n\t// this.cameraO.bottom = this.bottom / this.zoom;\n\n\tthis.cameraO.updateProjectionMatrix();\n\n\tthis.near = this.cameraO.near;\n\tthis.far = this.cameraO.far;\n\tthis.projectionMatrix = this.cameraO.projectionMatrix;\n\tthis.projectionMatrixInverse = this.cameraO.projectionMatrixInverse;\n\n\tthis.inPerspectiveMode = false;\n\tthis.inOrthographicMode = true;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setSize = function( width, height ) {\n\tthis.aspect = width / height;\n\tthis.left = - width / 2;\n\tthis.right = width / 2;\n\tthis.top = height / 2;\n\tthis.bottom = - height / 2;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setFov = function( fov ) {\n\n\tthis.fov = fov;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\n// For maintaining similar API with PerspectiveCamera\n\nTHREE.CombinedCamera.prototype.updateProjectionMatrix = function(target) {\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic(target);\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.updateNearFar = function() {\n\tthis.cameraP.near = this.near;\n\tthis.cameraP.far = this.far;\n\tthis.cameraO.near = this.near;\n\tthis.cameraO.far = this.far;\n};\n\n/*\n* Uses Focal Length (in mm) to estimate and set FOV\n* 35mm (full frame) camera is used if frame size is not specified;\n* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html\n*/\nTHREE.CombinedCamera.prototype.setLens = function ( focalLength, filmGauge ) {\n\n\tif ( filmGauge === undefined ) filmGauge = 35;\n\n\tvar vExtentSlope = 0.5 * filmGauge /\n\t\t\t( focalLength * Math.max( this.cameraP.aspect, 1 ) );\n\n\tvar fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\n\tthis.setFov( fov );\n\n\treturn fov;\n\n};\n\n\nTHREE.CombinedCamera.prototype.setZoom = function( zoom ) {\n\n\tthis.zoom = zoom;\n\n\tif ( this.inPerspectiveMode ) {\n\n\t\tthis.toPerspective();\n\n\t} else {\n\n\t\tthis.toOrthographic();\n\n\t}\n\n};\n\nTHREE.CombinedCamera.prototype.toFrontView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n\t// should we be modifing the matrix instead?\n\n};\n\nTHREE.CombinedCamera.prototype.toBackView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI;\n\tthis.rotation.z = 0;\n\n};\n\nTHREE.CombinedCamera.prototype.toLeftView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = - Math.PI / 2;\n\tthis.rotation.z = 0;\n\n};\n\nTHREE.CombinedCamera.prototype.toRightView = function() {\n\n\tthis.rotation.x = 0;\n\tthis.rotation.y = Math.PI / 2;\n\tthis.rotation.z = 0;\n\n};\n\nTHREE.CombinedCamera.prototype.toTopView = function() {\n\n\tthis.rotation.x = - Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n};\n\nTHREE.CombinedCamera.prototype.toBottomView = function() {\n\n\tthis.rotation.x = Math.PI / 2;\n\tthis.rotation.y = 0;\n\tthis.rotation.z = 0;\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/cameras/CombinedCamera.js?");

/***/ }),

/***/ "./js/vendor/three/controls.js":
/*!*************************************!*\
  !*** ./js/vendor/three/controls.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! vendor/three/controls/FirstPersonControls */ \"./js/vendor/three/controls/FirstPersonControls.js\"),\n        __webpack_require__(/*! vendor/three/controls/FlyControls */ \"./js/vendor/three/controls/FlyControls.js\"),\n        __webpack_require__(/*! vendor/three/controls/OrbitControls */ \"./js/vendor/three/controls/OrbitControls.js\"),\n        __webpack_require__(/*! vendor/three/controls/PointerLockControls */ \"./js/vendor/three/controls/PointerLockControls.js\"),\n        __webpack_require__(/*! vendor/three/controls/TrackballControls */ \"./js/vendor/three/controls/TrackballControls.js\"),\n        __webpack_require__(/*! vendor/three/controls/TransformControls */ \"./js/vendor/three/controls/TransformControls.js\"),\n        __webpack_require__(/*! vendor/three/cameras/CombinedCamera */ \"./js/vendor/three/cameras/CombinedCamera.js\"),\n        __webpack_require__(/*! vendor/three/controls/FirstPersonControlsClickDragRotation */ \"./js/vendor/three/controls/FirstPersonControlsClickDragRotation.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/FirstPersonControls.js":
/*!*********************************************************!*\
  !*** ./js/vendor/three/controls/FirstPersonControls.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author paulirish / http://paulirish.com/\n */\n\nTHREE.FirstPersonControls = function ( object, domElement ) {\n\n\tif ( domElement === undefined ) {\n\n\t\tconsole.warn( 'THREE.FirstPersonControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tdomElement = document;\n\n\t}\n\n\tthis.object = object;\n\tthis.domElement = domElement;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.movementSpeed = 1.0;\n\tthis.lookSpeed = 0.005;\n\n\tthis.lookVertical = true;\n\tthis.autoForward = false;\n\n\tthis.activeLook = true;\n\n\tthis.heightSpeed = false;\n\tthis.heightCoef = 1.0;\n\tthis.heightMin = 0.0;\n\tthis.heightMax = 1.0;\n\n\tthis.constrainVertical = false;\n\tthis.verticalMin = 0;\n\tthis.verticalMax = Math.PI;\n\n\tthis.mouseDragOn = false;\n\n\t// internals\n\n\tthis.autoSpeedFactor = 0.0;\n\n\tthis.mouseX = 0;\n\tthis.mouseY = 0;\n\n\tthis.moveForward = false;\n\tthis.moveBackward = false;\n\tthis.moveLeft = false;\n\tthis.moveRight = false;\n\n\tthis.viewHalfX = 0;\n\tthis.viewHalfY = 0;\n\n\t// private variables\n\n\tvar lat = 0;\n\tvar lon = 0;\n\n\tvar lookDirection = new THREE.Vector3();\n\tvar spherical = new THREE.Spherical();\n\tvar target = new THREE.Vector3();\n\n\t//\n\n\tif ( this.domElement !== document ) {\n\n\t\tthis.domElement.setAttribute( 'tabindex', - 1 );\n\n\t}\n\n\t//\n\n\tthis.handleResize = function () {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.viewHalfX = window.innerWidth / 2;\n\t\t\tthis.viewHalfY = window.innerHeight / 2;\n\n\t\t} else {\n\n\t\t\tthis.viewHalfX = this.domElement.offsetWidth / 2;\n\t\t\tthis.viewHalfY = this.domElement.offsetHeight / 2;\n\n\t\t}\n\n\t};\n\n\tthis.onMouseDown = function ( event ) {\n\n\t\tif ( this.domElement !== document ) {\n\n\t\t\tthis.domElement.focus();\n\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( this.activeLook ) {\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0: this.moveForward = true; break;\n\t\t\t\tcase 2: this.moveBackward = true; break;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseDragOn = true;\n\n\t};\n\n\tthis.onMouseUp = function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( this.activeLook ) {\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0: this.moveForward = false; break;\n\t\t\t\tcase 2: this.moveBackward = false; break;\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.mouseDragOn = false;\n\n\t};\n\n\tthis.onMouseMove = function ( event ) {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.mouseX = event.pageX - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.viewHalfY;\n\n\t\t} else {\n\n\t\t\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\n\n\t\t}\n\n\t};\n\n\tthis.onKeyDown = function ( event ) {\n\n\t\t//event.preventDefault();\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87: /*W*/ this.moveForward = true; break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65: /*A*/ this.moveLeft = true; break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83: /*S*/ this.moveBackward = true; break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68: /*D*/ this.moveRight = true; break;\n\n\t\t\tcase 82: /*R*/ this.moveUp = true; break;\n\t\t\tcase 70: /*F*/ this.moveDown = true; break;\n\n\t\t}\n\n\t};\n\n\tthis.onKeyUp = function ( event ) {\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87: /*W*/ this.moveForward = false; break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65: /*A*/ this.moveLeft = false; break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83: /*S*/ this.moveBackward = false; break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68: /*D*/ this.moveRight = false; break;\n\n\t\t\tcase 82: /*R*/ this.moveUp = false; break;\n\t\t\tcase 70: /*F*/ this.moveDown = false; break;\n\n\t\t}\n\n\t};\n\n\tthis.lookAt = function ( x, y, z ) {\n\n\t\tif ( x.isVector3 ) {\n\n\t\t\ttarget.copy( x );\n\n\t\t} else {\n\n\t\t\ttarget.set( x, y, z );\n\n\t\t}\n\n\t\tthis.object.lookAt( target );\n\n\t\tsetOrientation( this );\n\n\t\treturn this;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tvar targetPosition = new THREE.Vector3();\n\n\t\treturn function update( delta ) {\n\n\t\t\tif ( this.enabled === false ) return;\n\n\t\t\tif ( this.heightSpeed ) {\n\n\t\t\t\tvar y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );\n\t\t\t\tvar heightDelta = y - this.heightMin;\n\n\t\t\t\tthis.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );\n\n\t\t\t} else {\n\n\t\t\t\tthis.autoSpeedFactor = 0.0;\n\n\t\t\t}\n\n\t\t\tvar actualMoveSpeed = delta * this.movementSpeed;\n\n\t\t\tif ( this.moveForward || ( this.autoForward && ! this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );\n\t\t\tif ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );\n\n\t\t\tif ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );\n\t\t\tif ( this.moveRight ) this.object.translateX( actualMoveSpeed );\n\n\t\t\tif ( this.moveUp ) this.object.translateY( actualMoveSpeed );\n\t\t\tif ( this.moveDown ) this.object.translateY( - actualMoveSpeed );\n\n\t\t\tvar actualLookSpeed = delta * this.lookSpeed;\n\n\t\t\tif ( ! this.activeLook ) {\n\n\t\t\t\tactualLookSpeed = 0;\n\n\t\t\t\t// AXC: Skip code below if activelook is not set\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tvar verticalLookRatio = 1;\n\n\t\t\tif ( this.constrainVertical ) {\n\n\t\t\t\tverticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );\n\n\t\t\t}\n\n\t\t\tlon -= this.mouseX * actualLookSpeed;\n\t\t\tif ( this.lookVertical ) lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\n\n\t\t\tlat = Math.max( - 85, Math.min( 85, lat ) );\n\n\t\t\tvar phi = THREE.Math.degToRad( 90 - lat );\n\t\t\tvar theta = THREE.Math.degToRad( lon );\n\n\t\t\tif ( this.constrainVertical ) {\n\n\t\t\t\tphi = THREE.Math.mapLinear( phi, 0, Math.PI, this.verticalMin, this.verticalMax );\n\n\t\t\t}\n\n\t\t\tvar position = this.object.position;\n\n\t\t\ttargetPosition.setFromSphericalCoords( 1, phi, theta ).add( position );\n\n\t\t\tthis.object.lookAt( targetPosition );\n\n\t\t};\n\n\t}();\n\n\tfunction contextmenu( event ) {\n\n\t\tevent.preventDefault();\n\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\tthis.domElement.removeEventListener( 'mousedown', _onMouseDown, false );\n\t\tthis.domElement.removeEventListener( 'mousemove', _onMouseMove, false );\n\t\tthis.domElement.removeEventListener( 'mouseup', _onMouseUp, false );\n\n\t\twindow.removeEventListener( 'keydown', _onKeyDown, false );\n\t\twindow.removeEventListener( 'keyup', _onKeyUp, false );\n\n\t};\n\n\tvar _onMouseMove = bind( this, this.onMouseMove );\n\tvar _onMouseDown = bind( this, this.onMouseDown );\n\tvar _onMouseUp = bind( this, this.onMouseUp );\n\tvar _onKeyDown = bind( this, this.onKeyDown );\n\tvar _onKeyUp = bind( this, this.onKeyUp );\n\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\tthis.domElement.addEventListener( 'mousemove', _onMouseMove, false );\n\tthis.domElement.addEventListener( 'mousedown', _onMouseDown, false );\n\tthis.domElement.addEventListener( 'mouseup', _onMouseUp, false );\n\n\twindow.addEventListener( 'keydown', _onKeyDown, false );\n\twindow.addEventListener( 'keyup', _onKeyUp, false );\n\n\tfunction bind( scope, fn ) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply( scope, arguments );\n\n\t\t};\n\n\t}\n\n\tfunction setOrientation( controls ) {\n\n\t\tvar quaternion = controls.object.quaternion;\n\n\t\tlookDirection.set( 0, 0, - 1 ).applyQuaternion( quaternion );\n\t\tspherical.setFromVector3( lookDirection );\n\n\t\tlat = 90 - THREE.Math.radToDeg( spherical.phi );\n\t\tlon = THREE.Math.radToDeg( spherical.theta );\n\n\t}\n\n\tthis.handleResize();\n\n\tsetOrientation( this );\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/FirstPersonControls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/FirstPersonControlsClickDragRotation.js":
/*!**************************************************************************!*\
  !*** ./js/vendor/three/controls/FirstPersonControlsClickDragRotation.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n * @author paulirish / http://paulirish.com/\n */\n\nTHREE.FirstPersonControlsClickDragRotation = function ( object, domElement ) {\n\tthis.object = object;\n\tthis.target = new THREE.Vector3( 0, 0, 0 );\n\n\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\n\n\tthis.enabled = true;\n\n\tthis.movementSpeed = 1.0;\n\tthis.lookSpeed = 0.005;\n\n\tthis.lookVertical = true;\n\tthis.autoForward = false;\n\n\tthis.activeLook = true;\n\n\tthis.heightSpeed = false;\n\tthis.heightCoef = 1.0;\n\tthis.heightMin = 0.0;\n\tthis.heightMax = 1.0;\n\n\tthis.constrainVertical = false;\n\tthis.verticalMin = 0;\n\tthis.verticalMax = Math.PI;\n\n\tthis.autoSpeedFactor = 0.0;\n\n\tthis.mouseX = 0;\n\tthis.mouseY = 0;\n\n\tthis.lat = 0;\n\tthis.lon = 0;\n\tthis.phi = 0;\n\tthis.theta = 0;\n\n\tthis.moveForward = false;\n\tthis.moveBackward = false;\n\tthis.moveLeft = false;\n\tthis.moveRight = false;\n\n\tthis.mouseDragOn = false;\n\n\tthis.viewHalfX = 0;\n\tthis.viewHalfY = 0;\n\n\tthis.prevMouseLoc = null;\n\n\tif ( this.domElement !== document ) {\n\n\t\tthis.domElement.setAttribute( 'tabindex', -1 );\n\n\t}\n\n\t//\n\n\tthis.handleResize = function () {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.viewHalfX = window.innerWidth / 2;\n\t\t\tthis.viewHalfY = window.innerHeight / 2;\n\n\t\t} else {\n\n\t\t\tthis.viewHalfX = this.domElement.offsetWidth / 2;\n\t\t\tthis.viewHalfY = this.domElement.offsetHeight / 2;\n\n\t\t}\n\n\t};\n\n\tthis.onMouseDown = function ( event ) {\n\n\t\tif ( this.domElement !== document ) {\n\n\t\t\tthis.domElement.focus();\n\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t// if ( this.activeLook ) {\n\n\t\t// \tswitch ( event.button ) {\n\n\t\t// \t\tcase 0: this.moveForward = true; break;\n\t\t// \t\tcase 2: this.moveBackward = true; break;\n\n\t\t// \t}\n\n\t\t// }\n\n\t\tthis.mouseDragOn = true;\n\t\tthis.prevMouseLoc = {\"x\":this.mouseX,\"y\":this.mouseY}\n\t};\n\n\tthis.onMouseUp = function ( event ) {\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t// if ( this.activeLook ) {\n\n\t\t// \tswitch ( event.button ) {\n\n\t\t// \t\tcase 0: this.moveForward = false; break;\n\t\t// \t\tcase 2: this.moveBackward = false; break;\n\n\t\t// \t}\n\n\t\t// }\n\n\t\tthis.mouseDragOn = false;\n\n\t};\n\n\tthis.onMouseMove = function ( event ) {\n\n\t\tif ( this.domElement === document ) {\n\n\t\t\tthis.mouseX = event.pageX - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.viewHalfY;\n\n\t\t} else {\n\n\t\t\tthis.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;\n\t\t\tthis.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;\n\t\t}\n\n\n\t\tif (this.mouseDragOn){\n\t\t\tthis.rotateCamera()\n\t\t}\n\t};\n\n\tthis.rotateCamera = function() {\n\t\tvar targetPosition = this.target;\n\t\tvar position = this.object.position;\n\n\t\tvar deltaX = this.mouseX-this.prevMouseLoc.x;\n\t\tvar deltaY = this.mouseY-this.prevMouseLoc.y;\n\n\t\ttargetPosition.y -= deltaY;\n\t\tthis.object.lookAt( targetPosition );\n\t};\n\n\tthis.onKeyDown = function ( event ) {\n\n\t\t//event.preventDefault();\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87: /*W*/ this.moveForward = true; break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65: /*A*/ this.moveLeft = true; break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83: /*S*/ this.moveBackward = true; break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68: /*D*/ this.moveRight = true; break;\n\n\t\t\tcase 82: /*R*/ this.moveUp = true; break;\n\t\t\tcase 70: /*F*/ this.moveDown = true; break;\n\n\t\t}\n\t};\n\n\n\n\tthis.onKeyUp = function ( event ) {\n\n\t\tswitch( event.keyCode ) {\n\n\t\t\tcase 38: /*up*/\n\t\t\tcase 87: /*W*/ this.moveForward = false; break;\n\n\t\t\tcase 37: /*left*/\n\t\t\tcase 65: /*A*/ this.moveLeft = false; break;\n\n\t\t\tcase 40: /*down*/\n\t\t\tcase 83: /*S*/ this.moveBackward = false; break;\n\n\t\t\tcase 39: /*right*/\n\t\t\tcase 68: /*D*/ this.moveRight = false; break;\n\n\t\t\tcase 82: /*R*/ this.moveUp = false; break;\n\t\t\tcase 70: /*F*/ this.moveDown = false; break;\n\n\t\t}\n\n\t};\n\n\tthis.update = function( delta ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( this.heightSpeed ) {\n\n\t\t\tvar y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );\n\t\t\tvar heightDelta = y - this.heightMin;\n\n\t\t\tthis.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );\n\n\t\t} else {\n\n\t\t\tthis.autoSpeedFactor = 0.0;\n\n\t\t}\n\n\t\tvar actualMoveSpeed = delta * this.movementSpeed;\n\n\t\tif ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );\n\t\tif ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );\n\n\t\tif ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );\n\t\tif ( this.moveRight ) this.object.translateX( actualMoveSpeed );\n\n\t\tif ( this.moveUp ) this.object.translateY( actualMoveSpeed );\n\t\tif ( this.moveDown ) this.object.translateY( - actualMoveSpeed );\n\n\t\t// var actualLookSpeed = delta * this.lookSpeed;\n\n\t\t// if ( !this.activeLook ) {\n\n\t\t// \tactualLookSpeed = 0;\n  //           // AXC: Skip code below if activelook is not set\n  //           return;\n\t\t// }\n\n\t\t// var verticalLookRatio = 1;\n\n\t\t// if ( this.constrainVertical ) {\n\n\t\t// \tverticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );\n\n\t\t// }\n\n\t\t// this.lon += this.mouseX * actualLookSpeed;\n\t\t// if( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;\n\n\t\t// this.lat = Math.max( - 85, Math.min( 85, this.lat ) );\n\t\t// this.phi = THREE.Math.degToRad( 90 - this.lat );\n\n\t\t// this.theta = THREE.Math.degToRad( this.lon );\n\n\t\t// if ( this.constrainVertical ) {\n\n\t\t// \tthis.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );\n\n\t\t// }\n\n\t\t// var targetPosition = this.target,\n\t\t// \tposition = this.object.position;\n\n\t\t// targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );\n\t\t// targetPosition.y = position.y + 100 * Math.cos( this.phi );\n\t\t// targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );\n\n\t\t// this.object.lookAt( targetPosition );\n\n\t};\n\n\n\tthis.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );\n\tthis.domElement.addEventListener( 'mousemove', bind( this, this.onMouseMove ), false );\n\tthis.domElement.addEventListener( 'mousedown', bind( this, this.onMouseDown ), false );\n\tthis.domElement.addEventListener( 'mouseup', bind( this, this.onMouseUp ), false );\n\n\twindow.addEventListener( 'keydown', bind( this, this.onKeyDown ), false );\n\twindow.addEventListener( 'keyup', bind( this, this.onKeyUp ), false );\n\n\tfunction bind( scope, fn ) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply( scope, arguments );\n\n\t\t};\n\n\t};\n\n\tthis.handleResize();\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/FirstPersonControlsClickDragRotation.js?");

/***/ }),

/***/ "./js/vendor/three/controls/FlyControls.js":
/*!*************************************************!*\
  !*** ./js/vendor/three/controls/FlyControls.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author James Baicoianu / http://www.baicoianu.com/\n */\n\nTHREE.FlyControls = function ( object, domElement ) {\n\n\tif ( domElement === undefined ) {\n\n\t\tconsole.warn( 'THREE.FlyControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tdomElement = document;\n\n\t}\n\n\tthis.object = object;\n\tthis.domElement = domElement;\n\n\tif ( domElement ) this.domElement.setAttribute( 'tabindex', - 1 );\n\n\t// API\n\n\tthis.movementSpeed = 1.0;\n\tthis.rollSpeed = 0.005;\n\n\tthis.dragToLook = false;\n\tthis.autoForward = false;\n\n\t// disable default target object behavior\n\n\t// internals\n\n\tthis.tmpQuaternion = new THREE.Quaternion();\n\n\tthis.mouseStatus = 0;\n\n\tthis.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };\n\tthis.moveVector = new THREE.Vector3( 0, 0, 0 );\n\tthis.rotationVector = new THREE.Vector3( 0, 0, 0 );\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\tthis.handleEvent = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( typeof this[ event.type ] == 'function' ) {\n\n\t\t\tthis[ event.type ]( event );\n\n\t\t}\n\n\t};\n\n\tthis.keydown = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( event.altKey ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\t//event.preventDefault();\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 16: /* shift */ this.movementSpeedMultiplier = .1; break;\n\n\t\t\tcase 87: /*W*/ this.moveState.forward = 1; break;\n\t\t\tcase 83: /*S*/ this.moveState.back = 1; break;\n\n\t\t\tcase 65: /*A*/ this.moveState.left = 1; break;\n\t\t\tcase 68: /*D*/ this.moveState.right = 1; break;\n\n\t\t\tcase 82: /*R*/ this.moveState.up = 1; break;\n\t\t\tcase 70: /*F*/ this.moveState.down = 1; break;\n\n\t\t\tcase 38: /*up*/ this.moveState.pitchUp = 1; break;\n\t\t\tcase 40: /*down*/ this.moveState.pitchDown = 1; break;\n\n\t\t\tcase 37: /*left*/ this.moveState.yawLeft = 1; break;\n\t\t\tcase 39: /*right*/ this.moveState.yawRight = 1; break;\n\n\t\t\tcase 81: /*Q*/ this.moveState.rollLeft = 1; break;\n\t\t\tcase 69: /*E*/ this.moveState.rollRight = 1; break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\n\t};\n\n\tthis.keyup = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tswitch ( event.keyCode ) {\n\n\t\t\tcase 16: /* shift */ this.movementSpeedMultiplier = 1; break;\n\n\t\t\tcase 87: /*W*/ this.moveState.forward = 0; break;\n\t\t\tcase 83: /*S*/ this.moveState.back = 0; break;\n\n\t\t\tcase 65: /*A*/ this.moveState.left = 0; break;\n\t\t\tcase 68: /*D*/ this.moveState.right = 0; break;\n\n\t\t\tcase 82: /*R*/ this.moveState.up = 0; break;\n\t\t\tcase 70: /*F*/ this.moveState.down = 0; break;\n\n\t\t\tcase 38: /*up*/ this.moveState.pitchUp = 0; break;\n\t\t\tcase 40: /*down*/ this.moveState.pitchDown = 0; break;\n\n\t\t\tcase 37: /*left*/ this.moveState.yawLeft = 0; break;\n\t\t\tcase 39: /*right*/ this.moveState.yawRight = 0; break;\n\n\t\t\tcase 81: /*Q*/ this.moveState.rollLeft = 0; break;\n\t\t\tcase 69: /*E*/ this.moveState.rollRight = 0; break;\n\n\t\t}\n\n\t\tthis.updateMovementVector();\n\t\tthis.updateRotationVector();\n\n\t};\n\n\tthis.mousedown = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( this.domElement !== document ) {\n\n\t\t\tthis.domElement.focus();\n\n\t\t}\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( this.dragToLook ) {\n\n\t\t\tthis.mouseStatus ++;\n\n\t\t} else {\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0: this.moveState.forward = 1; break;\n\t\t\t\tcase 2: this.moveState.back = 1; break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\n\t\t}\n\n\t};\n\n\tthis.mousemove = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tif ( ! this.dragToLook || this.mouseStatus > 0 ) {\n\n\t\t\tvar container = this.getContainerDimensions();\n\t\t\tvar halfWidth = container.size[ 0 ] / 2;\n\t\t\tvar halfHeight = container.size[ 1 ] / 2;\n\n\t\t\tthis.moveState.yawLeft = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth ) / halfWidth;\n\t\t\tthis.moveState.pitchDown = ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;\n\n\t\t\tthis.updateRotationVector();\n\n\t\t}\n\n\t};\n\n\tthis.mouseup = function ( event ) {\n\t\tif ( this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( this.dragToLook ) {\n\n\t\t\tthis.mouseStatus --;\n\n\t\t\tthis.moveState.yawLeft = this.moveState.pitchDown = 0;\n\n\t\t} else {\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase 0: this.moveState.forward = 0; break;\n\t\t\t\tcase 2: this.moveState.back = 0; break;\n\n\t\t\t}\n\n\t\t\tthis.updateMovementVector();\n\n\t\t}\n\n\t\tthis.updateRotationVector();\n\n\t};\n\n\tthis.update = function ( delta ) {\n\n\t\tvar moveMult = delta * this.movementSpeed;\n\t\tvar rotMult = delta * this.rollSpeed;\n\n\t\tthis.object.translateX( this.moveVector.x * moveMult );\n\t\tthis.object.translateY( this.moveVector.y * moveMult );\n\t\tthis.object.translateZ( this.moveVector.z * moveMult );\n\n\t\tthis.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();\n\t\tthis.object.quaternion.multiply( this.tmpQuaternion );\n\n\t\t// expose the rotation vector for convenience\n\t\tthis.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );\n\n\n\t};\n\n\tthis.updateMovementVector = function () {\n\n\t\tvar forward = ( this.moveState.forward || ( this.autoForward && ! this.moveState.back ) ) ? 1 : 0;\n\n\t\tthis.moveVector.x = ( - this.moveState.left + this.moveState.right );\n\t\tthis.moveVector.y = ( - this.moveState.down + this.moveState.up );\n\t\tthis.moveVector.z = ( - forward + this.moveState.back );\n\n\t\t//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );\n\n\t};\n\n\tthis.updateRotationVector = function () {\n\n\t\tthis.rotationVector.x = ( - this.moveState.pitchDown + this.moveState.pitchUp );\n\t\tthis.rotationVector.y = ( - this.moveState.yawRight + this.moveState.yawLeft );\n\t\tthis.rotationVector.z = ( - this.moveState.rollRight + this.moveState.rollLeft );\n\n\t\t//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );\n\n\t};\n\n\tthis.getContainerDimensions = function () {\n\n\t\tif ( this.domElement != document ) {\n\n\t\t\treturn {\n\t\t\t\tsize: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],\n\t\t\t\toffset: [ this.domElement.offsetLeft, this.domElement.offsetTop ]\n\t\t\t};\n\n\t\t} else {\n\n\t\t\treturn {\n\t\t\t\tsize: [ window.innerWidth, window.innerHeight ],\n\t\t\t\toffset: [ 0, 0 ]\n\t\t\t};\n\n\t\t}\n\n\t};\n\n\tfunction bind( scope, fn ) {\n\n\t\treturn function () {\n\n\t\t\tfn.apply( scope, arguments );\n\n\t\t};\n\n\t}\n\n\tfunction contextmenu( event ) {\n\n\t\tevent.preventDefault();\n\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\tthis.domElement.removeEventListener( 'mousedown', _mousedown, false );\n\t\tthis.domElement.removeEventListener( 'mousemove', _mousemove, false );\n\t\tthis.domElement.removeEventListener( 'mouseup', _mouseup, false );\n\n\t\twindow.removeEventListener( 'keydown', _keydown, false );\n\t\twindow.removeEventListener( 'keyup', _keyup, false );\n\n\t};\n\n\tvar _mousemove = bind( this, this.mousemove );\n\tvar _mousedown = bind( this, this.mousedown );\n\tvar _mouseup = bind( this, this.mouseup );\n\tvar _keydown = bind( this, this.keydown );\n\tvar _keyup = bind( this, this.keyup );\n\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\n\tthis.domElement.addEventListener( 'mousemove', _mousemove, false );\n\tthis.domElement.addEventListener( 'mousedown', _mousedown, false );\n\tthis.domElement.addEventListener( 'mouseup', _mouseup, false );\n\n\twindow.addEventListener( 'keydown', _keydown, false );\n\twindow.addEventListener( 'keyup', _keyup, false );\n\n\tthis.updateMovementVector();\n\tthis.updateRotationVector();\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/FlyControls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/OrbitControls.js":
/*!***************************************************!*\
  !*** ./js/vendor/three/controls/OrbitControls.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author qiao / https://github.com/qiao\n * @author mrdoob / http://mrdoob.com\n * @author alteredq / http://alteredqualia.com/\n * @author WestLangley / http://github.com/WestLangley\n * @author erich666 / http://erichaines.com\n * @author ScieCode / http://github.com/sciecode\n */\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nTHREE.OrbitControls = function (object, domElement) {\n\n\tif (domElement === undefined) console.warn('THREE.OrbitControls: The second parameter \"domElement\" is now mandatory.');\n\tif (domElement === document) console.error('THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n\n\tthis.object = object;\n\tthis.domElement = domElement;\n\n\t// Set to false to disable this control\n\tthis.enabled = true;\n\n\t// \"target\" sets the location of focus, where the object orbits around\n\tthis.target = new THREE.Vector3();\n\n\t// How far you can dolly in and out ( PerspectiveCamera only )\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\t// How far you can zoom in and out ( OrthographicCamera only )\n\tthis.minZoom = 0;\n\tthis.maxZoom = Infinity;\n\n\t// How far you can orbit vertically, upper and lower limits.\n\t// Range is 0 to Math.PI radians.\n\tthis.minPolarAngle = 0; // radians\n\tthis.maxPolarAngle = Math.PI; // radians\n\n\t// How far you can orbit horizontally, upper and lower limits.\n\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\n\tthis.minAzimuthAngle = - Infinity; // radians\n\tthis.maxAzimuthAngle = Infinity; // radians\n\n\t// Set to true to enable damping (inertia)\n\t// If damping is enabled, you must call controls.update() in your animation loop\n\tthis.enableDamping = false;\n\tthis.dampingFactor = 0.05;\n\n\t// This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n\t// Set to false to disable zooming\n\tthis.enableZoom = true;\n\tthis.zoomSpeed = 1.0;\n\n\t// Set to false to disable rotating\n\tthis.enableRotate = true;\n\tthis.rotateSpeed = 1.0;\n\n\t// Set to false to disable panning\n\tthis.enablePan = true;\n\tthis.panSpeed = 1.0;\n\tthis.screenSpacePanning = false; // if true, pan in screen-space\n\tthis.keyPanSpeed = 7.0;\t// pixels moved per arrow key push\n\n\t// Set to true to automatically rotate around the target\n\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\n\tthis.autoRotate = false;\n\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\n\n\t// Set to false to disable use of the keys\n\tthis.enableKeys = true;\n\n\t// The four arrow keys\n\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\n\n\tthis.actions = Object.freeze({ ORBIT: 0, ZOOM: 1, PAN: 2 });\n\n\t// AXC: more generic mouse mappings\n\tthis.mouseMappings = [\n\t\t{ action: this.actions.PAN, button: THREE.MOUSE.LEFT, keys: ['ctrlKey', 'metaKey'] },\n\t\t{ action: this.actions.ORBIT, button: THREE.MOUSE.LEFT },\n\t\t{ action: this.actions.ZOOM, button: THREE.MOUSE.MIDDLE },\n\t\t{ action: this.actions.PAN, button: THREE.MOUSE.RIGHT }\n\t];\n\n\t// Touch fingers\n\tthis.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };\n\n\t// for reset\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t//\n\t// public methods\n\t//\n\n\tthis.getPolarAngle = function () {\n\n\t\treturn spherical.phi;\n\n\t};\n\n\tthis.getAzimuthalAngle = function () {\n\n\t\treturn spherical.theta;\n\n\t};\n\n\tthis.saveState = function () {\n\n\t\tscope.target0.copy(scope.target);\n\t\tscope.position0.copy(scope.object.position);\n\t\tscope.zoom0 = scope.object.zoom;\n\n\t};\n\n\tthis.reset = function () {\n\n\t\tscope.target.copy(scope.target0);\n\t\tscope.object.position.copy(scope.position0);\n\t\tscope.object.zoom = scope.zoom0;\n\n\t\tscope.object.updateProjectionMatrix();\n\t\tscope.dispatchEvent(changeEvent);\n\n\t\tscope.update();\n\n\t\tstate = STATE.NONE;\n\n\t};\n\n\tthis.getState = function () {\n\t\treturn { 'target': scope.target, 'position': scope.object.position, 'zoom': scope.object.zoom };\n\t}\n\n\tthis.setState = function (controlInfo) {\n\t\tscope.target0.copy(controlInfo['target']);\n\t\tscope.position0.copy(controlInfo['position']);\n\t\tscope.zoom0 = controlInfo['zoom'];\n\n\t\tscope.reset();\n\t}\n\n\t// this method is exposed, but perhaps it would be better if we can make it private...\n\tthis.update = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\t// so camera.up is the orbit axis\n\t\tvar quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));\n\t\tvar quatInverse = quat.clone().inverse();\n\n\t\tvar lastPosition = new THREE.Vector3();\n\t\tvar lastQuaternion = new THREE.Quaternion();\n\n\t\treturn function update() {\n\n\t\t\tvar position = scope.object.position;\n\n\t\t\toffset.copy(position).sub(scope.target);\n\n\t\t\t// rotate offset to \"y-axis-is-up\" space\n\t\t\toffset.applyQuaternion(quat);\n\n\t\t\t// angle from z-axis around y-axis\n\t\t\tspherical.setFromVector3(offset);\n\n\t\t\tif (scope.autoRotate && state === STATE.NONE) {\n\n\t\t\t\trotateLeft(getAutoRotationAngle());\n\n\t\t\t}\n\n\t\t\tif (scope.enableDamping) {\n\n\t\t\t\tspherical.theta += sphericalDelta.theta * scope.dampingFactor;\n\t\t\t\tspherical.phi += sphericalDelta.phi * scope.dampingFactor;\n\n\t\t\t} else {\n\n\t\t\t\tspherical.theta += sphericalDelta.theta;\n\t\t\t\tspherical.phi += sphericalDelta.phi;\n\n\t\t\t}\n\n\t\t\t// restrict theta to be between desired limits\n\t\t\tspherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta));\n\n\t\t\t// restrict phi to be between desired limits\n\t\t\tspherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));\n\n\t\t\tspherical.makeSafe();\n\n\n\t\t\tspherical.radius *= scale;\n\n\t\t\t// restrict radius to be between desired limits\n\t\t\tspherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius));\n\n\t\t\t// move target to panned location\n\n\t\t\tif (scope.enableDamping === true) {\n\n\t\t\t\tscope.target.addScaledVector(panOffset, scope.dampingFactor);\n\n\t\t\t} else {\n\n\t\t\t\tscope.target.add(panOffset);\n\n\t\t\t}\n\n\t\t\toffset.setFromSpherical(spherical);\n\n\t\t\t// rotate offset back to \"camera-up-vector-is-up\" space\n\t\t\toffset.applyQuaternion(quatInverse);\n\n\t\t\tposition.copy(scope.target).add(offset);\n\n\t\t\tscope.object.lookAt(scope.target);\n\n\t\t\tif (scope.enableDamping === true) {\n\n\t\t\t\tsphericalDelta.theta *= (1 - scope.dampingFactor);\n\t\t\t\tsphericalDelta.phi *= (1 - scope.dampingFactor);\n\n\t\t\t\tpanOffset.multiplyScalar(1 - scope.dampingFactor);\n\n\t\t\t} else {\n\n\t\t\t\tsphericalDelta.set(0, 0, 0);\n\n\t\t\t\tpanOffset.set(0, 0, 0);\n\n\t\t\t}\n\n\t\t\tscale = 1;\n\n\t\t\t// update condition is:\n\t\t\t// min(camera displacement, camera rotation in radians)^2 > EPS\n\t\t\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n\t\t\tif (zoomChanged ||\n\t\t\t\tlastPosition.distanceToSquared(scope.object.position) > EPS ||\n\t\t\t\t8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {\n\n\t\t\t\tscope.dispatchEvent(changeEvent);\n\n\t\t\t\tlastPosition.copy(scope.object.position);\n\t\t\t\tlastQuaternion.copy(scope.object.quaternion);\n\t\t\t\tzoomChanged = false;\n\n\t\t\t\treturn true;\n\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t};\n\n\t}();\n\n\tthis.dispose = function () {\n\n\t\tscope.domElement.removeEventListener('contextmenu', onContextMenu, false);\n\t\tscope.domElement.removeEventListener('mousedown', onMouseDown, false);\n\t\tscope.domElement.removeEventListener('wheel', onMouseWheel, false);\n\n\t\tscope.domElement.removeEventListener('touchstart', onTouchStart, false);\n\t\tscope.domElement.removeEventListener('touchend', onTouchEnd, false);\n\t\tscope.domElement.removeEventListener('touchmove', onTouchMove, false);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tscope.domElement.removeEventListener('keydown', onKeyDown, false);\n\n\t\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n\n\t};\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\tvar STATE = {\n\t\tNONE: - 1,\n\t\tROTATE: 0,\n\t\tDOLLY: 1,\n\t\tPAN: 2,\n\t\tTOUCH_ROTATE: 3,\n\t\tTOUCH_PAN: 4,\n\t\tTOUCH_DOLLY_PAN: 5,\n\t\tTOUCH_DOLLY_ROTATE: 6\n\t};\n\n\tvar state = STATE.NONE;\n\n\tvar EPS = 0.000001;\n\n\t// current position in spherical coordinates\n\tvar spherical = new THREE.Spherical();\n\tvar sphericalDelta = new THREE.Spherical();\n\n\tvar scale = 1;\n\tvar panOffset = new THREE.Vector3();\n\tvar zoomChanged = false;\n\n\tvar rotateStart = new THREE.Vector2();\n\tvar rotateEnd = new THREE.Vector2();\n\tvar rotateDelta = new THREE.Vector2();\n\n\tvar panStart = new THREE.Vector2();\n\tvar panEnd = new THREE.Vector2();\n\tvar panDelta = new THREE.Vector2();\n\n\tvar dollyStart = new THREE.Vector2();\n\tvar dollyEnd = new THREE.Vector2();\n\tvar dollyDelta = new THREE.Vector2();\n\n\tfunction getAutoRotationAngle() {\n\n\t\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\n\n\t}\n\n\tfunction getZoomScale() {\n\n\t\treturn Math.pow(0.95, scope.zoomSpeed);\n\n\t}\n\n\tfunction rotateLeft(angle) {\n\n\t\tsphericalDelta.theta -= angle;\n\n\t}\n\n\tfunction rotateUp(angle) {\n\n\t\tsphericalDelta.phi -= angle;\n\n\t}\n\n\tvar panLeft = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panLeft(distance, objectMatrix) {\n\n\t\t\tv.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix\n\t\t\tv.multiplyScalar(- distance);\n\n\t\t\tpanOffset.add(v);\n\n\t\t};\n\n\t}();\n\n\tvar panUp = function () {\n\n\t\tvar v = new THREE.Vector3();\n\n\t\treturn function panUp(distance, objectMatrix) {\n\n\t\t\tif (scope.screenSpacePanning === true) {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 1);\n\n\t\t\t} else {\n\n\t\t\t\tv.setFromMatrixColumn(objectMatrix, 0);\n\t\t\t\tv.crossVectors(scope.object.up, v);\n\n\t\t\t}\n\n\t\t\tv.multiplyScalar(distance);\n\n\t\t\tpanOffset.add(v);\n\n\t\t};\n\n\t}();\n\n\t// deltaX and deltaY are in pixels; right and down are positive\n\tvar pan = function () {\n\n\t\tvar offset = new THREE.Vector3();\n\n\t\treturn function pan(deltaX, deltaY) {\n\n\t\t\tvar element = scope.domElement;\n\n\t\t\tvar isCombinedCamera = THREE.CombinedCamera && scope.object instanceof THREE.CombinedCamera;\n\n\t\t\tif (scope.object instanceof THREE.PerspectiveCamera || (isCombinedCamera && scope.object.inPerspectiveMode)) {\n\n\t\t\t\t// perspective\n\t\t\t\tvar position = scope.object.position;\n\t\t\t\toffset.copy(position).sub(scope.target);\n\t\t\t\tvar targetDistance = offset.length();\n\n\t\t\t\t// half of the fov is center to top of screen\n\t\t\t\ttargetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);\n\n\t\t\t\t// we use only clientHeight here so aspect ratio does not distort speed\n\t\t\t\tpanLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);\n\t\t\t\tpanUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);\n\n\t\t\t} else if (scope.object instanceof THREE.OrthographicCamera || (isCombinedCamera && !scope.object.inPerspectiveMode)) {\n\n\t\t\t\t// orthographic\n\t\t\t\tpanLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);\n\t\t\t\tpanUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);\n\n\t\t\t} else {\n\n\t\t\t\t// camera neither orthographic nor perspective\n\t\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');\n\t\t\t\tscope.enablePan = false;\n\n\t\t\t}\n\n\t\t};\n\n\t}();\n\n\tfunction dollyIn(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale /= dollyScale;\n\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else if (THREE.CombinedCamera && scope.object instanceof THREE.CombinedCamera) {\n\n\t\t\tif (scope.object.inPerspectiveMode) {\n\t\t\t\tscale /= dollyScale;\n\t\t\t} else {\n\t\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\tfunction dollyOut(dollyScale) {\n\n\t\tif (scope.object.isPerspectiveCamera) {\n\n\t\t\tscale *= dollyScale;\n\n\t\t} else if (scope.object.isOrthographicCamera) {\n\n\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\tscope.object.updateProjectionMatrix();\n\t\t\tzoomChanged = true;\n\n\t\t} else if (THREE.CombinedCamera && scope.object instanceof THREE.CombinedCamera) {\n\n\t\t\tif (scope.object.inPerspectiveMode) {\n\t\t\t\tscale *= dollyScale;\n\t\t\t} else {\n\t\t\t\tscope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));\n\t\t\t\tscope.object.updateProjectionMatrix();\n\t\t\t\tzoomChanged = true;\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');\n\t\t\tscope.enableZoom = false;\n\n\t\t}\n\n\t}\n\n\t//\n\t// event callbacks - update the object state\n\t//\n\n\tfunction handleMouseDownRotate(event) {\n\n\t\trotateStart.set(event.clientX, event.clientY);\n\n\t}\n\n\tfunction handleMouseDownDolly(event) {\n\n\t\tdollyStart.set(event.clientX, event.clientY);\n\n\t}\n\n\tfunction handleMouseDownPan(event) {\n\n\t\tpanStart.set(event.clientX, event.clientY);\n\n\t}\n\n\tfunction handleMouseMoveRotate(event) {\n\n\t\trotateEnd.set(event.clientX, event.clientY);\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMoveDolly(event) {\n\n\t\tdollyEnd.set(event.clientX, event.clientY);\n\n\t\tdollyDelta.subVectors(dollyEnd, dollyStart);\n\n\t\tif (dollyDelta.y > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\n\t\t} else if (dollyDelta.y < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\n\t\t}\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseMovePan(event) {\n\n\t\tpanEnd.set(event.clientX, event.clientY);\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleMouseUp( /*event*/) {\n\n\t\t// no-op\n\n\t}\n\n\tfunction handleMouseWheel(event) {\n\n\t\tif (event.deltaY < 0) {\n\n\t\t\tdollyOut(getZoomScale());\n\n\t\t} else if (event.deltaY > 0) {\n\n\t\t\tdollyIn(getZoomScale());\n\n\t\t}\n\n\t\tscope.update();\n\n\t}\n\n\tfunction handleKeyDown(event) {\n\n\t\tvar needsUpdate = false;\n\n\t\tswitch (event.keyCode) {\n\n\t\t\tcase scope.keys.UP:\n\t\t\t\tpan(0, scope.keyPanSpeed);\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.BOTTOM:\n\t\t\t\tpan(0, - scope.keyPanSpeed);\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.LEFT:\n\t\t\t\tpan(scope.keyPanSpeed, 0);\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t\tcase scope.keys.RIGHT:\n\t\t\t\tpan(- scope.keyPanSpeed, 0);\n\t\t\t\tneedsUpdate = true;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif (needsUpdate) {\n\n\t\t\t// prevent the browser from scrolling on cursor keys\n\t\t\tevent.preventDefault();\n\n\t\t\tscope.update();\n\n\t\t}\n\n\n\t}\n\n\tfunction handleTouchStartRotate(event) {\n\n\t\tif (event.touches.length == 1) {\n\n\t\t\trotateStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t} else {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\trotateStart.set(x, y);\n\n\t\t}\n\n\t}\n\n\tfunction handleTouchStartPan(event) {\n\n\t\tif (event.touches.length == 1) {\n\n\t\t\tpanStart.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t} else {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanStart.set(x, y);\n\n\t\t}\n\n\t}\n\n\tfunction handleTouchStartDolly(event) {\n\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyStart.set(0, distance);\n\n\t}\n\n\tfunction handleTouchStartDollyPan(event) {\n\n\t\tif (scope.enableZoom) handleTouchStartDolly(event);\n\n\t\tif (scope.enablePan) handleTouchStartPan(event);\n\n\t}\n\n\tfunction handleTouchStartDollyRotate(event) {\n\n\t\tif (scope.enableZoom) handleTouchStartDolly(event);\n\n\t\tif (scope.enableRotate) handleTouchStartRotate(event);\n\n\t}\n\n\tfunction handleTouchMoveRotate(event) {\n\n\t\tif (event.touches.length == 1) {\n\n\t\t\trotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t} else {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\trotateEnd.set(x, y);\n\n\t\t}\n\n\t\trotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);\n\n\t\tvar element = scope.domElement;\n\n\t\trotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height\n\n\t\trotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);\n\n\t\trotateStart.copy(rotateEnd);\n\n\t}\n\n\tfunction handleTouchMovePan(event) {\n\n\t\tif (event.touches.length == 1) {\n\n\t\t\tpanEnd.set(event.touches[0].pageX, event.touches[0].pageY);\n\n\t\t} else {\n\n\t\t\tvar x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);\n\t\t\tvar y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);\n\n\t\t\tpanEnd.set(x, y);\n\n\t\t}\n\n\t\tpanDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);\n\n\t\tpan(panDelta.x, panDelta.y);\n\n\t\tpanStart.copy(panEnd);\n\n\t}\n\n\tfunction handleTouchMoveDolly(event) {\n\n\t\tvar dx = event.touches[0].pageX - event.touches[1].pageX;\n\t\tvar dy = event.touches[0].pageY - event.touches[1].pageY;\n\n\t\tvar distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\tdollyEnd.set(0, distance);\n\n\t\tdollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));\n\n\t\tdollyIn(dollyDelta.y);\n\n\t\tdollyStart.copy(dollyEnd);\n\n\t}\n\n\tfunction handleTouchMoveDollyPan(event) {\n\n\t\tif (scope.enableZoom) handleTouchMoveDolly(event);\n\n\t\tif (scope.enablePan) handleTouchMovePan(event);\n\n\t}\n\n\tfunction handleTouchMoveDollyRotate(event) {\n\n\t\tif (scope.enableZoom) handleTouchMoveDolly(event);\n\n\t\tif (scope.enableRotate) handleTouchMoveRotate(event);\n\n\t}\n\n\tfunction handleTouchEnd( /*event*/) {\n\n\t\t// no-op\n\n\t}\n\n\t//\n\t// event handlers - FSM: listen for events and reset state\n\t//\n\tthis.onMouseDownNoFocus = function onMouseDownNoFoucs(event) {\n\t\tif (scope.enabled === false) return;\n\n\t\t// Prevent the browser from scrolling.\n\n\t\tevent.preventDefault();\n\n\t\t// Manually set the focus since calling preventDefault above\n\t\t// prevents the browser from setting it automatically.\n\n\t\t// AXC: more generic mouse mappings\n\t\tstate = STATE.NONE;\n\t\tfor (var i = 0; i < scope.mouseMappings.length; i++) {\n\t\t\tvar mouseMapping = scope.mouseMappings[i];\n\n\t\t\t// Check if mouse mapping activates\n\t\t\tvar activated = mouseMapping.button === event.button;\n\t\t\tif (mouseMapping.keys && activated) {\n\t\t\t\tactivated = false;\n\t\t\t\tfor (var j = 0; j < mouseMapping.keys.length; j++) {\n\t\t\t\t\tvar key = mouseMapping.keys[j];\n\t\t\t\t\tif (event[key]) {\n\t\t\t\t\t\tactivated = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!activated) { continue; }\n\n\t\t\tvar handled = false;\n\t\t\tswitch (mouseMapping.action) {\n\n\t\t\t\tcase scope.actions.ORBIT:\n\t\t\t\t\tif (scope.enableRotate !== false) {\n\t\t\t\t\t\thandleMouseDownRotate(event);\n\t\t\t\t\t\tstate = STATE.ROTATE;\n\t\t\t\t\t\thandled = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.actions.ZOOM:\n\t\t\t\t\tif (scope.enableZoom !== false) {\n\t\t\t\t\t\thandleMouseDownDolly(event);\n\t\t\t\t\t\tstate = STATE.DOLLY;\n\t\t\t\t\t\thandled = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase scope.actions.PAN:\n\t\t\t\t\tif (scope.enablePan !== false) {\n\t\t\t\t\t\thandleMouseDownPan(event);\n\t\t\t\t\t\tstate = STATE.PAN;\n\t\t\t\t\t\thandled = true;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif (handled) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tdocument.addEventListener('mousemove', onMouseMove, false);\n\t\t\tdocument.addEventListener('mouseup', onMouseUp, false);\n\n\t\t\tscope.dispatchEvent(startEvent);\n\n\t\t}\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onMouseDown = function onMouseDown(event) {\n\t\t// TODO(AXC): check this focusing business\n\t\tscope.domElement.focus ? scope.domElement.focus() : window.focus();\n\n\t\tscope.onMouseDownNoFocus(event);\n\t}\n\n\tfunction onMouseMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (state) {\n\n\t\t\tcase STATE.ROTATE:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleMouseMoveRotate(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.DOLLY:\n\n\t\t\t\tif (scope.enableZoom === false) return;\n\n\t\t\t\thandleMouseMoveDolly(event);\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleMouseMovePan(event);\n\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction onMouseUp(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleMouseUp(event);\n\n\t\tdocument.removeEventListener('mousemove', onMouseMove, false);\n\t\tdocument.removeEventListener('mouseup', onMouseUp, false);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onMouseWheel = function onMouseWheel(event) {\n\n\t\tif (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tscope.dispatchEvent(startEvent);\n\n\t\thandleMouseWheel(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onKeyDown = function onKeyDown(event) {\n\n\t\tif (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;\n\n\t\thandleKeyDown(event);\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onTouchStart = function onTouchStart(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch (event.touches.length) {\n\n\t\t\tcase 1:\n\n\t\t\t\tswitch (scope.touches.ONE) {\n\n\t\t\t\t\tcase THREE.TOUCH.ROTATE:\n\n\t\t\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\t\t\thandleTouchStartRotate(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TOUCH.PAN:\n\n\t\t\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\t\t\thandleTouchStartPan(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\n\t\t\t\tswitch (scope.touches.TWO) {\n\n\t\t\t\t\tcase THREE.TOUCH.DOLLY_PAN:\n\n\t\t\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\t\t\thandleTouchStartDollyPan(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_PAN;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase THREE.TOUCH.DOLLY_ROTATE:\n\n\t\t\t\t\t\tif (scope.enableZoom === false && scope.enableRotate === false) return;\n\n\t\t\t\t\t\thandleTouchStartDollyRotate(event);\n\n\t\t\t\t\t\tstate = STATE.TOUCH_DOLLY_ROTATE;\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\n\t\t\t\t\t\tstate = STATE.NONE;\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t\tif (state !== STATE.NONE) {\n\n\t\t\tscope.dispatchEvent(startEvent);\n\n\t\t}\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onTouchMove = function onTouchMove(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch (state) {\n\n\t\t\tcase STATE.TOUCH_ROTATE:\n\n\t\t\t\tif (scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchMoveRotate(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_PAN:\n\n\t\t\t\tif (scope.enablePan === false) return;\n\n\t\t\t\thandleTouchMovePan(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_DOLLY_PAN:\n\n\t\t\t\tif (scope.enableZoom === false && scope.enablePan === false) return;\n\n\t\t\t\thandleTouchMoveDollyPan(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tcase STATE.TOUCH_DOLLY_ROTATE:\n\n\t\t\t\tif (scope.enableZoom === false && scope.enableRotate === false) return;\n\n\t\t\t\thandleTouchMoveDollyRotate(event);\n\n\t\t\t\tscope.update();\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tstate = STATE.NONE;\n\n\t\t}\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onTouchEnd = function onTouchEnd(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\thandleTouchEnd(event);\n\n\t\tscope.dispatchEvent(endEvent);\n\n\t\tstate = STATE.NONE;\n\n\t}\n\n\t// HXJ: more general listener function\n\tthis.onContextMenu = function onContextMenu(event) {\n\n\t\tif (scope.enabled === false) return;\n\n\t\tevent.preventDefault();\n\n\t}\n\n\t//\n\n\tscope.domElement.addEventListener('contextmenu', scope.onContextMenu, false);\n\n\tscope.domElement.addEventListener('mousedown', scope.onMouseDown, false);\n\tscope.domElement.addEventListener('wheel', scope.onMouseWheel, false);\n\n\tscope.domElement.addEventListener('touchstart', scope.onTouchStart, false);\n\tscope.domElement.addEventListener('touchend', scope.onTouchEnd, false);\n\tscope.domElement.addEventListener('touchmove', scope.onTouchMove, false);\n\n\tscope.domElement.addEventListener('keydown', scope.onKeyDown, false);\n\n\t// make sure element can receive keys.\n\n\tif (scope.domElement.tabIndex === - 1) {\n\n\t\tscope.domElement.tabIndex = 0;\n\n\t}\n\n\t// force an update at start\n\n\tthis.update();\n\n\t// AXC: Expose functions;\n\tthis.panLeft = function (delta) { pan(delta, 0); };\n\tthis.panUp = function (delta) { pan(0, delta); };\n\tthis.rotateLeft = rotateLeft;\n\tthis.rotateUp = rotateUp;\n\tthis.dollyIn = dollyIn;\n\tthis.dollyOut = dollyOut;\n};\n\nTHREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.OrbitControls.prototype.constructor = THREE.OrbitControls;\n\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nTHREE.MapControls = function (object, domElement) {\n\n\tTHREE.OrbitControls.call(this, object, domElement);\n\n\t// AXC: set mouse mappings\n\tthis.mouseMappings = [\n\t\t{ action: this.actions.PAN, button: THREE.MOUSE.LEFT },\n\t\t{ action: this.actions.ZOOM, button: THREE.MOUSE.MIDDLE },\n\t\t{ action: this.actions.ORBIT, button: THREE.MOUSE.RIGHT }\n\t];\n\n\n\tthis.touches.ONE = THREE.TOUCH.PAN;\n\tthis.touches.TWO = THREE.TOUCH.DOLLY_ROTATE;\n\n};\n\nTHREE.MapControls.prototype = Object.create(THREE.EventDispatcher.prototype);\nTHREE.MapControls.prototype.constructor = THREE.MapControls;\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/OrbitControls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/PointerLockControls.js":
/*!*********************************************************!*\
  !*** ./js/vendor/three/controls/PointerLockControls.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author mrdoob / http://mrdoob.com/\n * @author Mugen87 / https://github.com/Mugen87\n */\n\nTHREE.PointerLockControls = function ( camera, domElement ) {\n\n\tif ( domElement === undefined ) {\n\n\t\tconsole.warn( 'THREE.PointerLockControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tdomElement = document.body;\n\n\t}\n\n\tthis.domElement = domElement;\n\tthis.isLocked = false;\n\n\t//\n\t// internals\n\t//\n\n\tvar scope = this;\n\n\tvar changeEvent = { type: 'change' };\n\tvar lockEvent = { type: 'lock' };\n\tvar unlockEvent = { type: 'unlock' };\n\n\tvar euler = new THREE.Euler( 0, 0, 0, 'YXZ' );\n\n\tvar PI_2 = Math.PI / 2;\n\n\tvar vec = new THREE.Vector3();\n\n\tfunction onMouseMove( event ) {\n\n\t\tif ( scope.isLocked === false ) return;\n\n\t\tvar movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;\n\t\tvar movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;\n\n\t\teuler.setFromQuaternion( camera.quaternion );\n\n\t\teuler.y -= movementX * 0.002;\n\t\teuler.x -= movementY * 0.002;\n\n\t\teuler.x = Math.max( - PI_2, Math.min( PI_2, euler.x ) );\n\n\t\tcamera.quaternion.setFromEuler( euler );\n\n\t\tscope.dispatchEvent( changeEvent );\n\n\t}\n\n\tfunction onPointerlockChange() {\n\n\t\tif ( document.pointerLockElement === scope.domElement ) {\n\n\t\t\tscope.dispatchEvent( lockEvent );\n\n\t\t\tscope.isLocked = true;\n\n\t\t} else {\n\n\t\t\tscope.dispatchEvent( unlockEvent );\n\n\t\t\tscope.isLocked = false;\n\n\t\t}\n\n\t}\n\n\tfunction onPointerlockError() {\n\n\t\tconsole.error( 'THREE.PointerLockControls: Unable to use Pointer Lock API' );\n\n\t}\n\n\tthis.connect = function () {\n\n\t\tdocument.addEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.addEventListener( 'pointerlockchange', onPointerlockChange, false );\n\t\tdocument.addEventListener( 'pointerlockerror', onPointerlockError, false );\n\n\t};\n\n\tthis.disconnect = function () {\n\n\t\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\n\t\tdocument.removeEventListener( 'pointerlockchange', onPointerlockChange, false );\n\t\tdocument.removeEventListener( 'pointerlockerror', onPointerlockError, false );\n\n\t};\n\n\tthis.dispose = function () {\n\n\t\tthis.disconnect();\n\n\t};\n\n\tthis.getObject = function () { // retaining this method for backward compatibility\n\n\t\treturn camera;\n\n\t};\n\n\tthis.getDirection = function () {\n\n\t\tvar direction = new THREE.Vector3( 0, 0, - 1 );\n\n\t\treturn function ( v ) {\n\n\t\t\treturn v.copy( direction ).applyQuaternion( camera.quaternion );\n\n\t\t};\n\n\t}();\n\n\tthis.moveForward = function ( distance ) {\n\n\t\t// move forward parallel to the xz-plane\n\t\t// assumes camera.up is y-up\n\n\t\tvec.setFromMatrixColumn( camera.matrix, 0 );\n\n\t\tvec.crossVectors( camera.up, vec );\n\n\t\tcamera.position.addScaledVector( vec, distance );\n\n\t};\n\n\tthis.moveRight = function ( distance ) {\n\n\t\tvec.setFromMatrixColumn( camera.matrix, 0 );\n\n\t\tcamera.position.addScaledVector( vec, distance );\n\n\t};\n\n\tthis.lock = function () {\n\n\t\tthis.domElement.requestPointerLock();\n\n\t};\n\n\tthis.unlock = function () {\n\n\t\tdocument.exitPointerLock();\n\n\t};\n\n\tthis.connect();\n\n};\n\nTHREE.PointerLockControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.PointerLockControls.prototype.constructor = THREE.PointerLockControls;\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/PointerLockControls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/TrackballControls.js":
/*!*******************************************************!*\
  !*** ./js/vendor/three/controls/TrackballControls.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Eberhard Graether / http://egraether.com/\n * @author Mark Lundin \t/ http://mark-lundin.com\n * @author Simone Manini / http://daron1337.github.io\n * @author Luca Antiga \t/ http://lantiga.github.io\n */\n\nTHREE.TrackballControls = function ( object, domElement ) {\n\n\tif ( domElement === undefined ) console.warn( 'THREE.TrackballControls: The second parameter \"domElement\" is now mandatory.' );\n\tif ( domElement === document ) console.error( 'THREE.TrackballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.' );\n\n\tvar _this = this;\n\tvar STATE = { NONE: - 1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM_PAN: 4 };\n\n\tthis.object = object;\n\tthis.domElement = domElement;\n\n\t// API\n\n\tthis.enabled = true;\n\n\tthis.screen = { left: 0, top: 0, width: 0, height: 0 };\n\n\tthis.rotateSpeed = 1.0;\n\tthis.zoomSpeed = 1.2;\n\tthis.panSpeed = 0.3;\n\n\tthis.noRotate = false;\n\tthis.noZoom = false;\n\tthis.noPan = false;\n\n\tthis.staticMoving = false;\n\tthis.dynamicDampingFactor = 0.2;\n\n\tthis.minDistance = 0;\n\tthis.maxDistance = Infinity;\n\n\tthis.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];\n\n\tthis.mouseButtons = { LEFT: THREE.MOUSE.ROTATE, MIDDLE: THREE.MOUSE.ZOOM, RIGHT: THREE.MOUSE.PAN };\n\n\t// internals\n\n\tthis.target = new THREE.Vector3();\n\n\tvar EPS = 0.000001;\n\n\tvar lastPosition = new THREE.Vector3();\n\tvar lastZoom = 1;\n\n\tvar _state = STATE.NONE,\n\t\t_keyState = STATE.NONE,\n\n\t\t_eye = new THREE.Vector3(),\n\n\t\t_movePrev = new THREE.Vector2(),\n\t\t_moveCurr = new THREE.Vector2(),\n\n\t\t_lastAxis = new THREE.Vector3(),\n\t\t_lastAngle = 0,\n\n\t\t_zoomStart = new THREE.Vector2(),\n\t\t_zoomEnd = new THREE.Vector2(),\n\n\t\t_touchZoomDistanceStart = 0,\n\t\t_touchZoomDistanceEnd = 0,\n\n\t\t_panStart = new THREE.Vector2(),\n\t\t_panEnd = new THREE.Vector2();\n\n\t// for reset\n\n\tthis.target0 = this.target.clone();\n\tthis.position0 = this.object.position.clone();\n\tthis.up0 = this.object.up.clone();\n\tthis.zoom0 = this.object.zoom;\n\n\t// events\n\n\tvar changeEvent = { type: 'change' };\n\tvar startEvent = { type: 'start' };\n\tvar endEvent = { type: 'end' };\n\n\n\t// methods\n\n\tthis.handleResize = function () {\n\n\t\tvar box = this.domElement.getBoundingClientRect();\n\t\t// adjustments come from similar code in the jquery offset() function\n\t\tvar d = this.domElement.ownerDocument.documentElement;\n\t\tthis.screen.left = box.left + window.pageXOffset - d.clientLeft;\n\t\tthis.screen.top = box.top + window.pageYOffset - d.clientTop;\n\t\tthis.screen.width = box.width;\n\t\tthis.screen.height = box.height;\n\n\t};\n\n\tvar getMouseOnScreen = ( function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnScreen( pageX, pageY ) {\n\n\t\t\tvector.set(\n\t\t\t\t( pageX - _this.screen.left ) / _this.screen.width,\n\t\t\t\t( pageY - _this.screen.top ) / _this.screen.height\n\t\t\t);\n\n\t\t\treturn vector;\n\n\t\t};\n\n\t}() );\n\n\tvar getMouseOnCircle = ( function () {\n\n\t\tvar vector = new THREE.Vector2();\n\n\t\treturn function getMouseOnCircle( pageX, pageY ) {\n\n\t\t\tvector.set(\n\t\t\t\t( ( pageX - _this.screen.width * 0.5 - _this.screen.left ) / ( _this.screen.width * 0.5 ) ),\n\t\t\t\t( ( _this.screen.height + 2 * ( _this.screen.top - pageY ) ) / _this.screen.width ) // screen.width intentional\n\t\t\t);\n\n\t\t\treturn vector;\n\n\t\t};\n\n\t}() );\n\n\tthis.rotateCamera = ( function () {\n\n\t\tvar axis = new THREE.Vector3(),\n\t\t\tquaternion = new THREE.Quaternion(),\n\t\t\teyeDirection = new THREE.Vector3(),\n\t\t\tobjectUpDirection = new THREE.Vector3(),\n\t\t\tobjectSidewaysDirection = new THREE.Vector3(),\n\t\t\tmoveDirection = new THREE.Vector3(),\n\t\t\tangle;\n\n\t\treturn function rotateCamera() {\n\n\t\t\tmoveDirection.set( _moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0 );\n\t\t\tangle = moveDirection.length();\n\n\t\t\tif ( angle ) {\n\n\t\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\n\n\t\t\t\teyeDirection.copy( _eye ).normalize();\n\t\t\t\tobjectUpDirection.copy( _this.object.up ).normalize();\n\t\t\t\tobjectSidewaysDirection.crossVectors( objectUpDirection, eyeDirection ).normalize();\n\n\t\t\t\tobjectUpDirection.setLength( _moveCurr.y - _movePrev.y );\n\t\t\t\tobjectSidewaysDirection.setLength( _moveCurr.x - _movePrev.x );\n\n\t\t\t\tmoveDirection.copy( objectUpDirection.add( objectSidewaysDirection ) );\n\n\t\t\t\taxis.crossVectors( moveDirection, _eye ).normalize();\n\n\t\t\t\tangle *= _this.rotateSpeed;\n\t\t\t\tquaternion.setFromAxisAngle( axis, angle );\n\n\t\t\t\t_eye.applyQuaternion( quaternion );\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\n\n\t\t\t\t_lastAxis.copy( axis );\n\t\t\t\t_lastAngle = angle;\n\n\t\t\t} else if ( ! _this.staticMoving && _lastAngle ) {\n\n\t\t\t\t_lastAngle *= Math.sqrt( 1.0 - _this.dynamicDampingFactor );\n\t\t\t\t_eye.copy( _this.object.position ).sub( _this.target );\n\t\t\t\tquaternion.setFromAxisAngle( _lastAxis, _lastAngle );\n\t\t\t\t_eye.applyQuaternion( quaternion );\n\t\t\t\t_this.object.up.applyQuaternion( quaternion );\n\n\t\t\t}\n\n\t\t\t_movePrev.copy( _moveCurr );\n\n\t\t};\n\n\t}() );\n\n\n\tthis.zoomCamera = function () {\n\n\t\tvar factor;\n\n\t\tif ( _state === STATE.TOUCH_ZOOM_PAN ) {\n\n\t\t\tfactor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n\t\t\t_touchZoomDistanceStart = _touchZoomDistanceEnd;\n\n\t\t\tif ( _this.object.isPerspectiveCamera ) {\n\n\t\t\t\t_eye.multiplyScalar( factor );\n\n\t\t\t} else if ( _this.object.isOrthographicCamera ) {\n\n\t\t\t\t_this.object.zoom *= factor;\n\t\t\t\t_this.object.updateProjectionMatrix();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'THREE.TrackballControls: Unsupported camera type' );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfactor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;\n\n\t\t\tif ( factor !== 1.0 && factor > 0.0 ) {\n\n\t\t\t\tif ( _this.object.isPerspectiveCamera ) {\n\n\t\t\t\t\t_eye.multiplyScalar( factor );\n\n\t\t\t\t} else if ( _this.object.isOrthographicCamera ) {\n\n\t\t\t\t\t_this.object.zoom /= factor;\n\t\t\t\t\t_this.object.updateProjectionMatrix();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.TrackballControls: Unsupported camera type' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t_zoomStart.copy( _zoomEnd );\n\n\t\t\t} else {\n\n\t\t\t\t_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.panCamera = ( function () {\n\n\t\tvar mouseChange = new THREE.Vector2(),\n\t\t\tobjectUp = new THREE.Vector3(),\n\t\t\tpan = new THREE.Vector3();\n\n\t\treturn function panCamera() {\n\n\t\t\tmouseChange.copy( _panEnd ).sub( _panStart );\n\n\t\t\tif ( mouseChange.lengthSq() ) {\n\n\t\t\t\tif ( _this.object.isOrthographicCamera ) {\n\n\t\t\t\t\tvar scale_x = ( _this.object.right - _this.object.left ) / _this.object.zoom / _this.domElement.clientWidth;\n\t\t\t\t\tvar scale_y = ( _this.object.top - _this.object.bottom ) / _this.object.zoom / _this.domElement.clientWidth;\n\n\t\t\t\t\tmouseChange.x *= scale_x;\n\t\t\t\t\tmouseChange.y *= scale_y;\n\n\t\t\t\t}\n\n\t\t\t\tmouseChange.multiplyScalar( _eye.length() * _this.panSpeed );\n\n\t\t\t\tpan.copy( _eye ).cross( _this.object.up ).setLength( mouseChange.x );\n\t\t\t\tpan.add( objectUp.copy( _this.object.up ).setLength( mouseChange.y ) );\n\n\t\t\t\t_this.object.position.add( pan );\n\t\t\t\t_this.target.add( pan );\n\n\t\t\t\tif ( _this.staticMoving ) {\n\n\t\t\t\t\t_panStart.copy( _panEnd );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t};\n\n\t}() );\n\n\tthis.checkDistances = function () {\n\n\t\tif ( ! _this.noZoom || ! _this.noPan ) {\n\n\t\t\tif ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );\n\t\t\t\t_zoomStart.copy( _zoomEnd );\n\n\t\t\t}\n\n\t\t\tif ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {\n\n\t\t\t\t_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );\n\t\t\t\t_zoomStart.copy( _zoomEnd );\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.update = function () {\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\tif ( ! _this.noRotate ) {\n\n\t\t\t_this.rotateCamera();\n\n\t\t}\n\n\t\tif ( ! _this.noZoom ) {\n\n\t\t\t_this.zoomCamera();\n\n\t\t}\n\n\t\tif ( ! _this.noPan ) {\n\n\t\t\t_this.panCamera();\n\n\t\t}\n\n\t\t_this.object.position.addVectors( _this.target, _eye );\n\n\t\tif ( _this.object.isPerspectiveCamera ) {\n\n\t\t\t_this.checkDistances();\n\n\t\t\t_this.object.lookAt( _this.target );\n\n\t\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > EPS ) {\n\n\t\t\t\t_this.dispatchEvent( changeEvent );\n\n\t\t\t\tlastPosition.copy( _this.object.position );\n\n\t\t\t}\n\n\t\t} else if ( _this.object.isOrthographicCamera ) {\n\n\t\t\t_this.object.lookAt( _this.target );\n\n\t\t\tif ( lastPosition.distanceToSquared( _this.object.position ) > EPS ||lastZoom !== _this.object.zoom ) {\n\n\t\t\t\t_this.dispatchEvent( changeEvent );\n\n\t\t\t\tlastPosition.copy( _this.object.position );\n\t\t\t\tlastZoom = _this.object.zoom;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tconsole.warn( 'THREE.TrackballControls: Unsupported camera type' );\n\n\t\t}\n\n\t};\n\n\tthis.reset = function () {\n\n\t\t_state = STATE.NONE;\n\t\t_keyState = STATE.NONE;\n\n\t\t_this.target.copy( _this.target0 );\n\t\t_this.object.position.copy( _this.position0 );\n\t\t_this.object.up.copy( _this.up0 );\n\t\t_this.object.zoom = _this.zoom0;\n\n\t\t_this.object.updateProjectionMatrix();\n\n\t\t_eye.subVectors( _this.object.position, _this.target );\n\n\t\t_this.object.lookAt( _this.target );\n\n\t\t_this.dispatchEvent( changeEvent );\n\n\t\tlastPosition.copy( _this.object.position );\n\t\tlastZoom = _this.object.zoom;\n\n\t};\n\n\t// listeners\n\n\tfunction keydown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\twindow.removeEventListener( 'keydown', keydown );\n\n\t\tif ( _keyState !== STATE.NONE ) {\n\n\t\t\treturn;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && ! _this.noRotate ) {\n\n\t\t\t_keyState = STATE.ROTATE;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && ! _this.noZoom ) {\n\n\t\t\t_keyState = STATE.ZOOM;\n\n\t\t} else if ( event.keyCode === _this.keys[ STATE.PAN ] && ! _this.noPan ) {\n\n\t\t\t_keyState = STATE.PAN;\n\n\t\t}\n\n\t}\n\n\tfunction keyup() {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\t_keyState = STATE.NONE;\n\n\t\twindow.addEventListener( 'keydown', keydown, false );\n\n\t}\n\n\tfunction mousedown( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tif ( _state === STATE.NONE ) {\n\n\t\t\tswitch ( event.button ) {\n\n\t\t\t\tcase _this.mouseButtons.LEFT:\n\t\t\t\t\t_state = STATE.ROTATE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _this.mouseButtons.MIDDLE:\n\t\t\t\t\t_state = STATE.ZOOM;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase _this.mouseButtons.RIGHT:\n\t\t\t\t\t_state = STATE.PAN;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t_state = STATE.NONE;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar state = ( _keyState !== STATE.NONE ) ? _keyState : _state;\n\n\t\tif ( state === STATE.ROTATE && ! _this.noRotate ) {\n\n\t\t\t_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );\n\t\t\t_movePrev.copy( _moveCurr );\n\n\t\t} else if ( state === STATE.ZOOM && ! _this.noZoom ) {\n\n\t\t\t_zoomStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\n\t\t\t_zoomEnd.copy( _zoomStart );\n\n\t\t} else if ( state === STATE.PAN && ! _this.noPan ) {\n\n\t\t\t_panStart.copy( getMouseOnScreen( event.pageX, event.pageY ) );\n\t\t\t_panEnd.copy( _panStart );\n\n\t\t}\n\n\t\tdocument.addEventListener( 'mousemove', mousemove, false );\n\t\tdocument.addEventListener( 'mouseup', mouseup, false );\n\n\t\t_this.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction mousemove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tvar state = ( _keyState !== STATE.NONE ) ? _keyState : _state;\n\n\t\tif ( state === STATE.ROTATE && ! _this.noRotate ) {\n\n\t\t\t_movePrev.copy( _moveCurr );\n\t\t\t_moveCurr.copy( getMouseOnCircle( event.pageX, event.pageY ) );\n\n\t\t} else if ( state === STATE.ZOOM && ! _this.noZoom ) {\n\n\t\t\t_zoomEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\n\n\t\t} else if ( state === STATE.PAN && ! _this.noPan ) {\n\n\t\t\t_panEnd.copy( getMouseOnScreen( event.pageX, event.pageY ) );\n\n\t\t}\n\n\t}\n\n\tfunction mouseup( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\t_state = STATE.NONE;\n\n\t\tdocument.removeEventListener( 'mousemove', mousemove );\n\t\tdocument.removeEventListener( 'mouseup', mouseup );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction mousewheel( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tif ( _this.noZoom === true ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.deltaMode ) {\n\n\t\t\tcase 2:\n\t\t\t\t// Zoom in pages\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.025;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t// Zoom in lines\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.01;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t// undefined, 0, assume pixels\n\t\t\t\t_zoomStart.y -= event.deltaY * 0.00025;\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent( startEvent );\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction touchstart( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\n\t\t\t\t_movePrev.copy( _moveCurr );\n\t\t\t\tbreak;\n\n\t\t\tdefault: // 2 or more\n\t\t\t\t_state = STATE.TOUCH_ZOOM_PAN;\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\n\t\t\t\t_panStart.copy( getMouseOnScreen( x, y ) );\n\t\t\t\t_panEnd.copy( _panStart );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent( startEvent );\n\n\t}\n\n\tfunction touchmove( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 1:\n\t\t\t\t_movePrev.copy( _moveCurr );\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\n\t\t\t\tbreak;\n\n\t\t\tdefault: // 2 or more\n\t\t\t\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\n\t\t\t\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\n\t\t\t\t_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );\n\n\t\t\t\tvar x = ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX ) / 2;\n\t\t\t\tvar y = ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY ) / 2;\n\t\t\t\t_panEnd.copy( getMouseOnScreen( x, y ) );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t}\n\n\tfunction touchend( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tswitch ( event.touches.length ) {\n\n\t\t\tcase 0:\n\t\t\t\t_state = STATE.NONE;\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\t_state = STATE.TOUCH_ROTATE;\n\t\t\t\t_moveCurr.copy( getMouseOnCircle( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY ) );\n\t\t\t\t_movePrev.copy( _moveCurr );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\t_this.dispatchEvent( endEvent );\n\n\t}\n\n\tfunction contextmenu( event ) {\n\n\t\tif ( _this.enabled === false ) return;\n\n\t\tevent.preventDefault();\n\n\t}\n\n\tthis.dispose = function () {\n\n\t\tthis.domElement.removeEventListener( 'contextmenu', contextmenu, false );\n\t\tthis.domElement.removeEventListener( 'mousedown', mousedown, false );\n\t\tthis.domElement.removeEventListener( 'wheel', mousewheel, false );\n\n\t\tthis.domElement.removeEventListener( 'touchstart', touchstart, false );\n\t\tthis.domElement.removeEventListener( 'touchend', touchend, false );\n\t\tthis.domElement.removeEventListener( 'touchmove', touchmove, false );\n\n\t\tdocument.removeEventListener( 'mousemove', mousemove, false );\n\t\tdocument.removeEventListener( 'mouseup', mouseup, false );\n\n\t\twindow.removeEventListener( 'keydown', keydown, false );\n\t\twindow.removeEventListener( 'keyup', keyup, false );\n\n\t};\n\n\tthis.domElement.addEventListener( 'contextmenu', contextmenu, false );\n\tthis.domElement.addEventListener( 'mousedown', mousedown, false );\n\tthis.domElement.addEventListener( 'wheel', mousewheel, false );\n\n\tthis.domElement.addEventListener( 'touchstart', touchstart, false );\n\tthis.domElement.addEventListener( 'touchend', touchend, false );\n\tthis.domElement.addEventListener( 'touchmove', touchmove, false );\n\n\twindow.addEventListener( 'keydown', keydown, false );\n\twindow.addEventListener( 'keyup', keyup, false );\n\n\tthis.handleResize();\n\n\t// force an update at start\n\tthis.update();\n\n};\n\nTHREE.TrackballControls.prototype = Object.create( THREE.EventDispatcher.prototype );\nTHREE.TrackballControls.prototype.constructor = THREE.TrackballControls;\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/TrackballControls.js?");

/***/ }),

/***/ "./js/vendor/three/controls/TransformControls.js":
/*!*******************************************************!*\
  !*** ./js/vendor/three/controls/TransformControls.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author arodic / https://github.com/arodic\n */\n\nTHREE.TransformControls = function ( camera, domElement ) {\n\n\tif ( domElement === undefined ) {\n\n\t\tconsole.warn( 'THREE.TransformControls: The second parameter \"domElement\" is now mandatory.' );\n\t\tdomElement = document;\n\n\t}\n\n\tTHREE.Object3D.call( this );\n\n\tthis.visible = false;\n\n\tvar _gizmo = new THREE.TransformControlsGizmo();\n\tthis.add( _gizmo );\n\n\tvar _plane = new THREE.TransformControlsPlane();\n\tthis.add( _plane );\n\n\tvar scope = this;\n\n\t// Define properties with getters/setter\n\t// Setting the defined property will automatically trigger change event\n\t// Defined properties are passed down to gizmo and plane\n\n\tdefineProperty( \"camera\", camera );\n\tdefineProperty( \"object\", undefined );\n\tdefineProperty( \"enabled\", true );\n\tdefineProperty( \"axis\", null );\n\tdefineProperty( \"mode\", \"translate\" );\n\tdefineProperty( \"translationSnap\", null );\n\tdefineProperty( \"rotationSnap\", null );\n\tdefineProperty( \"space\", \"world\" );\n\tdefineProperty( \"size\", 1 );\n\tdefineProperty( \"dragging\", false );\n\tdefineProperty( \"showX\", true );\n\tdefineProperty( \"showY\", true );\n\tdefineProperty( \"showZ\", true );\n\n\tvar changeEvent = { type: \"change\" };\n\tvar mouseDownEvent = { type: \"mouseDown\" };\n\tvar mouseUpEvent = { type: \"mouseUp\", mode: scope.mode };\n\tvar objectChangeEvent = { type: \"objectChange\" };\n\n\t// Reusable utility variables\n\n\tvar ray = new THREE.Raycaster();\n\n\tvar _tempVector = new THREE.Vector3();\n\tvar _tempVector2 = new THREE.Vector3();\n\tvar _tempQuaternion = new THREE.Quaternion();\n\tvar _unit = {\n\t\tX: new THREE.Vector3( 1, 0, 0 ),\n\t\tY: new THREE.Vector3( 0, 1, 0 ),\n\t\tZ: new THREE.Vector3( 0, 0, 1 )\n\t};\n\n\tvar pointStart = new THREE.Vector3();\n\tvar pointEnd = new THREE.Vector3();\n\tvar offset = new THREE.Vector3();\n\tvar rotationAxis = new THREE.Vector3();\n\tvar startNorm = new THREE.Vector3();\n\tvar endNorm = new THREE.Vector3();\n\tvar rotationAngle = 0;\n\n\tvar cameraPosition = new THREE.Vector3();\n\tvar cameraQuaternion = new THREE.Quaternion();\n\tvar cameraScale = new THREE.Vector3();\n\n\tvar parentPosition = new THREE.Vector3();\n\tvar parentQuaternion = new THREE.Quaternion();\n\tvar parentQuaternionInv = new THREE.Quaternion();\n\tvar parentScale = new THREE.Vector3();\n\n\tvar worldPositionStart = new THREE.Vector3();\n\tvar worldQuaternionStart = new THREE.Quaternion();\n\tvar worldScaleStart = new THREE.Vector3();\n\n\tvar worldPosition = new THREE.Vector3();\n\tvar worldQuaternion = new THREE.Quaternion();\n\tvar worldQuaternionInv = new THREE.Quaternion();\n\tvar worldScale = new THREE.Vector3();\n\n\tvar eye = new THREE.Vector3();\n\n\tvar positionStart = new THREE.Vector3();\n\tvar quaternionStart = new THREE.Quaternion();\n\tvar scaleStart = new THREE.Vector3();\n\n\t// TODO: remove properties unused in plane and gizmo\n\n\tdefineProperty( \"worldPosition\", worldPosition );\n\tdefineProperty( \"worldPositionStart\", worldPositionStart );\n\tdefineProperty( \"worldQuaternion\", worldQuaternion );\n\tdefineProperty( \"worldQuaternionStart\", worldQuaternionStart );\n\tdefineProperty( \"cameraPosition\", cameraPosition );\n\tdefineProperty( \"cameraQuaternion\", cameraQuaternion );\n\tdefineProperty( \"pointStart\", pointStart );\n\tdefineProperty( \"pointEnd\", pointEnd );\n\tdefineProperty( \"rotationAxis\", rotationAxis );\n\tdefineProperty( \"rotationAngle\", rotationAngle );\n\tdefineProperty( \"eye\", eye );\n\n\t{\n\n\t\tdomElement.addEventListener( \"mousedown\", onPointerDown, false );\n\t\tdomElement.addEventListener( \"touchstart\", onPointerDown, false );\n\t\tdomElement.addEventListener( \"mousemove\", onPointerHover, false );\n\t\tdomElement.addEventListener( \"touchmove\", onPointerHover, false );\n\t\tdomElement.addEventListener( \"touchmove\", onPointerMove, false );\n\t\tdocument.addEventListener( \"mouseup\", onPointerUp, false );\n\t\tdomElement.addEventListener( \"touchend\", onPointerUp, false );\n\t\tdomElement.addEventListener( \"touchcancel\", onPointerUp, false );\n\t\tdomElement.addEventListener( \"touchleave\", onPointerUp, false );\n\n\t}\n\n\tthis.dispose = function () {\n\n\t\tdomElement.removeEventListener( \"mousedown\", onPointerDown );\n\t\tdomElement.removeEventListener( \"touchstart\", onPointerDown );\n\t\tdomElement.removeEventListener( \"mousemove\", onPointerHover );\n\t\tdocument.removeEventListener( \"mousemove\", onPointerMove );\n\t\tdomElement.removeEventListener( \"touchmove\", onPointerHover );\n\t\tdomElement.removeEventListener( \"touchmove\", onPointerMove );\n\t\tdocument.removeEventListener( \"mouseup\", onPointerUp );\n\t\tdomElement.removeEventListener( \"touchend\", onPointerUp );\n\t\tdomElement.removeEventListener( \"touchcancel\", onPointerUp );\n\t\tdomElement.removeEventListener( \"touchleave\", onPointerUp );\n\n\t\tthis.traverse( function ( child ) {\n\n\t\t\tif ( child.geometry ) child.geometry.dispose();\n\t\t\tif ( child.material ) child.material.dispose();\n\n\t\t} );\n\n\t};\n\n\t// Set current object\n\tthis.attach = function ( object ) {\n\n\t\tthis.object = object;\n\t\tthis.visible = true;\n\n\t\treturn this;\n\n\t};\n\n\t// Detatch from object\n\tthis.detach = function () {\n\n\t\tthis.object = undefined;\n\t\tthis.visible = false;\n\t\tthis.axis = null;\n\n\t\treturn this;\n\n\t};\n\n\t// Defined getter, setter and store for a property\n\tfunction defineProperty( propName, defaultValue ) {\n\n\t\tvar propValue = defaultValue;\n\n\t\tObject.defineProperty( scope, propName, {\n\n\t\t\tget: function () {\n\n\t\t\t\treturn propValue !== undefined ? propValue : defaultValue;\n\n\t\t\t},\n\n\t\t\tset: function ( value ) {\n\n\t\t\t\tif ( propValue !== value ) {\n\n\t\t\t\t\tpropValue = value;\n\t\t\t\t\t_plane[ propName ] = value;\n\t\t\t\t\t_gizmo[ propName ] = value;\n\n\t\t\t\t\tscope.dispatchEvent( { type: propName + \"-changed\", value: value } );\n\t\t\t\t\tscope.dispatchEvent( changeEvent );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t\tscope[ propName ] = defaultValue;\n\t\t_plane[ propName ] = defaultValue;\n\t\t_gizmo[ propName ] = defaultValue;\n\n\t}\n\n\t// updateMatrixWorld  updates key transformation variables\n\tthis.updateMatrixWorld = function () {\n\n\t\tif ( this.object !== undefined ) {\n\n\t\t\tthis.object.updateMatrixWorld();\n\t\t\tthis.object.parent.matrixWorld.decompose( parentPosition, parentQuaternion, parentScale );\n\t\t\tthis.object.matrixWorld.decompose( worldPosition, worldQuaternion, worldScale );\n\n\t\t\tparentQuaternionInv.copy( parentQuaternion ).inverse();\n\t\t\tworldQuaternionInv.copy( worldQuaternion ).inverse();\n\n\t\t}\n\n\t\tthis.camera.updateMatrixWorld();\n\t\tthis.camera.matrixWorld.decompose( cameraPosition, cameraQuaternion, cameraScale );\n\n\t\teye.copy( cameraPosition ).sub( worldPosition ).normalize();\n\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n\tthis.pointerHover = function ( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) return;\n\n\t\tray.setFromCamera( pointer, this.camera );\n\n\t\tvar intersect = ray.intersectObjects( _gizmo.picker[ this.mode ].children, true )[ 0 ] || false;\n\n\t\tif ( intersect ) {\n\n\t\t\tthis.axis = intersect.object.name;\n\n\t\t} else {\n\n\t\t\tthis.axis = null;\n\n\t\t}\n\n\t};\n\n\tthis.pointerDown = function ( pointer ) {\n\n\t\tif ( this.object === undefined || this.dragging === true || ( pointer.button !== undefined && pointer.button !== 0 ) ) return;\n\n\t\tif ( ( pointer.button === 0 || pointer.button === undefined ) && this.axis !== null ) {\n\n\t\t\tray.setFromCamera( pointer, this.camera );\n\n\t\t\tvar planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;\n\n\t\t\tif ( planeIntersect ) {\n\n\t\t\t\tvar space = this.space;\n\n\t\t\t\tif ( this.mode === 'scale' ) {\n\n\t\t\t\t\tspace = 'local';\n\n\t\t\t\t} else if ( this.axis === 'E' || this.axis === 'XYZE' || this.axis === 'XYZ' ) {\n\n\t\t\t\t\tspace = 'world';\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'local' && this.mode === 'rotate' ) {\n\n\t\t\t\t\tvar snap = this.rotationSnap;\n\n\t\t\t\t\tif ( this.axis === 'X' && snap ) this.object.rotation.x = Math.round( this.object.rotation.x / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Y' && snap ) this.object.rotation.y = Math.round( this.object.rotation.y / snap ) * snap;\n\t\t\t\t\tif ( this.axis === 'Z' && snap ) this.object.rotation.z = Math.round( this.object.rotation.z / snap ) * snap;\n\n\t\t\t\t}\n\n\t\t\t\tthis.object.updateMatrixWorld();\n\t\t\t\tthis.object.parent.updateMatrixWorld();\n\n\t\t\t\tpositionStart.copy( this.object.position );\n\t\t\t\tquaternionStart.copy( this.object.quaternion );\n\t\t\t\tscaleStart.copy( this.object.scale );\n\n\t\t\t\tthis.object.matrixWorld.decompose( worldPositionStart, worldQuaternionStart, worldScaleStart );\n\n\t\t\t\tpointStart.copy( planeIntersect.point ).sub( worldPositionStart );\n\n\t\t\t}\n\n\t\t\tthis.dragging = true;\n\t\t\tmouseDownEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( mouseDownEvent );\n\n\t\t\t// AXC: Track event handled\n\t\t\treturn true;\n\t\t}\n\n\t};\n\n\tthis.pointerMove = function ( pointer ) {\n\n\t\tvar axis = this.axis;\n\t\tvar mode = this.mode;\n\t\tvar object = this.object;\n\t\tvar space = this.space;\n\n\t\tif ( mode === 'scale' ) {\n\n\t\t\tspace = 'local';\n\n\t\t} else if ( axis === 'E' || axis === 'XYZE' || axis === 'XYZ' ) {\n\n\t\t\tspace = 'world';\n\n\t\t}\n\n\t\tif ( object === undefined || axis === null || this.dragging === false || ( pointer.button !== undefined && pointer.button !== 0 ) ) return;\n\n\t\tray.setFromCamera( pointer, this.camera );\n\n\t\tvar planeIntersect = ray.intersectObjects( [ _plane ], true )[ 0 ] || false;\n\n\t\tif ( planeIntersect === false ) return;\n\n\t\tpointEnd.copy( planeIntersect.point ).sub( worldPositionStart );\n\n\t\tif ( mode === 'translate' ) {\n\n\t\t\t// Apply translate\n\n\t\t\toffset.copy( pointEnd ).sub( pointStart );\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\toffset.applyQuaternion( worldQuaternionInv );\n\n\t\t\t}\n\n\t\t\tif ( axis.indexOf( 'X' ) === - 1 ) offset.x = 0;\n\t\t\tif ( axis.indexOf( 'Y' ) === - 1 ) offset.y = 0;\n\t\t\tif ( axis.indexOf( 'Z' ) === - 1 ) offset.z = 0;\n\n\t\t\tif ( space === 'local' && axis !== 'XYZ' ) {\n\n\t\t\t\toffset.applyQuaternion( quaternionStart ).divide( parentScale );\n\n\t\t\t} else {\n\n\t\t\t\toffset.applyQuaternion( parentQuaternionInv ).divide( parentScale );\n\n\t\t\t}\n\n\t\t\tobject.position.copy( offset ).add( positionStart );\n\n\t\t\t// Apply translation snap\n\n\t\t\tif ( this.translationSnap ) {\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\tobject.position.applyQuaternion( _tempQuaternion.copy( quaternionStart ).inverse() );\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobject.position.applyQuaternion( quaternionStart );\n\n\t\t\t\t}\n\n\t\t\t\tif ( space === 'world' ) {\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.add( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.x = Math.round( object.position.x / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.y = Math.round( object.position.y / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( axis.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\t\tobject.position.z = Math.round( object.position.z / this.translationSnap ) * this.translationSnap;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( object.parent ) {\n\n\t\t\t\t\t\tobject.position.sub( _tempVector.setFromMatrixPosition( object.parent.matrixWorld ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else if ( mode === 'scale' ) {\n\n\t\t\tif ( axis.search( 'XYZ' ) !== - 1 ) {\n\n\t\t\t\tvar d = pointEnd.length() / pointStart.length();\n\n\t\t\t\tif ( pointEnd.dot( pointStart ) < 0 ) d *= - 1;\n\n\t\t\t\t_tempVector2.set( d, d, d );\n\n\t\t\t} else {\n\n\t\t\t\t_tempVector.copy( pointStart );\n\t\t\t\t_tempVector2.copy( pointEnd );\n\n\t\t\t\t_tempVector.applyQuaternion( worldQuaternionInv );\n\t\t\t\t_tempVector2.applyQuaternion( worldQuaternionInv );\n\n\t\t\t\t_tempVector2.divide( _tempVector );\n\n\t\t\t\tif ( axis.search( 'X' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.x = 1;\n\n\t\t\t\t}\n\t\t\t\tif ( axis.search( 'Y' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.y = 1;\n\n\t\t\t\t}\n\t\t\t\tif ( axis.search( 'Z' ) === - 1 ) {\n\n\t\t\t\t\t_tempVector2.z = 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Apply scale\n\n\t\t\tobject.scale.copy( scaleStart ).multiply( _tempVector2 );\n\n\t\t} else if ( mode === 'rotate' ) {\n\n\t\t\toffset.copy( pointEnd ).sub( pointStart );\n\n\t\t\tvar ROTATION_SPEED = 20 / worldPosition.distanceTo( _tempVector.setFromMatrixPosition( this.camera.matrixWorld ) );\n\n\t\t\tif ( axis === 'E' ) {\n\n\t\t\t\trotationAxis.copy( eye );\n\t\t\t\trotationAngle = pointEnd.angleTo( pointStart );\n\n\t\t\t\tstartNorm.copy( pointStart ).normalize();\n\t\t\t\tendNorm.copy( pointEnd ).normalize();\n\n\t\t\t\trotationAngle *= ( endNorm.cross( startNorm ).dot( eye ) < 0 ? 1 : - 1 );\n\n\t\t\t} else if ( axis === 'XYZE' ) {\n\n\t\t\t\trotationAxis.copy( offset ).cross( eye ).normalize();\n\t\t\t\trotationAngle = offset.dot( _tempVector.copy( rotationAxis ).cross( this.eye ) ) * ROTATION_SPEED;\n\n\t\t\t} else if ( axis === 'X' || axis === 'Y' || axis === 'Z' ) {\n\n\t\t\t\trotationAxis.copy( _unit[ axis ] );\n\n\t\t\t\t_tempVector.copy( _unit[ axis ] );\n\n\t\t\t\tif ( space === 'local' ) {\n\n\t\t\t\t\t_tempVector.applyQuaternion( worldQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\trotationAngle = offset.dot( _tempVector.cross( eye ).normalize() ) * ROTATION_SPEED;\n\n\t\t\t}\n\n\t\t\t// Apply rotation snap\n\n\t\t\tif ( this.rotationSnap ) rotationAngle = Math.round( rotationAngle / this.rotationSnap ) * this.rotationSnap;\n\n\t\t\tthis.rotationAngle = rotationAngle;\n\n\t\t\t// Apply rotate\n\t\t\tif ( space === 'local' && axis !== 'E' && axis !== 'XYZE' ) {\n\n\t\t\t\tobject.quaternion.copy( quaternionStart );\n\t\t\t\tobject.quaternion.multiply( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) ).normalize();\n\n\t\t\t} else {\n\n\t\t\t\trotationAxis.applyQuaternion( parentQuaternionInv );\n\t\t\t\tobject.quaternion.copy( _tempQuaternion.setFromAxisAngle( rotationAxis, rotationAngle ) );\n\t\t\t\tobject.quaternion.multiply( quaternionStart ).normalize();\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.dispatchEvent( changeEvent );\n\t\tthis.dispatchEvent( objectChangeEvent );\n\n\t\t// AXC: Track that we handled this\n\t\treturn true;\n\t};\n\n\tthis.pointerUp = function ( pointer ) {\n\n\t\tif ( pointer.button !== undefined && pointer.button !== 0 ) return;\n\n\t\tvar handled = false; // AXC: track handled\n\t\tif ( this.dragging && ( this.axis !== null ) ) {\n\n\t\t\tmouseUpEvent.mode = this.mode;\n\t\t\tthis.dispatchEvent( mouseUpEvent );\n\t\t\thandled = true; // AXC: track handled;\n\t\t}\n\n\t\tthis.dragging = false;\n\n\t\tif ( pointer.button === undefined ) this.axis = null;\n\n\t\treturn handled; // AXC: track handled\n\t};\n\n\t// normalize mouse / touch pointer and remap {x,y} to view space.\n\n\tfunction getPointer( event ) {\n\n\t\tif ( document.pointerLockElement ) {\n\n\t\t\treturn {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\tbutton: event.button\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tvar pointer = event.changedTouches ? event.changedTouches[ 0 ] : event;\n\n\t\t\tvar rect = domElement.getBoundingClientRect();\n\n\t\t\treturn {\n\t\t\t\tx: ( pointer.clientX - rect.left ) / rect.width * 2 - 1,\n\t\t\t\ty: - ( pointer.clientY - rect.top ) / rect.height * 2 + 1,\n\t\t\t\tbutton: event.button\n\t\t\t};\n\n\t\t}\n\n\t}\n\n\t// mouse / touch event handlers\n\n\tfunction onPointerHover( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tscope.pointerHover( getPointer( event ) );\n\n\t}\n\n\tfunction onPointerDown( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tdocument.addEventListener( \"mousemove\", onPointerMove, false );\n\n\t\tscope.pointerHover( getPointer( event ) );\n\n        // AXC: track handled\n\t\tvar handled = scope.pointerDown( getPointer( event ) );\n\n\t\tif (handled) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n        }\n\t}\n\n\tfunction onPointerMove( event ) {\n\t\tif ( !scope.enabled ) return;\n\n\t\tevent.preventDefault();\n\n\t\t// AXC: track handled\n\t\tvar handled = scope.pointerMove( getPointer( event ) );\n\t\tif (handled) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n        }\n\t}\n\n\tfunction onPointerUp( event ) {\n\n\t\tif ( ! scope.enabled ) return;\n\n\t\tdocument.removeEventListener( \"mousemove\", onPointerMove, false );\n\t\tvar handled = scope.pointerUp( getPointer( event ) );\n\n        if (handled) {\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n        }\n\t}\n\n\t// TODO: deprecate\n\n\tthis.getMode = function () {\n\n\t\treturn scope.mode;\n\n\t};\n\n\tthis.setMode = function ( mode ) {\n\n\t\tscope.mode = mode;\n\n\t};\n\n\tthis.setTranslationSnap = function ( translationSnap ) {\n\n\t\tscope.translationSnap = translationSnap;\n\n\t};\n\n\tthis.setRotationSnap = function ( rotationSnap ) {\n\n\t\tscope.rotationSnap = rotationSnap;\n\n\t};\n\n\tthis.setSize = function ( size ) {\n\n\t\tscope.size = size;\n\n\t};\n\n\tthis.setSpace = function ( space ) {\n\n\t\tscope.space = space;\n\n\t};\n\n\tthis.update = function () {\n\n\t\tconsole.warn( 'THREE.TransformControls: update function has no more functionality and therefore has been deprecated.' );\n\n\t};\n\n};\n\nTHREE.TransformControls.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.TransformControls,\n\n\tisTransformControls: true\n\n} );\n\n\nTHREE.TransformControlsGizmo = function () {\n\n\t'use strict';\n\n\tTHREE.Object3D.call( this );\n\n\tthis.type = 'TransformControlsGizmo';\n\n\t// shared materials\n\n\tvar gizmoMaterial = new THREE.MeshBasicMaterial( {\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true,\n\t\tside: THREE.DoubleSide,\n\t\tfog: false\n\t} );\n\n\tvar gizmoLineMaterial = new THREE.LineBasicMaterial( {\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true,\n\t\tlinewidth: 1,\n\t\tfog: false\n\t} );\n\n\t// Make unique material for each axis/color\n\n\tvar matInvisible = gizmoMaterial.clone();\n\tmatInvisible.opacity = 0.15;\n\n\tvar matHelper = gizmoMaterial.clone();\n\tmatHelper.opacity = 0.33;\n\n\tvar matRed = gizmoMaterial.clone();\n\tmatRed.color.set( 0xff0000 );\n\n\tvar matGreen = gizmoMaterial.clone();\n\tmatGreen.color.set( 0x00ff00 );\n\n\tvar matBlue = gizmoMaterial.clone();\n\tmatBlue.color.set( 0x0000ff );\n\n\tvar matWhiteTransparent = gizmoMaterial.clone();\n\tmatWhiteTransparent.opacity = 0.25;\n\n\tvar matYellowTransparent = matWhiteTransparent.clone();\n\tmatYellowTransparent.color.set( 0xffff00 );\n\n\tvar matCyanTransparent = matWhiteTransparent.clone();\n\tmatCyanTransparent.color.set( 0x00ffff );\n\n\tvar matMagentaTransparent = matWhiteTransparent.clone();\n\tmatMagentaTransparent.color.set( 0xff00ff );\n\n\tvar matYellow = gizmoMaterial.clone();\n\tmatYellow.color.set( 0xffff00 );\n\n\tvar matLineRed = gizmoLineMaterial.clone();\n\tmatLineRed.color.set( 0xff0000 );\n\n\tvar matLineGreen = gizmoLineMaterial.clone();\n\tmatLineGreen.color.set( 0x00ff00 );\n\n\tvar matLineBlue = gizmoLineMaterial.clone();\n\tmatLineBlue.color.set( 0x0000ff );\n\n\tvar matLineCyan = gizmoLineMaterial.clone();\n\tmatLineCyan.color.set( 0x00ffff );\n\n\tvar matLineMagenta = gizmoLineMaterial.clone();\n\tmatLineMagenta.color.set( 0xff00ff );\n\n\tvar matLineYellow = gizmoLineMaterial.clone();\n\tmatLineYellow.color.set( 0xffff00 );\n\n\tvar matLineGray = gizmoLineMaterial.clone();\n\tmatLineGray.color.set( 0x787878 );\n\n\tvar matLineYellowTransparent = matLineYellow.clone();\n\tmatLineYellowTransparent.opacity = 0.25;\n\n\t// reusable geometry\n\n\tvar arrowGeometry = new THREE.CylinderBufferGeometry( 0, 0.05, 0.2, 12, 1, false );\n\n\tvar scaleHandleGeometry = new THREE.BoxBufferGeometry( 0.125, 0.125, 0.125 );\n\n\tvar lineGeometry = new THREE.BufferGeometry( );\n\tlineGeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0,\t1, 0, 0 ], 3 ) );\n\n\tvar CircleGeometry = function ( radius, arc ) {\n\n\t\tvar geometry = new THREE.BufferGeometry( );\n\t\tvar vertices = [];\n\n\t\tfor ( var i = 0; i <= 64 * arc; ++ i ) {\n\n\t\t\tvertices.push( 0, Math.cos( i / 32 * Math.PI ) * radius, Math.sin( i / 32 * Math.PI ) * radius );\n\n\t\t}\n\n\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\t// Special geometry for transform helper. If scaled with position vector it spans from [0,0,0] to position\n\n\tvar TranslateHelperGeometry = function () {\n\n\t\tvar geometry = new THREE.BufferGeometry();\n\n\t\tgeometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ 0, 0, 0, 1, 1, 1 ], 3 ) );\n\n\t\treturn geometry;\n\n\t};\n\n\t// Gizmo definitions - custom hierarchy definitions for setupGizmo() function\n\n\tvar gizmoTranslate = {\n\t\tX: [\n\t\t\t[ new THREE.Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, - Math.PI / 2 ], null, 'fwd' ],\n\t\t\t[ new THREE.Mesh( arrowGeometry, matRed ), [ 1, 0, 0 ], [ 0, 0, Math.PI / 2 ], null, 'bwd' ],\n\t\t\t[ new THREE.Line( lineGeometry, matLineRed ) ]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], null, null, 'fwd' ],\n\t\t\t[ new THREE.Mesh( arrowGeometry, matGreen ), [ 0, 1, 0 ], [ Math.PI, 0, 0 ], null, 'bwd' ],\n\t\t\t[ new THREE.Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ Math.PI / 2, 0, 0 ], null, 'fwd' ],\n\t\t\t[ new THREE.Mesh( arrowGeometry, matBlue ), [ 0, 0, 1 ], [ - Math.PI / 2, 0, 0 ], null, 'bwd' ],\n\t\t\t[ new THREE.Line( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ]]\n\t\t],\n\t\tXYZ: [\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.1, 0 ), matWhiteTransparent.clone() ), [ 0, 0, 0 ], [ 0, 0, 0 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.295, 0.295 ), matYellowTransparent.clone() ), [ 0.15, 0.15, 0 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineYellow ), [ 0.18, 0.3, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineYellow ), [ 0.3, 0.18, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.295, 0.295 ), matCyanTransparent.clone() ), [ 0, 0.15, 0.15 ], [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineCyan ), [ 0, 0.18, 0.3 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineCyan ), [ 0, 0.3, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.295, 0.295 ), matMagentaTransparent.clone() ), [ 0.15, 0, 0.15 ], [ - Math.PI / 2, 0, 0 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineMagenta ), [ 0.18, 0, 0.3 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineMagenta ), [ 0.3, 0, 0.18 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t]\n\t};\n\n\tvar pickerTranslate = {\n\t\tX: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0.6, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0.6, 0 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 1, 4, 1, false ), matInvisible ), [ 0, 0, 0.6 ], [ Math.PI / 2, 0, 0 ]]\n\t\t],\n\t\tXYZ: [\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.2, 0 ), matInvisible ) ]\n\t\t],\n\t\tXY: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0.2, 0 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0, 0.2, 0.2 ], [ 0, Math.PI / 2, 0 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new THREE.Mesh( new THREE.PlaneBufferGeometry( 0.4, 0.4 ), matInvisible ), [ 0.2, 0, 0.2 ], [ - Math.PI / 2, 0, 0 ]]\n\t\t]\n\t};\n\n\tvar helperTranslate = {\n\t\tSTART: [\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tEND: [\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.01, 2 ), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tDELTA: [\n\t\t\t[ new THREE.Line( TranslateHelperGeometry(), matHelper ), null, null, null, 'helper' ]\n\t\t],\n\t\tX: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\tvar gizmoRotate = {\n\t\tX: [\n\t\t\t[ new THREE.Line( CircleGeometry( 1, 0.5 ), matLineRed ) ],\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.04, 0 ), matRed ), [ 0, 0, 0.99 ], null, [ 1, 3, 1 ]],\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Line( CircleGeometry( 1, 0.5 ), matLineGreen ), null, [ 0, 0, - Math.PI / 2 ]],\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.04, 0 ), matGreen ), [ 0, 0, 0.99 ], null, [ 3, 1, 1 ]],\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Line( CircleGeometry( 1, 0.5 ), matLineBlue ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new THREE.Mesh( new THREE.OctahedronBufferGeometry( 0.04, 0 ), matBlue ), [ 0.99, 0, 0 ], null, [ 1, 3, 1 ]],\n\t\t],\n\t\tE: [\n\t\t\t[ new THREE.Line( CircleGeometry( 1.25, 1 ), matLineYellowTransparent ), null, [ 0, Math.PI / 2, 0 ]],\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 1.17, 0, 0 ], [ 0, 0, - Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ - 1.17, 0, 0 ], [ 0, 0, Math.PI / 2 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, - 1.17, 0 ], [ Math.PI, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.03, 0, 0.15, 4, 1, false ), matLineYellowTransparent ), [ 0, 1.17, 0 ], [ 0, 0, 0 ], [ 1, 1, 0.001 ]],\n\t\t],\n\t\tXYZE: [\n\t\t\t[ new THREE.Line( CircleGeometry( 1, 1 ), matLineGray ), null, [ 0, Math.PI / 2, 0 ]]\n\t\t]\n\t};\n\n\tvar helperRotate = {\n\t\tAXIS: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\tvar pickerRotate = {\n\t\tX: [\n\t\t\t[ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, - Math.PI / 2, - Math.PI / 2 ]],\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ Math.PI / 2, 0, 0 ]],\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Mesh( new THREE.TorusBufferGeometry( 1, 0.1, 4, 24 ), matInvisible ), [ 0, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t],\n\t\tE: [\n\t\t\t[ new THREE.Mesh( new THREE.TorusBufferGeometry( 1.25, 0.1, 2, 24 ), matInvisible ) ]\n\t\t],\n\t\tXYZE: [\n\t\t\t[ new THREE.Mesh( new THREE.SphereBufferGeometry( 0.7, 10, 8 ), matInvisible ) ]\n\t\t]\n\t};\n\n\tvar gizmoScale = {\n\t\tX: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matRed ), [ 0.8, 0, 0 ], [ 0, 0, - Math.PI / 2 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineRed ), null, null, [ 0.8, 1, 1 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matGreen ), [ 0, 0.8, 0 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineGreen ), null, [ 0, 0, Math.PI / 2 ], [ 0.8, 1, 1 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matBlue ), [ 0, 0, 0.8 ], [ Math.PI / 2, 0, 0 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineBlue ), null, [ 0, - Math.PI / 2, 0 ], [ 0.8, 1, 1 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matYellowTransparent ), [ 0.85, 0.85, 0 ], null, [ 2, 2, 0.2 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineYellow ), [ 0.855, 0.98, 0 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineYellow ), [ 0.98, 0.855, 0 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tYZ: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matCyanTransparent ), [ 0, 0.85, 0.85 ], null, [ 0.2, 2, 2 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineCyan ), [ 0, 0.855, 0.98 ], [ 0, 0, Math.PI / 2 ], [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineCyan ), [ 0, 0.98, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXZ: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matMagentaTransparent ), [ 0.85, 0, 0.85 ], null, [ 2, 0.2, 2 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineMagenta ), [ 0.855, 0, 0.98 ], null, [ 0.125, 1, 1 ]],\n\t\t\t[ new THREE.Line( lineGeometry, matLineMagenta ), [ 0.98, 0, 0.855 ], [ 0, - Math.PI / 2, 0 ], [ 0.125, 1, 1 ]]\n\t\t],\n\t\tXYZX: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 1.1, 0, 0 ]],\n\t\t],\n\t\tXYZY: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 1.1, 0 ]],\n\t\t],\n\t\tXYZZ: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.125, 0.125, 0.125 ), matWhiteTransparent.clone() ), [ 0, 0, 1.1 ]],\n\t\t]\n\t};\n\n\tvar pickerScale = {\n\t\tX: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0.5, 0, 0 ], [ 0, 0, - Math.PI / 2 ]]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0.5, 0 ]]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Mesh( new THREE.CylinderBufferGeometry( 0.2, 0, 0.8, 4, 1, false ), matInvisible ), [ 0, 0, 0.5 ], [ Math.PI / 2, 0, 0 ]]\n\t\t],\n\t\tXY: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0.85, 0 ], null, [ 3, 3, 0.2 ]],\n\t\t],\n\t\tYZ: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matInvisible ), [ 0, 0.85, 0.85 ], null, [ 0.2, 3, 3 ]],\n\t\t],\n\t\tXZ: [\n\t\t\t[ new THREE.Mesh( scaleHandleGeometry, matInvisible ), [ 0.85, 0, 0.85 ], null, [ 3, 0.2, 3 ]],\n\t\t],\n\t\tXYZX: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 1.1, 0, 0 ]],\n\t\t],\n\t\tXYZY: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 1.1, 0 ]],\n\t\t],\n\t\tXYZZ: [\n\t\t\t[ new THREE.Mesh( new THREE.BoxBufferGeometry( 0.2, 0.2, 0.2 ), matInvisible ), [ 0, 0, 1.1 ]],\n\t\t]\n\t};\n\n\tvar helperScale = {\n\t\tX: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ - 1e3, 0, 0 ], null, [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tY: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ 0, - 1e3, 0 ], [ 0, 0, Math.PI / 2 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t],\n\t\tZ: [\n\t\t\t[ new THREE.Line( lineGeometry, matHelper.clone() ), [ 0, 0, - 1e3 ], [ 0, - Math.PI / 2, 0 ], [ 1e6, 1, 1 ], 'helper' ]\n\t\t]\n\t};\n\n\t// Creates an Object3D with gizmos described in custom hierarchy definition.\n\n\tvar setupGizmo = function ( gizmoMap ) {\n\n\t\tvar gizmo = new THREE.Object3D();\n\n\t\tfor ( var name in gizmoMap ) {\n\n\t\t\tfor ( var i = gizmoMap[ name ].length; i --; ) {\n\n\t\t\t\tvar object = gizmoMap[ name ][ i ][ 0 ].clone();\n\t\t\t\tvar position = gizmoMap[ name ][ i ][ 1 ];\n\t\t\t\tvar rotation = gizmoMap[ name ][ i ][ 2 ];\n\t\t\t\tvar scale = gizmoMap[ name ][ i ][ 3 ];\n\t\t\t\tvar tag = gizmoMap[ name ][ i ][ 4 ];\n\n\t\t\t\t// name and tag properties are essential for picking and updating logic.\n\t\t\t\tobject.name = name;\n\t\t\t\tobject.tag = tag;\n\n\t\t\t\tif ( position ) {\n\n\t\t\t\t\tobject.position.set( position[ 0 ], position[ 1 ], position[ 2 ] );\n\n\t\t\t\t}\n\t\t\t\tif ( rotation ) {\n\n\t\t\t\t\tobject.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ] );\n\n\t\t\t\t}\n\t\t\t\tif ( scale ) {\n\n\t\t\t\t\tobject.scale.set( scale[ 0 ], scale[ 1 ], scale[ 2 ] );\n\n\t\t\t\t}\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t\tvar tempGeometry = object.geometry.clone();\n\t\t\t\ttempGeometry.applyMatrix( object.matrix );\n\t\t\t\tobject.geometry = tempGeometry;\n\t\t\t\tobject.renderOrder = Infinity;\n\n\t\t\t\tobject.position.set( 0, 0, 0 );\n\t\t\t\tobject.rotation.set( 0, 0, 0 );\n\t\t\t\tobject.scale.set( 1, 1, 1 );\n\n\t\t\t\tgizmo.add( object );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn gizmo;\n\n\t};\n\n\t// Reusable utility variables\n\n\tvar tempVector = new THREE.Vector3( 0, 0, 0 );\n\tvar tempEuler = new THREE.Euler();\n\tvar alignVector = new THREE.Vector3( 0, 1, 0 );\n\tvar zeroVector = new THREE.Vector3( 0, 0, 0 );\n\tvar lookAtMatrix = new THREE.Matrix4();\n\tvar tempQuaternion = new THREE.Quaternion();\n\tvar tempQuaternion2 = new THREE.Quaternion();\n\tvar identityQuaternion = new THREE.Quaternion();\n\n\tvar unitX = new THREE.Vector3( 1, 0, 0 );\n\tvar unitY = new THREE.Vector3( 0, 1, 0 );\n\tvar unitZ = new THREE.Vector3( 0, 0, 1 );\n\n\t// Gizmo creation\n\n\tthis.gizmo = {};\n\tthis.picker = {};\n\tthis.helper = {};\n\n\tthis.add( this.gizmo[ \"translate\" ] = setupGizmo( gizmoTranslate ) );\n\tthis.add( this.gizmo[ \"rotate\" ] = setupGizmo( gizmoRotate ) );\n\tthis.add( this.gizmo[ \"scale\" ] = setupGizmo( gizmoScale ) );\n\tthis.add( this.picker[ \"translate\" ] = setupGizmo( pickerTranslate ) );\n\tthis.add( this.picker[ \"rotate\" ] = setupGizmo( pickerRotate ) );\n\tthis.add( this.picker[ \"scale\" ] = setupGizmo( pickerScale ) );\n\tthis.add( this.helper[ \"translate\" ] = setupGizmo( helperTranslate ) );\n\tthis.add( this.helper[ \"rotate\" ] = setupGizmo( helperRotate ) );\n\tthis.add( this.helper[ \"scale\" ] = setupGizmo( helperScale ) );\n\n\t// Pickers should be hidden always\n\n\tthis.picker[ \"translate\" ].visible = false;\n\tthis.picker[ \"rotate\" ].visible = false;\n\tthis.picker[ \"scale\" ].visible = false;\n\n\t// updateMatrixWorld will update transformations and appearance of individual handles\n\n\tthis.updateMatrixWorld = function () {\n\n\t\tvar space = this.space;\n\n\t\tif ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation\n\n\t\tvar quaternion = space === \"local\" ? this.worldQuaternion : identityQuaternion;\n\n\t\t// Show only gizmos for current transform mode\n\n\t\tthis.gizmo[ \"translate\" ].visible = this.mode === \"translate\";\n\t\tthis.gizmo[ \"rotate\" ].visible = this.mode === \"rotate\";\n\t\tthis.gizmo[ \"scale\" ].visible = this.mode === \"scale\";\n\n\t\tthis.helper[ \"translate\" ].visible = this.mode === \"translate\";\n\t\tthis.helper[ \"rotate\" ].visible = this.mode === \"rotate\";\n\t\tthis.helper[ \"scale\" ].visible = this.mode === \"scale\";\n\n\n\t\tvar handles = [];\n\t\thandles = handles.concat( this.picker[ this.mode ].children );\n\t\thandles = handles.concat( this.gizmo[ this.mode ].children );\n\t\thandles = handles.concat( this.helper[ this.mode ].children );\n\n\t\tfor ( var i = 0; i < handles.length; i ++ ) {\n\n\t\t\tvar handle = handles[ i ];\n\n\t\t\t// hide aligned to camera\n\n\t\t\thandle.visible = true;\n\t\t\thandle.rotation.set( 0, 0, 0 );\n\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\tvar eyeDistance = this.worldPosition.distanceTo( this.cameraPosition );\n\t\t\thandle.scale.set( 1, 1, 1 ).multiplyScalar( eyeDistance * this.size / 7 );\n\n\t\t\t// TODO: simplify helpers and consider decoupling from gizmo\n\n\t\t\tif ( handle.tag === 'helper' ) {\n\n\t\t\t\thandle.visible = false;\n\n\t\t\t\tif ( handle.name === 'AXIS' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = !! this.axis;\n\n\t\t\t\t\tif ( this.axis === 'X' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Y' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, 0, Math.PI / 2 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'Z' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\thandle.quaternion.copy( quaternion ).multiply( tempQuaternion );\n\n\t\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > 0.9 ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'XYZE' ) {\n\n\t\t\t\t\t\ttempQuaternion.setFromEuler( tempEuler.set( 0, Math.PI / 2, 0 ) );\n\t\t\t\t\t\talignVector.copy( this.rotationAxis );\n\t\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( zeroVector, alignVector, unitY ) );\n\t\t\t\t\t\thandle.quaternion.multiply( tempQuaternion );\n\t\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis === 'E' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else if ( handle.name === 'START' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'END' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPosition );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else if ( handle.name === 'DELTA' ) {\n\n\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\t\t\t\t\thandle.quaternion.copy( this.worldQuaternionStart );\n\t\t\t\t\ttempVector.set( 1e-10, 1e-10, 1e-10 ).add( this.worldPositionStart ).sub( this.worldPosition ).multiplyScalar( - 1 );\n\t\t\t\t\ttempVector.applyQuaternion( this.worldQuaternionStart.clone().inverse() );\n\t\t\t\t\thandle.scale.copy( tempVector );\n\t\t\t\t\thandle.visible = this.dragging;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\t\t\tif ( this.dragging ) {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPositionStart );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\thandle.position.copy( this.worldPosition );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( this.axis ) {\n\n\t\t\t\t\t\thandle.visible = this.axis.search( handle.name ) !== - 1;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// If updating helper, skip rest of the loop\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Align handles to current local or world rotation\n\n\t\t\thandle.quaternion.copy( quaternion );\n\n\t\t\tif ( this.mode === 'translate' || this.mode === 'scale' ) {\n\n\t\t\t\t// Hide translate and scale axis facing the camera\n\n\t\t\t\tvar AXIS_HIDE_TRESHOLD = 0.99;\n\t\t\t\tvar PLANE_HIDE_TRESHOLD = 0.2;\n\t\t\t\tvar AXIS_FLIP_TRESHOLD = 0.0;\n\n\n\t\t\t\tif ( handle.name === 'X' || handle.name === 'XYZX' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( handle.name === 'Y' || handle.name === 'XYZY' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( handle.name === 'Z' || handle.name === 'XYZZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) > AXIS_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( handle.name === 'XY' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( handle.name === 'YZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ( handle.name === 'XZ' ) {\n\n\t\t\t\t\tif ( Math.abs( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) ) < PLANE_HIDE_TRESHOLD ) {\n\n\t\t\t\t\t\thandle.scale.set( 1e-10, 1e-10, 1e-10 );\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Flip translate and scale axis ocluded behind another axis\n\n\t\t\t\tif ( handle.name.search( 'X' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitX ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.x *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Y' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitY ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.y *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name.search( 'Z' ) !== - 1 ) {\n\n\t\t\t\t\tif ( alignVector.copy( unitZ ).applyQuaternion( quaternion ).dot( this.eye ) < AXIS_FLIP_TRESHOLD ) {\n\n\t\t\t\t\t\tif ( handle.tag === 'fwd' ) {\n\n\t\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\thandle.scale.z *= - 1;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( handle.tag === 'bwd' ) {\n\n\t\t\t\t\t\thandle.visible = false;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else if ( this.mode === 'rotate' ) {\n\n\t\t\t\t// Align handles to current local or world rotation\n\n\t\t\t\ttempQuaternion2.copy( quaternion );\n\t\t\t\talignVector.copy( this.eye ).applyQuaternion( tempQuaternion.copy( quaternion ).inverse() );\n\n\t\t\t\tif ( handle.name.search( \"E\" ) !== - 1 ) {\n\n\t\t\t\t\thandle.quaternion.setFromRotationMatrix( lookAtMatrix.lookAt( this.eye, zeroVector, unitY ) );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'X' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitX, Math.atan2( - alignVector.y, alignVector.z ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Y' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitY, Math.atan2( alignVector.x, alignVector.z ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t\tif ( handle.name === 'Z' ) {\n\n\t\t\t\t\ttempQuaternion.setFromAxisAngle( unitZ, Math.atan2( alignVector.y, alignVector.x ) );\n\t\t\t\t\ttempQuaternion.multiplyQuaternions( tempQuaternion2, tempQuaternion );\n\t\t\t\t\thandle.quaternion.copy( tempQuaternion );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Hide disabled axes\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"X\" ) === - 1 || this.showX );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"Y\" ) === - 1 || this.showY );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"Z\" ) === - 1 || this.showZ );\n\t\t\thandle.visible = handle.visible && ( handle.name.indexOf( \"E\" ) === - 1 || ( this.showX && this.showY && this.showZ ) );\n\n\t\t\t// highlight selected axis\n\n\t\t\thandle.material._opacity = handle.material._opacity || handle.material.opacity;\n\t\t\thandle.material._color = handle.material._color || handle.material.color.clone();\n\n\t\t\thandle.material.color.copy( handle.material._color );\n\t\t\thandle.material.opacity = handle.material._opacity;\n\n\t\t\tif ( ! this.enabled ) {\n\n\t\t\t\thandle.material.opacity *= 0.5;\n\t\t\t\thandle.material.color.lerp( new THREE.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t} else if ( this.axis ) {\n\n\t\t\t\tif ( handle.name === this.axis ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new THREE.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else if ( this.axis.split( '' ).some( function ( a ) {\n\n\t\t\t\t\treturn handle.name === a;\n\n\t\t\t\t} ) ) {\n\n\t\t\t\t\thandle.material.opacity = 1.0;\n\t\t\t\t\thandle.material.color.lerp( new THREE.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\thandle.material.opacity *= 0.25;\n\t\t\t\t\thandle.material.color.lerp( new THREE.Color( 1, 1, 1 ), 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n};\n\nTHREE.TransformControlsGizmo.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\n\n\tconstructor: THREE.TransformControlsGizmo,\n\n\tisTransformControlsGizmo: true\n\n} );\n\n\nTHREE.TransformControlsPlane = function () {\n\n\t'use strict';\n\n\tTHREE.Mesh.call( this,\n\t\tnew THREE.PlaneBufferGeometry( 100000, 100000, 2, 2 ),\n\t\tnew THREE.MeshBasicMaterial( { visible: false, wireframe: true, side: THREE.DoubleSide, transparent: true, opacity: 0.1 } )\n\t);\n\n\tthis.type = 'TransformControlsPlane';\n\n\tvar unitX = new THREE.Vector3( 1, 0, 0 );\n\tvar unitY = new THREE.Vector3( 0, 1, 0 );\n\tvar unitZ = new THREE.Vector3( 0, 0, 1 );\n\n\tvar tempVector = new THREE.Vector3();\n\tvar dirVector = new THREE.Vector3();\n\tvar alignVector = new THREE.Vector3();\n\tvar tempMatrix = new THREE.Matrix4();\n\tvar identityQuaternion = new THREE.Quaternion();\n\n\tthis.updateMatrixWorld = function () {\n\n\t\tvar space = this.space;\n\n\t\tthis.position.copy( this.worldPosition );\n\n\t\tif ( this.mode === 'scale' ) space = 'local'; // scale always oriented to local rotation\n\n\t\tunitX.set( 1, 0, 0 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\n\t\tunitY.set( 0, 1, 0 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\n\t\tunitZ.set( 0, 0, 1 ).applyQuaternion( space === \"local\" ? this.worldQuaternion : identityQuaternion );\n\n\t\t// Align the plane for current transform mode, axis and space.\n\n\t\talignVector.copy( unitY );\n\n\t\tswitch ( this.mode ) {\n\n\t\t\tcase 'translate':\n\t\t\tcase 'scale':\n\t\t\t\tswitch ( this.axis ) {\n\n\t\t\t\t\tcase 'X':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitX );\n\t\t\t\t\t\tdirVector.copy( unitX ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitY );\n\t\t\t\t\t\tdirVector.copy( unitY ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\t\talignVector.copy( this.eye ).cross( unitZ );\n\t\t\t\t\t\tdirVector.copy( unitZ ).cross( alignVector );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XY':\n\t\t\t\t\t\tdirVector.copy( unitZ );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'YZ':\n\t\t\t\t\t\tdirVector.copy( unitX );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XZ':\n\t\t\t\t\t\talignVector.copy( unitZ );\n\t\t\t\t\t\tdirVector.copy( unitY );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'XYZ':\n\t\t\t\t\tcase 'E':\n\t\t\t\t\t\tdirVector.set( 0, 0, 0 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'rotate':\n\t\t\tdefault:\n\t\t\t\t// special case for rotate\n\t\t\t\tdirVector.set( 0, 0, 0 );\n\n\t\t}\n\n\t\tif ( dirVector.length() === 0 ) {\n\n\t\t\t// If in rotate mode, make the plane parallel to camera\n\t\t\tthis.quaternion.copy( this.cameraQuaternion );\n\n\t\t} else {\n\n\t\t\ttempMatrix.lookAt( tempVector.set( 0, 0, 0 ), dirVector, alignVector );\n\n\t\t\tthis.quaternion.setFromRotationMatrix( tempMatrix );\n\n\t\t}\n\n\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this );\n\n\t};\n\n};\n\nTHREE.TransformControlsPlane.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\n\n\tconstructor: THREE.TransformControlsPlane,\n\n\tisTransformControlsPlane: true\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/controls/TransformControls.js?");

/***/ }),

/***/ "./js/vendor/three/geo/ConvexGeometry.js":
/*!***********************************************!*\
  !*** ./js/vendor/three/geo/ConvexGeometry.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Mugen87 / https://github.com/Mugen87\n */\n\n( function () {\n\n\t// ConvexGeometry\n\n\tfunction ConvexGeometry( points ) {\n\n\t\tTHREE.Geometry.call( this );\n\n\t\tthis.fromBufferGeometry( new ConvexBufferGeometry( points ) );\n\t\tthis.mergeVertices();\n\n\t}\n\n\tConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );\n\tConvexGeometry.prototype.constructor = ConvexGeometry;\n\n\t// ConvexBufferGeometry\n\n\tfunction ConvexBufferGeometry( points ) {\n\n\t\tTHREE.BufferGeometry.call( this );\n\n\t\t// buffers\n\n\t\tvar vertices = [];\n\t\tvar normals = [];\n\n\t\t// execute QuickHull\n\n\t\tif ( THREE.QuickHull === undefined ) {\n\n\t\t\tconsole.error( 'THREE.ConvexBufferGeometry: ConvexBufferGeometry relies on THREE.QuickHull' );\n\n\t\t}\n\n\t\tvar quickHull = new THREE.QuickHull().setFromPoints( points );\n\n\t\t// generate vertices and normals\n\n\t\tvar faces = quickHull.faces;\n\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\n\n\t\t\tvar face = faces[ i ];\n\t\t\tvar edge = face.edge;\n\n\t\t\t// we move along a doubly-connected edge list to access all face points (see HalfEdge docs)\n\n\t\t\tdo {\n\n\t\t\t\tvar point = edge.head().point;\n\n\t\t\t\tvertices.push( point.x, point.y, point.z );\n\t\t\t\tnormals.push( face.normal.x, face.normal.y, face.normal.z );\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== face.edge );\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tConvexBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\n\tConvexBufferGeometry.prototype.constructor = ConvexBufferGeometry;\n\n\t// export\n\n\tTHREE.ConvexGeometry = ConvexGeometry;\n\tTHREE.ConvexBufferGeometry = ConvexBufferGeometry;\n\n} )();\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/geo/ConvexGeometry.js?");

/***/ }),

/***/ "./js/vendor/three/geo/OBB.js":
/*!************************************!*\
  !*** ./js/vendor/three/geo/OBB.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * @file A 3D arbitrarily oriented bounding box.\n * \n * This data structure represents a box in 3D space. The local axes of this box\n * can be arbitrarily oriented/rotated with respect to the global world\n * coordinate system. This allows OBBs to more tightly bound objects than AABBs\n * do, which always align with the world space axes. This flexibility has the\n * drawback that the geometry tests and operations involving OBBs are more\n * costly, and representing an OBB in memory takes more space.\n * \n * Reference:\n * \n * This file is a JavaScript/three.js implementation of the MathGeoLib by Jukka\n * Jylnki. The prototype does not contain the entire logic of the original\n * source.\n * \n * https://github.com/juj/MathGeoLib/blob/master/src/Geometry/OBB.h\n * https://github.com/juj/MathGeoLib/blob/master/src/Geometry/OBB.cpp\n * \n * @author Human Interactive\n */\n\n\n//var THREE = require( \"three\" );\n\n/**\n * Creates the OBB.\n * \n * @constructor\n * \n * @param {THREE.Vector3} position - The center position of the OBB.\n * @param {THREE.Vector3} halfSizes - Stores half-sizes to x, y and z directions\n * in the local space of the OBB.\n * @param {THREE.Matrix4} basis - Specifies normalized direction vectors for the\n * local axes.\n */\nfunction OBB( position, halfSizes, basis ) {\n\n\tObject.defineProperties( this, {\n\t\tposition : {\n\t\t\tvalue : position || new THREE.Vector3(),\n\t\t\tconfigurable : false,\n\t\t\tenumerable : true,\n\t\t\twritable : true\n\t\t},\n\t\thalfSizes : {\n\t\t\tvalue : halfSizes || new THREE.Vector3(),\n\t\t\tconfigurable : false,\n\t\t\tenumerable : true,\n\t\t\twritable : true\n\t\t},\n\t\tbasis : {\n\t\t\tvalue : basis || new THREE.Matrix4(),\n\t\t\tconfigurable : false,\n\t\t\tenumerable : true,\n\t\t\twritable : true\n\t\t},\n\t\t// The OBB-OBB test utilizes a SAT test to detect the intersection.\n\t\t// A robust implementation requires an epsilon threshold to test that\n\t\t// the used axes are not degenerate.\n\t\t_EPSILON : {\n\t\t\tvalue : 1e-3,\n\t\t\tconfigurable : false,\n\t\t\tenumerable : false,\n\t\t\twritable : false\n\t\t}\n\t} );\n}\n\n/**\n * Sets the OBB from a mesh.\n * \n * The basis of the objects world matrix is assumed to be orthogonal, which\n * means no projection or shear is allowed. Additionally, the matrix must\n * contain only uniform scaling.\n * \n * @param {THREE.Mesh} object - The mesh object to convert to an OBB.\n * \n * @returns {OBB} The reference to the OBB.\n */\nOBB.prototype.setFromObject = ( function() {\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function( object ) {\n\t\t\n\t\tvar scale, aabb, w;\n\n\t\t// calculate AABB, if necessary\n\t\tif ( object.geometry.boundingBox === null )\n\t\t{\n\t\t\tobject.geometry.computeBoundingBox();\n\t\t}\n\n\t\t// ensure, world matrix of the object is up to date\n\t\tobject.updateMatrixWorld();\n\n\t\t// shortcuts\n\t\taabb = object.geometry.boundingBox;\n\t\tw = object.matrixWorld.elements;\n\n\t\t// assign the transform center to the position member\n\t\taabb.getCenter( this.position ).applyMatrix4( object.matrixWorld );\n\n\t\t// extract the rotation and assign it to the basis of the OBB\n\t\t// for numerical stability, you could orthonormalize the basis\n\t\tthis.basis.extractRotation( object.matrixWorld );\n\n\t\t// calculate half sizes for each axis\n\t\taabb.getSize( this.halfSizes ).multiplyScalar( 0.5 );\n\n\t\t// extract the (uniform) scaling and apply it to the halfSizes\n\t\tscale = vector.set( w[ 0 ], w[ 1 ], w[ 2 ] ).length();\n\n\t\t// do the scale\n\t\tthis.halfSizes.multiplyScalar( scale );\n\n\t\treturn this;\n\t};\n\n}() );\n\n/**\n * Sets the OBB from an Axis-Aligned Bounding Box (AABB).\n * \n * @param {THREE.Box3} aabb - The AABB to convert to an OBB.\n * \n * @returns {OBB} The reference to the OBB.\n */\nOBB.prototype.setFromAABB = function( aabb ) {\n\n\taabb.getCenter( this.position );\n\n\taabb.getSize( this.halfSizes ).multiplyScalar( 0.5 );\n\n\tthis.basis.identity();\n\n\treturn this;\n};\n\n/**\n * Sets the OBB from a bounding sphere.\n * \n * @param {THREE.Sphere} sphere - The bounding sphere to convert to an OBB.\n * \n * @returns {OBB} The reference to the OBB.\n */\nOBB.prototype.setFromSphere = function( sphere ) {\n\n\tthis.position.copy( sphere.center );\n\n\tthis.halfSizes.set( sphere.radius, sphere.radius, sphere.radius );\n\n\tthis.basis.identity();\n\n\treturn this;\n};\n\n/**\n * Computes the closest point inside the OBB to the given point.\n * \n * @param {THREE.Vector3} point - The target point.\n * \n * @returns {THREE.Vector3} The closest point inside the OBB.\n */\nOBB.prototype.closestPoint = ( function() {\n\n\tvar displacement = new THREE.Vector3();\n\n\tvar xAxis = new THREE.Vector3();\n\tvar yAxis = new THREE.Vector3();\n\tvar zAxis = new THREE.Vector3();\n\n\treturn function( point ) {\n\t\t\n\t\tvar index, value, axis = [];\n\n\t\tvar closesPoint = new THREE.Vector3();\n\n\t\t// extract each axis\n\t\tthis.basis.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// push axis to array\n\t\taxis.push( xAxis, yAxis, zAxis );\n\n\t\t// calculate displacement vector of targetPoint and center position\n\t\tdisplacement.subVectors( point, this.position );\n\n\t\t// start at the center position of the OBB\n\t\tclosesPoint.copy( this.position );\n\n\t\t// project the target onto the OBB axes and walk towards that point\n\t\tfor ( index = 0; index < 3; index++ )\n\t\t{\n\t\t\tvalue = THREE.Math.clamp( displacement.dot( axis[ index ] ), -this.halfSizes.getComponent( index ), this.halfSizes.getComponent( index ) );\n\n\t\t\tclosesPoint.add( axis[ index ].multiplyScalar( value ) );\n\t\t}\n\n\t\treturn closesPoint;\n\t};\n\n}() );\n\n/**\n * Tests if the given point is fully contained inside the OBB.\n * \n * @param {THREE.Vector3} point - The point to test.\n * \n * @returns {boolean} Is the point contained inside the OBB?\n */\nOBB.prototype.isPointContained = ( function() {\n\n\tvar displacement = new THREE.Vector3();\n\n\tvar xAxis = new THREE.Vector3();\n\tvar yAxis = new THREE.Vector3();\n\tvar zAxis = new THREE.Vector3();\n\n\treturn function( point ) {\n\n\t\t// calculate displacement vector of point and center position\n\t\tdisplacement.subVectors( point, this.position );\n\n\t\t// extract each axis\n\t\tthis.basis.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// project the calculated displacement vector to each axis and\n\t\t// compare the result with the respective half size.\n\t\treturn Math.abs( displacement.dot( xAxis ) ) <= this.halfSizes.x && \n\t\t\t   Math.abs( displacement.dot( yAxis ) ) <= this.halfSizes.y && \n\t\t\t   Math.abs( displacement.dot( zAxis ) ) <= this.halfSizes.z;\n\t};\n\n}() );\n\n/**\n * Tests if the given AABB is fully contained inside the OBB.\n * \n * @param {THREE.Box3} aabb - The AABB to test.\n * \n * @returns {boolean} Is the AABB fully contained inside the OBB?\n */\nOBB.prototype.isAABBContained = ( function() {\n\n\tvar points = [ new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3(), \n\t               new THREE.Vector3() ];\n\n\treturn function( aabb ) {\n\n\t\t// determine all corner points\n\t\tpoints[ 0 ].set( aabb.min.x, aabb.min.y, aabb.min.z );\n\t\tpoints[ 1 ].set( aabb.min.x, aabb.min.y, aabb.max.z );\n\t\tpoints[ 2 ].set( aabb.min.x, aabb.max.y, aabb.min.z );\n\t\tpoints[ 3 ].set( aabb.min.x, aabb.max.y, aabb.max.z );\n\t\tpoints[ 4 ].set( aabb.max.x, aabb.min.y, aabb.min.z );\n\t\tpoints[ 5 ].set( aabb.max.x, aabb.min.y, aabb.max.z );\n\t\tpoints[ 6 ].set( aabb.max.x, aabb.max.y, aabb.min.z );\n\t\tpoints[ 7 ].set( aabb.max.x, aabb.max.y, aabb.max.z );\n\n\t\tfor ( var index = 0; index < 8; ++index )\n\t\t{\n\t\t\t// check each point\n\t\t\tif ( this.isPointContained( points[ index ] ) === false )\n\t\t\t{\n\t\t\t\t// as soon as one point is outside the OBB, return false\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t};\n\n}() );\n\n/**\n * Tests if the given line segment is fully contained inside the OBB.\n * \n * @param {THREE.Line3} line - The line segment to test.\n * \n * @returns {boolean} Is the line segment contained inside the OBB?\n */\nOBB.prototype.isLineContained = function( line ) {\n\n\treturn this.isPointContained( line.start ) && \n\t\t   this.isPointContained( line.end );\n};\n\n/**\n * Tests if the given triangle is fully contained inside the OBB.\n * \n * @param {THREE.Triangle} triangle - The triangle to test.\n * \n * @returns {boolean} Is the triangle contained inside the OBB?\n */\nOBB.prototype.isTriangleContained = function( triangle ) {\n\n\treturn this.isPointContained( triangle.a ) && \n\t\t   this.isPointContained( triangle.b ) && \n\t\t   this.isPointContained( triangle.c );\n};\n\n/**\n * Tests whether this OBB and the given AABB intersect.\n * \n * @param {THREE.Box3} box - The AABB to test.\n * \n * @returns {boolean} Is there an intersection between the given AABB and the\n * OBB?\n */\nOBB.prototype.intersectsAABB = function( box ) {\n\n\treturn this.intersectsOBB( new OBB().setFromAABB( box ) );\n};\n\n/**\n * Tests whether this OBB and the given sphere intersect.\n * \n * @param {THREE.Sphere} sphere - The sphere to test.\n * \n * @returns {boolean} Is there an intersection between the given sphere and the\n * OBB?\n */\nOBB.prototype.intersectsSphere = function( sphere ) {\n\n\treturn this.intersectSphere( sphere ) !== null;\n};\n\n/**\n * Tests whether this OBB and the given OBB intersect.\n * \n * @param {OBB} box - The OBB to test.\n * \n * @returns {boolean} Is there an intersection between the given OBB and the\n * OBB?\n */\nOBB.prototype.intersectsOBB = ( function() {\n\n\tvar xAxisA = new THREE.Vector3();\n\tvar yAxisA = new THREE.Vector3();\n\tvar zAxisA = new THREE.Vector3();\n\n\tvar xAxisB = new THREE.Vector3();\n\tvar yAxisB = new THREE.Vector3();\n\tvar zAxisB = new THREE.Vector3();\n\n\tvar translation = new THREE.Vector3();\n\n\tvar vector = new THREE.Vector3();\n\n\treturn function( obb ) {\n\t\t\n\t\tvar axisA = [];\n\t\tvar axisB = [];\n\t\tvar rotationMatrix = [ [], [], [] ];\n\t\tvar rotationMatrixAbs = [ [], [], [] ];\n\t\t\n\t\tvar halfSizeA, halfSizeB;\n\t\tvar t, i;\n\n\t\t// extract each axis\n\t\tthis.basis.extractBasis( xAxisA, yAxisA, zAxisA );\n\t\tobb.basis.extractBasis( xAxisB, yAxisB, zAxisB );\n\n\t\t// push basis vectors into arrays, so you can access them via indices\n\t\taxisA.push( xAxisA, yAxisA, zAxisA );\n\t\taxisB.push( xAxisB, yAxisB, zAxisB );\n\n\t\t// get displacement vector\n\t\tvector.subVectors( obb.position, this.position );\n\n\t\t// express the translation vector in the coordinate frame of the current\n\t\t// OBB (this)\n\t\tfor ( i = 0; i < 3; i++ )\n\t\t{\n\t\t\ttranslation.setComponent( i, vector.dot( axisA[ i ] ) );\n\t\t}\n\n\t\t// generate a rotation matrix that transforms from world space to the\n\t\t// OBB's coordinate space\n\t\tfor ( i = 0; i < 3; i++ )\n\t\t{\n\t\t\tfor ( var j = 0; j < 3; j++ )\n\t\t\t{\n\t\t\t\trotationMatrix[ i ][ j ] = axisA[ i ].dot( axisB[ j ] );\n\t\t\t\trotationMatrixAbs[ i ][ j ] = Math.abs( rotationMatrix[ i ][ j ] ) + this._EPSILON;\n\t\t\t}\n\t\t}\n\n\t\t// test the three major axes of this OBB\n\t\tfor ( i = 0; i < 3; i++ )\n\t\t{\n\t\t\tvector.set( rotationMatrixAbs[ i ][ 0 ], rotationMatrixAbs[ i ][ 1 ], rotationMatrixAbs[ i ][ 2 ] );\n\n\t\t\thalfSizeA = this.halfSizes.getComponent( i );\n\t\t\thalfSizeB = obb.halfSizes.dot( vector );\n\n\t\t\tif ( Math.abs( translation.getComponent( i ) ) > halfSizeA + halfSizeB )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// test the three major axes of other OBB\n\t\tfor ( i = 0; i < 3; i++ )\n\t\t{\n\t\t\tvector.set( rotationMatrixAbs[ 0 ][ i ], rotationMatrixAbs[ 1 ][ i ], rotationMatrixAbs[ 2 ][ i ] );\n\n\t\t\thalfSizeA = this.halfSizes.dot( vector );\n\t\t\thalfSizeB = obb.halfSizes.getComponent( i );\n\n\t\t\tvector.set( rotationMatrix[ 0 ][ i ], rotationMatrix[ 1 ][ i ], rotationMatrix[ 2 ][ i ] );\n\t\t\tt = translation.dot( vector );\n\n\t\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t// test the 9 different cross-axes\n\n\t\t// A.x <cross> B.x\n\t\thalfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 0 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 0 ];\n\t\thalfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 0 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 0 ][ 1 ];\n\n\t\tt = translation.z * rotationMatrix[ 1 ][ 0 ] - translation.y * rotationMatrix[ 2 ][ 0 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.x < cross> B.y\n\t\thalfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 1 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 1 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 0 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 0 ][ 0 ];\n\n\t\tt = translation.z * rotationMatrix[ 1 ][ 1 ] - translation.y * rotationMatrix[ 2 ][ 1 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.x <cross> B.z\n\t\thalfSizeA = this.halfSizes.y * rotationMatrixAbs[ 2 ][ 2 ] + this.halfSizes.z * rotationMatrixAbs[ 1 ][ 2 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 0 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 0 ][ 0 ];\n\n\t\tt = translation.z * rotationMatrix[ 1 ][ 2 ] - translation.y * rotationMatrix[ 2 ][ 2 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.y <cross> B.x\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 0 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 0 ];\n\t\thalfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 1 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 1 ][ 1 ];\n\n\t\tt = translation.x * rotationMatrix[ 2 ][ 0 ] - translation.z * rotationMatrix[ 0 ][ 0 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.y <cross> B.y\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 1 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 1 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 1 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 1 ][ 0 ];\n\n\t\tt = translation.x * rotationMatrix[ 2 ][ 1 ] - translation.z * rotationMatrix[ 0 ][ 1 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.y <cross> B.z\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 2 ][ 2 ] + this.halfSizes.z * rotationMatrixAbs[ 0 ][ 2 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 1 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 1 ][ 0 ];\n\n\t\tt = translation.x * rotationMatrix[ 2 ][ 2 ] - translation.z * rotationMatrix[ 0 ][ 2 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.z <cross> B.x\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 0 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 0 ];\n\t\thalfSizeB = obb.halfSizes.y * rotationMatrixAbs[ 2 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 2 ][ 1 ];\n\n\t\tt = translation.y * rotationMatrix[ 0 ][ 0 ] - translation.x * rotationMatrix[ 1 ][ 0 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.z <cross> B.y\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 1 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 1 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 2 ][ 2 ] + obb.halfSizes.z * rotationMatrixAbs[ 2 ][ 0 ];\n\n\t\tt = translation.y * rotationMatrix[ 0 ][ 1 ] - translation.x * rotationMatrix[ 1 ][ 1 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// A.z <cross> B.z\n\t\thalfSizeA = this.halfSizes.x * rotationMatrixAbs[ 1 ][ 2 ] + this.halfSizes.y * rotationMatrixAbs[ 0 ][ 2 ];\n\t\thalfSizeB = obb.halfSizes.x * rotationMatrixAbs[ 2 ][ 1 ] + obb.halfSizes.y * rotationMatrixAbs[ 2 ][ 0 ];\n\n\t\tt = translation.y * rotationMatrix[ 0 ][ 2 ] - translation.x * rotationMatrix[ 1 ][ 2 ];\n\n\t\tif ( Math.abs( t ) > halfSizeA + halfSizeB )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// no separating axis exists, so the two OBB don't intersect\n\t\treturn true;\n\t};\n\n}() );\n\n/**\n * Tests whether this OBB and the given plane intersect.\n * \n * @param {THREE.Plane} plane - The plane to test.\n * \n * @returns {boolean} Is there an intersection between the given plane and the\n * OBB?\n */\nOBB.prototype.intersectsPlane = ( function() {\n\n\tvar xAxis = new THREE.Vector3();\n\tvar yAxis = new THREE.Vector3();\n\tvar zAxis = new THREE.Vector3();\n\n\treturn function( plane ) {\n\t\t\n\t\tvar t, s;\n\n\t\t// extract each axis\n\t\tthis.basis.extractBasis( xAxis, yAxis, zAxis );\n\n\t\t// compute the projection interval radius of this OBB onto L(t) =\n\t\t// this->pos + x * p.normal;\n\t\tt = this.halfSizes.x * Math.abs( plane.normal.dot( xAxis ) ) + \n\t\t\tthis.halfSizes.y * Math.abs( plane.normal.dot( yAxis ) ) + \n\t\t\tthis.halfSizes.z * Math.abs( plane.normal.dot( zAxis ) );\n\n\t\t// compute the distance of this OBB center from the plane\n\t\ts = plane.normal.dot( this.position ) - plane.constant;\n\n\t\treturn Math.abs( s ) <= t;\n\t};\n\n}() );\n\n/**\n * Tests whether this OBB and the given ray intersect.\n * \n * @param {THREE.Ray} ray - The ray to test.\n * \n * @returns {boolean} Is there an intersection between the given ray and the\n * OBB?\n */\nOBB.prototype.intersectsRay = function( ray ) {\n\n\treturn this.intersectRay( ray ) !== null;\n};\n\n/**\n * Calculates the intersection point between this OBB and the given ray.\n * \n * @param {THREE.Ray} ray - The ray to test.\n * \n * @returns {THREE.Vector3} The intersection point.\n */\nOBB.prototype.intersectRay = ( function() {\n\n\tvar zeroVector = new THREE.Vector3();\n\tvar size = new THREE.Vector3();\n\tvar aabb = new THREE.Box3();\n\tvar rayLocal = new THREE.Ray();\n\n\tvar transformationMatrix = new THREE.Matrix4();\n\tvar transformationMatrixInverse = new THREE.Matrix4();\n\n\treturn function( ray ) {\n\n\t\tvar intersection;\n\t\t\n\t\t// get size of OBB\n\t\tthis.size( size );\n\n\t\t// set AABB to origin with the size of the OBB\n\t\taabb.setFromCenterAndSize( zeroVector, size );\n\n\t\t// transform ray to the local space of the OBB\n\t\ttransformationMatrix.copy( this.basis );\n\t\ttransformationMatrix.setPosition( this.position );\n\n\t\trayLocal.copy( ray );\n\t\trayLocal.applyMatrix4( transformationMatrixInverse.getInverse( transformationMatrix ) );\n\n\t\t// do ray <-> AABB intersection\n\t\tintersection = rayLocal.intersectBox( aabb, new THREE.Vector3() );\n\n\t\tif ( intersection !== null )\n\t\t{\n\t\t\t// transform the intersection point back to world space\n\t\t\tintersection.applyMatrix4( transformationMatrix );\n\t\t}\n\n\t\treturn intersection;\n\t};\n\n}() );\n\n/**\n * Calculates the intersection point between this OBB and the given sphere.\n * \n * @param {THREE.Sphere} sphere - The sphere to test.\n * \n * @returns {THREE.Vector3} The intersection point.\n */\nOBB.prototype.intersectSphere = function( sphere ) {\n\n\t// find the point on this OBB closest to the sphere center\n\tvar closestPoint = this.closestPoint( sphere.center );\n\n\t// if that point is inside the sphere, the OBB and sphere intersect\n\tif ( closestPoint.distanceToSquared( sphere.center ) <= sphere.radius * sphere.radius )\n\t{\n\t\treturn closestPoint;\n\t}\n\n\treturn null;\n};\n\n/**\n * Gets the size of the OBB.\n * \n * @param {THREE.Vector3} optionalTarget - An optional target for the operation.\n * \n * @returns {THREE.Vector3} The size of the OBB.\n */\nOBB.prototype.size = function( optionalTarget ) {\n\t\n\tvar result = optionalTarget || new THREE.Vector3();\n\n\treturn result.copy( this.halfSizes ).multiplyScalar( 2 );\n};\n\n/**\n * Translates the OBB in world space.\n * \n * @param {THREE.Vector3} offset - The amount of displacement to apply to this\n * OBB, in world space coordinates.\n * \n * @returns {OBB} The reference to the OBB.\n */\nOBB.prototype.translate = function( offset ) {\n\n\tthis.position.add( offset );\n\n\treturn this;\n};\n\n/**\n * Copies the values of a given OBB to the current OBB.\n * \n * @param {OBB} obb - The OBB to copy.\n * \n * @returns {OBB} The reference to the OBB.\n */\nOBB.prototype.copy = function( obb ) {\n\n\tthis.position.copy( obb.position );\n\tthis.halfSizes.copy( obb.halfSizes );\n\tthis.basis.copy( obb.basis );\n\n\treturn this;\n};\n\n/**\n * Creates a new instance from the current OBB.\n * \n * @returns {OBB} The new OBB.\n */\nOBB.prototype.clone = function() {\n\n\treturn new OBB().copy( this );\n};\n\nmodule.exports = OBB;\n\n//# sourceURL=webpack://STK/./js/vendor/three/geo/OBB.js?");

/***/ }),

/***/ "./js/vendor/three/geo/QuickHull.js":
/*!******************************************!*\
  !*** ./js/vendor/three/geo/QuickHull.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Ported from: https://github.com/maurizzzio/quickhull3d/ by Mauricio Poppe (https://github.com/maurizzzio)\n *\n */\n\n( function () {\n\n\tvar Visible = 0;\n\tvar Deleted = 1;\n\n\tfunction QuickHull() {\n\n\t\tthis.tolerance = - 1;\n\n\t\tthis.faces = []; // the generated faces of the convex hull\n\t\tthis.newFaces = []; // this array holds the faces that are generated within a single iteration\n\n\t\t// the vertex lists work as follows:\n\t\t//\n\t\t// let 'a' and 'b' be 'Face' instances\n\t\t// let 'v' be points wrapped as instance of 'Vertex'\n\t\t//\n\t\t//     [v, v, ..., v, v, v, ...]\n\t\t//      ^             ^\n\t\t//      |             |\n\t\t//  a.outside     b.outside\n\t\t//\n\t\tthis.assigned = new VertexList();\n\t\tthis.unassigned = new VertexList();\n\n\t\tthis.vertices = []; \t// vertices of the hull (internal representation of given geometry data)\n\n\t}\n\n\tObject.assign( QuickHull.prototype, {\n\n\t\tsetFromPoints: function ( points ) {\n\n\t\t\tif ( Array.isArray( points ) !== true ) {\n\n\t\t\t\tconsole.error( 'THREE.QuickHull: Points parameter is not an array.' );\n\n\t\t\t}\n\n\t\t\tif ( points.length < 4 ) {\n\n\t\t\t\tconsole.error( 'THREE.QuickHull: The algorithm needs at least four points.' );\n\n\t\t\t}\n\n\t\t\tthis.makeEmpty();\n\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\t\tthis.vertices.push( new VertexNode( points[ i ] ) );\n\n\t\t\t}\n\n\t\t\tthis.compute();\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tsetFromObject: function ( object ) {\n\n\t\t\tvar points = [];\n\n\t\t\tobject.updateMatrixWorld( true );\n\n\t\t\tobject.traverse( function ( node ) {\n\n\t\t\t\tvar i, l, point;\n\n\t\t\t\tvar geometry = node.geometry;\n\n\t\t\t\tif ( geometry !== undefined ) {\n\n\t\t\t\t\tif ( geometry.isGeometry ) {\n\n\t\t\t\t\t\tvar vertices = geometry.vertices;\n\n\t\t\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\tpoint = vertices[ i ].clone();\n\t\t\t\t\t\t\tpoint.applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if ( geometry.isBufferGeometry ) {\n\n\t\t\t\t\t\tvar attribute = geometry.attributes.position;\n\n\t\t\t\t\t\tif ( attribute !== undefined ) {\n\n\t\t\t\t\t\t\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\t\t\t\t\t\tpoint = new THREE.Vector3();\n\n\t\t\t\t\t\t\t\tpoint.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\n\n\t\t\t\t\t\t\t\tpoints.push( point );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\treturn this.setFromPoints( points );\n\n\t\t},\n\n\t\tmakeEmpty: function () {\n\n\t\t\tthis.faces = [];\n\t\t\tthis.vertices = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the 'assigned' list of vertices and assigns it to the given face\n\n\t\taddVertexToFace: function ( vertex, face ) {\n\n\t\t\tvertex.face = face;\n\n\t\t\tif ( face.outside === null ) {\n\n\t\t\t\tthis.assigned.append( vertex );\n\n\t\t\t} else {\n\n\t\t\t\tthis.assigned.insertBefore( face.outside, vertex );\n\n\t\t\t}\n\n\t\t\tface.outside = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the 'assigned' list of vertices and from the given face\n\n\t\tremoveVertexFromFace: function ( vertex, face ) {\n\n\t\t\tif ( vertex === face.outside ) {\n\n\t\t\t\t// fix face.outside link\n\n\t\t\t\tif ( vertex.next !== null && vertex.next.face === face ) {\n\n\t\t\t\t\t// face has at least 2 outside vertices, move the 'outside' reference\n\n\t\t\t\t\tface.outside = vertex.next;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// vertex was the only outside vertex that face had\n\n\t\t\t\t\tface.outside = null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.assigned.remove( vertex );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertext list\n\n\t\tremoveAllVerticesFromFace: function ( face ) {\n\n\t\t\tif ( face.outside !== null ) {\n\n\t\t\t\t// reference to the first and last vertex of this face\n\n\t\t\t\tvar start = face.outside;\n\t\t\t\tvar end = face.outside;\n\n\t\t\t\twhile ( end.next !== null && end.next.face === face ) {\n\n\t\t\t\t\tend = end.next;\n\n\t\t\t\t}\n\n\t\t\t\tthis.assigned.removeSubList( start, end );\n\n\t\t\t\t// fix references\n\n\t\t\t\tstart.prev = end.next = null;\n\t\t\t\tface.outside = null;\n\n\t\t\t\treturn start;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Removes all the visible vertices that 'face' is able to see\n\n\t\tdeleteFaceVertices: function ( face, absorbingFace ) {\n\n\t\t\tvar faceVertices = this.removeAllVerticesFromFace( face );\n\n\t\t\tif ( faceVertices !== undefined ) {\n\n\t\t\t\tif ( absorbingFace === undefined ) {\n\n\t\t\t\t\t// mark the vertices to be reassigned to some other face\n\n\t\t\t\t\tthis.unassigned.appendChain( faceVertices );\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// if there's an absorbing face try to assign as many vertices as possible to it\n\n\t\t\t\t\tvar vertex = faceVertices;\n\n\t\t\t\t\tdo {\n\n\t\t\t\t\t\t// we need to buffer the subsequent vertex at this point because the 'vertex.next' reference\n\t\t\t\t\t\t// will be changed by upcoming method calls\n\n\t\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\t\tvar distance = absorbingFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t// check if 'vertex' is able to see 'absorbingFace'\n\n\t\t\t\t\t\tif ( distance > this.tolerance ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, absorbingFace );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tthis.unassigned.append( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// now assign next vertex\n\n\t\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t\t} while ( vertex !== null );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Reassigns as many vertices as possible from the unassigned list to the new faces\n\n\t\tresolveUnassignedPoints: function ( newFaces ) {\n\n\t\t\tif ( this.unassigned.isEmpty() === false ) {\n\n\t\t\t\tvar vertex = this.unassigned.first();\n\n\t\t\t\tdo {\n\n\t\t\t\t\t// buffer 'next' reference, see .deleteFaceVertices()\n\n\t\t\t\t\tvar nextVertex = vertex.next;\n\n\t\t\t\t\tvar maxDistance = this.tolerance;\n\n\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\tfor ( var i = 0; i < newFaces.length; i ++ ) {\n\n\t\t\t\t\t\tvar face = newFaces[ i ];\n\n\t\t\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\t\t\tvar distance = face.distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = face;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( maxDistance > 1000 * this.tolerance ) break;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// 'maxFace' can be null e.g. if there are identical vertices\n\n\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = nextVertex;\n\n\t\t\t\t} while ( vertex !== null );\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Computes the extremes of a simplex which will be the initial hull\n\n\t\tcomputeExtremes: function () {\n\n\t\t\tvar min = new THREE.Vector3();\n\t\t\tvar max = new THREE.Vector3();\n\n\t\t\tvar minVertices = [];\n\t\t\tvar maxVertices = [];\n\n\t\t\tvar i, l, j;\n\n\t\t\t// initially assume that the first vertex is the min/max\n\n\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\tminVertices[ i ] = maxVertices[ i ] = this.vertices[ 0 ];\n\n\t\t\t}\n\n\t\t\tmin.copy( this.vertices[ 0 ].point );\n\t\t\tmax.copy( this.vertices[ 0 ].point );\n\n\t\t\t// compute the min/max vertex on all six directions\n\n\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\tvar vertex = this.vertices[ i ];\n\t\t\t\tvar point = vertex.point;\n\n\t\t\t\t// update the min coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) < min.getComponent( j ) ) {\n\n\t\t\t\t\t\tmin.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tminVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// update the max coordinates\n\n\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\tif ( point.getComponent( j ) > max.getComponent( j ) ) {\n\n\t\t\t\t\t\tmax.setComponent( j, point.getComponent( j ) );\n\t\t\t\t\t\tmaxVertices[ j ] = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// use min/max vectors to compute an optimal epsilon\n\n\t\t\tthis.tolerance = 3 * Number.EPSILON * (\n\t\t\t\tMath.max( Math.abs( min.x ), Math.abs( max.x ) ) +\n\t\t\t\tMath.max( Math.abs( min.y ), Math.abs( max.y ) ) +\n\t\t\t\tMath.max( Math.abs( min.z ), Math.abs( max.z ) )\n\t\t\t);\n\n\t\t\treturn { min: minVertices, max: maxVertices };\n\n\t\t},\n\n\t\t// Computes the initial simplex assigning to its faces all the points\n\t\t// that are candidates to form part of the hull\n\n\t\tcomputeInitialHull: function () {\n\n\t\t\tvar line3, plane, closestPoint;\n\n\t\t\treturn function computeInitialHull() {\n\n\t\t\t\tif ( line3 === undefined ) {\n\n\t\t\t\t\tline3 = new THREE.Line3();\n\t\t\t\t\tplane = new THREE.Plane();\n\t\t\t\t\tclosestPoint = new THREE.Vector3();\n\n\t\t\t\t}\n\n\t\t\t\tvar vertex, vertices = this.vertices;\n\t\t\t\tvar extremes = this.computeExtremes();\n\t\t\t\tvar min = extremes.min;\n\t\t\t\tvar max = extremes.max;\n\n\t\t\t\tvar v0, v1, v2, v3;\n\t\t\t\tvar i, l, j;\n\n\t\t\t\t// 1. Find the two vertices 'v0' and 'v1' with the greatest 1d separation\n\t\t\t\t// (max.x - min.x)\n\t\t\t\t// (max.y - min.y)\n\t\t\t\t// (max.z - min.z)\n\n\t\t\t\tvar distance, maxDistance = 0;\n\t\t\t\tvar index = 0;\n\n\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\tdistance = max[ i ].point.getComponent( i ) - min[ i ].point.getComponent( i );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\tindex = i;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tv0 = min[ index ];\n\t\t\t\tv1 = max[ index ];\n\n\t\t\t\t// 2. The next vertex 'v2' is the one farthest to the line formed by 'v0' and 'v1'\n\n\t\t\t\tmaxDistance = 0;\n\t\t\t\tline3.set( v0.point, v1.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 ) {\n\n\t\t\t\t\t\tline3.closestPointToPoint( vertex.point, true, closestPoint );\n\n\t\t\t\t\t\tdistance = closestPoint.distanceToSquared( vertex.point );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv2 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// 3. The next vertex 'v3' is the one farthest to the plane 'v0', 'v1', 'v2'\n\n\t\t\t\tmaxDistance = - 1;\n\t\t\t\tplane.setFromCoplanarPoints( v0.point, v1.point, v2.point );\n\n\t\t\t\tfor ( i = 0, l = this.vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 ) {\n\n\t\t\t\t\t\tdistance = Math.abs( plane.distanceToPoint( vertex.point ) );\n\n\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\tv3 = vertex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar faces = [];\n\n\t\t\t\tif ( plane.distanceToPoint( v3.point ) < 0 ) {\n\n\t\t\t\t\t// the face is not able to see the point so 'plane.normal' is pointing outside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v1, v0 ),\n\t\t\t\t\t\tFace.create( v3, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v2 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( j ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ], 1 <= i <= 3\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 1 ).setTwin( faces[ j + 1 ].getEdge( 0 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// the face is able to see the point so 'plane.normal' is pointing inside the tetrahedron\n\n\t\t\t\t\tfaces.push(\n\t\t\t\t\t\tFace.create( v0, v2, v1 ),\n\t\t\t\t\t\tFace.create( v3, v0, v1 ),\n\t\t\t\t\t\tFace.create( v3, v1, v2 ),\n\t\t\t\t\t\tFace.create( v3, v2, v0 )\n\t\t\t\t\t);\n\n\t\t\t\t\t// set the twin edge\n\n\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\tj = ( i + 1 ) % 3;\n\n\t\t\t\t\t\t// join face[ i ] i > 0, with the first face\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 2 ).setTwin( faces[ 0 ].getEdge( ( 3 - i ) % 3 ) );\n\n\t\t\t\t\t\t// join face[ i ] with face[ i + 1 ]\n\n\t\t\t\t\t\tfaces[ i + 1 ].getEdge( 0 ).setTwin( faces[ j + 1 ].getEdge( 1 ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// the initial hull is the tetrahedron\n\n\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\tthis.faces.push( faces[ i ] );\n\n\t\t\t\t}\n\n\t\t\t\t// initial assignment of vertices to the faces of the tetrahedron\n\n\t\t\t\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\n\n\t\t\t\t\tvertex = vertices[ i ];\n\n\t\t\t\t\tif ( vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3 ) {\n\n\t\t\t\t\t\tmaxDistance = this.tolerance;\n\t\t\t\t\t\tvar maxFace = null;\n\n\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\tdistance = this.faces[ j ].distanceToPoint( vertex.point );\n\n\t\t\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\t\t\tmaxFace = this.faces[ j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( maxFace !== null ) {\n\n\t\t\t\t\t\t\tthis.addVertexToFace( vertex, maxFace );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\t// Removes inactive faces\n\n\t\treindexFaces: function () {\n\n\t\t\tvar activeFaces = [];\n\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\n\n\t\t\t\tvar face = this.faces[ i ];\n\n\t\t\t\tif ( face.mark === Visible ) {\n\n\t\t\t\t\tactiveFaces.push( face );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.faces = activeFaces;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Finds the next vertex to create faces with the current hull\n\n\t\tnextVertexToAdd: function () {\n\n\t\t\t// if the 'assigned' list of vertices is empty, no vertices are left. return with 'undefined'\n\n\t\t\tif ( this.assigned.isEmpty() === false ) {\n\n\t\t\t\tvar eyeVertex, maxDistance = 0;\n\n\t\t\t\t// grap the first available face and start with the first visible vertex of that face\n\n\t\t\t\tvar eyeFace = this.assigned.first().face;\n\t\t\t\tvar vertex = eyeFace.outside;\n\n\t\t\t\t// now calculate the farthest vertex that face can see\n\n\t\t\t\tdo {\n\n\t\t\t\t\tvar distance = eyeFace.distanceToPoint( vertex.point );\n\n\t\t\t\t\tif ( distance > maxDistance ) {\n\n\t\t\t\t\t\tmaxDistance = distance;\n\t\t\t\t\t\teyeVertex = vertex;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvertex = vertex.next;\n\n\t\t\t\t} while ( vertex !== null && vertex.face === eyeFace );\n\n\t\t\t\treturn eyeVertex;\n\n\t\t\t}\n\n\t\t},\n\n\t\t// Computes a chain of half edges in CCW order called the 'horizon'.\n\t\t// For an edge to be part of the horizon it must join a face that can see\n\t\t// 'eyePoint' and a face that cannot see 'eyePoint'.\n\n\t\tcomputeHorizon: function ( eyePoint, crossEdge, face, horizon ) {\n\n\t\t\t// moves face's vertices to the 'unassigned' vertex list\n\n\t\t\tthis.deleteFaceVertices( face );\n\n\t\t\tface.mark = Deleted;\n\n\t\t\tvar edge;\n\n\t\t\tif ( crossEdge === null ) {\n\n\t\t\t\tedge = crossEdge = face.getEdge( 0 );\n\n\t\t\t} else {\n\n\t\t\t\t// start from the next edge since 'crossEdge' was already analyzed\n\t\t\t\t// (actually 'crossEdge.twin' was the edge who called this method recursively)\n\n\t\t\t\tedge = crossEdge.next;\n\n\t\t\t}\n\n\t\t\tdo {\n\n\t\t\t\tvar twinEdge = edge.twin;\n\t\t\t\tvar oppositeFace = twinEdge.face;\n\n\t\t\t\tif ( oppositeFace.mark === Visible ) {\n\n\t\t\t\t\tif ( oppositeFace.distanceToPoint( eyePoint ) > this.tolerance ) {\n\n\t\t\t\t\t\t// the opposite face can see the vertex, so proceed with next edge\n\n\t\t\t\t\t\tthis.computeHorizon( eyePoint, twinEdge, oppositeFace, horizon );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// the opposite face can't see the vertex, so this edge is part of the horizon\n\n\t\t\t\t\t\thorizon.push( edge );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tedge = edge.next;\n\n\t\t\t} while ( edge !== crossEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order\n\n\t\taddAdjoiningFace: function ( eyeVertex, horizonEdge ) {\n\n\t\t\t// all the half edges are created in ccw order thus the face is always pointing outside the hull\n\n\t\t\tvar face = Face.create( eyeVertex, horizonEdge.tail(), horizonEdge.head() );\n\n\t\t\tthis.faces.push( face );\n\n\t\t\t// join face.getEdge( - 1 ) with the horizon's opposite edge face.getEdge( - 1 ) = face.getEdge( 2 )\n\n\t\t\tface.getEdge( - 1 ).setTwin( horizonEdge.twin );\n\n\t\t\treturn face.getEdge( 0 ); // the half edge whose vertex is the eyeVertex\n\n\n\t\t},\n\n\t\t//  Adds 'horizon.length' faces to the hull, each face will be linked with the\n\t\t//  horizon opposite face and the face on the left/right\n\n\t\taddNewFaces: function ( eyeVertex, horizon ) {\n\n\t\t\tthis.newFaces = [];\n\n\t\t\tvar firstSideEdge = null;\n\t\t\tvar previousSideEdge = null;\n\n\t\t\tfor ( var i = 0; i < horizon.length; i ++ ) {\n\n\t\t\t\tvar horizonEdge = horizon[ i ];\n\n\t\t\t\t// returns the right side edge\n\n\t\t\t\tvar sideEdge = this.addAdjoiningFace( eyeVertex, horizonEdge );\n\n\t\t\t\tif ( firstSideEdge === null ) {\n\n\t\t\t\t\tfirstSideEdge = sideEdge;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// joins face.getEdge( 1 ) with previousFace.getEdge( 0 )\n\n\t\t\t\t\tsideEdge.next.setTwin( previousSideEdge );\n\n\t\t\t\t}\n\n\t\t\t\tthis.newFaces.push( sideEdge.face );\n\t\t\t\tpreviousSideEdge = sideEdge;\n\n\t\t\t}\n\n\t\t\t// perform final join of new faces\n\n\t\t\tfirstSideEdge.next.setTwin( previousSideEdge );\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Adds a vertex to the hull\n\n\t\taddVertexToHull: function ( eyeVertex ) {\n\n\t\t\tvar horizon = [];\n\n\t\t\tthis.unassigned.clear();\n\n\t\t\t// remove 'eyeVertex' from 'eyeVertex.face' so that it can't be added to the 'unassigned' vertex list\n\n\t\t\tthis.removeVertexFromFace( eyeVertex, eyeVertex.face );\n\n\t\t\tthis.computeHorizon( eyeVertex.point, null, eyeVertex.face, horizon );\n\n\t\t\tthis.addNewFaces( eyeVertex, horizon );\n\n\t\t\t// reassign 'unassigned' vertices to the new faces\n\n\t\t\tthis.resolveUnassignedPoints( this.newFaces );\n\n\t\t\treturn\tthis;\n\n\t\t},\n\n\t\tcleanup: function () {\n\n\t\t\tthis.assigned.clear();\n\t\t\tthis.unassigned.clear();\n\t\t\tthis.newFaces = [];\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar vertex;\n\n\t\t\tthis.computeInitialHull();\n\n\t\t\t// add all available vertices gradually to the hull\n\n\t\t\twhile ( ( vertex = this.nextVertexToAdd() ) !== undefined ) {\n\n\t\t\t\tthis.addVertexToHull( vertex );\n\n\t\t\t}\n\n\t\t\tthis.reindexFaces();\n\n\t\t\tthis.cleanup();\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t//\n\n\tfunction Face() {\n\n\t\tthis.normal = new THREE.Vector3();\n\t\tthis.midpoint = new THREE.Vector3();\n\t\tthis.area = 0;\n\n\t\tthis.constant = 0; // signed distance from face to the origin\n\t\tthis.outside = null; // reference to a vertex in a vertex list this face can see\n\t\tthis.mark = Visible;\n\t\tthis.edge = null;\n\n\t}\n\n\tObject.assign( Face, {\n\n\t\tcreate: function ( a, b, c ) {\n\n\t\t\tvar face = new Face();\n\n\t\t\tvar e0 = new HalfEdge( a, face );\n\t\t\tvar e1 = new HalfEdge( b, face );\n\t\t\tvar e2 = new HalfEdge( c, face );\n\n\t\t\t// join edges\n\n\t\t\te0.next = e2.prev = e1;\n\t\t\te1.next = e0.prev = e2;\n\t\t\te2.next = e1.prev = e0;\n\n\t\t\t// main half edge reference\n\n\t\t\tface.edge = e0;\n\n\t\t\treturn face.compute();\n\n\t\t}\n\n\t} );\n\n\tObject.assign( Face.prototype, {\n\n\t\tgetEdge: function ( i ) {\n\n\t\t\tvar edge = this.edge;\n\n\t\t\twhile ( i > 0 ) {\n\n\t\t\t\tedge = edge.next;\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\twhile ( i < 0 ) {\n\n\t\t\t\tedge = edge.prev;\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn edge;\n\n\t\t},\n\n\t\tcompute: function () {\n\n\t\t\tvar triangle;\n\n\t\t\treturn function compute() {\n\n\t\t\t\tif ( triangle === undefined ) triangle = new THREE.Triangle();\n\n\t\t\t\tvar a = this.edge.tail();\n\t\t\t\tvar b = this.edge.head();\n\t\t\t\tvar c = this.edge.next.head();\n\n\t\t\t\ttriangle.set( a.point, b.point, c.point );\n\n\t\t\t\ttriangle.getNormal( this.normal );\n\t\t\t\ttriangle.getMidpoint( this.midpoint );\n\t\t\t\tthis.area = triangle.getArea();\n\n\t\t\t\tthis.constant = this.normal.dot( this.midpoint );\n\n\t\t\t\treturn this;\n\n\t\t\t};\n\n\t\t}(),\n\n\t\tdistanceToPoint: function ( point ) {\n\n\t\t\treturn this.normal.dot( point ) - this.constant;\n\n\t\t}\n\n\t} );\n\n\t// Entity for a Doubly-Connected Edge List (DCEL).\n\n\tfunction HalfEdge( vertex, face ) {\n\n\t\tthis.vertex = vertex;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.twin = null;\n\t\tthis.face = face;\n\n\t}\n\n\tObject.assign( HalfEdge.prototype, {\n\n\t\thead: function () {\n\n\t\t\treturn this.vertex;\n\n\t\t},\n\n\t\ttail: function () {\n\n\t\t\treturn this.prev ? this.prev.vertex : null;\n\n\t\t},\n\n\t\tlength: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceTo( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tlengthSquared: function () {\n\n\t\t\tvar head = this.head();\n\t\t\tvar tail = this.tail();\n\n\t\t\tif ( tail !== null ) {\n\n\t\t\t\treturn tail.point.distanceToSquared( head.point );\n\n\t\t\t}\n\n\t\t\treturn - 1;\n\n\t\t},\n\n\t\tsetTwin: function ( edge ) {\n\n\t\t\tthis.twin = edge;\n\t\t\tedge.twin = this;\n\n\t\t\treturn this;\n\n\t\t}\n\n\t} );\n\n\t// A vertex as a double linked list node.\n\n\tfunction VertexNode( point ) {\n\n\t\tthis.point = point;\n\t\tthis.prev = null;\n\t\tthis.next = null;\n\t\tthis.face = null; // the face that is able to see this vertex\n\n\t}\n\n\t// A double linked list that contains vertex nodes.\n\n\tfunction VertexList() {\n\n\t\tthis.head = null;\n\t\tthis.tail = null;\n\n\t}\n\n\tObject.assign( VertexList.prototype, {\n\n\t\tfirst: function () {\n\n\t\t\treturn this.head;\n\n\t\t},\n\n\t\tlast: function () {\n\n\t\t\treturn this.tail;\n\n\t\t},\n\n\t\tclear: function () {\n\n\t\t\tthis.head = this.tail = null;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex before the target vertex\n\n\t\tinsertBefore: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target.prev;\n\t\t\tvertex.next = target;\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.prev = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Inserts a vertex after the target vertex\n\n\t\tinsertAfter: function ( target, vertex ) {\n\n\t\t\tvertex.prev = target;\n\t\t\tvertex.next = target.next;\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex;\n\n\t\t\t}\n\n\t\t\ttarget.next = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a vertex to the end of the linked list\n\n\t\tappend: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\t\t\tvertex.next = null; // the tail has no subsequent vertex\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Appends a chain of vertices where 'vertex' is the head.\n\n\t\tappendChain: function ( vertex ) {\n\n\t\t\tif ( this.head === null ) {\n\n\t\t\t\tthis.head = vertex;\n\n\t\t\t} else {\n\n\t\t\t\tthis.tail.next = vertex;\n\n\t\t\t}\n\n\t\t\tvertex.prev = this.tail;\n\n\t\t\t// ensure that the 'tail' reference points to the last vertex of the chain\n\n\t\t\twhile ( vertex.next !== null ) {\n\n\t\t\t\tvertex = vertex.next;\n\n\t\t\t}\n\n\t\t\tthis.tail = vertex;\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a vertex from the linked list\n\n\t\tremove: function ( vertex ) {\n\n\t\t\tif ( vertex.prev === null ) {\n\n\t\t\t\tthis.head = vertex.next;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.prev.next = vertex.next;\n\n\t\t\t}\n\n\t\t\tif ( vertex.next === null ) {\n\n\t\t\t\tthis.tail = vertex.prev;\n\n\t\t\t} else {\n\n\t\t\t\tvertex.next.prev = vertex.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\t// Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b\n\n\t\tremoveSubList: function ( a, b ) {\n\n\t\t\tif ( a.prev === null ) {\n\n\t\t\t\tthis.head = b.next;\n\n\t\t\t} else {\n\n\t\t\t\ta.prev.next = b.next;\n\n\t\t\t}\n\n\t\t\tif ( b.next === null ) {\n\n\t\t\t\tthis.tail = a.prev;\n\n\t\t\t} else {\n\n\t\t\t\tb.next.prev = a.prev;\n\n\t\t\t}\n\n\t\t\treturn this;\n\n\t\t},\n\n\t\tisEmpty: function () {\n\n\t\t\treturn this.head === null;\n\n\t\t}\n\n\t} );\n\n\t// export\n\n\tTHREE.QuickHull = QuickHull;\n\n\n} )();\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/geo/QuickHull.js?");

/***/ }),

/***/ "./js/vendor/three/geo/SimplexNoise.js":
/*!*********************************************!*\
  !*** ./js/vendor/three/geo/SimplexNoise.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Ported from Stefan Gustavson's java implementation\n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n// Read Stefan's excellent paper for details on how this code works.\n//\n// Sean McCullough banksean@gmail.com\n//\n// Added 4D noise\n// Joshua Koo zz85nus@gmail.com \n\n/**\n * You can pass in a random number generator object if you like.\n * It is assumed to have a random() method.\n */\nvar SimplexNoise = function(r) {\n\tif (r == undefined) r = Math;\n\tthis.grad3 = [[ 1,1,0 ],[ -1,1,0 ],[ 1,-1,0 ],[ -1,-1,0 ], \n                                 [ 1,0,1 ],[ -1,0,1 ],[ 1,0,-1 ],[ -1,0,-1 ], \n                                 [ 0,1,1 ],[ 0,-1,1 ],[ 0,1,-1 ],[ 0,-1,-1 ]]; \n\n\tthis.grad4 = [[ 0,1,1,1 ], [ 0,1,1,-1 ], [ 0,1,-1,1 ], [ 0,1,-1,-1 ],\n\t     [ 0,-1,1,1 ], [ 0,-1,1,-1 ], [ 0,-1,-1,1 ], [ 0,-1,-1,-1 ],\n\t     [ 1,0,1,1 ], [ 1,0,1,-1 ], [ 1,0,-1,1 ], [ 1,0,-1,-1 ],\n\t     [ -1,0,1,1 ], [ -1,0,1,-1 ], [ -1,0,-1,1 ], [ -1,0,-1,-1 ],\n\t     [ 1,1,0,1 ], [ 1,1,0,-1 ], [ 1,-1,0,1 ], [ 1,-1,0,-1 ],\n\t     [ -1,1,0,1 ], [ -1,1,0,-1 ], [ -1,-1,0,1 ], [ -1,-1,0,-1 ],\n\t     [ 1,1,1,0 ], [ 1,1,-1,0 ], [ 1,-1,1,0 ], [ 1,-1,-1,0 ],\n\t     [ -1,1,1,0 ], [ -1,1,-1,0 ], [ -1,-1,1,0 ], [ -1,-1,-1,0 ]];\n\n\tthis.p = [];\n\tfor (var i = 0; i < 256; i ++) {\n\t\tthis.p[i] = Math.floor(r.random() * 256);\n\t}\n  // To remove the need for index wrapping, double the permutation table length \n\tthis.perm = []; \n\tfor (var i = 0; i < 512; i ++) {\n\t\tthis.perm[i] = this.p[i & 255];\n\t} \n\n  // A lookup table to traverse the simplex around a given point in 4D. \n  // Details can be found where this table is used, in the 4D noise method. \n\tthis.simplex = [ \n    [ 0,1,2,3 ],[ 0,1,3,2 ],[ 0,0,0,0 ],[ 0,2,3,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,2,3,0 ], \n    [ 0,2,1,3 ],[ 0,0,0,0 ],[ 0,3,1,2 ],[ 0,3,2,1 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 1,3,2,0 ], \n    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], \n    [ 1,2,0,3 ],[ 0,0,0,0 ],[ 1,3,0,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,3,0,1 ],[ 2,3,1,0 ], \n    [ 1,0,2,3 ],[ 1,0,3,2 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 2,0,3,1 ],[ 0,0,0,0 ],[ 2,1,3,0 ], \n    [ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ], \n    [ 2,0,1,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,0,1,2 ],[ 3,0,2,1 ],[ 0,0,0,0 ],[ 3,1,2,0 ], \n    [ 2,1,0,3 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 0,0,0,0 ],[ 3,1,0,2 ],[ 0,0,0,0 ],[ 3,2,0,1 ],[ 3,2,1,0 ]]; \n};\n\nSimplexNoise.prototype.dot = function(g, x, y) { \n\treturn g[0] * x + g[1] * y;\n};\n\nSimplexNoise.prototype.dot3 = function(g, x, y, z) {\n\treturn g[0] * x + g[1] * y + g[2] * z; \n};\n\nSimplexNoise.prototype.dot4 = function(g, x, y, z, w) {\n\treturn g[0] * x + g[1] * y + g[2] * z + g[3] * w;\n};\n\nSimplexNoise.prototype.noise = function(xin, yin) { \n\tvar n0, n1, n2; // Noise contributions from the three corners \n  // Skew the input space to determine which simplex cell we're in \n\tvar F2 = 0.5 * (Math.sqrt(3.0) - 1.0); \n\tvar s = (xin + yin) * F2; // Hairy factor for 2D \n\tvar i = Math.floor(xin + s); \n\tvar j = Math.floor(yin + s); \n\tvar G2 = (3.0 - Math.sqrt(3.0)) / 6.0; \n\tvar t = (i + j) * G2; \n\tvar X0 = i - t; // Unskew the cell origin back to (x,y) space \n\tvar Y0 = j - t; \n\tvar x0 = xin - X0; // The x,y distances from the cell origin \n\tvar y0 = yin - Y0; \n  // For the 2D case, the simplex shape is an equilateral triangle. \n  // Determine which simplex we are in. \n\tvar i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords \n\tif (x0 > y0) {i1 = 1; j1 = 0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1) \n\telse {i1 = 0; j1 = 1;}      // upper triangle, YX order: (0,0)->(0,1)->(1,1) \n  // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and \n  // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where \n  // c = (3-sqrt(3))/6 \n\tvar x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords \n\tvar y1 = y0 - j1 + G2; \n\tvar x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords \n\tvar y2 = y0 - 1.0 + 2.0 * G2; \n  // Work out the hashed gradient indices of the three simplex corners \n\tvar ii = i & 255; \n\tvar jj = j & 255; \n\tvar gi0 = this.perm[ii + this.perm[jj]] % 12; \n\tvar gi1 = this.perm[ii + i1 + this.perm[jj + j1]] % 12; \n\tvar gi2 = this.perm[ii + 1 + this.perm[jj + 1]] % 12; \n  // Calculate the contribution from the three corners \n\tvar t0 = 0.5 - x0 * x0 - y0 * y0; \n\tif (t0 < 0) n0 = 0.0; \n\telse { \n\t\tt0 *= t0; \n\t\tn0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0);  // (x,y) of grad3 used for 2D gradient \n\t} \n\tvar t1 = 0.5 - x1 * x1 - y1 * y1; \n\tif (t1 < 0) n1 = 0.0; \n\telse { \n\t\tt1 *= t1; \n\t\tn1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1); \n\t}\n\tvar t2 = 0.5 - x2 * x2 - y2 * y2; \n\tif (t2 < 0) n2 = 0.0; \n\telse { \n\t\tt2 *= t2; \n\t\tn2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2); \n\t} \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to return values in the interval [-1,1]. \n\treturn 70.0 * (n0 + n1 + n2); \n};\n\n// 3D simplex noise \nSimplexNoise.prototype.noise3d = function(xin, yin, zin) { \n\tvar n0, n1, n2, n3; // Noise contributions from the four corners \n  // Skew the input space to determine which simplex cell we're in \n\tvar F3 = 1.0 / 3.0; \n\tvar s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D \n\tvar i = Math.floor(xin + s); \n\tvar j = Math.floor(yin + s); \n\tvar k = Math.floor(zin + s); \n\tvar G3 = 1.0 / 6.0; // Very nice and simple unskew factor, too \n\tvar t = (i + j + k) * G3; \n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z) space \n\tvar Y0 = j - t; \n\tvar Z0 = k - t; \n\tvar x0 = xin - X0; // The x,y,z distances from the cell origin \n\tvar y0 = yin - Y0; \n\tvar z0 = zin - Z0; \n  // For the 3D case, the simplex shape is a slightly irregular tetrahedron. \n  // Determine which simplex we are in. \n\tvar i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords \n\tvar i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords \n\tif (x0 >= y0) { \n\t\tif (y0 >= z0) \n      { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order \n      else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order \n\t\telse { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order \n\t} \n\telse { // x0<y0 \n\t\tif (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order \n    else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order \n\t\telse { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order \n\t} \n  // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z), \n  // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and \n  // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where \n  // c = 1/6.\n\tvar x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords \n\tvar y1 = y0 - j1 + G3; \n\tvar z1 = z0 - k1 + G3; \n\tvar x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords \n\tvar y2 = y0 - j2 + 2.0 * G3; \n\tvar z2 = z0 - k2 + 2.0 * G3; \n\tvar x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords \n\tvar y3 = y0 - 1.0 + 3.0 * G3; \n\tvar z3 = z0 - 1.0 + 3.0 * G3; \n  // Work out the hashed gradient indices of the four simplex corners \n\tvar ii = i & 255; \n\tvar jj = j & 255; \n\tvar kk = k & 255; \n\tvar gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12; \n\tvar gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12; \n\tvar gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12; \n\tvar gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12; \n  // Calculate the contribution from the four corners \n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0; \n\tif (t0 < 0) n0 = 0.0; \n\telse { \n\t\tt0 *= t0; \n\t\tn0 = t0 * t0 * this.dot3(this.grad3[gi0], x0, y0, z0); \n\t}\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1; \n\tif (t1 < 0) n1 = 0.0; \n\telse { \n\t\tt1 *= t1; \n\t\tn1 = t1 * t1 * this.dot3(this.grad3[gi1], x1, y1, z1); \n\t} \n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2; \n\tif (t2 < 0) n2 = 0.0; \n\telse { \n\t\tt2 *= t2; \n\t\tn2 = t2 * t2 * this.dot3(this.grad3[gi2], x2, y2, z2); \n\t} \n\tvar t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3; \n\tif (t3 < 0) n3 = 0.0; \n\telse { \n\t\tt3 *= t3; \n\t\tn3 = t3 * t3 * this.dot3(this.grad3[gi3], x3, y3, z3); \n\t} \n  // Add contributions from each corner to get the final noise value. \n  // The result is scaled to stay just inside [-1,1] \n\treturn 32.0 * (n0 + n1 + n2 + n3); \n};\n\n// 4D simplex noise\nSimplexNoise.prototype.noise4d = function( x, y, z, w ) {\n\t// For faster and easier lookups\n\tvar grad4 = this.grad4;\n\tvar simplex = this.simplex;\n\tvar perm = this.perm;\n\t\n   // The skewing and unskewing factors are hairy again for the 4D case\n\tvar F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\n\tvar G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\n\tvar n0, n1, n2, n3, n4; // Noise contributions from the five corners\n   // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\n\tvar s = (x + y + z + w) * F4; // Factor for 4D skewing\n\tvar i = Math.floor(x + s);\n\tvar j = Math.floor(y + s);\n\tvar k = Math.floor(z + s);\n\tvar l = Math.floor(w + s);\n\tvar t = (i + j + k + l) * G4; // Factor for 4D unskewing\n\tvar X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\n\tvar Y0 = j - t;\n\tvar Z0 = k - t;\n\tvar W0 = l - t;\n\tvar x0 = x - X0;  // The x,y,z,w distances from the cell origin\n\tvar y0 = y - Y0;\n\tvar z0 = z - Z0;\n\tvar w0 = w - W0;\n\n   // For the 4D case, the simplex is a 4D shape I won't even try to describe.\n   // To find out which of the 24 possible simplices we're in, we need to\n   // determine the magnitude ordering of x0, y0, z0 and w0.\n   // The method below is a good way of finding the ordering of x,y,z,w and\n   // then find the correct traversal order for the simplex were in.\n   // First, six pair-wise comparisons are performed between each possible pair\n   // of the four coordinates, and the results are used to add up binary bits\n   // for an integer index.\n\tvar c1 = (x0 > y0) ? 32 : 0;\n\tvar c2 = (x0 > z0) ? 16 : 0;\n\tvar c3 = (y0 > z0) ? 8 : 0;\n\tvar c4 = (x0 > w0) ? 4 : 0;\n\tvar c5 = (y0 > w0) ? 2 : 0;\n\tvar c6 = (z0 > w0) ? 1 : 0;\n\tvar c = c1 + c2 + c3 + c4 + c5 + c6;\n\tvar i1, j1, k1, l1; // The integer offsets for the second simplex corner\n\tvar i2, j2, k2, l2; // The integer offsets for the third simplex corner\n\tvar i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\n   // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\n   // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\n   // impossible. Only the 24 indices which have non-zero entries make any sense.\n   // We use a thresholding to set the coordinates in turn from the largest magnitude.\n   // The number 3 in the \"simplex\" array is at the position of the largest coordinate.\n\ti1 = simplex[c][0] >= 3 ? 1 : 0;\n\tj1 = simplex[c][1] >= 3 ? 1 : 0;\n\tk1 = simplex[c][2] >= 3 ? 1 : 0;\n\tl1 = simplex[c][3] >= 3 ? 1 : 0;\n   // The number 2 in the \"simplex\" array is at the second largest coordinate.\n\ti2 = simplex[c][0] >= 2 ? 1 : 0;\n\tj2 = simplex[c][1] >= 2 ? 1 : 0;    k2 = simplex[c][2] >= 2 ? 1 : 0;\n\tl2 = simplex[c][3] >= 2 ? 1 : 0;\n   // The number 1 in the \"simplex\" array is at the second smallest coordinate.\n\ti3 = simplex[c][0] >= 1 ? 1 : 0;\n\tj3 = simplex[c][1] >= 1 ? 1 : 0;\n\tk3 = simplex[c][2] >= 1 ? 1 : 0;\n\tl3 = simplex[c][3] >= 1 ? 1 : 0;\n   // The fifth corner has all coordinate offsets = 1, so no need to look that up.\n\tvar x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\n\tvar y1 = y0 - j1 + G4;\n\tvar z1 = z0 - k1 + G4;\n\tvar w1 = w0 - l1 + G4;\n\tvar x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\n\tvar y2 = y0 - j2 + 2.0 * G4;\n\tvar z2 = z0 - k2 + 2.0 * G4;\n\tvar w2 = w0 - l2 + 2.0 * G4;\n\tvar x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\n\tvar y3 = y0 - j3 + 3.0 * G4;\n\tvar z3 = z0 - k3 + 3.0 * G4;\n\tvar w3 = w0 - l3 + 3.0 * G4;\n\tvar x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\n\tvar y4 = y0 - 1.0 + 4.0 * G4;\n\tvar z4 = z0 - 1.0 + 4.0 * G4;\n\tvar w4 = w0 - 1.0 + 4.0 * G4;\n   // Work out the hashed gradient indices of the five simplex corners\n\tvar ii = i & 255;\n\tvar jj = j & 255;\n\tvar kk = k & 255;\n\tvar ll = l & 255;\n\tvar gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32;\n\tvar gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32;\n\tvar gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32;\n\tvar gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32;\n\tvar gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32;\n   // Calculate the contribution from the five corners\n\tvar t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\n\tif (t0 < 0) n0 = 0.0;\n\telse {\n\t\tt0 *= t0;\n\t\tn0 = t0 * t0 * this.dot4(grad4[gi0], x0, y0, z0, w0);\n\t}\n\tvar t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\n\tif (t1 < 0) n1 = 0.0;\n\telse {\n\t\tt1 *= t1;\n\t\tn1 = t1 * t1 * this.dot4(grad4[gi1], x1, y1, z1, w1);\n\t}\n\tvar t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\n\tif (t2 < 0) n2 = 0.0;\n\telse {\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * this.dot4(grad4[gi2], x2, y2, z2, w2);\n\t}   var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\n\tif (t3 < 0) n3 = 0.0;\n\telse {\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * this.dot4(grad4[gi3], x3, y3, z3, w3);\n\t}\n\tvar t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\n\tif (t4 < 0) n4 = 0.0;\n\telse {\n\t\tt4 *= t4;\n\t\tn4 = t4 * t4 * this.dot4(grad4[gi4], x4, y4, z4, w4);\n\t}\n   // Sum up and scale the result to cover the range [-1,1]\n\treturn 27.0 * (n0 + n1 + n2 + n3 + n4);\n};\n\nTHREE.SimplexNoise = SimplexNoise;\n\n//# sourceURL=webpack://STK/./js/vendor/three/geo/SimplexNoise.js?");

/***/ }),

/***/ "./js/vendor/three/gfx/Mirror.js":
/*!***************************************!*\
  !*** ./js/vendor/three/gfx/Mirror.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Slayvin / http://slayvin.net\n */\n\nTHREE.ShaderLib[ 'mirror' ] = {\n\n\tuniforms: {\n\t\t\"mirrorColor\": { value: new THREE.Color( 0x7F7F7F ) },\n\t\t\"mirrorSampler\": { value: null },\n\t\t\"textureMatrix\" : { value: new THREE.Matrix4() }\n\t},\n\n\tvertexShader: [\n\n\t\t\"uniform mat4 textureMatrix;\",\n\n\t\t\"varying vec4 mirrorCoord;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\t\"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );\",\n\t\t\t\"mirrorCoord = textureMatrix * worldPosition;\",\n\n\t\t\t\"gl_Position = projectionMatrix * mvPosition;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform vec3 mirrorColor;\",\n\t\t\"uniform sampler2D mirrorSampler;\",\n\n\t\t\"varying vec4 mirrorCoord;\",\n\n\t\t\"float blendOverlay(float base, float blend, float a) {\",\n\t\t\t\"return( a < 0.1? base : (base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) ) );\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec4 color = texture2DProj(mirrorSampler, mirrorCoord);\",\n\t\t\t\"color = vec4(blendOverlay(mirrorColor.r, color.r, color.a), blendOverlay(mirrorColor.g, color.g, color.a), blendOverlay(mirrorColor.b, color.b, color.a), 1.0);\",\n\n\t\t\t\"gl_FragColor = color;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\nTHREE.Mirror = function ( renderer, camera, options ) {\n\n\tTHREE.Object3D.call( this );\n\n\tthis.name = 'mirror_' + this.id;\n\n\toptions = options || {};\n\n\tthis.matrixNeedsUpdate = true;\n\n\tvar width = options.textureWidth !== undefined ? options.textureWidth : 512;\n\tvar height = options.textureHeight !== undefined ? options.textureHeight : 512;\n\n\tthis.clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;\n\n\tvar mirrorColor = options.color !== undefined ? new THREE.Color( options.color ) : new THREE.Color( 0x7F7F7F );\n\n\tthis.renderer = renderer;\n\tthis.mirrorPlane = new THREE.Plane();\n\tthis.normal = new THREE.Vector3( 0, 0, 1 );\n\tthis.mirrorWorldPosition = new THREE.Vector3();\n\tthis.cameraWorldPosition = new THREE.Vector3();\n\tthis.rotationMatrix = new THREE.Matrix4();\n\tthis.lookAtPosition = new THREE.Vector3( 0, 0, - 1 );\n\tthis.clipPlane = new THREE.Vector4();\n\n\t// For debug only, show the normal and plane of the mirror\n\tvar debugMode = options.debugMode !== undefined ? options.debugMode : false;\n\n\tif ( debugMode ) {\n\n\t\tvar arrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 0, 1 ), new THREE.Vector3( 0, 0, 0 ), 10, 0xffff80 );\n\t\tvar planeGeometry = new THREE.Geometry();\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( - 10, - 10, 0 ) );\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( 10, - 10, 0 ) );\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( 10, 10, 0 ) );\n\t\tplaneGeometry.vertices.push( new THREE.Vector3( - 10, 10, 0 ) );\n\t\tplaneGeometry.vertices.push( planeGeometry.vertices[ 0 ] );\n\t\tvar plane = new THREE.Line( planeGeometry, new THREE.LineBasicMaterial( { color: 0xffff80 } ) );\n\n\t\tthis.add( arrow );\n\t\tthis.add( plane );\n\n\t}\n\n\tif ( camera instanceof THREE.PerspectiveCamera ) {\n\n\t\tthis.camera = camera;\n\n\t} else {\n\n\t\tthis.camera = new THREE.PerspectiveCamera();\n\t\tconsole.log( this.name + ': camera is not a Perspective Camera!' );\n\n\t}\n\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tthis.mirrorCamera = this.camera.clone();\n\tthis.mirrorCamera.matrixAutoUpdate = true;\n\n\tvar parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };\n\n\tthis.renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );\n\tthis.renderTarget2 = new THREE.WebGLRenderTarget( width, height, parameters );\n\n\tvar mirrorShader = THREE.ShaderLib[ \"mirror\" ];\n\tvar mirrorUniforms = THREE.UniformsUtils.clone( mirrorShader.uniforms );\n\n\tthis.material = new THREE.ShaderMaterial( {\n\n\t\tfragmentShader: mirrorShader.fragmentShader,\n\t\tvertexShader: mirrorShader.vertexShader,\n\t\tuniforms: mirrorUniforms\n\n\t} );\n\n\tthis.material.uniforms.mirrorSampler.value = this.renderTarget.texture;\n\tthis.material.uniforms.mirrorColor.value = mirrorColor;\n\tthis.material.uniforms.textureMatrix.value = this.textureMatrix;\n\n\tif ( ! THREE.Math.isPowerOfTwo( width ) || ! THREE.Math.isPowerOfTwo( height ) ) {\n\n\t\tthis.renderTarget.texture.generateMipmaps = false;\n\t\tthis.renderTarget2.texture.generateMipmaps = false;\n\n\t}\n\n\tthis.updateTextureMatrix();\n\tthis.render();\n\n};\n\nTHREE.Mirror.prototype = Object.create( THREE.Object3D.prototype );\nTHREE.Mirror.prototype.constructor = THREE.Mirror;\n\nTHREE.Mirror.prototype.renderWithMirror = function ( otherMirror ) {\n\n\t// update the mirror matrix to mirror the current view\n\tthis.updateTextureMatrix();\n\tthis.matrixNeedsUpdate = false;\n\n\t// set the camera of the other mirror so the mirrored view is the reference view\n\tvar tempCamera = otherMirror.camera;\n\totherMirror.camera = this.mirrorCamera;\n\n\t// render the other mirror in temp texture\n\totherMirror.renderTemp();\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget2.texture;\n\n\t// render the current mirror\n\tthis.render();\n\tthis.matrixNeedsUpdate = true;\n\n\t// restore material and camera of other mirror\n\totherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget.texture;\n\totherMirror.camera = tempCamera;\n\n\t// restore texture matrix of other mirror\n\totherMirror.updateTextureMatrix();\n\n};\n\nTHREE.Mirror.prototype.updateTextureMatrix = function () {\n\n\tthis.updateMatrixWorld();\n\tthis.camera.updateMatrixWorld();\n\n\tthis.mirrorWorldPosition.setFromMatrixPosition( this.matrixWorld );\n\tthis.cameraWorldPosition.setFromMatrixPosition( this.camera.matrixWorld );\n\n\tthis.rotationMatrix.extractRotation( this.matrixWorld );\n\n\tthis.normal.set( 0, 0, 1 );\n\tthis.normal.applyMatrix4( this.rotationMatrix );\n\n\tvar view = this.mirrorWorldPosition.clone().sub( this.cameraWorldPosition );\n\tview.reflect( this.normal ).negate();\n\tview.add( this.mirrorWorldPosition );\n\n\tthis.rotationMatrix.extractRotation( this.camera.matrixWorld );\n\n\tthis.lookAtPosition.set( 0, 0, - 1 );\n\tthis.lookAtPosition.applyMatrix4( this.rotationMatrix );\n\tthis.lookAtPosition.add( this.cameraWorldPosition );\n\n\tvar target = this.mirrorWorldPosition.clone().sub( this.lookAtPosition );\n\ttarget.reflect( this.normal ).negate();\n\ttarget.add( this.mirrorWorldPosition );\n\n\tthis.up.set( 0, - 1, 0 );\n\tthis.up.applyMatrix4( this.rotationMatrix );\n\tthis.up.reflect( this.normal ).negate();\n\n\tthis.mirrorCamera.position.copy( view );\n\tthis.mirrorCamera.up = this.up;\n\tthis.mirrorCamera.lookAt( target );\n\n\tthis.mirrorCamera.updateProjectionMatrix();\n\tthis.mirrorCamera.updateMatrixWorld();\n\tthis.mirrorCamera.matrixWorldInverse.getInverse( this.mirrorCamera.matrixWorld );\n\n\t// Update the texture matrix\n\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0 );\n\tthis.textureMatrix.multiply( this.mirrorCamera.projectionMatrix );\n\tthis.textureMatrix.multiply( this.mirrorCamera.matrixWorldInverse );\n\n\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\tthis.mirrorPlane.setFromNormalAndCoplanarPoint( this.normal, this.mirrorWorldPosition );\n\tthis.mirrorPlane.applyMatrix4( this.mirrorCamera.matrixWorldInverse );\n\n\tthis.clipPlane.set( this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant );\n\n\tvar q = new THREE.Vector4();\n\tvar projectionMatrix = this.mirrorCamera.projectionMatrix;\n\n\tq.x = ( Math.sign( this.clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\tq.y = ( Math.sign( this.clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\tq.z = - 1.0;\n\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t// Calculate the scaled plane vector\n\tvar c = new THREE.Vector4();\n\tc = this.clipPlane.multiplyScalar( 2.0 / this.clipPlane.dot( q ) );\n\n\t// Replacing the third row of the projection matrix\n\tprojectionMatrix.elements[ 2 ] = c.x;\n\tprojectionMatrix.elements[ 6 ] = c.y;\n\tprojectionMatrix.elements[ 10 ] = c.z + 1.0 - this.clipBias;\n\tprojectionMatrix.elements[ 14 ] = c.w;\n\n};\n\nTHREE.Mirror.prototype.render = function () {\n\n\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\n\n\tthis.matrixNeedsUpdate = true;\n\n\t// Render the mirrored view of the current scene into the target texture\n\tvar scene = this;\n\n\twhile ( scene.parent !== null ) {\n\n\t\tscene = scene.parent;\n\n\t}\n\n\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\t// We can't render ourself to ourself\n\t\tvar visible = this.material.visible;\n\t\tthis.material.visible = false;\n\n\t\tthis.renderer.setRenderTarget(this.renderTarget);\n\t\tthis.renderer.clear();\n\t\tthis.renderer.render( scene, this.mirrorCamera );\n\n\t\tthis.material.visible = visible;\n\n\t}\n\n};\n\nTHREE.Mirror.prototype.renderTemp = function () {\n\n\tif ( this.matrixNeedsUpdate ) this.updateTextureMatrix();\n\n\tthis.matrixNeedsUpdate = true;\n\n\t// Render the mirrored view of the current scene into the target texture\n\tvar scene = this;\n\n\twhile ( scene.parent !== null ) {\n\n\t\tscene = scene.parent;\n\n\t}\n\n\tif ( scene !== undefined && scene instanceof THREE.Scene ) {\n\n\t\tthis.renderer.render( scene, this.mirrorCamera, this.renderTarget2, true );\n\n\t}\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/gfx/Mirror.js?");

/***/ }),

/***/ "./js/vendor/three/loaders/deprecated/LegacyJSONLoader.js":
/*!****************************************************************!*\
  !*** ./js/vendor/three/loaders/deprecated/LegacyJSONLoader.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n */\n\n// AXC: Added so THREE.js will report messages on deprecated stuff, but not so much!!!\n\nTHREE.LegacyJSONLoader = ( function () {\n\n\tfunction LegacyJSONLoader( manager ) {\n\n\t\tif ( typeof manager === 'boolean' ) {\n\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\n\t\t\tmanager = undefined;\n\n\t\t}\n\n\t\tTHREE.Loader.call( this, manager );\n\n\t\tthis.withCredentials = false;\n\n\t}\n\n\t// AXC: Added so THREE.js will report messages on deprecated stuff, but not so much!!!\n\tLegacyJSONLoader.__reportedMessages = {};\n\n\tLegacyJSONLoader.prototype = Object.assign( Object.create( THREE.Loader.prototype ), {\n\n\t\tconstructor: LegacyJSONLoader,\n\n\t\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\t\tvar scope = this;\n\n\t\t\tvar path = ( this.path === '' ) ? THREE.LoaderUtils.extractUrlBase( url ) : this.path;\n\n\t\t\tvar loader = new THREE.FileLoader( this.manager );\n\t\t\tloader.setPath( this.path );\n\t\t\tloader.setWithCredentials( this.withCredentials );\n\t\t\tloader.load( url, function ( text ) {\n\n\t\t\t\tvar json = JSON.parse( text );\n\t\t\t\tvar metadata = json.metadata;\n\n\t\t\t\tif ( metadata !== undefined ) {\n\n\t\t\t\t\tvar type = metadata.type;\n\n\t\t\t\t\tif ( type !== undefined ) {\n\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\n\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar object = scope.parse( json, path );\n\t\t\t\tonLoad( object.geometry, object.materials );\n\n\t\t\t}, onProgress, onError );\n\n\t\t},\n\n\t\tparse: ( function () {\n\n\t\t\tvar _BlendingMode = {\n\t\t\t\tNoBlending: THREE.NoBlending,\n\t\t\t\tNormalBlending: THREE.NormalBlending,\n\t\t\t\tAdditiveBlending: THREE.AdditiveBlending,\n\t\t\t\tSubtractiveBlending: THREE.SubtractiveBlending,\n\t\t\t\tMultiplyBlending: THREE.MultiplyBlending,\n\t\t\t\tCustomBlending: THREE.CustomBlending\n\t\t\t};\n\n\t\t\tvar _color = new THREE.Color();\n\t\t\tvar _textureLoader = new THREE.TextureLoader();\n\t\t\tvar _materialLoader = new THREE.MaterialLoader();\n\n\t\t\tfunction initMaterials( materials, texturePath, crossOrigin, manager ) {\n\n\t\t\t\tvar array = [];\n\n\t\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\n\n\t\t\t\t\tarray[ i ] = createMaterial( materials[ i ], texturePath, crossOrigin, manager );\n\n\t\t\t\t}\n\n\t\t\t\treturn array;\n\n\t\t\t}\n\n\t\t\tfunction createMaterial( m, texturePath, crossOrigin, manager ) {\n\n\t\t\t\t// convert from old material format\n\n\t\t\t\tvar textures = {};\n\n\t\t\t\t//\n\n\t\t\t\tvar json = {\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\n\t\t\t\t\ttype: THREE.Loader.DefaultMaterialType\n\t\t\t\t};\n\n\t\t\t\tfor ( var name in m ) {\n\n\t\t\t\t\tvar value = m[ name ];\n\n\t\t\t\t\tswitch ( name ) {\n\n\t\t\t\t\t\tcase 'DbgColor':\n\t\t\t\t\t\tcase 'DbgIndex':\n\t\t\t\t\t\tcase 'opticalDensity':\n\t\t\t\t\t\tcase 'illumination':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'DbgName':\n\t\t\t\t\t\t\tjson.name = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'blending':\n\t\t\t\t\t\t\tjson.blending = _BlendingMode[ value ];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorAmbient':\n\t\t\t\t\t\tcase 'mapAmbient':\n\t\t\t\t\t\t\tif (!LegacyJSONLoader.__reportedMessages['mapAmbient']) {   // AXC: Make reporting of these messages quieter\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LegacyJSONLoader.createMaterial:', name, 'is no longer supported.' );\n\t\t\t\t\t\t\t\tLegacyJSONLoader.__reportedMessages['mapAmbient'] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorDiffuse':\n\t\t\t\t\t\t\tjson.color = _color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorSpecular':\n\t\t\t\t\t\t\tjson.specular = _color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'colorEmissive':\n\t\t\t\t\t\t\tjson.emissive = _color.fromArray( value ).getHex();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'specularCoef':\n\t\t\t\t\t\t\tjson.shininess = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'shading':\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuse':\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissive':\n\t\t\t\t\t\t\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapEmissiveRepeat':\n\t\t\t\t\t\tcase 'mapEmissiveOffset':\n\t\t\t\t\t\tcase 'mapEmissiveWrap':\n\t\t\t\t\t\tcase 'mapEmissiveAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLight':\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapLightRepeat':\n\t\t\t\t\t\tcase 'mapLightOffset':\n\t\t\t\t\t\tcase 'mapLightWrap':\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAO':\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAORepeat':\n\t\t\t\t\t\tcase 'mapAOOffset':\n\t\t\t\t\t\tcase 'mapAOWrap':\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBump':\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpScale':\n\t\t\t\t\t\t\tjson.bumpScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapBumpRepeat':\n\t\t\t\t\t\tcase 'mapBumpOffset':\n\t\t\t\t\t\tcase 'mapBumpWrap':\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormal':\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalFactor':\n\t\t\t\t\t\t\tjson.normalScale = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapNormalRepeat':\n\t\t\t\t\t\tcase 'mapNormalOffset':\n\t\t\t\t\t\tcase 'mapNormalWrap':\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecular':\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\n\t\t\t\t\t\tcase 'mapSpecularOffset':\n\t\t\t\t\t\tcase 'mapSpecularWrap':\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalness':\n\t\t\t\t\t\t\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapMetalnessRepeat':\n\t\t\t\t\t\tcase 'mapMetalnessOffset':\n\t\t\t\t\t\tcase 'mapMetalnessWrap':\n\t\t\t\t\t\tcase 'mapMetalnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughness':\n\t\t\t\t\t\t\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapRoughnessRepeat':\n\t\t\t\t\t\tcase 'mapRoughnessOffset':\n\t\t\t\t\t\tcase 'mapRoughnessWrap':\n\t\t\t\t\t\tcase 'mapRoughnessAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlpha':\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy, textures, texturePath, crossOrigin, manager );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\n\t\t\t\t\t\tcase 'mapAlphaOffset':\n\t\t\t\t\t\tcase 'mapAlphaWrap':\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'flipSided':\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'doubleSided':\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\t\tif (!LegacyJSONLoader.__reportedMessages['transparency renamed']) {   // AXC: Make reporting of these messages quieter\n\t\t\t\t\t\t\t\tconsole.warn( 'THREE.LegacyJSONLoader.createMaterial: transparency has been renamed to opacity' );\n\t\t\t\t\t\t\t\tLegacyJSONLoader.__reportedMessages['transparency renamed'] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjson.opacity = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'depthTest':\n\t\t\t\t\t\tcase 'depthWrite':\n\t\t\t\t\t\tcase 'colorWrite':\n\t\t\t\t\t\tcase 'opacity':\n\t\t\t\t\t\tcase 'reflectivity':\n\t\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tcase 'visible':\n\t\t\t\t\t\tcase 'wireframe':\n\t\t\t\t\t\t\tjson[ name ] = value;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'vertexColors':\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tif (!LegacyJSONLoader__reportedMessages['unsupported ' + name]) {   // AXC: Make reporting of these messages quieter\n\t\t\t\t\t\t\t\tconsole.error( 'THREE.LegacyJSONLoader.createMaterial: Unsupported', name, value );\n\t\t\t\t\t\t\t\tLegacyJSONLoader.__reportedMessages['unsupported ' + name] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\n\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\n\n\t\t\t\t_materialLoader.setTextures( textures );\n\n\t\t\t\treturn _materialLoader.parse( json );\n\n\t\t\t}\n\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy, textures, texturePath, crossOrigin, manager ) {\n\t\t\t\t// AXC: Sometimes there is no path\n\t\t\t\tif (!path) {\n\t\t\t\t\tconsole.warn(\"No path when loading texture\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar fullPath = texturePath + path;\n\t\t\t\tvar loader = manager.getHandler( fullPath );\n\n\t\t\t\tvar texture;\n\n\t\t\t\tif ( loader !== null ) {\n\n\t\t\t\t\ttexture = loader.load( fullPath );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_textureLoader.setCrossOrigin( crossOrigin );\n\t\t\t\t\ttexture = _textureLoader.load( fullPath );\n\n\t\t\t\t}\n\n\t\t\t\tif ( repeat !== undefined ) {\n\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\n\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( offset !== undefined ) {\n\n\t\t\t\t\ttexture.offset.fromArray( offset );\n\n\t\t\t\t}\n\n\t\t\t\tif ( wrap !== undefined ) {\n\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\n\n\t\t\t\t}\n\n\t\t\t\tif ( anisotropy !== undefined ) {\n\n\t\t\t\t\ttexture.anisotropy = anisotropy;\n\n\t\t\t\t}\n\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\n\n\t\t\t\ttextures[ uuid ] = texture;\n\n\t\t\t\treturn uuid;\n\n\t\t\t}\n\n\t\t\tfunction parseModel( json, geometry ) {\n\n\t\t\t\tfunction isBitSet( value, position ) {\n\n\t\t\t\t\treturn value & ( 1 << position );\n\n\t\t\t\t}\n\n\t\t\t\tvar i, j, fi,\n\n\t\t\t\t\toffset, zLength,\n\n\t\t\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\n\n\t\t\t\t\ttype,\n\t\t\t\t\tisQuad,\n\t\t\t\t\thasMaterial,\n\t\t\t\t\thasFaceVertexUv,\n\t\t\t\t\thasFaceNormal, hasFaceVertexNormal,\n\t\t\t\t\thasFaceColor, hasFaceVertexColor,\n\n\t\t\t\t\tvertex, face, faceA, faceB, hex, normal,\n\n\t\t\t\t\tuvLayer, uv, u, v,\n\n\t\t\t\t\tfaces = json.faces,\n\t\t\t\t\tvertices = json.vertices,\n\t\t\t\t\tnormals = json.normals,\n\t\t\t\t\tcolors = json.colors,\n\n\t\t\t\t\tscale = json.scale,\n\n\t\t\t\t\tnUvLayers = 0;\n\n\n\t\t\t\tif ( json.uvs !== undefined ) {\n\n\t\t\t\t\t// disregard empty arrays\n\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\n\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = vertices.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\tvertex = new THREE.Vector3();\n\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\n\n\t\t\t\t\tgeometry.vertices.push( vertex );\n\n\t\t\t\t}\n\n\t\t\t\toffset = 0;\n\t\t\t\tzLength = faces.length;\n\n\t\t\t\twhile ( offset < zLength ) {\n\n\t\t\t\t\ttype = faces[ offset ++ ];\n\n\t\t\t\t\tisQuad = isBitSet( type, 0 );\n\t\t\t\t\thasMaterial = isBitSet( type, 1 );\n\t\t\t\t\thasFaceVertexUv = isBitSet( type, 3 );\n\t\t\t\t\thasFaceNormal = isBitSet( type, 4 );\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\n\t\t\t\t\thasFaceColor = isBitSet( type, 6 );\n\t\t\t\t\thasFaceVertexColor = isBitSet( type, 7 );\n\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\n\n\t\t\t\t\tif ( isQuad ) {\n\n\t\t\t\t\t\tfaceA = new THREE.Face3();\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\tfaceB = new THREE.Face3();\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\n\n\t\t\t\t\t\toffset += 4;\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tfaceA.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\n\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( faceA );\n\t\t\t\t\t\tgeometry.faces.push( faceB );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tface = new THREE.Face3();\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\n\n\t\t\t\t\t\tif ( hasMaterial ) {\n\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// to get face <=> uv index correspondence\n\n\t\t\t\t\t\tfi = geometry.faces.length;\n\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\n\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\n\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\n\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\n\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\n\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\n\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\n\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceNormal ) {\n\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\tface.normal.set(\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\n\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceColor ) {\n\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\n\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\n\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgeometry.faces.push( face );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseSkin( json, geometry ) {\n\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\n\n\t\t\t\tif ( json.skinWeights ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar x = json.skinWeights[ i ];\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.skinIndices ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\n\n\t\t\t\t\t\tvar a = json.skinIndices[ i ];\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\n\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.bones = json.bones;\n\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\n\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseMorphing( json, geometry ) {\n\n\t\t\t\tvar scale = json.scale;\n\n\t\t\t\tif ( json.morphTargets !== undefined ) {\n\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\n\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\n\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\n\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\n\n\t\t\t\t\t\t\tdstVertices.push( vertex );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\n\n\t\t\t\t\tvar faces = geometry.faces;\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\n\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction parseAnimations( json, geometry ) {\n\n\t\t\t\tvar outputAnimations = [];\n\n\t\t\t\t// parse old style Bone/Hierarchy animations\n\t\t\t\tvar animations = [];\n\n\t\t\t\tif ( json.animation !== undefined ) {\n\n\t\t\t\t\tanimations.push( json.animation );\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.animations !== undefined ) {\n\n\t\t\t\t\tif ( json.animations.length ) {\n\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tanimations.push( json.animations );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\n\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\n\n\t\t\t\t}\n\n\t\t\t\t// parse implicit morph animations\n\t\t\t\tif ( geometry.morphTargets ) {\n\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\n\n\t\t\t\t}\n\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\n\n\t\t\t}\n\n\t\t\treturn function parse( json, path ) {\n\n\t\t\t\tif ( json.data !== undefined ) {\n\n\t\t\t\t\t// Geometry 4.0 spec\n\t\t\t\t\tjson = json.data;\n\n\t\t\t\t}\n\n\t\t\t\tif ( json.scale !== undefined ) {\n\n\t\t\t\t\tjson.scale = 1.0 / json.scale;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tjson.scale = 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tvar geometry = new THREE.Geometry();\n\n\t\t\t\tparseModel( json, geometry );\n\t\t\t\tparseSkin( json, geometry );\n\t\t\t\tparseMorphing( json, geometry );\n\t\t\t\tparseAnimations( json, geometry );\n\n\t\t\t\tgeometry.computeFaceNormals();\n\t\t\t\tgeometry.computeBoundingSphere();\n\n\t\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\n\n\t\t\t\t\treturn { geometry: geometry };\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar materials = initMaterials( json.materials, this.resourcePath || path, this.crossOrigin, this.manager );\n\n\t\t\t\t\treturn { geometry: geometry, materials: materials };\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t} )()\n\n\t} );\n\n\treturn LegacyJSONLoader;\n\n} )();\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/loaders/deprecated/LegacyJSONLoader.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/EffectComposer.js":
/*!**********************************************************!*\
  !*** ./js/vendor/three/postprocessing/EffectComposer.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.EffectComposer = function ( renderer, renderTarget ) {\n\n\tthis.renderer = renderer;\n\n\tif ( renderTarget === undefined ) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getSize( new THREE.Vector2() );\n\t\tthis._pixelRatio = renderer.getPixelRatio();\n\t\tthis._width = size.width;\n\t\tthis._height = size.height;\n\n\t\trenderTarget = new THREE.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\n\t} else {\n\n\t\tthis._pixelRatio = 1;\n\t\tthis._width = renderTarget.width;\n\t\tthis._height = renderTarget.height;\n\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.renderToScreen = true;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif ( THREE.CopyShader === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on THREE.CopyShader' );\n\n\t}\n\n\tif ( THREE.ShaderPass === undefined ) {\n\n\t\tconsole.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );\n\n\t}\n\n\tthis.copyPass = new THREE.ShaderPass( THREE.CopyShader );\n\n\tthis.clock = new THREE.Clock();\n\n};\n\nObject.assign( THREE.EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\n\t},\n\n\taddPass: function ( pass ) {\n\n\t\tthis.passes.push( pass );\n\t\tpass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t},\n\n\tinsertPass: function ( pass, index ) {\n\n\t\tthis.passes.splice( index, 0, pass );\n\n\t},\n\n\tisLastEnabledPass: function ( passIndex ) {\n\n\t\tfor ( var i = passIndex + 1; i < this.passes.length; i ++ ) {\n\n\t\t\tif ( this.passes[ i ].enabled ) {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn true;\n\n\t},\n\n\trender: function ( deltaTime ) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif ( deltaTime === undefined ) {\n\n\t\t\tdeltaTime = this.clock.getDelta();\n\n\t\t}\n\n\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tvar maskActive = false;\n\n\t\tvar pass, i, il = this.passes.length;\n\n\t\tfor ( i = 0; i < il; i ++ ) {\n\n\t\t\tpass = this.passes[ i ];\n\n\t\t\tif ( pass.enabled === false ) continue;\n\n\t\t\tpass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );\n\t\t\tpass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );\n\n\t\t\tif ( pass.needsSwap ) {\n\n\t\t\t\tif ( maskActive ) {\n\n\t\t\t\t\tvar context = this.renderer.getContext();\n\t\t\t\t\tvar stencil = this.renderer.state.buffers.stencil;\n\n\t\t\t\t\t//context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );\n\n\t\t\t\t\tthis.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime );\n\n\t\t\t\t\t//context.stencilFunc( context.EQUAL, 1, 0xffffffff );\n\t\t\t\t\tstencil.setFunc( context.EQUAL, 1, 0xffffffff );\n\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\n\t\t\t}\n\n\t\t\tif ( THREE.MaskPass !== undefined ) {\n\n\t\t\t\tif ( pass instanceof THREE.MaskPass ) {\n\n\t\t\t\t\tmaskActive = true;\n\n\t\t\t\t} else if ( pass instanceof THREE.ClearMaskPass ) {\n\n\t\t\t\t\tmaskActive = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderer.setRenderTarget( currentRenderTarget );\n\n\t},\n\n\treset: function ( renderTarget ) {\n\n\t\tif ( renderTarget === undefined ) {\n\n\t\t\tvar size = this.renderer.getSize( new THREE.Vector2() );\n\t\t\tthis._pixelRatio = this.renderer.getPixelRatio();\n\t\t\tthis._width = size.width;\n\t\t\tthis._height = size.height;\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );\n\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis._width = width;\n\t\tthis._height = height;\n\n\t\tvar effectiveWidth = this._width * this._pixelRatio;\n\t\tvar effectiveHeight = this._height * this._pixelRatio;\n\n\t\tthis.renderTarget1.setSize( effectiveWidth, effectiveHeight );\n\t\tthis.renderTarget2.setSize( effectiveWidth, effectiveHeight );\n\n\t\tfor ( var i = 0; i < this.passes.length; i ++ ) {\n\n\t\t\tthis.passes[ i ].setSize( effectiveWidth, effectiveHeight );\n\n\t\t}\n\n\t},\n\n\tsetPixelRatio: function ( pixelRatio ) {\n\n\t\tthis._pixelRatio = pixelRatio;\n\n\t\tthis.setSize( this._width, this._height );\n\n\t}\n\n} );\n\n\nTHREE.Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n\n};\n\nObject.assign( THREE.Pass.prototype, {\n\n\tsetSize: function ( /* width, height */ ) {},\n\n\trender: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n} );\n\n// Helper for passes that need to fill the viewport with a single quad.\nTHREE.Pass.FullScreenQuad = ( function () {\n\n\tvar camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\tvar geometry = new THREE.PlaneBufferGeometry( 2, 2 );\n\n\tvar FullScreenQuad = function ( material ) {\n\n\t\tthis._mesh = new THREE.Mesh( geometry, material );\n\n\t};\n\n\tObject.defineProperty( FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\n\t\t},\n\n\t\tset: function ( value ) {\n\n\t\t\tthis._mesh.material = value;\n\n\t\t}\n\n\t} );\n\n\tObject.assign( FullScreenQuad.prototype, {\n\n\t\trender: function ( renderer ) {\n\n\t\t\trenderer.render( this._mesh, camera );\n\n\t\t}\n\n\t} );\n\n\treturn FullScreenQuad;\n\n} )();\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/EffectComposer.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/MaskPass.js":
/*!****************************************************!*\
  !*** ./js/vendor/three/postprocessing/MaskPass.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.MaskPass = function ( scene, camera ) {\n\n\tTHREE.Pass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.inverse = false;\n\n};\n\nTHREE.MaskPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\tconstructor: THREE.MaskPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar context = renderer.getContext();\n\t\tvar state = renderer.state;\n\n\t\t// don't update color or depth\n\n\t\tstate.buffers.color.setMask( false );\n\t\tstate.buffers.depth.setMask( false );\n\n\t\t// lock buffers\n\n\t\tstate.buffers.color.setLocked( true );\n\t\tstate.buffers.depth.setLocked( true );\n\n\t\t// set up stencil\n\n\t\tvar writeValue, clearValue;\n\n\t\tif ( this.inverse ) {\n\n\t\t\twriteValue = 0;\n\t\t\tclearValue = 1;\n\n\t\t} else {\n\n\t\t\twriteValue = 1;\n\t\t\tclearValue = 0;\n\n\t\t}\n\n\t\tstate.buffers.stencil.setTest( true );\n\t\tstate.buffers.stencil.setOp( context.REPLACE, context.REPLACE, context.REPLACE );\n\t\tstate.buffers.stencil.setFunc( context.ALWAYS, writeValue, 0xffffffff );\n\t\tstate.buffers.stencil.setClear( clearValue );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t\t// draw into the stencil buffer\n\n\t\trenderer.setRenderTarget( readBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\trenderer.setRenderTarget( writeBuffer );\n\t\tif ( this.clear ) renderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// unlock color and depth buffer for subsequent rendering\n\n\t\tstate.buffers.color.setLocked( false );\n\t\tstate.buffers.depth.setLocked( false );\n\n\t\t// only render where stencil is set to 1\n\n\t\tstate.buffers.stencil.setLocked( false );\n\t\tstate.buffers.stencil.setFunc( context.EQUAL, 1, 0xffffffff ); // draw if == 1\n\t\tstate.buffers.stencil.setOp( context.KEEP, context.KEEP, context.KEEP );\n\t\tstate.buffers.stencil.setLocked( true );\n\n\t}\n\n} );\n\n\nTHREE.ClearMaskPass = function () {\n\n\tTHREE.Pass.call( this );\n\n\tthis.needsSwap = false;\n\n};\n\nTHREE.ClearMaskPass.prototype = Object.create( THREE.Pass.prototype );\n\nObject.assign( THREE.ClearMaskPass.prototype, {\n\n\trender: function ( renderer /*, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\trenderer.state.buffers.stencil.setLocked( false );\n\t\trenderer.state.buffers.stencil.setTest( false );\n\n\t}\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/MaskPass.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/OutlinePass.js":
/*!*******************************************************!*\
  !*** ./js/vendor/three/postprocessing/OutlinePass.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author spidersharma / http://eduperiment.com/\n */\n\nTHREE.OutlinePass = function ( resolution, scene, camera, selectedObjects ) {\n\n\tthis.renderScene = scene;\n\tthis.renderCamera = camera;\n\tthis.selectedObjects = selectedObjects !== undefined ? selectedObjects : [];\n\tthis.visibleEdgeColor = new THREE.Color( 1, 1, 1 );\n\tthis.hiddenEdgeColor = new THREE.Color( 0.1, 0.04, 0.02 );\n\tthis.edgeGlow = 0.0;\n\tthis.usePatternTexture = false;\n\tthis.edgeThickness = 1.0;\n\tthis.edgeStrength = 3.0;\n\tthis.downSampleRatio = 2;\n\tthis.pulsePeriod = 0;\n\n\tTHREE.Pass.call( this );\n\n\tthis.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );\n\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\n\tvar resx = Math.round( this.resolution.x / this.downSampleRatio );\n\tvar resy = Math.round( this.resolution.y / this.downSampleRatio );\n\n\tthis.maskBufferMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff } );\n\tthis.maskBufferMaterial.side = THREE.DoubleSide;\n\tthis.renderTargetMaskBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\tthis.renderTargetMaskBuffer.texture.name = \"OutlinePass.mask\";\n\tthis.renderTargetMaskBuffer.texture.generateMipmaps = false;\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.side = THREE.DoubleSide;\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.prepareMaskMaterial = this.getPrepareMaskMaterial();\n\tthis.prepareMaskMaterial.side = THREE.DoubleSide;\n\tthis.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ( this.prepareMaskMaterial.fragmentShader, this.renderCamera );\n\n\tthis.renderTargetDepthBuffer = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, pars );\n\tthis.renderTargetDepthBuffer.texture.name = \"OutlinePass.depth\";\n\tthis.renderTargetDepthBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetMaskDownSampleBuffer = new THREE.WebGLRenderTarget( resx, resy, pars );\n\tthis.renderTargetMaskDownSampleBuffer.texture.name = \"OutlinePass.depthDownSample\";\n\tthis.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;\n\n\tthis.renderTargetBlurBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );\n\tthis.renderTargetBlurBuffer1.texture.name = \"OutlinePass.blur1\";\n\tthis.renderTargetBlurBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetBlurBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\tthis.renderTargetBlurBuffer2.texture.name = \"OutlinePass.blur2\";\n\tthis.renderTargetBlurBuffer2.texture.generateMipmaps = false;\n\n\tthis.edgeDetectionMaterial = this.getEdgeDetectionMaterial();\n\tthis.renderTargetEdgeBuffer1 = new THREE.WebGLRenderTarget( resx, resy, pars );\n\tthis.renderTargetEdgeBuffer1.texture.name = \"OutlinePass.edge1\";\n\tthis.renderTargetEdgeBuffer1.texture.generateMipmaps = false;\n\tthis.renderTargetEdgeBuffer2 = new THREE.WebGLRenderTarget( Math.round( resx / 2 ), Math.round( resy / 2 ), pars );\n\tthis.renderTargetEdgeBuffer2.texture.name = \"OutlinePass.edge2\";\n\tthis.renderTargetEdgeBuffer2.texture.generateMipmaps = false;\n\n\tvar MAX_EDGE_THICKNESS = 4;\n\tvar MAX_EDGE_GLOW = 4;\n\n\tthis.separableBlurMaterial1 = this.getSeperableBlurMaterial( MAX_EDGE_THICKNESS );\n\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value = new THREE.Vector2( resx, resy );\n\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = 1;\n\tthis.separableBlurMaterial2 = this.getSeperableBlurMaterial( MAX_EDGE_GLOW );\n\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value = new THREE.Vector2( Math.round( resx / 2 ), Math.round( resy / 2 ) );\n\tthis.separableBlurMaterial2.uniforms[ \"kernelRadius\" ].value = MAX_EDGE_GLOW;\n\n\t// Overlay material\n\tthis.overlayMaterial = this.getOverlayMaterial();\n\n\t// copy material\n\tif ( THREE.CopyShader === undefined )\n\t\tconsole.error( \"THREE.OutlinePass relies on THREE.CopyShader\" );\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\n\tthis.copyUniforms[ \"opacity\" ].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial( {\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.NoBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t} );\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.fsQuad = new THREE.Pass.FullScreenQuad( null );\n\n\tthis.tempPulseColor1 = new THREE.Color();\n\tthis.tempPulseColor2 = new THREE.Color();\n\tthis.textureMatrix = new THREE.Matrix4();\n\n\tfunction replaceDepthToViewZ( string, camera ) {\n\n\t\tvar type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';\n\n\t\treturn string.replace( /DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ' );\n\n\t}\n\n};\n\nTHREE.OutlinePass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\tconstructor: THREE.OutlinePass,\n\n\tdispose: function () {\n\n\t\tthis.renderTargetMaskBuffer.dispose();\n\t\tthis.renderTargetDepthBuffer.dispose();\n\t\tthis.renderTargetMaskDownSampleBuffer.dispose();\n\t\tthis.renderTargetBlurBuffer1.dispose();\n\t\tthis.renderTargetBlurBuffer2.dispose();\n\t\tthis.renderTargetEdgeBuffer1.dispose();\n\t\tthis.renderTargetEdgeBuffer2.dispose();\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis.renderTargetMaskBuffer.setSize( width, height );\n\n\t\tvar resx = Math.round( width / this.downSampleRatio );\n\t\tvar resy = Math.round( height / this.downSampleRatio );\n\t\tthis.renderTargetMaskDownSampleBuffer.setSize( resx, resy );\n\t\tthis.renderTargetBlurBuffer1.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer1.setSize( resx, resy );\n\t\tthis.separableBlurMaterial1.uniforms[ \"texSize\" ].value = new THREE.Vector2( resx, resy );\n\n\t\tresx = Math.round( resx / 2 );\n\t\tresy = Math.round( resy / 2 );\n\n\t\tthis.renderTargetBlurBuffer2.setSize( resx, resy );\n\t\tthis.renderTargetEdgeBuffer2.setSize( resx, resy );\n\n\t\tthis.separableBlurMaterial2.uniforms[ \"texSize\" ].value = new THREE.Vector2( resx, resy );\n\n\t},\n\n\tchangeVisibilityOfSelectedObjects: function ( bVisible ) {\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) {\n\n\t\t\t\tif ( bVisible ) {\n\n\t\t\t\t\tobject.visible = object.userData.oldVisible;\n\t\t\t\t\tdelete object.userData.oldVisible;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tobject.userData.oldVisible = object.visible;\n\t\t\t\t\tobject.visible = bVisible;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tvar selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t},\n\n\tchangeVisibilityOfNonSelectedObjects: function ( bVisible ) {\n\n\t\tvar selectedMeshes = [];\n\n\t\tfunction gatherSelectedMeshesCallBack( object ) {\n\n\t\t\tif ( object.isMesh ) selectedMeshes.push( object );\n\n\t\t}\n\n\t\tfor ( var i = 0; i < this.selectedObjects.length; i ++ ) {\n\n\t\t\tvar selectedObject = this.selectedObjects[ i ];\n\t\t\tselectedObject.traverse( gatherSelectedMeshesCallBack );\n\n\t\t}\n\n\t\tfunction VisibilityChangeCallBack( object ) {\n\n\t\t\tif ( object.isMesh || object.isLine || object.isSprite ) {\n\n\t\t\t\tvar bFound = false;\n\n\t\t\t\tfor ( var i = 0; i < selectedMeshes.length; i ++ ) {\n\n\t\t\t\t\tvar selectedObjectId = selectedMeshes[ i ].id;\n\n\t\t\t\t\tif ( selectedObjectId === object.id ) {\n\n\t\t\t\t\t\tbFound = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! bFound ) {\n\n\t\t\t\t\tvar visibility = object.visible;\n\n\t\t\t\t\tif ( ! bVisible || object.bVisible ) object.visible = bVisible;\n\n\t\t\t\t\tobject.bVisible = visibility;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.renderScene.traverse( VisibilityChangeCallBack );\n\n\t},\n\n\tupdateTextureMatrix: function () {\n\n\t\tthis.textureMatrix.set( 0.5, 0.0, 0.0, 0.5,\n\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t0.0, 0.0, 0.0, 1.0 );\n\t\tthis.textureMatrix.multiply( this.renderCamera.projectionMatrix );\n\t\tthis.textureMatrix.multiply( this.renderCamera.matrixWorldInverse );\n\n\t},\n\n\trender: function ( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\tif ( this.selectedObjects.length > 0 ) {\n\n\t\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\t\tvar oldAutoClear = renderer.autoClear;\n\n\t\t\trenderer.autoClear = false;\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t\trenderer.setClearColor( 0xffffff, 1 );\n\n\t\t\t// Make selected objects invisible\n\t\t\tthis.changeVisibilityOfSelectedObjects( false );\n\n\t\t\tvar currentBackground = this.renderScene.background;\n\t\t\tthis.renderScene.background = null;\n\n\t\t\t// AXC: Save oldOverrideMaterial so it can be restored\n\t\t\tvar oldOverrideMaterial = this.renderScene.overrideMaterial;\n\n\t\t\t// 1. Draw Non Selected objects in the depth buffer\n\t\t\tthis.renderScene.overrideMaterial = this.depthMaterial;\n\t\t\trenderer.setRenderTarget( this.renderTargetDepthBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\n\t\t\t// Make selected objects visible\n\t\t\tthis.changeVisibilityOfSelectedObjects( true );\n\n\t\t\t// Update Texture Matrix for Depth compare\n\t\t\tthis.updateTextureMatrix();\n\n\t\t\t// Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( false );\n\t\t\tthis.renderScene.overrideMaterial = this.prepareMaskMaterial;\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"cameraNearFar\" ].value = new THREE.Vector2( this.renderCamera.near, this.renderCamera.far );\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"depthTexture\" ].value = this.renderTargetDepthBuffer.texture;\n\t\t\tthis.prepareMaskMaterial.uniforms[ \"textureMatrix\" ].value = this.textureMatrix;\n\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskBuffer );\n\t\t\trenderer.clear();\n\t\t\trenderer.render( this.renderScene, this.renderCamera );\n\t\t\t// AXC: Restore oldOverrideMaterial\n\t\t\tthis.renderScene.overrideMaterial = oldOverrideMaterial;\n\t\t\tthis.changeVisibilityOfNonSelectedObjects( true );\n\n\t\t\tthis.renderScene.background = currentBackground;\n\n\t\t\t// 2. Downsample to Half resolution\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetMaskBuffer.texture;\n\t\t\trenderer.setRenderTarget( this.renderTargetMaskDownSampleBuffer );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.tempPulseColor1.copy( this.visibleEdgeColor );\n\t\t\tthis.tempPulseColor2.copy( this.hiddenEdgeColor );\n\n\t\t\tif ( this.pulsePeriod > 0 ) {\n\n\t\t\t\tvar scalar = ( 1 + 0.25 ) / 2 + Math.cos( performance.now() * 0.01 / this.pulsePeriod ) * ( 1.0 - 0.25 ) / 2;\n\t\t\t\tthis.tempPulseColor1.multiplyScalar( scalar );\n\t\t\t\tthis.tempPulseColor2.multiplyScalar( scalar );\n\n\t\t\t}\n\n\t\t\t// 3. Apply Edge Detection Pass\n\t\t\tthis.fsQuad.material = this.edgeDetectionMaterial;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskDownSampleBuffer.texture;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"texSize\" ].value = new THREE.Vector2( this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height );\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"visibleEdgeColor\" ].value = this.tempPulseColor1;\n\t\t\tthis.edgeDetectionMaterial.uniforms[ \"hiddenEdgeColor\" ].value = this.tempPulseColor2;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// 4. Apply Blur on Half res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial1;\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"kernelRadius\" ].value = this.edgeThickness;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer1.texture;\n\t\t\tthis.separableBlurMaterial1.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer1 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Apply Blur on quarter res\n\t\t\tthis.fsQuad.material = this.separableBlurMaterial2;\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetBlurBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"colorTexture\" ].value = this.renderTargetBlurBuffer2.texture;\n\t\t\tthis.separableBlurMaterial2.uniforms[ \"direction\" ].value = THREE.OutlinePass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetEdgeBuffer2 );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\t// Blend it additively over the input texture\n\t\t\tthis.fsQuad.material = this.overlayMaterial;\n\t\t\tthis.overlayMaterial.uniforms[ \"maskTexture\" ].value = this.renderTargetMaskBuffer.texture;\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture1\" ].value = this.renderTargetEdgeBuffer1.texture;\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeTexture2\" ].value = this.renderTargetEdgeBuffer2.texture;\n\t\t\tthis.overlayMaterial.uniforms[ \"patternTexture\" ].value = this.patternTexture;\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeStrength\" ].value = this.edgeStrength;\n\t\t\tthis.overlayMaterial.uniforms[ \"edgeGlow\" ].value = this.edgeGlow;\n\t\t\tthis.overlayMaterial.uniforms[ \"usePatternTexture\" ].value = this.usePatternTexture;\n\n\n\t\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\t\trenderer.autoClear = oldAutoClear;\n\n\t\t}\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.materialCopy;\n\t\t\tthis.copyUniforms[ \"tDiffuse\" ].value = readBuffer.texture;\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t},\n\n\tgetPrepareMaskMaterial: function () {\n\n\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t\"depthTexture\": { value: null },\n\t\t\t\t\"cameraNearFar\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"textureMatrix\": { value: new THREE.Matrix4() }\n\t\t\t},\n\n\t\t\tvertexShader: [\n\t\t\t\t'varying vec4 projTexCoord;',\n\t\t\t\t'varying vec4 vPosition;',\n\t\t\t\t'uniform mat4 textureMatrix;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tvPosition = modelViewMatrix * vec4( position, 1.0 );',\n\t\t\t\t'\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );',\n\t\t\t\t'\tprojTexCoord = textureMatrix * worldPosition;',\n\t\t\t\t'\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',\n\n\t\t\t\t'}'\n\t\t\t].join( '\\n' ),\n\n\t\t\tfragmentShader: [\n\t\t\t\t'#include <packing>',\n\t\t\t\t'varying vec4 vPosition;',\n\t\t\t\t'varying vec4 projTexCoord;',\n\t\t\t\t'uniform sampler2D depthTexture;',\n\t\t\t\t'uniform vec2 cameraNearFar;',\n\n\t\t\t\t'void main() {',\n\n\t\t\t\t'\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));',\n\t\t\t\t'\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );',\n\t\t\t\t'\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;',\n\t\t\t\t'\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);',\n\n\t\t\t\t'}'\n\t\t\t].join( '\\n' )\n\n\t\t} );\n\n\t},\n\n\tgetEdgeDetectionMaterial: function () {\n\n\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"visibleEdgeColor\": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t\t\"hiddenEdgeColor\": { value: new THREE.Vector3( 1.0, 1.0, 1.0 ) },\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec3 visibleEdgeColor;\\\n\t\t\t\tuniform vec3 hiddenEdgeColor;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\\\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\\\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\\\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\\\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\\\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\\\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\\\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\\\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\\\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\\\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\\\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\\\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\\\n\t\t\t\t}\"\n\t\t} );\n\n\t},\n\n\tgetSeperableBlurMaterial: function ( maxRadius ) {\n\n\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t\"MAX_RADIUS\": maxRadius,\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2( 0.5, 0.5 ) },\n\t\t\t\t\"kernelRadius\": { value: 1.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"#include <common>\\\n\t\t\t\tvarying vec2 vUv;\\\n\t\t\t\tuniform sampler2D colorTexture;\\\n\t\t\t\tuniform vec2 texSize;\\\n\t\t\t\tuniform vec2 direction;\\\n\t\t\t\tuniform float kernelRadius;\\\n\t\t\t\t\\\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\n\t\t\t\t}\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, kernelRadius);\\\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\\\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\\\n\t\t\t\t\tvec2 uvOffset = delta;\\\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\\\n\t\t\t\t\t\tfloat w = gaussianPdf(uvOffset.x, kernelRadius);\\\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\\\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\\\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\\\n\t\t\t\t\t\tweightSum += (2.0 * w);\\\n\t\t\t\t\t\tuvOffset += delta;\\\n\t\t\t\t\t}\\\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\\\n\t\t\t\t}\"\n\t\t} );\n\n\t},\n\n\tgetOverlayMaterial: function () {\n\n\t\treturn new THREE.ShaderMaterial( {\n\n\t\t\tuniforms: {\n\t\t\t\t\"maskTexture\": { value: null },\n\t\t\t\t\"edgeTexture1\": { value: null },\n\t\t\t\t\"edgeTexture2\": { value: null },\n\t\t\t\t\"patternTexture\": { value: null },\n\t\t\t\t\"edgeStrength\": { value: 1.0 },\n\t\t\t\t\"edgeGlow\": { value: 1.0 },\n\t\t\t\t\"usePatternTexture\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t\"varying vec2 vUv;\\n\\\n\t\t\t\tvoid main() {\\n\\\n\t\t\t\t\tvUv = uv;\\n\\\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\n\t\t\t\t}\",\n\n\t\t\tfragmentShader:\n\t\t\t\t\"varying vec2 vUv;\\\n\t\t\t\tuniform sampler2D maskTexture;\\\n\t\t\t\tuniform sampler2D edgeTexture1;\\\n\t\t\t\tuniform sampler2D edgeTexture2;\\\n\t\t\t\tuniform sampler2D patternTexture;\\\n\t\t\t\tuniform float edgeStrength;\\\n\t\t\t\tuniform float edgeGlow;\\\n\t\t\t\tuniform bool usePatternTexture;\\\n\t\t\t\t\\\n\t\t\t\tvoid main() {\\\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\\\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\\\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\\\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\\\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\\\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\\\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\\\n\t\t\t\t\tif(usePatternTexture)\\\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\\\n\t\t\t\t\tgl_FragColor = finalColor;\\\n\t\t\t\t}\",\n\t\t\tblending: THREE.AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t}\n\n} );\n\nTHREE.OutlinePass.BlurDirectionX = new THREE.Vector2( 1.0, 0.0 );\nTHREE.OutlinePass.BlurDirectionY = new THREE.Vector2( 0.0, 1.0 );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/OutlinePass.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/RenderPass.js":
/*!******************************************************!*\
  !*** ./js/vendor/three/postprocessing/RenderPass.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {\n\n\tTHREE.Pass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.overrideMaterial = overrideMaterial;\n\n\tthis.clearColor = clearColor;\n\tthis.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;\n\n\tthis.clear = true;\n\tthis.clearDepth = false;\n\tthis.needsSwap = false;\n\n};\n\nTHREE.RenderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\tconstructor: THREE.RenderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\t// AXC: Save oldOverrideMaterial so it can be restored\n\t\t// AXC: also keep with scene overrideMaterial if our own overrideMaterial not specified\n\t\tvar oldOverrideMaterial = this.scene.overrideMaterial;\n\t\tthis.scene.overrideMaterial = (this.overrideMaterial !== undefined)? this.overrideMaterial : oldOverrideMaterial;\n\n\t\tvar oldClearColor, oldClearAlpha;\n\n\t\tif ( this.clearColor ) {\n\n\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\trenderer.setClearColor( this.clearColor, this.clearAlpha );\n\n\t\t}\n\n\t\tif ( this.clearDepth ) {\n\n\t\t\trenderer.clearDepth();\n\n\t\t}\n\n\t\trenderer.setRenderTarget( this.renderToScreen ? null : readBuffer );\n\n\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\trenderer.render( this.scene, this.camera );\n\n\t\tif ( this.clearColor ) {\n\n\t\t\trenderer.setClearColor( oldClearColor, oldClearAlpha );\n\n\t\t}\n\n\t\t// AXC: Restore oldOverrideMaterial\n\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/RenderPass.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/SAOPass.js":
/*!***************************************************!*\
  !*** ./js/vendor/three/postprocessing/SAOPass.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author ludobaka / ludobaka.github.io\n * SAO implementation inspired from bhouston previous SAO work\n */\n\nTHREE.SAOPass = function ( scene, camera, depthTexture, useNormals, resolution ) {\n\n\tTHREE.Pass.call( this );\n\n\tthis.scene = scene;\n\tthis.camera = camera;\n\n\tthis.clear = true;\n\tthis.needsSwap = false;\n\n\tthis.supportsDepthTextureExtension = ( depthTexture !== undefined ) ? depthTexture : false;\n\tthis.supportsNormalTexture = ( useNormals !== undefined ) ? useNormals : false;\n\n\tthis.originalClearColor = new THREE.Color();\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.params = {\n\t\toutput: 0,\n\t\tsaoBias: 0.5,\n\t\tsaoIntensity: 0.18,\n\t\tsaoScale: 1,\n\t\tsaoKernelRadius: 100,\n\t\tsaoMinResolution: 0,\n\t\tsaoBlur: true,\n\t\tsaoBlurRadius: 8,\n\t\tsaoBlurStdDev: 4,\n\t\tsaoBlurDepthCutoff: 0.01\n\t};\n\n\tthis.resolution = ( resolution !== undefined ) ? new THREE.Vector2( resolution.x, resolution.y ) : new THREE.Vector2( 256, 256 );\n\n\tthis.saoRenderTarget = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.LinearFilter,\n\t\tmagFilter: THREE.LinearFilter,\n\t\tformat: THREE.RGBAFormat\n\t} );\n\tthis.blurIntermediateRenderTarget = this.saoRenderTarget.clone();\n\tthis.beautyRenderTarget = this.saoRenderTarget.clone();\n\n\tthis.normalRenderTarget = new THREE.WebGLRenderTarget( this.resolution.x, this.resolution.y, {\n\t\tminFilter: THREE.NearestFilter,\n\t\tmagFilter: THREE.NearestFilter,\n\t\tformat: THREE.RGBAFormat\n\t} );\n\tthis.depthRenderTarget = this.normalRenderTarget.clone();\n\n\tif ( this.supportsDepthTextureExtension ) {\n\n\t\tvar depthTexture = new THREE.DepthTexture();\n\t\tdepthTexture.type = THREE.UnsignedShortType;\n\t\tdepthTexture.minFilter = THREE.NearestFilter;\n\t\tdepthTexture.maxFilter = THREE.NearestFilter;\n\n\t\tthis.beautyRenderTarget.depthTexture = depthTexture;\n\t\tthis.beautyRenderTarget.depthBuffer = true;\n\n\t}\n\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\tthis.normalMaterial = new THREE.MeshNormalMaterial();\n\tthis.normalMaterial.blending = THREE.NoBlending;\n\n\tif ( THREE.SAOShader === undefined ) {\n\n\t\tconsole.error( 'THREE.SAOPass relies on THREE.SAOShader' );\n\n\t}\n\n\tthis.saoMaterial = new THREE.ShaderMaterial( {\n\t\tdefines: Object.assign( {}, THREE.SAOShader.defines ),\n\t\tfragmentShader: THREE.SAOShader.fragmentShader,\n\t\tvertexShader: THREE.SAOShader.vertexShader,\n\t\tuniforms: THREE.UniformsUtils.clone( THREE.SAOShader.uniforms )\n\t} );\n\tthis.saoMaterial.extensions.derivatives = true;\n\tthis.saoMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.saoMaterial.defines[ 'NORMAL_TEXTURE' ] = this.supportsNormalTexture ? 1 : 0;\n\tthis.saoMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.saoMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\n\tthis.saoMaterial.uniforms[ 'tNormal' ].value = this.normalRenderTarget.texture;\n\tthis.saoMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\n\tthis.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );\n\tthis.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;\n\tthis.saoMaterial.blending = THREE.NoBlending;\n\n\tif ( THREE.DepthLimitedBlurShader === undefined ) {\n\n\t\tconsole.error( 'THREE.SAOPass relies on THREE.DepthLimitedBlurShader' );\n\n\t}\n\n\tthis.vBlurMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( THREE.DepthLimitedBlurShader.uniforms ),\n\t\tdefines: Object.assign( {}, THREE.DepthLimitedBlurShader.defines ),\n\t\tvertexShader: THREE.DepthLimitedBlurShader.vertexShader,\n\t\tfragmentShader: THREE.DepthLimitedBlurShader.fragmentShader\n\t} );\n\tthis.vBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.vBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.vBlurMaterial.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\n\tthis.vBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\n\tthis.vBlurMaterial.blending = THREE.NoBlending;\n\n\tthis.hBlurMaterial = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( THREE.DepthLimitedBlurShader.uniforms ),\n\t\tdefines: Object.assign( {}, THREE.DepthLimitedBlurShader.defines ),\n\t\tvertexShader: THREE.DepthLimitedBlurShader.vertexShader,\n\t\tfragmentShader: THREE.DepthLimitedBlurShader.fragmentShader\n\t} );\n\tthis.hBlurMaterial.defines[ 'DEPTH_PACKING' ] = this.supportsDepthTextureExtension ? 0 : 1;\n\tthis.hBlurMaterial.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera.isPerspectiveCamera ? 1 : 0;\n\tthis.hBlurMaterial.uniforms[ 'tDiffuse' ].value = this.blurIntermediateRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms[ 'tDepth' ].value = ( this.supportsDepthTextureExtension ) ? depthTexture : this.depthRenderTarget.texture;\n\tthis.hBlurMaterial.uniforms[ 'size' ].value.set( this.resolution.x, this.resolution.y );\n\tthis.hBlurMaterial.blending = THREE.NoBlending;\n\n\tif ( THREE.CopyShader === undefined ) {\n\n\t\tconsole.error( 'THREE.SAOPass relies on THREE.CopyShader' );\n\n\t}\n\n\tthis.materialCopy = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( THREE.CopyShader.uniforms ),\n\t\tvertexShader: THREE.CopyShader.vertexShader,\n\t\tfragmentShader: THREE.CopyShader.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t} );\n\tthis.materialCopy.transparent = true;\n\tthis.materialCopy.depthTest = false;\n\tthis.materialCopy.depthWrite = false;\n\tthis.materialCopy.blending = THREE.CustomBlending;\n\tthis.materialCopy.blendSrc = THREE.DstColorFactor;\n\tthis.materialCopy.blendDst = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquation = THREE.AddEquation;\n\tthis.materialCopy.blendSrcAlpha = THREE.DstAlphaFactor;\n\tthis.materialCopy.blendDstAlpha = THREE.ZeroFactor;\n\tthis.materialCopy.blendEquationAlpha = THREE.AddEquation;\n\n\tif ( THREE.UnpackDepthRGBAShader === undefined ) {\n\n\t\tconsole.error( 'THREE.SAOPass relies on THREE.UnpackDepthRGBAShader' );\n\n\t}\n\n\tthis.depthCopy = new THREE.ShaderMaterial( {\n\t\tuniforms: THREE.UniformsUtils.clone( THREE.UnpackDepthRGBAShader.uniforms ),\n\t\tvertexShader: THREE.UnpackDepthRGBAShader.vertexShader,\n\t\tfragmentShader: THREE.UnpackDepthRGBAShader.fragmentShader,\n\t\tblending: THREE.NoBlending\n\t} );\n\n\tthis.fsQuad = new THREE.Pass.FullScreenQuad( null );\n\n};\n\nTHREE.SAOPass.OUTPUT = {\n\t'Beauty': 1,\n\t'Default': 0,\n\t'SAO': 2,\n\t'Depth': 3,\n\t'Normal': 4\n};\n\nTHREE.SAOPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\tconstructor: THREE.SAOPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer/*, deltaTime, maskActive*/ ) {\n\n\t\t// Rendering readBuffer first when rendering to screen\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.materialCopy.blending = THREE.NoBlending;\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\t\t\tthis.renderPass( renderer, this.materialCopy, null );\n\n\t\t}\n\n\t\tif ( this.params.output === 1 ) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.oldClearColor.copy( renderer.getClearColor() );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setRenderTarget( this.depthRenderTarget );\n\t\trenderer.clear();\n\n\t\tthis.saoMaterial.uniforms[ 'bias' ].value = this.params.saoBias;\n\t\tthis.saoMaterial.uniforms[ 'intensity' ].value = this.params.saoIntensity;\n\t\tthis.saoMaterial.uniforms[ 'scale' ].value = this.params.saoScale;\n\t\tthis.saoMaterial.uniforms[ 'kernelRadius' ].value = this.params.saoKernelRadius;\n\t\tthis.saoMaterial.uniforms[ 'minResolution' ].value = this.params.saoMinResolution;\n\t\tthis.saoMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\n\t\tthis.saoMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\n\t\t// this.saoMaterial.uniforms['randomSeed'].value = Math.random();\n\n\t\tvar depthCutoff = this.params.saoBlurDepthCutoff * ( this.camera.far - this.camera.near );\n\t\tthis.vBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;\n\t\tthis.hBlurMaterial.uniforms[ 'depthCutoff' ].value = depthCutoff;\n\n\t\tthis.vBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\n\t\tthis.vBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\n\t\tthis.hBlurMaterial.uniforms[ 'cameraNear' ].value = this.camera.near;\n\t\tthis.hBlurMaterial.uniforms[ 'cameraFar' ].value = this.camera.far;\n\n\t\tthis.params.saoBlurRadius = Math.floor( this.params.saoBlurRadius );\n\t\tif ( ( this.prevStdDev !== this.params.saoBlurStdDev ) || ( this.prevNumSamples !== this.params.saoBlurRadius ) ) {\n\n\t\t\tTHREE.BlurShaderUtils.configure( this.vBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2( 0, 1 ) );\n\t\t\tTHREE.BlurShaderUtils.configure( this.hBlurMaterial, this.params.saoBlurRadius, this.params.saoBlurStdDev, new THREE.Vector2( 1, 0 ) );\n\t\t\tthis.prevStdDev = this.params.saoBlurStdDev;\n\t\t\tthis.prevNumSamples = this.params.saoBlurRadius;\n\n\t\t}\n\n\t\t// Rendering scene to depth texture\n\t\trenderer.setClearColor( 0x000000 );\n\t\trenderer.setRenderTarget( this.beautyRenderTarget );\n\t\trenderer.clear();\n\t\trenderer.render( this.scene, this.camera );\n\n\t\t// Re-render scene if depth texture extension is not supported\n\t\tif ( ! this.supportsDepthTextureExtension ) {\n\n\t\t\t// Clear rule : far clipping plane in both RGBA and Basic encoding\n\t\t\tthis.renderOverride( renderer, this.depthMaterial, this.depthRenderTarget, 0x000000, 1.0 );\n\n\t\t}\n\n\t\tif ( this.supportsNormalTexture ) {\n\n\t\t\t// Clear rule : default normal is facing the camera\n\t\t\tthis.renderOverride( renderer, this.normalMaterial, this.normalRenderTarget, 0x7777ff, 1.0 );\n\n\t\t}\n\n\t\t// Rendering SAO texture\n\t\tthis.renderPass( renderer, this.saoMaterial, this.saoRenderTarget, 0xffffff, 1.0 );\n\n\t\t// Blurring SAO texture\n\t\tif ( this.params.saoBlur ) {\n\n\t\t\tthis.renderPass( renderer, this.vBlurMaterial, this.blurIntermediateRenderTarget, 0xffffff, 1.0 );\n\t\t\tthis.renderPass( renderer, this.hBlurMaterial, this.saoRenderTarget, 0xffffff, 1.0 );\n\n\t\t}\n\n\t\tvar outputMaterial = this.materialCopy;\n\t\t// Setting up SAO rendering\n\t\tif ( this.params.output === 3 ) {\n\n\t\t\tif ( this.supportsDepthTextureExtension ) {\n\n\t\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.beautyRenderTarget.depthTexture;\n\t\t\t\tthis.materialCopy.needsUpdate = true;\n\n\t\t\t} else {\n\n\t\t\t\tthis.depthCopy.uniforms[ 'tDiffuse' ].value = this.depthRenderTarget.texture;\n\t\t\t\tthis.depthCopy.needsUpdate = true;\n\t\t\t\toutputMaterial = this.depthCopy;\n\n\t\t\t}\n\n\t\t} else if ( this.params.output === 4 ) {\n\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.normalRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\n\t\t} else {\n\n\t\t\tthis.materialCopy.uniforms[ 'tDiffuse' ].value = this.saoRenderTarget.texture;\n\t\t\tthis.materialCopy.needsUpdate = true;\n\n\t\t}\n\n\t\t// Blending depends on output, only want a CustomBlending when showing SAO\n\t\tif ( this.params.output === 0 ) {\n\n\t\t\toutputMaterial.blending = THREE.CustomBlending;\n\n\t\t} else {\n\n\t\t\toutputMaterial.blending = THREE.NoBlending;\n\n\t\t}\n\n\t\t// Rendering SAOPass result on top of previous pass\n\t\tthis.renderPass( renderer, outputMaterial, this.renderToScreen ? null : readBuffer );\n\n\t\trenderer.setClearColor( this.oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t},\n\n\trenderPass: function ( renderer, passMaterial, renderTarget, clearColor, clearAlpha ) {\n\n\t\t// save original state\n\t\tthis.originalClearColor.copy( renderer.getClearColor() );\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t// setup pass state\n\t\trenderer.autoClear = false;\n\t\tif ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {\n\n\t\t\trenderer.setClearColor( clearColor );\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\n\t\t\trenderer.clear();\n\n\t\t}\n\n\t\tthis.fsQuad.material = passMaterial;\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor( this.originalClearColor );\n\t\trenderer.setClearAlpha( originalClearAlpha );\n\n\t},\n\n\trenderOverride: function ( renderer, overrideMaterial, renderTarget, clearColor, clearAlpha ) {\n\n\t\tthis.originalClearColor.copy( renderer.getClearColor() );\n\t\tvar originalClearAlpha = renderer.getClearAlpha();\n\t\tvar originalAutoClear = renderer.autoClear;\n\n\t\trenderer.setRenderTarget( renderTarget );\n\t\trenderer.autoClear = false;\n\n\t\tclearColor = overrideMaterial.clearColor || clearColor;\n\t\tclearAlpha = overrideMaterial.clearAlpha || clearAlpha;\n\t\tif ( ( clearColor !== undefined ) && ( clearColor !== null ) ) {\n\n\t\t\trenderer.setClearColor( clearColor );\n\t\t\trenderer.setClearAlpha( clearAlpha || 0.0 );\n\t\t\trenderer.clear();\n\n\t\t}\n\n\t\t// AXC: Save oldOverrideMaterial so it can be restored\n\t\tvar oldOverrideMaterial = this.scene.overrideMaterial;\n\t\tthis.scene.overrideMaterial = overrideMaterial;\n\t\trenderer.render( this.scene, this.camera );\n\t\tthis.scene.overrideMaterial = oldOverrideMaterial;\n\n\t\t// restore original state\n\t\trenderer.autoClear = originalAutoClear;\n\t\trenderer.setClearColor( this.originalClearColor );\n\t\trenderer.setClearAlpha( originalClearAlpha );\n\n\t},\n\n\tsetSize: function ( width, height ) {\n\n\t\tthis.beautyRenderTarget.setSize( width, height );\n\t\tthis.saoRenderTarget.setSize( width, height );\n\t\tthis.blurIntermediateRenderTarget.setSize( width, height );\n\t\tthis.normalRenderTarget.setSize( width, height );\n\t\tthis.depthRenderTarget.setSize( width, height );\n\n\t\tthis.saoMaterial.uniforms[ 'size' ].value.set( width, height );\n\t\tthis.saoMaterial.uniforms[ 'cameraInverseProjectionMatrix' ].value.getInverse( this.camera.projectionMatrix );\n\t\tthis.saoMaterial.uniforms[ 'cameraProjectionMatrix' ].value = this.camera.projectionMatrix;\n\t\tthis.saoMaterial.needsUpdate = true;\n\n\t\tthis.vBlurMaterial.uniforms[ 'size' ].value.set( width, height );\n\t\tthis.vBlurMaterial.needsUpdate = true;\n\n\t\tthis.hBlurMaterial.uniforms[ 'size' ].value.set( width, height );\n\t\tthis.hBlurMaterial.needsUpdate = true;\n\n\t}\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/SAOPass.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/SSAOPassOld.js":
/*!*******************************************************!*\
  !*** ./js/vendor/three/postprocessing/SSAOPassOld.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Screen-space ambient occlusion pass.\n *\n * Has the following parameters\n *  - radius\n *  \t- Ambient occlusion shadow radius (numeric value).\n *  - onlyAO\n *  \t- Display only ambient occlusion result (boolean value).\n *  - aoClamp\n *  \t- Ambient occlusion clamp (numeric value).\n *  - lumInfluence\n *  \t- Pixel luminosity influence in AO calculation (numeric value).\n *\n * To output to screen set renderToScreens true\n *\n * @author alteredq / http://alteredqualia.com/\n * @author tentone\n * @class SSAOPass\n */\nTHREE.SSAOPass = function ( scene, camera, width, height ) {\n\n\tif ( THREE.SSAOShader === undefined ) {\n\n\t\tconsole.warn( 'THREE.SSAOPass depends on THREE.SSAOShader' );\n\t\treturn new THREE.ShaderPass();\n\n\t}\n\n\tTHREE.ShaderPass.call( this, THREE.SSAOShader );\n\n\tthis.width = ( width !== undefined ) ? width : 512;\n\tthis.height = ( height !== undefined ) ? height : 256;\n\n\tthis.renderToScreen = false;\n\n\tthis.camera2 = camera;\n\tthis.scene2 = scene;\n\n\t//Depth material\n\tthis.depthMaterial = new THREE.MeshDepthMaterial();\n\tthis.depthMaterial.depthPacking = THREE.RGBADepthPacking;\n\tthis.depthMaterial.blending = THREE.NoBlending;\n\n\t//Depth render target\n\tthis.depthRenderTarget = new THREE.WebGLRenderTarget( this.width, this.height, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter } );\n\t//this.depthRenderTarget.texture.name = 'SSAOShader.rt';\n\n\t//Shader uniforms\n\tthis.uniforms[ 'tDepth' ].value = this.depthRenderTarget.texture;\n\tthis.uniforms[ 'size' ].value.set( this.width, this.height );\n\tthis.uniforms[ 'cameraNear' ].value = this.camera2.near;\n\tthis.uniforms[ 'cameraFar' ].value = this.camera2.far;\n\t// AXC: Switch for perspective camera\n\tthis.material.defines[ 'PERSPECTIVE_CAMERA' ] = this.camera2.isPerspectiveCamera ? 1 : 0;\n\n\tthis.uniforms[ 'radius' ].value = 4;\n\tthis.uniforms[ 'onlyAO' ].value = false;\n\tthis.uniforms[ 'aoClamp' ].value = 0.25;\n\tthis.uniforms[ 'lumInfluence' ].value = 0.7;\n\n\t//Setters and getters for uniforms\n\n\tObject.defineProperties( this, {\n\n\t\tradius: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms[ 'radius' ].value;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms[ 'radius' ].value = value;\n\n\t\t\t}\n\t\t},\n\n\t\tonlyAO: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms[ 'onlyAO' ].value;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms[ 'onlyAO' ].value = value;\n\n\t\t\t}\n\t\t},\n\n\t\taoClamp: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms[ 'aoClamp' ].value;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms[ 'aoClamp' ].value = value;\n\n\t\t\t}\n\t\t},\n\n\t\tlumInfluence: {\n\t\t\tget: function () {\n\n\t\t\t\treturn this.uniforms[ 'lumInfluence' ].value;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tthis.uniforms[ 'lumInfluence' ].value = value;\n\n\t\t\t}\n\t\t},\n\n\t} );\n\n};\n\nTHREE.SSAOPass.prototype = Object.create( THREE.ShaderPass.prototype );\n\n/**\n * Render using this pass.\n *\n * @method render\n * @param {WebGLRenderer} renderer\n * @param {WebGLRenderTarget} writeBuffer Buffer to write output.\n * @param {WebGLRenderTarget} readBuffer Input buffer.\n * @param {Number} delta Delta time in milliseconds.\n * @param {Boolean} maskActive Not used in this pass.\n */\nTHREE.SSAOPass.prototype.render = function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\n\n\t//Render depth into depthRenderTarget\n\t// AXC: Save oldOverrideMaterial so it can be restored\n\tvar oldOverrideMaterial = this.scene2.overrideMaterial;\n\tthis.scene2.overrideMaterial = this.depthMaterial;\n\n  renderer.setRenderTarget( this.depthRenderTarget );\n  renderer.clear();\n\trenderer.render( this.scene2, this.camera2 );\n\t\n\tthis.scene2.overrideMaterial = oldOverrideMaterial;\n\n\t//SSAO shaderPass\n\tTHREE.ShaderPass.prototype.render.call( this, renderer, writeBuffer, readBuffer, delta, maskActive );\n\n};\n\n/**\n * Change scene to be renderer by this render pass.\n *\n * @method setScene\n * @param {Scene} scene\n */\nTHREE.SSAOPass.prototype.setScene = function ( scene ) {\n\n\tthis.scene2 = scene;\n\n};\n\n/**\n * Set camera used by this render pass.\n *\n * @method setCamera\n * @param {Camera} camera\n */\nTHREE.SSAOPass.prototype.setCamera = function ( camera ) {\n\n\tthis.camera2 = camera;\n\n\tthis.uniforms[ 'cameraNear' ].value = this.camera2.near;\n\tthis.uniforms[ 'cameraFar' ].value = this.camera2.far;\n\t// AXC: switch for perspective camera\n\tthis.material.defines[ 'PERSPECTIVE_CAMERA' ] = (this.camera2.isPerspectiveCamera || this.camera2.inPerspectiveMode)  ? 1 : 0;\n\n};\n\n/**\n * Set resolution of this render pass.\n *\n * @method setSize\n * @param {Number} width\n * @param {Number} height\n */\nTHREE.SSAOPass.prototype.setSize = function ( width, height ) {\n\n\tthis.width = width;\n\tthis.height = height;\n\n\tthis.uniforms[ 'size' ].value.set( this.width, this.height );\n\tthis.depthRenderTarget.setSize( this.width, this.height );\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/SSAOPassOld.js?");

/***/ }),

/***/ "./js/vendor/three/postprocessing/ShaderPass.js":
/*!******************************************************!*\
  !*** ./js/vendor/three/postprocessing/ShaderPass.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nTHREE.ShaderPass = function ( shader, textureID ) {\n\n\tTHREE.Pass.call( this );\n\n\tthis.textureID = ( textureID !== undefined ) ? textureID : \"tDiffuse\";\n\n\tif ( shader instanceof THREE.ShaderMaterial ) {\n\n\t\tthis.uniforms = shader.uniforms;\n\n\t\tthis.material = shader;\n\n\t} else if ( shader ) {\n\n\t\tthis.uniforms = THREE.UniformsUtils.clone( shader.uniforms );\n\n\t\tthis.material = new THREE.ShaderMaterial( {\n\n\t\t\tdefines: Object.assign( {}, shader.defines ),\n\t\t\tuniforms: this.uniforms,\n\t\t\tvertexShader: shader.vertexShader,\n\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t} );\n\n\t}\n\n\tthis.fsQuad = new THREE.Pass.FullScreenQuad( this.material );\n\n};\n\nTHREE.ShaderPass.prototype = Object.assign( Object.create( THREE.Pass.prototype ), {\n\n\tconstructor: THREE.ShaderPass,\n\n\trender: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {\n\n\t\tif ( this.uniforms[ this.textureID ] ) {\n\n\t\t\tthis.uniforms[ this.textureID ].value = readBuffer.texture;\n\n\t\t}\n\n\t\tthis.fsQuad.material = this.material;\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( writeBuffer );\n\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\tif ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t}\n\n} );\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/postprocessing/ShaderPass.js?");

/***/ }),

/***/ "./js/vendor/three/shaders.js":
/*!************************************!*\
  !*** ./js/vendor/three/shaders.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! vendor/three/geo/SimplexNoise */ \"./js/vendor/three/geo/SimplexNoise.js\"),\n        __webpack_require__(/*! vendor/three/shaders/CopyShader */ \"./js/vendor/three/shaders/CopyShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/SSAOShaderOld */ \"./js/vendor/three/shaders/SSAOShaderOld.js\"),\n        __webpack_require__(/*! vendor/three/shaders/SAOShader */ \"./js/vendor/three/shaders/SAOShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/FXAAShader */ \"./js/vendor/three/shaders/FXAAShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/DepthLimitedBlurShader */ \"./js/vendor/three/shaders/DepthLimitedBlurShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/UnpackDepthRGBAShader */ \"./js/vendor/three/shaders/UnpackDepthRGBAShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/LuminosityShader */ \"./js/vendor/three/shaders/LuminosityShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/SobelOperatorShader */ \"./js/vendor/three/shaders/SobelOperatorShader.js\"),\n        __webpack_require__(/*! vendor/three/shaders/ColorCorrectionShader */ \"./js/vendor/three/shaders/ColorCorrectionShader.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/EffectComposer */ \"./js/vendor/three/postprocessing/EffectComposer.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/MaskPass */ \"./js/vendor/three/postprocessing/MaskPass.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/RenderPass */ \"./js/vendor/three/postprocessing/RenderPass.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/ShaderPass */ \"./js/vendor/three/postprocessing/ShaderPass.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/SSAOPassOld */ \"./js/vendor/three/postprocessing/SSAOPassOld.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/SAOPass */ \"./js/vendor/three/postprocessing/SAOPass.js\"),\n        __webpack_require__(/*! vendor/three/postprocessing/OutlinePass */ \"./js/vendor/three/postprocessing/OutlinePass.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/ColorCorrectionShader.js":
/*!**********************************************************!*\
  !*** ./js/vendor/three/shaders/ColorCorrectionShader.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Color correction\n */\n\nTHREE.ColorCorrectionShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"powRGB\": { value: new THREE.Vector3( 2, 2, 2 ) },\n\t\t\"mulRGB\": { value: new THREE.Vector3( 1, 1, 1 ) },\n\t\t\"addRGB\": { value: new THREE.Vector3( 0, 0, 0 ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec3 powRGB;\",\n\t\t\"uniform vec3 mulRGB;\",\n\t\t\"uniform vec3 addRGB;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tgl_FragColor = texture2D( tDiffuse, vUv );\",\n\t\t\"\tgl_FragColor.rgb = mulRGB * pow( ( gl_FragColor.rgb + addRGB ), powRGB );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/ColorCorrectionShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/CopyShader.js":
/*!***********************************************!*\
  !*** ./js/vendor/three/shaders/CopyShader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Full-screen textured quad shader\n */\n\nTHREE.CopyShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\t\t\"\tgl_FragColor = opacity * texel;\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/CopyShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/DepthLimitedBlurShader.js":
/*!***********************************************************!*\
  !*** ./js/vendor/three/shaders/DepthLimitedBlurShader.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * TODO\n */\n\nTHREE.DepthLimitedBlurShader = {\n\tdefines: {\n\t\t\"KERNEL_RADIUS\": 4,\n\t\t\"DEPTH_PACKING\": 1,\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\tuniforms: {\n\t\t\"tDiffuse\": { value: null },\n\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\t\t\"sampleUvOffsets\": { value: [ new THREE.Vector2( 0, 0 ) ] },\n\t\t\"sampleWeights\": { value: [ 1.0 ] },\n\t\t\"tDepth\": { value: null },\n\t\t\"cameraNear\": { value: 10 },\n\t\t\"cameraFar\": { value: 1000 },\n\t\t\"depthCutoff\": { value: 10 },\n\t},\n\tvertexShader: [\n\t\t\"#include <common>\",\n\n\t\t\"uniform vec2 size;\",\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec2 vInvSize;\",\n\n\t\t\"void main() {\",\n\t\t\"\tvUv = uv;\",\n\t\t\"\tvInvSize = 1.0 / size;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\tfragmentShader: [\n\t\t\"#include <common>\",\n\t\t\"#include <packing>\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"uniform float depthCutoff;\",\n\n\t\t\"uniform vec2 sampleUvOffsets[ KERNEL_RADIUS + 1 ];\",\n\t\t\"uniform float sampleWeights[ KERNEL_RADIUS + 1 ];\",\n\n\t\t\"varying vec2 vUv;\",\n\t\t\"varying vec2 vInvSize;\",\n\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\"\t#else\",\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#else\",\n\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\t\t\"\tfloat depth = getDepth( vUv );\",\n\t\t\"\tif( depth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\"\t\tdiscard;\",\n\t\t\"\t}\",\n\n\t\t\"\tfloat centerViewZ = -getViewZ( depth );\",\n\t\t\"\tbool rBreak = false, lBreak = false;\",\n\n\t\t\"\tfloat weightSum = sampleWeights[0];\",\n\t\t\"\tvec4 diffuseSum = texture2D( tDiffuse, vUv ) * weightSum;\",\n\n\t\t\"\tfor( int i = 1; i <= KERNEL_RADIUS; i ++ ) {\",\n\n\t\t\"\t\tfloat sampleWeight = sampleWeights[i];\",\n\t\t\"\t\tvec2 sampleUvOffset = sampleUvOffsets[i] * vInvSize;\",\n\n\t\t\"\t\tvec2 sampleUv = vUv + sampleUvOffset;\",\n\t\t\"\t\tfloat viewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) rBreak = true;\",\n\n\t\t\"\t\tif( ! rBreak ) {\",\n\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\tsampleUv = vUv - sampleUvOffset;\",\n\t\t\"\t\tviewZ = -getViewZ( getDepth( sampleUv ) );\",\n\n\t\t\"\t\tif( abs( viewZ - centerViewZ ) > depthCutoff ) lBreak = true;\",\n\n\t\t\"\t\tif( ! lBreak ) {\",\n\t\t\"\t\t\tdiffuseSum += texture2D( tDiffuse, sampleUv ) * sampleWeight;\",\n\t\t\"\t\t\tweightSum += sampleWeight;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t}\",\n\n\t\t\"\tgl_FragColor = diffuseSum / weightSum;\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\n\nTHREE.BlurShaderUtils = {\n\n\tcreateSampleWeights: function ( kernelRadius, stdDev ) {\n\n\t\tvar gaussian = function ( x, stdDev ) {\n\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * ( stdDev * stdDev ) ) ) / ( Math.sqrt( 2.0 * Math.PI ) * stdDev );\n\n\t\t};\n\n\t\tvar weights = [];\n\n\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\tweights.push( gaussian( i, stdDev ) );\n\n\t\t}\n\n\t\treturn weights;\n\n\t},\n\n\tcreateSampleOffsets: function ( kernelRadius, uvIncrement ) {\n\n\t\tvar offsets = [];\n\n\t\tfor ( var i = 0; i <= kernelRadius; i ++ ) {\n\n\t\t\toffsets.push( uvIncrement.clone().multiplyScalar( i ) );\n\n\t\t}\n\n\t\treturn offsets;\n\n\t},\n\n\tconfigure: function ( material, kernelRadius, stdDev, uvIncrement ) {\n\n\t\tmaterial.defines[ \"KERNEL_RADIUS\" ] = kernelRadius;\n\t\tmaterial.uniforms[ \"sampleUvOffsets\" ].value = THREE.BlurShaderUtils.createSampleOffsets( kernelRadius, uvIncrement );\n\t\tmaterial.uniforms[ \"sampleWeights\" ].value = THREE.BlurShaderUtils.createSampleWeights( kernelRadius, stdDev );\n\t\tmaterial.needsUpdate = true;\n\n\t}\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/DepthLimitedBlurShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/FXAAShader.js":
/*!***********************************************!*\
  !*** ./js/vendor/three/shaders/FXAAShader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n * @author davidedc / http://www.sketchpatch.net/\n *\n * NVIDIA FXAA by Timothy Lottes\n * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html\n * - WebGL port by @supereggbert\n * http://www.glge.org/demos/fxaa/\n */\n\nTHREE.FXAAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\t\t\"precision highp float;\",\n\t\t\"\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"\",\n\t\t\"uniform vec2 resolution;\",\n\t\t\"\",\n\t\t\"varying vec2 vUv;\",\n\t\t\"\",\n\t\t\"// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\",\n\t\t\"\",\n\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\"// File:        es3-kepler\\FXAA\\assets\\shaders/FXAA_DefaultES.frag\",\n\t\t\"// SDK Version: v3.00\",\n\t\t\"// Email:       gameworks@nvidia.com\",\n\t\t\"// Site:        http://developer.nvidia.com/\",\n\t\t\"//\",\n\t\t\"// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\",\n\t\t\"//\",\n\t\t\"// Redistribution and use in source and binary forms, with or without\",\n\t\t\"// modification, are permitted provided that the following conditions\",\n\t\t\"// are met:\",\n\t\t\"//  * Redistributions of source code must retain the above copyright\",\n\t\t\"//    notice, this list of conditions and the following disclaimer.\",\n\t\t\"//  * Redistributions in binary form must reproduce the above copyright\",\n\t\t\"//    notice, this list of conditions and the following disclaimer in the\",\n\t\t\"//    documentation and/or other materials provided with the distribution.\",\n\t\t\"//  * Neither the name of NVIDIA CORPORATION nor the names of its\",\n\t\t\"//    contributors may be used to endorse or promote products derived\",\n\t\t\"//    from this software without specific prior written permission.\",\n\t\t\"//\",\n\t\t\"// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\",\n\t\t\"// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\",\n\t\t\"// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\",\n\t\t\"// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\",\n\t\t\"// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\",\n\t\t\"// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\",\n\t\t\"// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\",\n\t\t\"// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\",\n\t\t\"// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\",\n\t\t\"// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\",\n\t\t\"// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\",\n\t\t\"//\",\n\t\t\"//----------------------------------------------------------------------------------\",\n\t\t\"\",\n\t\t\"#define FXAA_PC 1\",\n\t\t\"#define FXAA_GLSL_100 1\",\n\t\t\"#define FXAA_QUALITY_PRESET 12\",\n\t\t\"\",\n\t\t\"#define FXAA_GREEN_AS_LUMA 1\",\n\t\t\"\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_PC_CONSOLE\",\n\t\t\"    //\",\n\t\t\"    // The console algorithm for PC is included\",\n\t\t\"    // for developers targeting really low spec machines.\",\n\t\t\"    // Likely better to just run FXAA_PC, and use a really low preset.\",\n\t\t\"    //\",\n\t\t\"    #define FXAA_PC_CONSOLE 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_GLSL_120\",\n\t\t\"    #define FXAA_GLSL_120 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_GLSL_130\",\n\t\t\"    #define FXAA_GLSL_130 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_HLSL_3\",\n\t\t\"    #define FXAA_HLSL_3 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_HLSL_4\",\n\t\t\"    #define FXAA_HLSL_4 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_HLSL_5\",\n\t\t\"    #define FXAA_HLSL_5 0\",\n\t\t\"#endif\",\n\t\t\"/*==========================================================================*/\",\n\t\t\"#ifndef FXAA_GREEN_AS_LUMA\",\n\t\t\"    //\",\n\t\t\"    // For those using non-linear color,\",\n\t\t\"    // and either not able to get luma in alpha, or not wanting to,\",\n\t\t\"    // this enables FXAA to run using green as a proxy for luma.\",\n\t\t\"    // So with this enabled, no need to pack luma in alpha.\",\n\t\t\"    //\",\n\t\t\"    // This will turn off AA on anything which lacks some amount of green.\",\n\t\t\"    // Pure red and blue or combination of only R and B, will get no AA.\",\n\t\t\"    //\",\n\t\t\"    // Might want to lower the settings for both,\",\n\t\t\"    //    fxaaConsoleEdgeThresholdMin\",\n\t\t\"    //    fxaaQualityEdgeThresholdMin\",\n\t\t\"    // In order to insure AA does not get turned off on colors\",\n\t\t\"    // which contain a minor amount of green.\",\n\t\t\"    //\",\n\t\t\"    // 1 = On.\",\n\t\t\"    // 0 = Off.\",\n\t\t\"    //\",\n\t\t\"    #define FXAA_GREEN_AS_LUMA 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_EARLY_EXIT\",\n\t\t\"    //\",\n\t\t\"    // Controls algorithm's early exit path.\",\n\t\t\"    // On PS3 turning this ON adds 2 cycles to the shader.\",\n\t\t\"    // On 360 turning this OFF adds 10ths of a millisecond to the shader.\",\n\t\t\"    // Turning this off on console will result in a more blurry image.\",\n\t\t\"    // So this defaults to on.\",\n\t\t\"    //\",\n\t\t\"    // 1 = On.\",\n\t\t\"    // 0 = Off.\",\n\t\t\"    //\",\n\t\t\"    #define FXAA_EARLY_EXIT 1\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_DISCARD\",\n\t\t\"    //\",\n\t\t\"    // Only valid for PC OpenGL currently.\",\n\t\t\"    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.\",\n\t\t\"    //\",\n\t\t\"    // 1 = Use discard on pixels which don't need AA.\",\n\t\t\"    //     For APIs which enable concurrent TEX+ROP from same surface.\",\n\t\t\"    // 0 = Return unchanged color on pixels which don't need AA.\",\n\t\t\"    //\",\n\t\t\"    #define FXAA_DISCARD 0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\"    //\",\n\t\t\"    // Used for GLSL 120 only.\",\n\t\t\"    //\",\n\t\t\"    // 1 = GL API supports fast pixel offsets\",\n\t\t\"    // 0 = do not use fast pixel offsets\",\n\t\t\"    //\",\n\t\t\"    #ifdef GL_EXT_gpu_shader4\",\n\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifndef FXAA_FAST_PIXEL_OFFSET\",\n\t\t\"        #define FXAA_FAST_PIXEL_OFFSET 0\",\n\t\t\"    #endif\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#ifndef FXAA_GATHER4_ALPHA\",\n\t\t\"    //\",\n\t\t\"    // 1 = API supports gather4 on alpha channel.\",\n\t\t\"    // 0 = API does not support gather4 on alpha channel.\",\n\t\t\"    //\",\n\t\t\"    #if (FXAA_HLSL_5 == 1)\",\n\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifdef GL_ARB_gpu_shader5\",\n\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifdef GL_NV_gpu_shader5\",\n\t\t\"        #define FXAA_GATHER4_ALPHA 1\",\n\t\t\"    #endif\",\n\t\t\"    #ifndef FXAA_GATHER4_ALPHA\",\n\t\t\"        #define FXAA_GATHER4_ALPHA 0\",\n\t\t\"    #endif\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"                        FXAA QUALITY - TUNING KNOBS\",\n\t\t\"------------------------------------------------------------------------------\",\n\t\t\"NOTE the other tuning knobs are now in the shader function inputs!\",\n\t\t\"============================================================================*/\",\n\t\t\"#ifndef FXAA_QUALITY_PRESET\",\n\t\t\"    //\",\n\t\t\"    // Choose the quality preset.\",\n\t\t\"    // This needs to be compiled into the shader as it effects code.\",\n\t\t\"    // Best option to include multiple presets is to\",\n\t\t\"    // in each shader define the preset, then include this file.\",\n\t\t\"    //\",\n\t\t\"    // OPTIONS\",\n\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\"    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)\",\n\t\t\"    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)\",\n\t\t\"    // 39       - no dither, very expensive\",\n\t\t\"    //\",\n\t\t\"    // NOTES\",\n\t\t\"    // -----------------------------------------------------------------------\",\n\t\t\"    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)\",\n\t\t\"    // 13 = about same speed as FXAA 3.9 and better than 12\",\n\t\t\"    // 23 = closest to FXAA 3.9 visually and performance wise\",\n\t\t\"    //  _ = the lowest digit is directly related to performance\",\n\t\t\"    // _  = the highest digit is directly related to style\",\n\t\t\"    //\",\n\t\t\"    #define FXAA_QUALITY_PRESET 12\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"\",\n\t\t\"                           FXAA QUALITY - PRESETS\",\n\t\t\"\",\n\t\t\"============================================================================*/\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"                     FXAA QUALITY - MEDIUM DITHER PRESETS\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 10)\",\n\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\"    #define FXAA_QUALITY_P1 3.0\",\n\t\t\"    #define FXAA_QUALITY_P2 12.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 11)\",\n\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 3.0\",\n\t\t\"    #define FXAA_QUALITY_P3 12.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 12)\",\n\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 4.0\",\n\t\t\"    #define FXAA_QUALITY_P4 12.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 13)\",\n\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 4.0\",\n\t\t\"    #define FXAA_QUALITY_P5 12.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 14)\",\n\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 4.0\",\n\t\t\"    #define FXAA_QUALITY_P6 12.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 15)\",\n\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\"    #define FXAA_QUALITY_P7 12.0\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"                     FXAA QUALITY - LOW DITHER PRESETS\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 20)\",\n\t\t\"    #define FXAA_QUALITY_PS 3\",\n\t\t\"    #define FXAA_QUALITY_P0 1.5\",\n\t\t\"    #define FXAA_QUALITY_P1 2.0\",\n\t\t\"    #define FXAA_QUALITY_P2 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 21)\",\n\t\t\"    #define FXAA_QUALITY_PS 4\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 22)\",\n\t\t\"    #define FXAA_QUALITY_PS 5\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 23)\",\n\t\t\"    #define FXAA_QUALITY_PS 6\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 24)\",\n\t\t\"    #define FXAA_QUALITY_PS 7\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 3.0\",\n\t\t\"    #define FXAA_QUALITY_P6 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 25)\",\n\t\t\"    #define FXAA_QUALITY_PS 8\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 4.0\",\n\t\t\"    #define FXAA_QUALITY_P7 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 26)\",\n\t\t\"    #define FXAA_QUALITY_PS 9\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\"    #define FXAA_QUALITY_P7 4.0\",\n\t\t\"    #define FXAA_QUALITY_P8 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 27)\",\n\t\t\"    #define FXAA_QUALITY_PS 10\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\"    #define FXAA_QUALITY_P8 4.0\",\n\t\t\"    #define FXAA_QUALITY_P9 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 28)\",\n\t\t\"    #define FXAA_QUALITY_PS 11\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\"    #define FXAA_QUALITY_P9 4.0\",\n\t\t\"    #define FXAA_QUALITY_P10 8.0\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 29)\",\n\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.5\",\n\t\t\"    #define FXAA_QUALITY_P2 2.0\",\n\t\t\"    #define FXAA_QUALITY_P3 2.0\",\n\t\t\"    #define FXAA_QUALITY_P4 2.0\",\n\t\t\"    #define FXAA_QUALITY_P5 2.0\",\n\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"                     FXAA QUALITY - EXTREME QUALITY\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_QUALITY_PRESET == 39)\",\n\t\t\"    #define FXAA_QUALITY_PS 12\",\n\t\t\"    #define FXAA_QUALITY_P0 1.0\",\n\t\t\"    #define FXAA_QUALITY_P1 1.0\",\n\t\t\"    #define FXAA_QUALITY_P2 1.0\",\n\t\t\"    #define FXAA_QUALITY_P3 1.0\",\n\t\t\"    #define FXAA_QUALITY_P4 1.0\",\n\t\t\"    #define FXAA_QUALITY_P5 1.5\",\n\t\t\"    #define FXAA_QUALITY_P6 2.0\",\n\t\t\"    #define FXAA_QUALITY_P7 2.0\",\n\t\t\"    #define FXAA_QUALITY_P8 2.0\",\n\t\t\"    #define FXAA_QUALITY_P9 2.0\",\n\t\t\"    #define FXAA_QUALITY_P10 4.0\",\n\t\t\"    #define FXAA_QUALITY_P11 8.0\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"\",\n\t\t\"                                API PORTING\",\n\t\t\"\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)\",\n\t\t\"    #define FxaaBool bool\",\n\t\t\"    #define FxaaDiscard discard\",\n\t\t\"    #define FxaaFloat float\",\n\t\t\"    #define FxaaFloat2 vec2\",\n\t\t\"    #define FxaaFloat3 vec3\",\n\t\t\"    #define FxaaFloat4 vec4\",\n\t\t\"    #define FxaaHalf float\",\n\t\t\"    #define FxaaHalf2 vec2\",\n\t\t\"    #define FxaaHalf3 vec3\",\n\t\t\"    #define FxaaHalf4 vec4\",\n\t\t\"    #define FxaaInt2 ivec2\",\n\t\t\"    #define FxaaSat(x) clamp(x, 0.0, 1.0)\",\n\t\t\"    #define FxaaTex sampler2D\",\n\t\t\"#else\",\n\t\t\"    #define FxaaBool bool\",\n\t\t\"    #define FxaaDiscard clip(-1)\",\n\t\t\"    #define FxaaFloat float\",\n\t\t\"    #define FxaaFloat2 float2\",\n\t\t\"    #define FxaaFloat3 float3\",\n\t\t\"    #define FxaaFloat4 float4\",\n\t\t\"    #define FxaaHalf half\",\n\t\t\"    #define FxaaHalf2 half2\",\n\t\t\"    #define FxaaHalf3 half3\",\n\t\t\"    #define FxaaHalf4 half4\",\n\t\t\"    #define FxaaSat(x) saturate(x)\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_GLSL_100 == 1)\",\n\t\t\"  #define FxaaTexTop(t, p) texture2D(t, p, 0.0)\",\n\t\t\"  #define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_GLSL_120 == 1)\",\n\t\t\"    // Requires,\",\n\t\t\"    //  #version 120\",\n\t\t\"    // And at least,\",\n\t\t\"    //  #extension GL_EXT_gpu_shader4 : enable\",\n\t\t\"    //  (or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)\",\n\t\t\"    #define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)\",\n\t\t\"    #if (FXAA_FAST_PIXEL_OFFSET == 1)\",\n\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)\",\n\t\t\"    #else\",\n\t\t\"        #define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)\",\n\t\t\"    #endif\",\n\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\"    #endif\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_GLSL_130 == 1)\",\n\t\t\"    // Requires \\\"#version 130\\\" or better\",\n\t\t\"    #define FxaaTexTop(t, p) textureLod(t, p, 0.0)\",\n\t\t\"    #define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)\",\n\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\"        // use #extension GL_ARB_gpu_shader5 : enable\",\n\t\t\"        #define FxaaTexAlpha4(t, p) textureGather(t, p, 3)\",\n\t\t\"        #define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)\",\n\t\t\"        #define FxaaTexGreen4(t, p) textureGather(t, p, 1)\",\n\t\t\"        #define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)\",\n\t\t\"    #endif\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_HLSL_3 == 1)\",\n\t\t\"    #define FxaaInt2 float2\",\n\t\t\"    #define FxaaTex sampler2D\",\n\t\t\"    #define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))\",\n\t\t\"    #define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_HLSL_4 == 1)\",\n\t\t\"    #define FxaaInt2 int2\",\n\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\"#endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"#if (FXAA_HLSL_5 == 1)\",\n\t\t\"    #define FxaaInt2 int2\",\n\t\t\"    struct FxaaTex { SamplerState smpl; Texture2D tex; };\",\n\t\t\"    #define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)\",\n\t\t\"    #define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)\",\n\t\t\"    #define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)\",\n\t\t\"    #define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)\",\n\t\t\"    #define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)\",\n\t\t\"    #define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"                   GREEN AS LUMA OPTION SUPPORT FUNCTION\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }\",\n\t\t\"#else\",\n\t\t\"    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"\",\n\t\t\"/*============================================================================\",\n\t\t\"\",\n\t\t\"                             FXAA3 QUALITY - PC\",\n\t\t\"\",\n\t\t\"============================================================================*/\",\n\t\t\"#if (FXAA_PC == 1)\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"FxaaFloat4 FxaaPixelShader(\",\n\t\t\"    //\",\n\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\"    // {xy} = center of pixel\",\n\t\t\"    FxaaFloat2 pos,\",\n\t\t\"    //\",\n\t\t\"    // Used only for FXAA Console, and not used on the 360 version.\",\n\t\t\"    // Use noperspective interpolation here (turn off perspective interpolation).\",\n\t\t\"    // {xy_} = upper left of pixel\",\n\t\t\"    // {_zw} = lower right of pixel\",\n\t\t\"    FxaaFloat4 fxaaConsolePosPos,\",\n\t\t\"    //\",\n\t\t\"    // Input color texture.\",\n\t\t\"    // {rgb_} = color in linear or perceptual color space\",\n\t\t\"    // if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\"    //     {__a} = luma in perceptual color space (not linear)\",\n\t\t\"    FxaaTex tex,\",\n\t\t\"    //\",\n\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\"    // For 360, same texture, just alias with a 2nd sampler.\",\n\t\t\"    // This sampler needs to have an exponent bias of -1.\",\n\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegOne,\",\n\t\t\"    //\",\n\t\t\"    // Only used on the optimized 360 version of FXAA Console.\",\n\t\t\"    // For everything but 360, just use the same input here as for \\\"tex\\\".\",\n\t\t\"    // For 360, same texture, just alias with a 3nd sampler.\",\n\t\t\"    // This sampler needs to have an exponent bias of -2.\",\n\t\t\"    FxaaTex fxaaConsole360TexExpBiasNegTwo,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Quality.\",\n\t\t\"    // This must be from a constant/uniform.\",\n\t\t\"    // {x_} = 1.0/screenWidthInPixels\",\n\t\t\"    // {_y} = 1.0/screenHeightInPixels\",\n\t\t\"    FxaaFloat2 fxaaQualityRcpFrame,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // This must be from a constant/uniform.\",\n\t\t\"    // This effects sub-pixel AA quality and inversely sharpness.\",\n\t\t\"    //   Where N ranges between,\",\n\t\t\"    //     N = 0.50 (default)\",\n\t\t\"    //     N = 0.33 (sharper)\",\n\t\t\"    // {x__} = -N/screenWidthInPixels\",\n\t\t\"    // {_y_} = -N/screenHeightInPixels\",\n\t\t\"    // {_z_} =  N/screenWidthInPixels\",\n\t\t\"    // {__w} =  N/screenHeightInPixels\",\n\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // Not used on 360, but used on PS3 and PC.\",\n\t\t\"    // This must be from a constant/uniform.\",\n\t\t\"    // {x__} = -2.0/screenWidthInPixels\",\n\t\t\"    // {_y_} = -2.0/screenHeightInPixels\",\n\t\t\"    // {_z_} =  2.0/screenWidthInPixels\",\n\t\t\"    // {__w} =  2.0/screenHeightInPixels\",\n\t\t\"    FxaaFloat4 fxaaConsoleRcpFrameOpt2,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // Only used on 360 in place of fxaaConsoleRcpFrameOpt2.\",\n\t\t\"    // This must be from a constant/uniform.\",\n\t\t\"    // {x__} =  8.0/screenWidthInPixels\",\n\t\t\"    // {_y_} =  8.0/screenHeightInPixels\",\n\t\t\"    // {_z_} = -4.0/screenWidthInPixels\",\n\t\t\"    // {__w} = -4.0/screenHeightInPixels\",\n\t\t\"    FxaaFloat4 fxaaConsole360RcpFrameOpt2,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Quality.\",\n\t\t\"    // This used to be the FXAA_QUALITY_SUBPIX define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // Choose the amount of sub-pixel aliasing removal.\",\n\t\t\"    // This can effect sharpness.\",\n\t\t\"    //   1.00 - upper limit (softer)\",\n\t\t\"    //   0.75 - default amount of filtering\",\n\t\t\"    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)\",\n\t\t\"    //   0.25 - almost off\",\n\t\t\"    //   0.00 - completely off\",\n\t\t\"    FxaaFloat fxaaQualitySubpix,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Quality.\",\n\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // The minimum amount of local contrast required to apply algorithm.\",\n\t\t\"    //   0.333 - too little (faster)\",\n\t\t\"    //   0.250 - low quality\",\n\t\t\"    //   0.166 - default\",\n\t\t\"    //   0.125 - high quality\",\n\t\t\"    //   0.063 - overkill (slower)\",\n\t\t\"    FxaaFloat fxaaQualityEdgeThreshold,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Quality.\",\n\t\t\"    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\"    //   0.0833 - upper limit (default, the start of visible unfiltered edges)\",\n\t\t\"    //   0.0625 - high quality (faster)\",\n\t\t\"    //   0.0312 - visible limit (slower)\",\n\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\"    //   Likely want to set this to zero.\",\n\t\t\"    //   As colors that are mostly not-green\",\n\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\"    FxaaFloat fxaaQualityEdgeThresholdMin,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.\",\n\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\"    //   there are only three safe values here: 2 and 4 and 8.\",\n\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\"    // For all other platforms can be a non-power of two.\",\n\t\t\"    //   8.0 is sharper (default!!!)\",\n\t\t\"    //   4.0 is softer\",\n\t\t\"    //   2.0 is really soft (good only for vector graphics inputs)\",\n\t\t\"    FxaaFloat fxaaConsoleEdgeSharpness,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // This does not effect PS3, as this needs to be compiled in.\",\n\t\t\"    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.\",\n\t\t\"    //   Due to the PS3 being ALU bound,\",\n\t\t\"    //   there are only two safe values here: 1/4 and 1/8.\",\n\t\t\"    //   These options use the shaders ability to a free *|/ by 2|4|8.\",\n\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\"    // Other platforms can use other values.\",\n\t\t\"    //   0.125 leaves less aliasing, but is softer (default!!!)\",\n\t\t\"    //   0.25 leaves more aliasing, and is sharper\",\n\t\t\"    FxaaFloat fxaaConsoleEdgeThreshold,\",\n\t\t\"    //\",\n\t\t\"    // Only used on FXAA Console.\",\n\t\t\"    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.\",\n\t\t\"    // It is here now to allow easier tuning.\",\n\t\t\"    // Trims the algorithm from processing darks.\",\n\t\t\"    // The console setting has a different mapping than the quality setting.\",\n\t\t\"    // This only applies when FXAA_EARLY_EXIT is 1.\",\n\t\t\"    // This does not apply to PS3,\",\n\t\t\"    // PS3 was simplified to avoid more shader instructions.\",\n\t\t\"    //   0.06 - faster but more aliasing in darks\",\n\t\t\"    //   0.05 - default\",\n\t\t\"    //   0.04 - slower and less aliasing in darks\",\n\t\t\"    // Special notes when using FXAA_GREEN_AS_LUMA,\",\n\t\t\"    //   Likely want to set this to zero.\",\n\t\t\"    //   As colors that are mostly not-green\",\n\t\t\"    //   will appear very dark in the green channel!\",\n\t\t\"    //   Tune by looking at mostly non-green content,\",\n\t\t\"    //   then start at zero and increase until aliasing is a problem.\",\n\t\t\"    FxaaFloat fxaaConsoleEdgeThresholdMin,\",\n\t\t\"    //\",\n\t\t\"    // Extra constants for 360 FXAA Console only.\",\n\t\t\"    // Use zeros or anything else for other platforms.\",\n\t\t\"    // These must be in physical constant registers and NOT immediates.\",\n\t\t\"    // Immediates will result in compiler un-optimizing.\",\n\t\t\"    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)\",\n\t\t\"    FxaaFloat4 fxaaConsole360ConstDir\",\n\t\t\") {\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat2 posM;\",\n\t\t\"    posM.x = pos.x;\",\n\t\t\"    posM.y = pos.y;\",\n\t\t\"    #if (FXAA_GATHER4_ALPHA == 1)\",\n\t\t\"        #if (FXAA_DISCARD == 0)\",\n\t\t\"            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\"            #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\"                #define lumaM rgbyM.w\",\n\t\t\"            #else\",\n\t\t\"                #define lumaM rgbyM.y\",\n\t\t\"            #endif\",\n\t\t\"        #endif\",\n\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\"            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);\",\n\t\t\"            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\"        #else\",\n\t\t\"            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);\",\n\t\t\"            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));\",\n\t\t\"        #endif\",\n\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\"            #define lumaM luma4A.w\",\n\t\t\"        #endif\",\n\t\t\"        #define lumaE luma4A.z\",\n\t\t\"        #define lumaS luma4A.x\",\n\t\t\"        #define lumaSE luma4A.y\",\n\t\t\"        #define lumaNW luma4B.w\",\n\t\t\"        #define lumaN luma4B.z\",\n\t\t\"        #define lumaW luma4B.x\",\n\t\t\"    #else\",\n\t\t\"        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);\",\n\t\t\"        #if (FXAA_GREEN_AS_LUMA == 0)\",\n\t\t\"            #define lumaM rgbyM.w\",\n\t\t\"        #else\",\n\t\t\"            #define lumaM rgbyM.y\",\n\t\t\"        #endif\",\n\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"        #else\",\n\t\t\"          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));\",\n\t\t\"        #endif\",\n\t\t\"    #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat maxSM = max(lumaS, lumaM);\",\n\t\t\"    FxaaFloat minSM = min(lumaS, lumaM);\",\n\t\t\"    FxaaFloat maxESM = max(lumaE, maxSM);\",\n\t\t\"    FxaaFloat minESM = min(lumaE, minSM);\",\n\t\t\"    FxaaFloat maxWN = max(lumaN, lumaW);\",\n\t\t\"    FxaaFloat minWN = min(lumaN, lumaW);\",\n\t\t\"    FxaaFloat rangeMax = max(maxWN, maxESM);\",\n\t\t\"    FxaaFloat rangeMin = min(minWN, minESM);\",\n\t\t\"    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;\",\n\t\t\"    FxaaFloat range = rangeMax - rangeMin;\",\n\t\t\"    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);\",\n\t\t\"    FxaaBool earlyExit = range < rangeMaxClamped;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    if(earlyExit)\",\n\t\t\"        #if (FXAA_DISCARD == 1)\",\n\t\t\"            FxaaDiscard;\",\n\t\t\"        #else\",\n\t\t\"            return rgbyM;\",\n\t\t\"        #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    #if (FXAA_GATHER4_ALPHA == 0)\",\n\t\t\"        #if (FXAA_GLSL_100 == 1)\",\n\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));\",\n\t\t\"        #else\",\n\t\t\"          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));\",\n\t\t\"          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\"        #endif\",\n\t\t\"    #else\",\n\t\t\"        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));\",\n\t\t\"        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));\",\n\t\t\"    #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat lumaNS = lumaN + lumaS;\",\n\t\t\"    FxaaFloat lumaWE = lumaW + lumaE;\",\n\t\t\"    FxaaFloat subpixRcpRange = 1.0/range;\",\n\t\t\"    FxaaFloat subpixNSWE = lumaNS + lumaWE;\",\n\t\t\"    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;\",\n\t\t\"    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat lumaNESE = lumaNE + lumaSE;\",\n\t\t\"    FxaaFloat lumaNWNE = lumaNW + lumaNE;\",\n\t\t\"    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;\",\n\t\t\"    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat lumaNWSW = lumaNW + lumaSW;\",\n\t\t\"    FxaaFloat lumaSWSE = lumaSW + lumaSE;\",\n\t\t\"    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);\",\n\t\t\"    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);\",\n\t\t\"    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;\",\n\t\t\"    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;\",\n\t\t\"    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;\",\n\t\t\"    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;\",\n\t\t\"    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;\",\n\t\t\"    FxaaBool horzSpan = edgeHorz >= edgeVert;\",\n\t\t\"    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    if(!horzSpan) lumaN = lumaW;\",\n\t\t\"    if(!horzSpan) lumaS = lumaE;\",\n\t\t\"    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;\",\n\t\t\"    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat gradientN = lumaN - lumaM;\",\n\t\t\"    FxaaFloat gradientS = lumaS - lumaM;\",\n\t\t\"    FxaaFloat lumaNN = lumaN + lumaM;\",\n\t\t\"    FxaaFloat lumaSS = lumaS + lumaM;\",\n\t\t\"    FxaaBool pairN = abs(gradientN) >= abs(gradientS);\",\n\t\t\"    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));\",\n\t\t\"    if(pairN) lengthSign = -lengthSign;\",\n\t\t\"    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat2 posB;\",\n\t\t\"    posB.x = posM.x;\",\n\t\t\"    posB.y = posM.y;\",\n\t\t\"    FxaaFloat2 offNP;\",\n\t\t\"    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\",\n\t\t\"    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\",\n\t\t\"    if(!horzSpan) posB.x += lengthSign * 0.5;\",\n\t\t\"    if( horzSpan) posB.y += lengthSign * 0.5;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat2 posN;\",\n\t\t\"    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;\",\n\t\t\"    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;\",\n\t\t\"    FxaaFloat2 posP;\",\n\t\t\"    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;\",\n\t\t\"    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;\",\n\t\t\"    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;\",\n\t\t\"    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));\",\n\t\t\"    FxaaFloat subpixE = subpixC * subpixC;\",\n\t\t\"    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    if(!pairN) lumaNN = lumaSS;\",\n\t\t\"    FxaaFloat gradientScaled = gradient * 1.0/4.0;\",\n\t\t\"    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;\",\n\t\t\"    FxaaFloat subpixF = subpixD * subpixE;\",\n\t\t\"    FxaaBool lumaMLTZero = lumaMM < 0.0;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    lumaEndN -= lumaNN * 0.5;\",\n\t\t\"    lumaEndP -= lumaNN * 0.5;\",\n\t\t\"    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;\",\n\t\t\"    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;\",\n\t\t\"    FxaaBool doneNP = (!doneN) || (!doneP);\",\n\t\t\"    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;\",\n\t\t\"    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    if(doneNP) {\",\n\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;\",\n\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;\",\n\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;\",\n\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"        #if (FXAA_QUALITY_PS > 3)\",\n\t\t\"        if(doneNP) {\",\n\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;\",\n\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;\",\n\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;\",\n\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"            #if (FXAA_QUALITY_PS > 4)\",\n\t\t\"            if(doneNP) {\",\n\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;\",\n\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;\",\n\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;\",\n\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                #if (FXAA_QUALITY_PS > 5)\",\n\t\t\"                if(doneNP) {\",\n\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;\",\n\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;\",\n\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;\",\n\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                    #if (FXAA_QUALITY_PS > 6)\",\n\t\t\"                    if(doneNP) {\",\n\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;\",\n\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;\",\n\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;\",\n\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                        #if (FXAA_QUALITY_PS > 7)\",\n\t\t\"                        if(doneNP) {\",\n\t\t\"                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;\",\n\t\t\"                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;\",\n\t\t\"                            doneNP = (!doneN) || (!doneP);\",\n\t\t\"                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;\",\n\t\t\"                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    #if (FXAA_QUALITY_PS > 8)\",\n\t\t\"    if(doneNP) {\",\n\t\t\"        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;\",\n\t\t\"        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;\",\n\t\t\"        doneNP = (!doneN) || (!doneP);\",\n\t\t\"        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;\",\n\t\t\"        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"        #if (FXAA_QUALITY_PS > 9)\",\n\t\t\"        if(doneNP) {\",\n\t\t\"            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"            doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"            doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;\",\n\t\t\"            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;\",\n\t\t\"            doneNP = (!doneN) || (!doneP);\",\n\t\t\"            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;\",\n\t\t\"            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"            #if (FXAA_QUALITY_PS > 10)\",\n\t\t\"            if(doneNP) {\",\n\t\t\"                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;\",\n\t\t\"                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;\",\n\t\t\"                doneNP = (!doneN) || (!doneP);\",\n\t\t\"                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;\",\n\t\t\"                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                #if (FXAA_QUALITY_PS > 11)\",\n\t\t\"                if(doneNP) {\",\n\t\t\"                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                    doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                    doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;\",\n\t\t\"                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;\",\n\t\t\"                    doneNP = (!doneN) || (!doneP);\",\n\t\t\"                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;\",\n\t\t\"                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                    #if (FXAA_QUALITY_PS > 12)\",\n\t\t\"                    if(doneNP) {\",\n\t\t\"                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));\",\n\t\t\"                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));\",\n\t\t\"                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;\",\n\t\t\"                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;\",\n\t\t\"                        doneN = abs(lumaEndN) >= gradientScaled;\",\n\t\t\"                        doneP = abs(lumaEndP) >= gradientScaled;\",\n\t\t\"                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;\",\n\t\t\"                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;\",\n\t\t\"                        doneNP = (!doneN) || (!doneP);\",\n\t\t\"                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;\",\n\t\t\"                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                    }\",\n\t\t\"                    #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                }\",\n\t\t\"                #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"            }\",\n\t\t\"            #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"        }\",\n\t\t\"        #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    }\",\n\t\t\"    #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                        }\",\n\t\t\"                        #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                    }\",\n\t\t\"                    #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"                }\",\n\t\t\"                #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"            }\",\n\t\t\"            #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"        }\",\n\t\t\"        #endif\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    }\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat dstN = posM.x - posN.x;\",\n\t\t\"    FxaaFloat dstP = posP.x - posM.x;\",\n\t\t\"    if(!horzSpan) dstN = posM.y - posN.y;\",\n\t\t\"    if(!horzSpan) dstP = posP.y - posM.y;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;\",\n\t\t\"    FxaaFloat spanLength = (dstP + dstN);\",\n\t\t\"    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;\",\n\t\t\"    FxaaFloat spanLengthRcp = 1.0/spanLength;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaBool directionN = dstN < dstP;\",\n\t\t\"    FxaaFloat dst = min(dstN, dstP);\",\n\t\t\"    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;\",\n\t\t\"    FxaaFloat subpixG = subpixF * subpixF;\",\n\t\t\"    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;\",\n\t\t\"    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;\",\n\t\t\"/*--------------------------------------------------------------------------*/\",\n\t\t\"    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;\",\n\t\t\"    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);\",\n\t\t\"    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;\",\n\t\t\"    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;\",\n\t\t\"    #if (FXAA_DISCARD == 1)\",\n\t\t\"        return FxaaTexTop(tex, posM);\",\n\t\t\"    #else\",\n\t\t\"        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);\",\n\t\t\"    #endif\",\n\t\t\"}\",\n\t\t\"/*==========================================================================*/\",\n\t\t\"#endif\",\n\t\t\"\",\n\t\t\"void main() {\",\n\t\t\"  gl_FragColor = FxaaPixelShader(\",\n\t\t\"    vUv,\",\n\t\t\"    vec4(0.0),\",\n\t\t\"    tDiffuse,\",\n\t\t\"    tDiffuse,\",\n\t\t\"    tDiffuse,\",\n\t\t\"    resolution,\",\n\t\t\"    vec4(0.0),\",\n\t\t\"    vec4(0.0),\",\n\t\t\"    vec4(0.0),\",\n\t\t\"    0.75,\",\n\t\t\"    0.166,\",\n\t\t\"    0.0833,\",\n\t\t\"    0.0,\",\n\t\t\"    0.0,\",\n\t\t\"    0.0,\",\n\t\t\"    vec4(0.0)\",\n\t\t\"  );\",\n\t\t\"\",\n\t\t\"  // TODO avoid querying texture twice for same texel\",\n\t\t\"  gl_FragColor.a = texture2D(tDiffuse, vUv).a;\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/FXAAShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/LuminosityShader.js":
/*!*****************************************************!*\
  !*** ./js/vendor/three/shaders/LuminosityShader.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nTHREE.LuminosityShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"#include <common>\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec4 texel = texture2D( tDiffuse, vUv );\",\n\n\t\t\"\tfloat l = linearToRelativeLuminance( texel.rgb );\",\n\n\t\t\"\tgl_FragColor = vec4( l, l, l, texel.w );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/LuminosityShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/SAOShader.js":
/*!**********************************************!*\
  !*** ./js/vendor/three/shaders/SAOShader.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * TODO\n */\n\nTHREE.SAOShader = {\n\tdefines: {\n\t\t\"NUM_SAMPLES\": 7,\n\t\t\"NUM_RINGS\": 4,\n\t\t\"NORMAL_TEXTURE\": 0,\n\t\t\"DIFFUSE_TEXTURE\": 0,\n\t\t\"DEPTH_PACKING\": 1,\n\t\t\"PERSPECTIVE_CAMERA\": 1\n\t},\n\tuniforms: {\n\n\t\t\"tDepth\": { value: null },\n\t\t\"tDiffuse\": { value: null },\n\t\t\"tNormal\": { value: null },\n\t\t\"size\": { value: new THREE.Vector2( 512, 512 ) },\n\n\t\t\"cameraNear\": { value: 1 },\n\t\t\"cameraFar\": { value: 100 },\n\t\t\"cameraProjectionMatrix\": { value: new THREE.Matrix4() },\n\t\t\"cameraInverseProjectionMatrix\": { value: new THREE.Matrix4() },\n\n\t\t\"scale\": { value: 1.0 },\n\t\t\"intensity\": { value: 0.1 },\n\t\t\"bias\": { value: 0.5 },\n\n\t\t\"minResolution\": { value: 0.0 },\n\t\t\"kernelRadius\": { value: 100.0 },\n\t\t\"randomSeed\": { value: 0.0 }\n\t},\n\tvertexShader: [\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\tfragmentShader: [\n\t\t\"#include <common>\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#if DIFFUSE_TEXTURE == 1\",\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"#endif\",\n\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"#if NORMAL_TEXTURE == 1\",\n\t\t\"uniform sampler2D tNormal;\",\n\t\t\"#endif\",\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"uniform mat4 cameraProjectionMatrix;\",\n\t\t\"uniform mat4 cameraInverseProjectionMatrix;\",\n\n\t\t\"uniform float scale;\",\n\t\t\"uniform float intensity;\",\n\t\t\"uniform float bias;\",\n\t\t\"uniform float kernelRadius;\",\n\t\t\"uniform float minResolution;\",\n\t\t\"uniform vec2 size;\",\n\t\t\"uniform float randomSeed;\",\n\n\t\t\"// RGBA depth\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"vec4 getDefaultColor( const in vec2 screenPosition ) {\",\n\t\t\"\t#if DIFFUSE_TEXTURE == 1\",\n\t\t\"\treturn texture2D( tDiffuse, vUv );\",\n\t\t\"\t#else\",\n\t\t\"\treturn vec4( 1.0 );\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"float getDepth( const in vec2 screenPosition ) {\",\n\t\t\"\t#if DEPTH_PACKING == 1\",\n\t\t\"\treturn unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );\",\n\t\t\"\t#else\",\n\t\t\"\treturn texture2D( tDepth, screenPosition ).x;\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"float getViewZ( const in float depth ) {\",\n\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\"\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#else\",\n\t\t\"\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"vec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\",\n\t\t\"\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\",\n\t\t\"\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\",\n\t\t\"\tclipPosition *= clipW; // unprojection.\",\n\n\t\t\"\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\",\n\t\t\"}\",\n\n\t\t\"vec3 getViewNormal( const in vec3 viewPosition, const in vec2 screenPosition ) {\",\n\t\t\"\t#if NORMAL_TEXTURE == 1\",\n\t\t\"\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\",\n\t\t\"\t#else\",\n\t\t\"\treturn normalize( cross( dFdx( viewPosition ), dFdy( viewPosition ) ) );\",\n\t\t\"\t#endif\",\n\t\t\"}\",\n\n\t\t\"float scaleDividedByCameraFar;\",\n\t\t\"float minResolutionMultipliedByCameraFar;\",\n\n\t\t\"float getOcclusion( const in vec3 centerViewPosition, const in vec3 centerViewNormal, const in vec3 sampleViewPosition ) {\",\n\t\t\"\tvec3 viewDelta = sampleViewPosition - centerViewPosition;\",\n\t\t\"\tfloat viewDistance = length( viewDelta );\",\n\t\t\"\tfloat scaledScreenDistance = scaleDividedByCameraFar * viewDistance;\",\n\n\t\t\"\treturn max(0.0, (dot(centerViewNormal, viewDelta) - minResolutionMultipliedByCameraFar) / scaledScreenDistance - bias) / (1.0 + pow2( scaledScreenDistance ) );\",\n\t\t\"}\",\n\n\t\t\"// moving costly divides into consts\",\n\t\t\"const float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\",\n\t\t\"const float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\",\n\n\t\t\"float getAmbientOcclusion( const in vec3 centerViewPosition ) {\",\n\t\t\"\t// precompute some variables require in getOcclusion.\",\n\t\t\"\tscaleDividedByCameraFar = scale / cameraFar;\",\n\t\t\"\tminResolutionMultipliedByCameraFar = minResolution * cameraFar;\",\n\t\t\"\tvec3 centerViewNormal = getViewNormal( centerViewPosition, vUv );\",\n\n\t\t\"\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\",\n\t\t\"\tfloat angle = rand( vUv + randomSeed ) * PI2;\",\n\t\t\"\tvec2 radius = vec2( kernelRadius * INV_NUM_SAMPLES ) / size;\",\n\t\t\"\tvec2 radiusStep = radius;\",\n\n\t\t\"\tfloat occlusionSum = 0.0;\",\n\t\t\"\tfloat weightSum = 0.0;\",\n\n\t\t\"\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\",\n\t\t\"\t\tvec2 sampleUv = vUv + vec2( cos( angle ), sin( angle ) ) * radius;\",\n\t\t\"\t\tradius += radiusStep;\",\n\t\t\"\t\tangle += ANGLE_STEP;\",\n\n\t\t\"\t\tfloat sampleDepth = getDepth( sampleUv );\",\n\t\t\"\t\tif( sampleDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\"\t\t\tcontinue;\",\n\t\t\"\t\t}\",\n\n\t\t\"\t\tfloat sampleViewZ = getViewZ( sampleDepth );\",\n\t\t\"\t\tvec3 sampleViewPosition = getViewPosition( sampleUv, sampleDepth, sampleViewZ );\",\n\t\t\"\t\tocclusionSum += getOcclusion( centerViewPosition, centerViewNormal, sampleViewPosition );\",\n\t\t\"\t\tweightSum += 1.0;\",\n\t\t\"\t}\",\n\n\t\t\"\tif( weightSum == 0.0 ) discard;\",\n\n\t\t\"\treturn occlusionSum * ( intensity / weightSum );\",\n\t\t\"}\",\n\n\n\t\t\"void main() {\",\n\t\t\"\tfloat centerDepth = getDepth( vUv );\",\n\t\t\"\tif( centerDepth >= ( 1.0 - EPSILON ) ) {\",\n\t\t\"\t\tdiscard;\",\n\t\t\"\t}\",\n\n\t\t\"\tfloat centerViewZ = getViewZ( centerDepth );\",\n\t\t\"\tvec3 viewPosition = getViewPosition( vUv, centerDepth, centerViewZ );\",\n\n\t\t\"\tfloat ambientOcclusion = getAmbientOcclusion( viewPosition );\",\n\n\t\t\"\tgl_FragColor = getDefaultColor( vUv );\",\n\t\t\"\tgl_FragColor.xyz *=  1.0 - ambientOcclusion;\",\n\t\t\"}\"\n\t].join( \"\\n\" )\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/SAOShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/SSAOShaderOld.js":
/*!**************************************************!*\
  !*** ./js/vendor/three/shaders/SSAOShaderOld.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Screen-space ambient occlusion shader\n * - ported from\n *   SSAO GLSL shader v1.2\n *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)\n *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)\n * - modifications\n * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)\n * - refactoring and optimizations\n */\n\nTHREE.SSAOShader = {\n\n\t// AXC: accommodate perspective and orthographic cameras\n\tdefines: {\n\t\t'PERSPECTIVE_CAMERA': 1\n\t},\n\n\tuniforms: {\n\n\t\t\"tDiffuse\":     { value: null },\n\t\t\"tDepth\":       { value: null },\n\t\t\"size\":         { value: new THREE.Vector2( 512, 512 ) },\n\t\t\"cameraNear\":   { value: 1 },\n\t\t\"cameraFar\":    { value: 100 },\n\t\t\"radius\":       { value: 32 },\n\t\t\"onlyAO\":       { value: 0 },\n\t\t\"aoClamp\":      { value: 0.25 },\n\t\t\"lumInfluence\": { value: 0.7 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vUv = uv;\",\n\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float cameraNear;\",\n\t\t\"uniform float cameraFar;\",\n\t\t\"#ifdef USE_LOGDEPTHBUF\",\n\t\t\t\"uniform float logDepthBufFC;\",\n\t\t\"#endif\",\n\n\t\t\"uniform float radius;\",     // ao radius\n\t\t\"uniform bool onlyAO;\",      // use only ambient occlusion pass?\n\n\t\t\"uniform vec2 size;\",        // texture width, height\n\t\t\"uniform float aoClamp;\",    // depth clamp - reduces haloing at screen edges\n\n\t\t\"uniform float lumInfluence;\",  // how much luminance affects occlusion\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform sampler2D tDepth;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t// \"#define PI 3.14159265\",\n\t\t\"#define DL 2.399963229728653\",  // PI * ( 3.0 - sqrt( 5.0 ) )\n\t\t\"#define EULER 2.718281828459045\",\n\n\t\t// user variables\n\n\t\t\"const int samples = 64;\",     // ao sample count\n\n\t\t\"const bool useNoise = true;\",      // use noise instead of pattern for sample dithering\n\t\t\"const float noiseAmount = 0.0004;\", // dithering amount\n\n\t\t\"const float diffArea = 0.4;\",   // self-shadowing reduction\n\t\t\"const float gDisplace = 0.4;\",  // gauss bell center\n\n\n\t\t// RGBA depth\n\n\t\t\"#include <packing>\",\n\n\t\t// generating noise / pattern texture for dithering\n\n\t\t\"vec2 rand( const vec2 coord ) {\",\n\n\t\t\t\"vec2 noise;\",\n\n\t\t\t\"if ( useNoise ) {\",\n\n\t\t\t\t\"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );\",\n\t\t\t\t\"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\",\n\n\t\t\t\t\"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\",\n\t\t\t\t\"float gg = fract( coord.t * ( size.y / 2.0 ) );\",\n\n\t\t\t\t\"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return ( noise * 2.0  - 1.0 ) * noiseAmount;\",\n\n\t\t\"}\",\n\n\t\t\"float readDepth( const in vec2 coord ) {\",\n\n\t\t\t// AXC - use depth \n\t\t\t//\"float cameraFarPlusNear = cameraFar + cameraNear;\",\n\t\t\t//\"float cameraFarMinusNear = cameraFar - cameraNear;\",\n\t\t\t//\"float cameraCoef = 2.0 * cameraNear;\",\n\n\t\t\t\"#ifdef USE_LOGDEPTHBUF\",\n\n\t\t\t\t\"float logz = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\n\t\t\t\t\"float w = pow(2.0, (logz / logDepthBufFC)) - 1.0;\",\n\t\t\t\t\"float z = (logz / w) + 1.0;\",\n\n\t\t\t\"#else\",\n\n\t\t\t\t\"float z = unpackRGBAToDepth( texture2D( tDepth, coord ) );\",\n\n\t\t\t\"#endif\",\n\n\t\t\t// \"return cameraCoef / ( cameraFarPlusNear - z * cameraFarMinusNear );\",\n\n\t\t\t// AXC: use perspectiveDepth function (this seems to work better)\n \t\t\t\"\t#if PERSPECTIVE_CAMERA == 1\",\n\t\t\t\t\"return  - perspectiveDepthToViewZ(z, cameraNear, cameraFar);\",\n\t\t\t\"\t#else\",\n\t\t\t\t\"return  - orthographicDepthToViewZ(z, cameraNear, cameraFar);\",\n\t\t\t\"\t#endif\",\n\n\t\t\"}\",\n\n\t\t\"float compareDepths( const in float depth1, const in float depth2, inout int far ) {\",\n\n\t\t\t\"float garea = 8.0;\",                         // gauss bell width\n\t\t\t\"float diff = ( depth1 - depth2 ) * 100.0;\",  // depth difference (0-100)\n\n\t\t\t// reduce left bell width to avoid self-shadowing\n\n\t\t\t\"if ( diff < gDisplace ) {\",\n\n\t\t\t\t\"garea = diffArea;\",\n\n\t\t\t\"} else {\",\n\n\t\t\t\t\"far = 1;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"float dd = diff - gDisplace;\",\n\t\t\t\"float gauss = pow( EULER, -2.0 * ( dd * dd ) / ( garea * garea ) );\",\n\t\t\t\"return gauss;\",\n\n\t\t\"}\",\n\n\t\t\"float calcAO( float depth, float dw, float dh ) {\",\n\n\t\t\t\"vec2 vv = vec2( dw, dh );\",\n\n\t\t\t\"vec2 coord1 = vUv + radius * vv;\",\n\t\t\t\"vec2 coord2 = vUv - radius * vv;\",\n\n\t\t\t\"float temp1 = 0.0;\",\n\t\t\t\"float temp2 = 0.0;\",\n\n\t\t\t\"int far = 0;\",\n\t\t\t\"temp1 = compareDepths( depth, readDepth( coord1 ), far );\",\n\n\t\t\t// DEPTH EXTRAPOLATION\n\n\t\t\t\"if ( far > 0 ) {\",\n\n\t\t\t\t\"temp2 = compareDepths( readDepth( coord2 ), depth, far );\",\n\t\t\t\t\"temp1 += ( 1.0 - temp1 ) * temp2;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"return temp1;\",\n\n\t\t\"}\",\n\n\t\t\"void main() {\",\n\n\t\t\t\"vec2 noise = rand( vUv );\",\n\t\t\t\"float depth = readDepth( vUv );\",\n\n\t\t\t\"float tt = clamp( depth, aoClamp, 1.0 );\",\n\n\t\t\t\"float w = ( 1.0 / size.x ) / tt + ( noise.x * ( 1.0 - noise.x ) );\",\n\t\t\t\"float h = ( 1.0 / size.y ) / tt + ( noise.y * ( 1.0 - noise.y ) );\",\n\n\t\t\t\"float ao = 0.0;\",\n\n\t\t\t\"float dz = 1.0 / float( samples );\",\n\t\t\t\"float l = 0.0;\",\n\t\t\t\"float z = 1.0 - dz / 2.0;\",\n\n\t\t\t\"for ( int i = 0; i <= samples; i ++ ) {\",\n\n\t\t\t\t\"float r = sqrt( 1.0 - z );\",\n\n\t\t\t\t\"float pw = cos( l ) * r;\",\n\t\t\t\t\"float ph = sin( l ) * r;\",\n\t\t\t\t\"ao += calcAO( depth, pw * w, ph * h );\",\n\t\t\t\t\"z = z - dz;\",\n\t\t\t\t\"l = l + DL;\",\n\n\t\t\t\"}\",\n\n\t\t\t\"ao /= float( samples );\",\n\t\t\t\"ao = 1.0 - ao;\",\n\n\t\t\t\"vec4 color = texture2D( tDiffuse, vUv );\",\n\n\t\t\t\"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );\",\n\t\t\t\"float lum = dot( color.rgb, lumcoeff );\",\n\t\t\t\"vec3 luminance = vec3( lum );\",\n\n\t\t\t\"vec3 final = vec3( color.rgb * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // mix( color * ao, white, luminance )\n\n\t\t\t\"if ( onlyAO ) {\",\n\n\t\t\t\t\"final = vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );\",  // ambient occlusion only\n\n\t\t\t\"}\",\n\n\t\t\t\"gl_FragColor = vec4( final, color.a );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/SSAOShaderOld.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/SobelOperatorShader.js":
/*!********************************************************!*\
  !*** ./js/vendor/three/shaders/SobelOperatorShader.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author Mugen87 / https://github.com/Mugen87\n *\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\n *\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\n *\n */\n\nTHREE.SobelOperatorShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"resolution\": { value: new THREE.Vector2() }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\t\t\"uniform vec2 resolution;\",\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\",\n\n\t\t// kernel definition (in glsl matrices are filled in column-major order)\n\n\t\t\"\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 );\", // x direction kernel\n\t\t\"\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 );\", // y direction kernel\n\n\t\t// fetch the 3x3 neighbourhood of a fragment\n\n\t\t// first column\n\n\t\t\"\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\",\n\t\t\"\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\",\n\t\t\"\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\",\n\n\t\t// second column\n\n\t\t\"\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\",\n\t\t\"\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\",\n\t\t\"\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\",\n\n\t\t// third column\n\n\t\t\"\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\",\n\t\t\"\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\",\n\t\t\"\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\",\n\n\t\t// gradient value in x direction\n\n\t\t\"\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 + \",\n\t\t\"\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 + \",\n\t\t\"\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2; \",\n\n\t\t// gradient value in y direction\n\n\t\t\"\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 + \",\n\t\t\"\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 + \",\n\t\t\"\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2; \",\n\n\t\t// magnitute of the total gradient\n\n\t\t\"\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\",\n\n\t\t\"\tgl_FragColor = vec4( vec3( G ), 1 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/SobelOperatorShader.js?");

/***/ }),

/***/ "./js/vendor/three/shaders/UnpackDepthRGBAShader.js":
/*!**********************************************************!*\
  !*** ./js/vendor/three/shaders/UnpackDepthRGBAShader.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Unpack RGBA depth shader\n * - show RGBA encoded depth as monochrome color\n */\n\nTHREE.UnpackDepthRGBAShader = {\n\n\tuniforms: {\n\n\t\t\"tDiffuse\": { value: null },\n\t\t\"opacity\": { value: 1.0 }\n\n\t},\n\n\tvertexShader: [\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tvUv = uv;\",\n\t\t\"\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" ),\n\n\tfragmentShader: [\n\n\t\t\"uniform float opacity;\",\n\n\t\t\"uniform sampler2D tDiffuse;\",\n\n\t\t\"varying vec2 vUv;\",\n\n\t\t\"#include <packing>\",\n\n\t\t\"void main() {\",\n\n\t\t\"\tfloat depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );\",\n\t\t\"\tgl_FragColor = vec4( vec3( depth ), opacity );\",\n\n\t\t\"}\"\n\n\t].join( \"\\n\" )\n\n};\n\n\n//# sourceURL=webpack://STK/./js/vendor/three/shaders/UnpackDepthRGBAShader.js?");

/***/ })

/******/ });
});